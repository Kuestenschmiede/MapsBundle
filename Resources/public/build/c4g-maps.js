/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./Resources/public/js/c4g-maps-main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./Resources/public/js/c4g-baselayer-controller.js":
/*!*********************************************************!*\
  !*** ./Resources/public/js/c4g-baselayer-controller.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.C4gBaselayerController = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * This file is part of con4gis,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * the gis-kit for Contao CMS.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @package    con4gis
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @version    6
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @author     con4gis contributors (see "authors.txt")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @license    LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @copyright  Küstenschmiede GmbH Software & Design
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @link       https://www.con4gis.org
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _c4gBaselayer = __webpack_require__(/*! ./c4g-baselayer */ "./Resources/public/js/c4g-baselayer.js");

var _c4gOverlay = __webpack_require__(/*! ./c4g-overlay */ "./Resources/public/js/c4g-overlay.js");

var _c4gMapsConfig = __webpack_require__(/*! ./c4g-maps-config */ "./Resources/public/js/c4g-maps-config.js");

var _c4gMapsUtils = __webpack_require__(/*! ./c4g-maps-utils */ "./Resources/public/js/c4g-maps-utils.js");

var _c4gMapsConstant = __webpack_require__(/*! ./c4g-maps-constant */ "./Resources/public/js/c4g-maps-constant.js");

var _Tile = __webpack_require__(/*! ol/layer/Tile */ "./node_modules/ol/layer/Tile.js");

var _source = __webpack_require__(/*! ol/source */ "./node_modules/ol/source.js");

var _VectorTile = __webpack_require__(/*! ol/VectorTile */ "./node_modules/ol/VectorTile.js");

var _VectorTile2 = __webpack_require__(/*! ol/source/VectorTile */ "./node_modules/ol/source/VectorTile.js");

var _layer = __webpack_require__(/*! ol/layer */ "./node_modules/ol/layer.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var C4gBaselayerController = exports.C4gBaselayerController = function () {
  function C4gBaselayerController(proxy) {
    _classCallCheck(this, C4gBaselayerController);

    this.proxy = proxy;
    this.mapController = proxy.options.mapController;
    this.arrBaselayers = {};
    this.baselayerIds = [];
  }

  _createClass(C4gBaselayerController, [{
    key: "loadBaseLayers",
    value: function loadBaseLayers() {
      var self;

      self = this;

      jQuery.ajax(this.proxy.api_baselayer_url, {
        dataType: this.mapController.data.jsonp ? "jsonp" : "json"
      }).done(function (data) {
        if (data.baselayer) {
          self.addBaseLayers(data.baselayer);
          _c4gMapsUtils.utils.callHookFunctions(window.c4gMapsHooks.proxy_baselayer_loaded);
        }
        return true;
      }).fail(function () {
        // @TODO error-messages
        //   1) Visible message 4 users (i18n)
        //   2) Technical console.warn
        console.warn('An error occured while trying to load the baselayers. Do you have configured a default profile with baselayers?');
        self.mapController.spinner.hide();
        return false;
      }).always(function () {
        //self.mapController.spinner.hide();
      });
    } // end of "loadBaseLayers()"

  }, {
    key: "addBaseLayers",
    value: function addBaseLayers(baselayers) {
      var baselayer, uid, i, j;

      // sort baselayer (for internal list)
      baselayers.sort(function (a, b) {
        if (!a.sort && !b.sort || parseInt(a.sort, 10) === parseInt(b.sort, 10)) {
          if (!a.name || !b.name) {
            return !b.name ? -1 : 1;
          }
          return a.name.toLowerCase() > b.name.toLowerCase() ? 1 : -1;
        }
        if (!a.sort || !b.sort) {
          return !b.sort ? -1 : 1;
        }
        return parseInt(a.sort, 10) > parseInt(b.sort, 10) ? 1 : -1;
      });

      // build baselayer-list
      if (baselayers.length > 0) {
        for (i = 0; i < baselayers.length; i += 1) {

          baselayer = baselayers[i];

          uid = baselayer.id || _c4gMapsUtils.utils.getUniqueId();
          this.baselayerIds.push(uid);
          if (!this.arrBaselayers[uid]) {
            this.arrBaselayers[uid] = new _c4gBaselayer.C4gBaselayer(baselayer, this);
          }

          // @TODO: check initial baselayer-handling
          if (this.mapController.data.baselayer && parseInt(uid, 10) === parseInt(this.mapController.data.baselayer, 10)) {
            // check default from content/module (overrides profile settings)
            this.showBaseLayer(uid);
          } else if (this.mapController.data.default_baselayer && parseInt(uid, 10) === parseInt(this.mapController.data.default_baselayer, 10)) {
            // check default from profile
            this.showBaseLayer(uid);
          }
        }
      }

      if (!this.proxy.activeBaselayerId) {
        // no baselayer was activated
        if (baselayers.length > 0 && baselayers[0].id) {
          // take first baselayer if possible
          uid = baselayers[0].id;
        } else {
          // otherwise build default baselayer
          uid = 0;
          this.baselayerIds.push(uid);
          if (!this.arrBaselayers[uid]) {
            this.arrBaselayers[uid] = {
              id: 0,
              name: 'c4g_default',
              provider: 'osm',
              style: 'Mapnik'
            };
          }
        }
        this.showBaseLayer(uid);
      }
      this.proxy.baselayers_loaded = true;

      _c4gMapsUtils.utils.callHookFunctions(this.proxy.hook_baselayer_loaded, this.baselayerIds);
    } // end of "addBaseLayers()"

  }, {
    key: "createBaseLayer",
    value: function createBaseLayer(layerOptions, baseLayerConfig, sourceConfigs) {
      var newBaselayer;
      layerOptions = layerOptions || {};
      switch (baseLayerConfig.provider) {
        case 'custom':
          // custom
          var noUrl = true;
          if (baseLayerConfig.url) {
            if (baseLayerConfig.url.indexOf('https') !== -1) {
              layerOptions.crossOrigin = 'anonymous';
            }
            layerOptions.url = baseLayerConfig.url;
            noUrl = false;
          } else if (baseLayerConfig.urls) {
            layerOptions.urls = baseLayerConfig.urls;
            noUrl = false;
          }
          if (!noUrl) {
            newBaselayer = new _Tile.TileLayer({
              source: new _source.XYZ(layerOptions),
              extent: baseLayerConfig.extend
            });
          } else {
            console.warn('custom url(s) missing -> switch to default');
          }
          break;
        case 'osm':
          if (sourceConfigs.osm[baseLayerConfig.style]) {
            newBaselayer = new _Tile.TileLayer({
              source: new _source.OSM(jQuery.extend(sourceConfigs.osm[baseLayerConfig.style], layerOptions))
            });
          } else if (baseLayerConfig.style === 'osm_custom') {
            // custom
            var _noUrl = true;
            if (baseLayerConfig.url) {
              layerOptions.url = baseLayerConfig.url;
              _noUrl = false;
            } else if (baseLayerConfig.urls) {
              layerOptions.urls = baseLayerConfig.urls;
              _noUrl = false;
            }
            if (!_noUrl) {
              newBaselayer = new _Tile.TileLayer({
                source: new _source.XYZ(layerOptions)
              });
            } else {
              console.warn('custom url(s) missing -> switch to default');
            }
          } else {
            console.warn('unsupported osm-style -> switch to default');
          }
          break;
        case 'stamen':
          if (sourceConfigs.stamen[baseLayerConfig.style]) {
            // Stamen
            newBaselayer = new _Tile.TileLayer({
              source: new _source.Stamen(jQuery.extend(sourceConfigs.stamen[baseLayerConfig.style], layerOptions))
            });
            // } else if (mapQuestSourceConfigs[baseLayerConfig.style]) {
            //   // mapQuest
            //   newBaselayer = new TileLayer({
            //     source: new ol.source.MapQuest(mapQuestSourceConfigs[baseLayerConfig.style])
            //   });
          } else {
            console.warn('unsupported osm-style -> switch to default');
          }
          break;
        case 'con4gisIo':
          layerOptions.url = baseLayerConfig.url;
          newBaselayer = new _Tile.TileLayer({
            source: new _source.XYZ(layerOptions)
          });
          break;
        case 'mapbox':
          if (baseLayerConfig.api_key && baseLayerConfig.app_id && baseLayerConfig.mapbox_type) {

            if (baseLayerConfig.mapbox_type === 'Mapbox') {
              layerOptions.url = baseLayerConfig.url + baseLayerConfig.app_id + '/tiles/{z}/{x}/{y}?access_token=' + baseLayerConfig.api_key;
              newBaselayer = new _Tile.TileLayer({
                source: new _source.XYZ(jQuery.extend(sourceConfigs.mapbox[baseLayerConfig.mapbox_type], layerOptions))
              });
            } else {
              layerOptions.url = baseLayerConfig.url_classic + baseLayerConfig.app_id + '/{z}/{x}/{y}.png?access_token=' + baseLayerConfig.api_key;

              newBaselayer = new _Tile.TileLayer({
                source: new _source.XYZ(jQuery.extend(sourceConfigs.mapbox[baseLayerConfig.mapbox_type], layerOptions))
              });
            }
          } else if (baseLayerConfig.hide_in_be) {
            layerOptions.url = "con4gis/baseLayerTileService/" + baseLayerConfig.id + "/{z}/{x}/{y}";
            newBaselayer = new _Tile.TileLayer({
              source: new _source.XYZ(jQuery.extend(sourceConfigs.mapbox[baseLayerConfig.mapbox_type], layerOptions))
            });
          } else {
            console.warn('wrong mapbox configuration!');
          }
          break;
        case 'klokan':
          if (baseLayerConfig.api_key && baseLayerConfig.klokan_type) {

            if (baseLayerConfig.klokan_type === 'OpenMapTiles') {
              layerOptions.url = baseLayerConfig.url + '{z}/{x}/{y}.pbf';
              newBaselayer = new _VectorTile.VectorTile({
                source: new _VectorTile2.VectorTileSource(jQuery.extend(sourceConfigs.klokan[baseLayerConfig.klokan_type], layerOptions))
              });

              //ToDo style url
              fetch(baseLayerConfig.url + '/styles/' + baseLayerConfig.style + '/style.json').then(function (response) {
                response.json().then(function (glStyle) {
                  olms.applyStyle(newBaselayer, glStyle, 'openmaptiles');
                });
              });
            } else {
              layerOptions.url = baseLayerConfig.url + '/data/v3/{z}/{x}/{y}.pbf?key=' + baseLayerConfig.api_key;
              newBaselayer = new _VectorTile.VectorTile({
                source: new _VectorTile2.VectorTileSource(jQuery.extend(sourceConfigs.klokan[baseLayerConfig.klokan_type], layerOptions))
              });

              fetch(baseLayerConfig.url + '/styles/' + baseLayerConfig.style + '/style.json?key=' + baseLayerConfig.api_key).then(function (response) {
                response.json().then(function (glStyle) {
                  olms.applyStyle(newBaselayer, glStyle, 'openmaptiles');
                });
              });
            }
          } else {
            console.warn('wrong klokan configuration!');
          }
          break;
        case 'here':
          if (baseLayerConfig.api_key && baseLayerConfig.app_id && baseLayerConfig.here_type) {

            if (baseLayerConfig.style == 'normal') {
              layerOptions.url = 'https://{1-4}.base.maps.cit.api.here.com/maptile/2.1/maptile/newest/normal.day/{z}/{x}/{y}/256/png' + '?app_id=' + baseLayerConfig.app_id + '&app_code=' + baseLayerConfig.api_key;
            } else if (baseLayerConfig.style == 'transit') {
              layerOptions.url = 'https://{1-4}.base.maps.cit.api.here.com/maptile/2.1/maptile/newest/normal.day.transit/{z}/{x}/{y}/256/png' + '?app_id=' + baseLayerConfig.app_id + '&app_code=' + baseLayerConfig.api_key;
            } else if (baseLayerConfig.style == 'pedestrian') {
              layerOptions.url = 'https://{1-4}.base.maps.cit.api.here.com/maptile/2.1/maptile/newest/pedestrian.day/{z}/{x}/{y}/256/png' + '?app_id=' + baseLayerConfig.app_id + '&app_code=' + baseLayerConfig.api_key;
            } else if (baseLayerConfig.style == 'terrain') {
              layerOptions.url = 'https://{1-4}.aerial.maps.cit.api.here.com/maptile/2.1/maptile/newest/terrain.day/{z}/{x}/{y}/256/png' + '?app_id=' + baseLayerConfig.app_id + '&app_code=' + baseLayerConfig.api_key;
            } else if (baseLayerConfig.style == 'satellite') {
              layerOptions.url = 'https://{1-4}.aerial.maps.cit.api.here.com/maptile/2.1/maptile/newest/satellite.day/{z}/{x}/{y}/256/png' + '?app_id=' + baseLayerConfig.app_id + '&app_code=' + baseLayerConfig.api_key;
            } else if (baseLayerConfig.style == 'hybrid') {
              layerOptions.url = 'https://{1-4}.aerial.maps.cit.api.here.com/maptile/2.1/maptile/newest/hybrid.day/{z}/{x}/{y}/256/png' + '?app_id=' + baseLayerConfig.app_id + '&app_code=' + baseLayerConfig.api_key;
            }

            newBaselayer = new _Tile.TileLayer({
              source: new _source.XYZ(jQuery.extend(sourceConfigs.here[baseLayerConfig.here_type], layerOptions))
            });
          } else if (baseLayerConfig.hide_in_be) {
            layerOptions.url = layerOptions.url = "con4gis/baseLayerTileService/" + baseLayerConfig.id + "/{z}/{x}/{y}";
            newBaselayer = new _Tile.TileLayer({
              source: new _source.XYZ(jQuery.extend(sourceConfigs.mapbox[baseLayerConfig.here_type], layerOptions))
            });
          } else {
            console.warn('wrong HERE configuration!');
          }
          break;
        case 'thunder':
          if (baseLayerConfig.api_key && baseLayerConfig.thunderforest_type) {

            if (baseLayerConfig.style) {
              layerOptions.url = "https://tile.thunderforest.com/" + baseLayerConfig.style + "/{z}/{x}/{y}.png?apikey=" + baseLayerConfig.api_key;
            }

            newBaselayer = new _Tile.TileLayer({
              source: new _source.XYZ(jQuery.extend(sourceConfigs.thunderforest[baseLayerConfig.thunderforest_type], layerOptions))
            });
          } else if (baseLayerConfig.hide_in_be) {
            layerOptions.url = "con4gis/baseLayerTileService/" + baseLayerConfig.id + "/{z}/{x}/{y}";
            newBaselayer = new _Tile.TileLayer({
              source: new _source.XYZ(jQuery.extend(sourceConfigs.mapbox[baseLayerConfig.thunderforest_type], layerOptions))
            });
          } else {
            console.warn('wrong Thunderforest configuration!');
          }
          break;
        case 'google':
          //@todo
          console.warn('google-maps are currently unsupported');
          break;
        case 'bing':
          if (baseLayerConfig.api_key && baseLayerConfig.style) {
            newBaselayer = new _Tile.TileLayer({
              source: new _source.BingMaps({
                culture: navigator.languages ? navigator.languages[0] : navigator.language || navigator.userLanguage,
                key: baseLayerConfig.api_key,
                imagerySet: baseLayerConfig.style
              })
            });
          } else {
            console.warn('wrong bing-key or invalid imagery-set!');
          }
          break;
        case 'wms':
          if (baseLayerConfig.url.indexOf('https') !== -1) {
            newBaselayer = new _Tile.TileLayer({
              source: new _source.TileWMS({
                url: baseLayerConfig.url,
                params: {
                  LAYERS: baseLayerConfig.params.layers,
                  VERSION: baseLayerConfig.params.version,
                  //FORMAT: baseLayerConfig.params.format,
                  TRANSPARENT: baseLayerConfig.params.transparent
                },
                gutter: baseLayerConfig.gutter,
                attributions: baseLayerConfig.attribution + ' ' + _source.OSM.ATTRIBUTION,
                crossOrigin: 'anonymous'
              })
              //extent: ol.proj.transformExtent([5.59334, 50.0578, 9.74158, 52.7998], 'EPSG:4326', 'EPSG:3857')
            });
          } else {
            newBaselayer = new _Tile.TileLayer({
              source: new _source.TileWMS({
                url: baseLayerConfig.url,
                params: {
                  LAYERS: baseLayerConfig.params.layers,
                  VERSION: baseLayerConfig.params.version,
                  //FORMAT: baseLayerConfig.params.format,
                  TRANSPARENT: baseLayerConfig.params.transparent
                },
                gutter: baseLayerConfig.gutter,
                attributions: baseLayerConfig.attribution + ' ' + _source.OSM.ATTRIBUTION
              })
              //extent: ol.proj.transformExtent([5.59334, 50.0578, 9.74158, 52.7998], 'EPSG:4326', 'EPSG:3857')
            });
          }

          break;
        case 'owm':
          newBaselayer = new _Tile.TileLayer({
            source: new _source.XYZ({
              url: baseLayerConfig.url + baseLayerConfig.app_id + '/{z}/{x}/{y}?hash=' + baseLayerConfig.api_key,
              attributions: baseLayerConfig.attribution + ' ' + _source.OSM.ATTRIBUTION
            })
            //extent: ol.proj.transformExtent([5.59334, 50.0578, 9.74158, 52.7998], 'EPSG:4326', 'EPSG:3857')
          });
          break;
        case 'group':
          var baseLayerGroup = [];
          for (var index in baseLayerConfig['layerGroup']) {
            if (baseLayerConfig['layerGroup'].hasOwnProperty(index)) {

              var element = this.createBaseLayer(null, baseLayerConfig['layerGroup'][index], sourceConfigs);
              var maxZoom = this.proxy.options.mapController.map.getView().getResolutionForZoom(baseLayerConfig['layerGroup'][index]['minZoom']);
              var minZoom = this.proxy.options.mapController.map.getView().getResolutionForZoom(baseLayerConfig['layerGroup'][index]['maxZoom']);
              element.setMinResolution(minZoom);
              element.setMaxResolution(maxZoom);
              baseLayerGroup.push(element);
            }
          }
          newBaselayer = new _layer.LayerGroup({
            layers: baseLayerGroup
          });
          break;

        default:
          console.warn('unsupported provider');
          break;
      }
      return newBaselayer;
    }
  }, {
    key: "showBaseLayer",
    value: function showBaseLayer(baseLayerUid) {

      var self = this,
          layers = void 0,
          baselayer = void 0,
          addBaselayer = void 0,
          baseLayers = void 0,
          sourceConfigs = [],
          newBaselayer = void 0,
          layerOptions = void 0,
          i = void 0,
          view = void 0;

      var baseLayerConfig = this.arrBaselayers[baseLayerUid];

      if (typeof baseLayerConfig !== "undefined" && !baseLayerConfig.layer) {
        // create layer
        sourceConfigs.osm = _c4gMapsConfig.config.osm;
        sourceConfigs.stamen = _c4gMapsConfig.config.stamen;
        //mapQuestSourceConfigs = c4g.maps.config.mapquest;
        sourceConfigs.mapbox = _c4gMapsConfig.config.mapbox;
        sourceConfigs.klokan = _c4gMapsConfig.config.klokan;
        sourceConfigs.here = _c4gMapsConfig.config.here;
        sourceConfigs.thunderforest = _c4gMapsConfig.config.thunderforest;

        //newBaselayer = new TileLayer({
        //  source: new OSM()
        //});

        layerOptions = {};

        if (baseLayerConfig.attribution) {
          if (layerOptions.attributions) {
            layerOptions.attributions = layerOptions.attributions + ' ' + baseLayerConfig.attribution;
          } else {
            layerOptions.attributions = _source.OSM.ATTRIBUTION + ' ' + baseLayerConfig.attribution;
          }
        } else if (!layerOptions.attributions) {
          switch (baseLayerConfig.provider) {
            case 'osm':
              if (sourceConfigs.stamen[baseLayerConfig.style]) {
                layerOptions.attributions = sourceConfigs.stamen[baseLayerConfig.style].attributions;
                /*
                              } else if (mapQuestSourceConfigs[baseLayerConfig.style]) {
                                layerOptions.attributions = mapQuestSourceConfigs[baseLayerConfig.style].attributions;
                */
              } else if (sourceConfigs.osm[baseLayerConfig.style]) {
                layerOptions.attributions = sourceConfigs.osm[baseLayerConfig.style].attributions;
              } else {
                layerOptions.attributions = _source.OSM.ATTRIBUTION;
              }
              break;
            case 'mapbox':
              layerOptions.attributions = sourceConfigs.mapbox[baseLayerConfig.mapbox_type].attributions;
              break;
            case 'klokan':
              layerOptions.attributions = sourceConfigs.klokan[baseLayerConfig.klokan_type].attributions;
              break;
            case 'here':
              layerOptions.attributions = sourceConfigs.here[baseLayerConfig.here_type].attributions;
              break;
            case 'thunder':
              layerOptions.attributions = sourceConfigs.thunderforest[baseLayerConfig.thunderforest_type].attributions;
              break;
            default:
              layerOptions.attributions = _source.OSM.ATTRIBUTION;
              break;
          }
        }

        //ToDo helper class for attributions

        //additional attribution
        if (this.mapController.data && this.mapController.data.attribution && this.mapController.data.attribution.additional) {
          if (layerOptions.attributions) {
            var additionalAttribution = this.mapController.data.attribution.additional;

            exists = false;
            for (i = 0; i < layerOptions.attributions.length; i += 1) {
              if (layerOptions.attributions[i] == additionalAttribution) {
                exists = true;
                break;
              }
            }

            if (!exists) {
              layerOptions.attributions = layerOptions.attributions + ' ' + additionalAttribution;
            }
          } else {
            layerOptions.attributions = this.mapController.data.attribution.additional;
          }
        }

        //ToDo type class for geosearch_engine
        //geosearch attribution
        var geosearch_attribution = '';
        if (this.mapController.data.geosearch) {
          var geosearch_engine = this.mapController.data.geosearch.geosearch_engine;

          if (this.mapController.data && this.mapController.data.attribution) {

            switch (geosearch_engine) {
              case '4':
                geosearch_attribution = ''; //con4gis mapservices
                break;
              case '3':
                if (this.mapController.data.geosearch.custom_attribution) {
                  geosearch_attribution = this.mapController.data.geosearch.custom_attribution;
                }
                break;
              case '2':
                geosearch_attribution = 'Nominatim Search Courtesy of <a href="http://www.mapquest.com/" target="_blank">MapQuest</a> <img src="http://developer.mapquest.com/content/osm/mq_logo.png" alt="" />';
                break;
              case '1':
              default:
                geosearch_attribution = 'Nominatim Search Courtesy of <a href="http://wiki.openstreetmap.org/wiki/Nominatim_usage_policy" target="_blank">OpenStreetMap</a>';
                break;
            }

            var geosearchAttribution = geosearch_attribution;

            var exists = false;
            if (!layerOptions.attributions) {
              layerOptions.attributions = [];
            }
            for (i = 0; i < layerOptions.attributions.length; i += 1) {
              if (layerOptions.attributions[i] == geosearchAttribution) {
                exists = true;
                break;
              }
            }

            if (!exists) {
              layerOptions.attributions = layerOptions.attributions + ' ' + geosearchAttribution;
            } else {
              layerOptions.attributions = geosearchAttribution;
            }
          }
        }

        if (baseLayerConfig.sorting) {
          layerOptions.sort = baseLayerConfig.sorting;
        }
        if (baseLayerConfig.minZoom && baseLayerConfig.minZoom >= 0) {
          layerOptions.minZoom = baseLayerConfig.minZoom;
        }
        if (baseLayerConfig.maxZoom && baseLayerConfig.maxZoom >= 0) {
          layerOptions.maxZoom = baseLayerConfig.maxZoom;
        }

        newBaselayer = this.createBaseLayer(layerOptions, baseLayerConfig, sourceConfigs);
        if (baseLayerConfig.hasOverlays) {
          for (i = 0; i < baseLayerConfig.overlays.length; i++) {
            if (!baseLayerConfig.overlayController.arrOverlays[baseLayerConfig.overlays[i].id]) {
              baseLayerConfig.overlayController.arrOverlays[baseLayerConfig.overlays[i].id] = new _c4gOverlay.C4gOverlay(baseLayerConfig.overlays[i], this.mapController);
              baseLayerConfig.overlayController.arrOverlays[baseLayerConfig.overlays[i].id].layer = baseLayerConfig.overlayController.showOverlayLayer(baseLayerConfig.overlays[i].id);
            }
          }
        }

        this.arrBaselayers[baseLayerUid].layer = newBaselayer;
      }

      layers = this.mapController.map.getLayers();

      // secure
      if (layers.item(0).get('checkSum') === "baseMapsLayer") {
        baseLayers = layers.item(0).getLayers();

        if (typeof this.arrBaselayers[baseLayerUid] !== "undefined") {
          baselayer = this.arrBaselayers[baseLayerUid].layer;

          if (baselayer) {
            addBaselayer = true;
            baseLayers.forEach(function (element, index, array) {
              if (element && element === baselayer) {
                element.setVisible(true);
                addBaselayer = false;
              } else if (element) {
                element.setVisible(false);
              } else {
                addBaselayer = false;
              }
            }, this);

            if (addBaselayer) {
              baseLayers.push(baselayer);
            }
          }

          view = this.mapController.map.getView();
          var zoom = view.getZoom();
          var center = view.getCenter();
          if (baseLayerConfig.minZoom && baseLayerConfig.minZoom >= 0 || baseLayerConfig.maxZoom && baseLayerConfig.maxZoom >= 0) {
            if (baseLayerConfig.minZoom && view.getZoom() < baseLayerConfig.minZoom) {
              view.setZoom(baseLayerConfig.minZoom);
            } else if (baseLayerConfig.maxZoom && view.getZoom() > baseLayerConfig.maxZoom) {
              view.setZoom(baseLayerConfig.maxZoom);
            }

            var mapData = this.mapController.data;
            if (mapData.zoomlevel || mapData.mouseposition) {
              view.setMinZoom(parseInt(baseLayerConfig.minZoom, 10) || 0);
              view.setMaxZoom(parseInt(baseLayerConfig.maxZoom, 10) || 19);
              this.mapController.map.setView(view);
            }
          }
        }
      }

      if (typeof baseLayerConfig !== "undefined") {
        this.proxy.activeBaselayerId = baseLayerConfig.id;

        _c4gMapsUtils.utils.callHookFunctions(this.proxy.hook_baselayer_visibility, baseLayerConfig);

        /**
         * Cesium integration
         */
        if (typeof baseLayerConfig !== "undefined") {
          var mapData = this.mapController.data;
          if (mapData.cesium && mapData.cesium.enable && (mapData.cesium.always || baseLayerConfig.cesium)) {
            if (!this.ol3d) {
              this.ol3d = new olcs.OLCesium({
                map: this.mapController.map,
                createSynchronizers: false /*,
                                           time() {
                                           const val = timeElt.value;
                                           if (ol3d.getCesiumScene().globe.enableLighting && val) {
                                           const d = new Date();
                                           d.setUTCHours(val);
                                           return Cesium.JulianDate.fromDate(d);
                                           }
                                           return Cesium.JulianDate.now();
                                           }*/ });
            }
            /*const scene = ol3d.getCesiumScene();
            const terrainProvider = new Cesium.CesiumTerrainProvider({
                url: '//assets.agi.com/stk-terrain/world',
                requestVertexNormals: true
            });
            scene.terrainProvider = terrainProvider;*/
            this.ol3d.setEnabled(true);
            /*window['toggleTime'] = function() {
                scene.globe.enableLighting = !scene.globe.enableLighting;
                if (timeElt.style.display == 'none') {
                    timeElt.style.display = 'inline-block';
                } else {
                    timeElt.style.display = 'none';
                }
            };*/
          } else {
            if (this.ol3d && this.ol3d.getEnabled()) {
              this.ol3d.setEnabled(false);
              _c4gMapsUtils.utils.redrawMapView(this.mapController);
            }
          }
        }
      }
    } // end of "showBaseLayer()"

  }]);

  return C4gBaselayerController;
}();

/***/ }),

/***/ "./Resources/public/js/c4g-baselayer.js":
/*!**********************************************!*\
  !*** ./Resources/public/js/c4g-baselayer.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.C4gBaselayer = undefined;

var _c4gOverlayController = __webpack_require__(/*! ./c4g-overlay-controller */ "./Resources/public/js/c4g-overlay-controller.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
                                                                                                                                                           * This file is part of con4gis,
                                                                                                                                                           * the gis-kit for Contao CMS.
                                                                                                                                                           *
                                                                                                                                                           * @package    con4gis
                                                                                                                                                           * @version    6
                                                                                                                                                           * @author     con4gis contributors (see "authors.txt")
                                                                                                                                                           * @license    LGPL-3.0-or-later
                                                                                                                                                           * @copyright  Küstenschmiede GmbH Software & Design
                                                                                                                                                           * @link       https://www.con4gis.org
                                                                                                                                                           */


var C4gBaselayer = exports.C4gBaselayer = function C4gBaselayer(baselayerArr, controller) {
    _classCallCheck(this, C4gBaselayer);

    this.id = baselayerArr['id'];
    this.pid = baselayerArr['pid'];
    this.name = baselayerArr['name'];
    this.display_name = baselayerArr['display_name'];
    this.provider = baselayerArr['provider'];
    this.osm_style = baselayerArr['osm_style'];
    this.osm_style_url1 = baselayerArr['osm_style_url1'];
    this.osm_style_url2 = baselayerArr['osm_style_url2'];
    this.osm_style_url3 = baselayerArr['osm_style_url3'];
    this.osm_style_url4 = baselayerArr['osm_style_url4'];
    this.osm_keyname = baselayerArr['osm_keyname'];
    this.mapbox_type = baselayerArr['mapbox_type'];
    this.bing_style = baselayerArr['bing_style'];
    this.style = baselayerArr['style'];
    this.attribution = baselayerArr['attribution'];
    this.params = baselayerArr['params'];
    this.wms_gutter = baselayerArr['wms_gutter'];
    this.minZoom = baselayerArr['minZoom'];
    this.maxZoom = baselayerArr['maxZoom'];
    this.protect_baselayer = baselayerArr['protect_baselayer'];
    this.permitted_groups = baselayerArr['permitted_groups'];
    this.api_key = baselayerArr['apiKey'] ? baselayerArr['apiKey'] : baselayerArr['api_key'];
    this.app_id = baselayerArr['app_id'];
    this.thunderforest_type = baselayerArr['thunderforest_type'];
    this.here_type = baselayerArr['here_type'];
    this.cesium = baselayerArr['cesium'];
    this.hide_in_be = baselayerArr['hide_in_be'];
    this.url = baselayerArr['url'];
    this.urls = baselayerArr['urls'];
    this.klokan_type = baselayerArr['klokan_type'];
    this.style_url = baselayerArr['style_url'];
    this.hasOverlays = baselayerArr['hasOverlays'];
    this.overlays = baselayerArr['overlays'];
    if (baselayerArr['layerGroup']) {
        var layerGroup = [];
        for (var index in baselayerArr['layerGroup']) {
            if (baselayerArr['layerGroup'].hasOwnProperty(index)) {
                layerGroup[index] = new C4gBaselayer(baselayerArr['layerGroup'][index]['entry']);
                layerGroup[index]['minZoom'] = baselayerArr['layerGroup'][index]['minZoom'];
                layerGroup[index]['maxZoom'] = baselayerArr['layerGroup'][index]['maxZoom'];
            }
        }
        this.layerGroup = layerGroup;
    }
    this.overlayController = new _c4gOverlayController.C4gOverlayController(this);
    this.layer = false;
    this.controller = controller;
};

/***/ }),

/***/ "./Resources/public/js/c4g-layer-controller.js":
/*!*****************************************************!*\
  !*** ./Resources/public/js/c4g-layer-controller.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.C4gLayerController = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * This file is part of con4gis,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * the gis-kit for Contao CMS.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @package    con4gis
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @version    6
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @author     con4gis contributors (see "authors.txt")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @license    LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @copyright  Küstenschmiede GmbH Software & Design
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @link       https://www.con4gis.org
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _c4gLayer = __webpack_require__(/*! ./c4g-layer */ "./Resources/public/js/c4g-layer.js");

var _c4gMapsUtils = __webpack_require__(/*! ./c4g-maps-utils */ "./Resources/public/js/c4g-maps-utils.js");

var _c4gMapsConstant = __webpack_require__(/*! ./c4g-maps-constant */ "./Resources/public/js/c4g-maps-constant.js");

var _c4gMapsControlStarboardpluginCustomtab = __webpack_require__(/*! ./c4g-maps-control-starboardplugin-customtab */ "./Resources/public/js/c4g-maps-control-starboardplugin-customtab.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var C4gLayerController = exports.C4gLayerController = function () {
  function C4gLayerController(proxy) {
    _classCallCheck(this, C4gLayerController);

    this.proxy = proxy;
    this.mapController = proxy.options.mapController;
    this.arrLayers = {};
    this.layerRequests = {};
  }

  _createClass(C4gLayerController, [{
    key: "loadLayers",
    value: function loadLayers() {
      var self = this;
      if (this.mapId === 0) {
        return false;
      }

      //jQuery.ajax("maps/layerService",{//this.proxy.api_layer_url,{
      jQuery.ajax(this.proxy.api_layer_url, {
        dataType: this.mapController.data.jsonp ? "jsonp" : "json"

      }).done(function (data) {
        self.addLayers(data.layer, data.foreignLayers);
        self.proxy.layers_loaded = true;
        _c4gMapsUtils.utils.callHookFunctions(self.proxy.hook_layer_loaded, self.proxy.layerIds);
        _c4gMapsUtils.utils.callHookFunctions(window.c4gMapsHooks.proxy_layer_loaded, { layerIds: self.proxy.layerIds, proxy: self.proxy });
        self.proxy.checkLocationStyles({
          done: function done() {
            self.drawLayerInitial();
            _c4gMapsUtils.utils.callHookFunctions(window.c4gMapsHooks.proxy_layer_drawn, { layerIds: self.proxy.layerIds, proxy: self.proxy });
          }
        });
        return true;
      }).fail(function () {
        // @TODO: error-messages
        //   1) Visible message 4 users (i18n)
        //   2) Technical console.warn
        console.warn('An error occured while trying to load the layers...');
        return false;
      }).always(function () {
        // this.proxy.starboard.spinner.hide();
      });
    } // end of "loadLayer()"

  }, {
    key: "addLayers",
    value: function addLayers(layers, foreignLayers) {
      var i, j, k, p, isVisible, layer, storedItem, linkItems, uid, currentZoom, fnHandleAndAppendLayerChilds, endlessLoopId, parentId, parentIds, permalinkedLayers, child, _fnHandleChilds, key, starboard, fnAddToHook;

      var self = this;
      isVisible = false;

      permalinkedLayers = this.mapController.data.layers || [];

      fnHandleAndAppendLayerChilds = function fnHandleAndAppendLayerChilds(objItem) {
        var toggle, entryWrapper;

        if (objItem.hasChilds) {
          objItem.visibleChilds = self.addLayers(objItem.childs, foreignLayers);
        }
      }; // end of "fnHandleAndAppendLayerChilds()"

      // wrapper function to avoid closure accessibility
      fnAddToHook = function fnAddToHook(layer) {
        var layername, layerid, layericon;

        if (layer.childs && layer.childs.length > 0) {
          layername = layer.name;
          layerid = layer.tabId;
          layericon = layer.awesomeicon;
          starboard = self.proxy.options.mapController.controls.starboard;
          if (!starboard) {
            self.proxy.options.mapController.initializeStarboard();
            starboard = self.proxy.options.mapController.controls.starboard;
          }
          starboard.hook_layerswitcher_loaded.push(function () {
            starboard.starboardTabs = starboard.starboardTabs || {};
            starboard.starboardTabs[layerid] = new _c4gMapsControlStarboardpluginCustomtab.Customtab(starboard, {
              name: layername,
              tabId: layerid,
              awesomeicon: layericon
            });
          });
        }
      };

      if (layers && layers.length > 0) {
        for (i = 0; i < layers.length; i += 1) {
          if (this.arrLayers[layers[i].id]) {
            layer = this.arrLayers[layers[i].id];
          } else {
            layer = new _c4gLayer.C4gLayer(layers[i]); //layers[i];
          }

          linkItems = false;
          if (_typeof(layer.content) === "object") {
            layer.content = _c4gMapsUtils.utils.objectToArray(layer.content);
          }

          // endless-loop prevention
          //
          parentId = layer.pid;
          parentIds = {};
          // build parent-ids chain
          while (self.arrLayers[parentId]) {
            if (parentIds[parentId]) {
              console.warn('Caught endless-loop (ID: ' + layer.id + ')');
              break;
            }
            parentIds[parentId] = true;
            parentId = this.arrLayers[parentId].pid;
          }

          if (layer.content && layer.content[0] && layer.content[0].cssClass) {
            layer.cssClass = layer.content[0].cssClass;
          }

          if (!parentIds[parentId]) {

            // prepare layer data if they are a new starboard tab
            if (layer.type === "startab") {
              layer.editable = true;
              layer.renderSpecial = true;
              layer.tabId = layer.id;
              if (!layer.layername) {
                layer.display = true;
              }
              // iterate childs and tell them to not load in layerswitcher
              _fnHandleChilds = function fnHandleChilds(fLayer) {
                for (var count = 0; count < fLayer.childs.length; count++) {
                  var childArr = fLayer.childs[count];
                  childArr.editable = true;
                  childArr.tabId = fLayer.tabId;
                  childArr.renderSpecial = true;
                  if (self.arrLayers[childArr.id]) {
                    child = self.arrLayers[childArr.id];
                  } else {
                    child = new _c4gLayer.C4gLayer(childArr); //layers[i];
                  }
                  // set renderSpecial to remove it from normal layerswitcher
                  self.arrLayers[child.id] = child;
                  fLayer.childs[count] = child;
                  if (child.hasChilds) {
                    // recursive call
                    _fnHandleChilds(child);
                  }
                }
              }; // end of fnHandleChilds

              if (layer.hasChilds) {
                _fnHandleChilds(layer);
              }
              fnAddToHook(layer);
            }

            uid = layer.id || _c4gMapsUtils.utils.getUniqueId();
            this.arrLayers[uid] = layer;
            if (this.proxy.checkLayerIsActiveForZoom(layer.id)) {
              layer.isInactive = false;
            } else {
              layer.isInactive = true;
            }

            this.proxy.layerIds.push(layer.id);

            if (layer.display) {
              isVisible = true;
              fnHandleAndAppendLayerChilds(layer);
            } else if (layer.pid && this.arrLayers[layer.pid]) {
              // set hide when layers are not displayed in the starboard
              layer.hide = this.arrLayers[layer.pid].hide;
            }

            var visible = false;
            if (permalinkedLayers.length > 0) {
              for (p = 0; p < permalinkedLayers.length; p += 1) {
                if (permalinkedLayers[p] == layer.id) {
                  visible = true;
                  break;
                }
              }
            }

            if (layer.hide !== "1" || visible) {
              this.proxy.activeLayerIds[layer.id] = 'invisible';
            }
          }
        } // end of for-loop

        // wrapperElement.appendChild(wrapper);
      }

      return isVisible;
    } // end of "addLayers()"

  }, {
    key: "loadLayerContent",
    value: function loadLayerContent(itemUid) {

      var self = this,
          i,
          layers,
          features,
          featureProjection,
          dataProjection,
          layerGroup,
          contentData,
          requestData,
          requestContentData,
          requestVectorSource,
          vectorLayer,
          vectorSource,
          vectorStyle,
          clusterSource,
          styleForCluster,
          refreshInterval,
          refreshAjaxVars,
          fnAttachDataToLayer;

      refreshAjaxVars = {};

      fnAttachDataToLayer = function fnAttachDataToLayer(layer, data) {
        data.properties = data.properties || {};

        layer.popup = data.popup || data.properties.popup || false;
        layer.tooltip = data.tooltip || data.properties.tooltip || false;
        layer.tooltip_length = data.tooltip_length || data.properties.tooltip_length || false;
        layer.label = data.label || data.properties.label || false;
        layer.zoom_onclick = data.zoom_onclick || data.properties.zoom_onclick || false;
      };

      if (this.arrLayers[itemUid].content) {
        layers = [];

        var contentFeatures = [];
        for (i = 0; i < this.arrLayers[itemUid].content.length; i += 1) {
          contentData = this.arrLayers[itemUid].content[i];
          styleForCluster = function styleForCluster(feature, resolution) {

            var size, style, fFeatures, iconOffset, radius, k, fillcolor, fontcolor;

            if (contentData && contentData.locationStyle && self.proxy.locationStyleController.arrLocStyles[contentData.locationStyle]) {
              style = self.proxy.locationStyleController.arrLocStyles[contentData.locationStyle].style(feature, resolution);

              if (!style) {
                style = [];
                self.fittingExtends[itemUid] = vectorSource.getExtent();
              }

              if (feature !== undefined && feature !== null && feature.self !== window) {
                if (feature.get('features')) {
                  fFeatures = feature.get('features');
                } else {
                  fFeatures = [];
                  fFeatures[0] = feature;
                }
                size = fFeatures.length;
                if (size > 1) {
                  if (fFeatures[0].getStyle() && size < 1000) {
                    // limit for performance
                    style[0] = fFeatures[0].getStyle()[0];
                    for (k = 0; k < fFeatures.length; k += 1) {
                      if (!fFeatures[k].getStyle()) {
                        style = self.proxy.locationStyleController.arrLocStyles[contentData.locationStyle].style(fFeatures[0], resolution);
                        break;
                      }
                    }
                  } else {
                    style = self.proxy.locationStyleController.arrLocStyles[contentData.locationStyle].style(fFeatures[0], resolution);
                  }
                  if (!style) {
                    style = [];
                  }

                  // calculate bubble-offset
                  iconOffset = [0, 0];
                  if (style[0]) {
                    if (_typeof(style[0].getImage()) && style[0].getImage().getRadius && typeof style[0].getImage().getRadius === "function") {
                      radius = parseInt(style[0].getImage().getRadius(), 10);
                      if (radius) {
                        iconOffset = [0, radius];
                      }
                    } else if (style[0].getImage() && style[0].getImage().getAnchor && typeof style[0].getImage().getAnchor === "function") {
                      iconOffset = style[0].getImage().getAnchor() || [0, 0];
                    }
                  }

                  fillcolor = _c4gMapsUtils.utils.getRgbaFromHexAndOpacity('4975A8', {
                    unit: '%',
                    value: 70
                  });

                  if (contentData.cluster_fillcolor) {
                    fillcolor = _c4gMapsUtils.utils.getRgbaFromHexAndOpacity(contentData.cluster_fillcolor, {
                      unit: '%',
                      value: 70
                    });
                  }
                  fontcolor = '#FFFFFF';
                  if (contentData.cluster_fontcolor) {
                    fontcolor = _c4gMapsUtils.utils.getRgbaFromHexAndOpacity(contentData.cluster_fontcolor, {
                      unit: '%',
                      value: 100
                    });
                  }

                  style.push(new ol.style.Style({
                    text: new ol.style.Text({
                      text: "●",
                      font: "60px sans-serif",
                      offsetX: -1 * iconOffset[0],
                      offsetY: -1 * iconOffset[1],
                      fill: new ol.style.Fill({
                        color: fillcolor
                      })
                    })
                  }));
                  style.push(new ol.style.Style({
                    text: new ol.style.Text({
                      text: size.toString(),
                      offsetX: -1 * iconOffset[0],
                      offsetY: -1 * iconOffset[1] + 3,
                      fill: new ol.style.Fill({
                        color: fontcolor
                      })
                    })
                  }));
                } else if (size === 1 && fFeatures[0].getStyle()) {
                  return fFeatures[0].getStyle();
                }
              }
            }
            return style;
          }; // end of styleForCluster()

          if (contentData && contentData.type === "urlData") {
            requestData = {};
            requestData.url = contentData.data.url;
            if (contentData.data.params) {
              requestData.params = decodeURIComponent(contentData.data.params);
            }

            if (contentData.settings.boundingBox) {
              requestContentData = contentData;
              requestVectorSource = new ol.source.Vector({
                loader: function loader(extent, resolution, projection) {
                  var boundingArray, strBoundingBox, url;
                  boundingArray = ol.proj.transformExtent(extent, projection, 'EPSG:4326');
                  //different cases for Overpass_QL and XML query format
                  if (requestData.params && requestData.params.substr(0, 1).trim() === "<") {
                    strBoundingBox = '<bbox-query s="' + boundingArray[1] + '" n="' + boundingArray[3] + '" w="' + boundingArray[0] + '" e="' + boundingArray[2] + '"/>';
                  } else {
                    strBoundingBox = boundingArray[1] + ',' + boundingArray[0] + ',' + boundingArray[3] + ',' + boundingArray[2];
                  }

                  url = requestData.url;

                  if (requestData.params) {
                    var bboxTag = requestData.params.indexOf('(bbox)') >= 0 ? /\(bbox\)/g : /\{{bbox\}}/g;
                    url += url.includes("?") ? "&" : "?";
                    url += 'data=' + encodeURIComponent(requestData.params.replace(bboxTag, strBoundingBox));
                  }

                  if (self.layerRequests === undefined) {
                    self.layerRequests = {};
                  }
                  if (self.layerRequests['layerRequest' + itemUid] !== undefined) {
                    self.layerRequests['layerRequest' + itemUid].abort();
                  }

                  self.layerRequests['layerRequest' + itemUid] = jQuery.ajax({
                    url: url
                  }).done(function (response) {
                    var j, format, feature, rFeatures, osmNodes, osmNds, nodeIdx, ndIdx, infoNodes, newTag, ref;

                    delete self.layerRequests['layerRequest' + itemUid];

                    // preprocessing the osm_xml to find relation-nodes with information
                    if (response && response.children && response.children[0]) {
                      // 1) find nodes with data
                      osmNodes = response.children[0].getElementsByTagName('node');
                      if (osmNodes) {
                        infoNodes = {};
                        for (nodeIdx in osmNodes) {
                          if (osmNodes.hasOwnProperty(nodeIdx) && osmNodes[nodeIdx] && osmNodes[nodeIdx].children && osmNodes[nodeIdx].children.length > 0) {
                            infoNodes[osmNodes[nodeIdx].getAttribute('id')] = osmNodes[nodeIdx];
                            // infoNodes[osmNodes[nodeIdx].getAttribute('id')] = nodeIdx;
                          }
                        }
                      }

                      // 2) check and handle relations
                      osmNds = response.children[0].getElementsByTagName('nd');
                      if (osmNds) {
                        for (ndIdx in osmNds) {
                          if (ndIdx) {
                            if (osmNds.hasOwnProperty(ndIdx) && osmNds[ndIdx]) {
                              try {

                                ref = osmNds[ndIdx].getAttribute('ref');
                                if (infoNodes && ref && infoNodes[ref]) {
                                  if (requestContentData && requestContentData.settings) {
                                    if (requestContentData.settings.showAdditionalGeometries) {
                                      // mark as additional information
                                      if (response) {
                                        newTag = response.createElement('tag');
                                        if (newTag && osmNds[ndIdx].parentElement && osmNds[ndIdx].parentElement.getAttribute('id')) {
                                          newTag.setAttribute('k', 'c4g_osm_ref');
                                          newTag.setAttribute('v', osmNds[ndIdx].parentElement.getAttribute('id'));
                                          infoNodes[ref].appendChild(newTag);
                                        }
                                      }
                                    } else {
                                      // remove additional information
                                      infoNodes[ref].innerHTML = '';
                                    }
                                  }
                                }
                              } catch (e) {
                                console.warn('Could not check and handle relations.');
                              }
                            }
                          }
                        }
                      }
                      // import osm_xml
                      format = new ol.format.OSMXML();
                      if (format && response) {
                        try {
                          rFeatures = format.readFeatures(response, { featureProjection: projection });
                        } catch (e) {
                          console.warn('Can not read feature.');
                          //console.log(e.stack);
                        }
                      }

                      // postprocessing features
                      if (rFeatures && rFeatures.length > 0) {
                        for (j = 0; j < rFeatures.length; j += 1) {

                          if (rFeatures[j].getGeometry().getType() === "Point") {
                            rFeatures[j].set('osm_type', 'node');
                          } else {
                            rFeatures[j].set('osm_type', 'way');
                          }
                          rFeatures[j].set('c4g_type', 'osm');
                          rFeatures[j].set('cluster_zoom', contentData.cluster_zoom);
                          rFeatures[j].set('cluster_popup', contentData.cluster_popup);
                          rFeatures[j].set('loc_linkurl', contentData.loc_linkurl);
                          rFeatures[j].set('hover_location', contentData.hover_location);
                          rFeatures[j].set('hover_style', contentData.hover_style);
                          rFeatures[j].set('zoom_onclick', contentData.data.zoom_onclick);
                          rFeatures[j].set('label', contentData.data.label);

                          if (requestContentData.settings.forceNodes) {
                            // convert tracks and areas to points
                            if (rFeatures[j].getGeometry().getType() === "Polygon") {
                              var centerPoint = rFeatures[j].getGeometry().getInteriorPoint().getCoordinates();
                              rFeatures[j].setGeometry(new ol.geom.Point([centerPoint[0], centerPoint[1]]));
                            } else if (rFeatures[j].getGeometry().getType() === "LineString") {
                              // @TODO: prüfen ob dies korrekter Mittelpunkt ist
                              var lineExtent = rFeatures[j].getGeometry().getExtent();
                              var _centerPoint = ol.extent.getCenter(lineExtent);
                              rFeatures[j].setGeometry(new ol.geom.Point(_centerPoint));
                            }
                          }
                        }
                      }
                    } else if (response && response.elements) {
                      rFeatures = [];
                      for (var elementId = 0; elementId < response.elements.length; elementId++) {
                        var element = response.elements[elementId];
                        if (element.type === "node" && !element.tags) {
                          continue;
                        }
                        var tempFeature = self.featureFromOverpass(element, response.elements, contentData, requestContentData.settings.forceNodes);
                        if (tempFeature) {
                          rFeatures.push(tempFeature);
                        }
                      }
                    }
                    try {
                      requestVectorSource.addFeatures(rFeatures);
                    } catch (e) {
                      console.warn('Could not add features to source. The "forceNodes"-option should be used.');
                    }
                    //self.combineLayers(self);
                  }); // end of AJAX
                },
                strategy: ol.loadingstrategy.bbox,
                projection: 'EPSG:3857'
              });

              vectorSource = requestVectorSource;
            } else {

              if (typeof ol.format[contentData.format] === "function") {

                //StaticVector
                vectorSource = new ol.source.Vector({
                  format: new ol.format[contentData.format](),
                  url: requestData.url,
                  projection: 'EPSG:3857',
                  strategy: ol.loadingstrategy.all
                });

                if (contentData.settings && contentData.settings.refresh === true) {
                  if (self.layerRequests === undefined) {
                    self.layerRequests = {};
                  }

                  refreshInterval = typeof contentData.settings.interval === 'number' ? contentData.settings.interval : 10000;
                  /* do it with better ajax-handling
                   self.layerRequests['layerRequest' + itemUid] = window.setInterval(function () {
                   vectorSource.clear();
                   }, refreshInterval);
                   */

                  // Anfang Einschub neue AJAX-Layer
                  refreshAjaxVars.blnHasPositionIds = false;
                  refreshAjaxVars.arrPositionIds = [];
                  refreshAjaxVars.objFeatures = {};

                  vectorSource.set('refreshInterval', refreshInterval);

                  vectorSource.set('refreshFunction', function () {

                    if (!vectorSource.get('hasIds')) {
                      vectorSource.forEachFeature(function (feature) {
                        if (feature.get('positionId')) {
                          refreshAjaxVars.blnHasPositionIds = true;
                          refreshAjaxVars.arrPositionIds.push(feature.get('positionId'));
                          refreshAjaxVars.objFeatures[feature.get('positionId')] = feature;
                        }
                      });
                      if (refreshAjaxVars.blnHasPositionIds) {
                        vectorSource.set('hasIds', true);
                      }
                    }

                    jQuery.ajax({
                      url: requestData.url,
                      done: function done(data) {

                        if (data.renewableResponse) {
                          // update of stations
                          jQuery.each(data.features, function (index, featureData) {
                            if (featureData.type && featureData.type === "Feature") {
                              var feature = new ol.format[contentData.format]().readFeature(featureData, {
                                dataProjection: 'EPSG:4326',
                                featureProjection: 'EPSG:3857'
                              });
                              var layer = self.arrLayers[featureData.properties.id];
                              var popupContent = featureData.properties.popup;
                              layer.vectorLayer.getLayers().forEach(function (element, index, array) {
                                if (!self.proxy.locationStyleController.arrLocStyles[featureData.properties.styleId]) {
                                  self.proxy.locationStyleController.loadLocationStyles([featureData.properties.styleId], { done: function done() {
                                      element.setStyle(self.proxy.locationStyleController.arrLocStyles[featureData.properties.styleId].style);
                                    } });
                                } else {
                                  element.setStyle(self.proxy.locationStyleController.arrLocStyles[featureData.properties.styleId].style);
                                }
                                element.getSource().forEachFeature(function (nestedFeature) {
                                  nestedFeature.set('popup', popupContent);
                                });
                              });
                              layer.content[0].locationStyle = featureData.properties.styleId;

                              if (!self.proxy.locationStyleController.arrLocStyles[featureData.properties.styleId]) {
                                self.proxy.locationStyleController.loadLocationStyles([featureData.properties.styleId], { done: function done() {
                                    feature.setStyle(self.proxy.locationStyleController.arrLocStyles[featureData.properties.styleId].style);
                                  } });
                              } else {
                                feature.setStyle(self.proxy.locationStyleController.arrLocStyles[featureData.properties.styleId].style);
                              }

                              if (self.proxy.activeLayerIds[layer.id]) {
                                self.hideLayer(layer.id);
                                self.showLayer(layer.id);
                              }
                              // vectorSource.addFeature(feature);
                            }
                          });
                        }

                        if (data.features) {

                          refreshAjaxVars.arrNewPositionIds = [];
                          refreshAjaxVars.objNewFeatures = {};

                          jQuery.each(data.features, function (index, featureData) {
                            if (featureData.type && featureData.type == "Feature") {
                              refreshAjaxVars.feature = new ol.format[contentData.format]().readFeature(featureData, {
                                dataProjection: 'EPSG:4326',
                                featureProjection: 'EPSG:3857'
                              });
                              refreshAjaxVars.feature.set('cluster_zoom', contentData.cluster_zoom);
                              refreshAjaxVars.feature.set('loc_linkurl', contentData.loc_linkurl);
                              refreshAjaxVars.feature.set('hover_location', contentData.hover_location);
                              refreshAjaxVars.feature.set('hover_style', contentData.hover_style);
                              if (refreshAjaxVars.feature.get('positionId')) {
                                refreshAjaxVars.arrNewPositionIds.push(refreshAjaxVars.feature.get('positionId'));
                                refreshAjaxVars.objNewFeatures[refreshAjaxVars.feature.get('positionId')] = refreshAjaxVars.feature;
                              }
                            }
                          });

                          jQuery.each(refreshAjaxVars.arrPositionIds, function (index, positionId) {
                            if (refreshAjaxVars.arrNewPositionIds.indexOf(positionId) == -1) {
                              // positions id in neuer antwort nicht mehr enthalten -> lösche feature
                              if (typeof refreshAjaxVars.objFeatures[positionId] !== "undefined") {
                                vectorSource.removeFeature(refreshAjaxVars.objFeatures[positionId]);
                                delete refreshAjaxVars.arrPositionIds[index];
                              }
                            }
                          });

                          jQuery.each(refreshAjaxVars.arrNewPositionIds, function (index, positionId) {
                            if (refreshAjaxVars.arrPositionIds.indexOf(positionId) == -1) {
                              // positions id ist noch nicht vorhanden -> neues feature
                              refreshAjaxVars.arrPositionIds.push(positionId);
                              refreshAjaxVars.objFeatures[positionId] = refreshAjaxVars.objNewFeatures[positionId];
                              vectorSource.addFeature(refreshAjaxVars.objNewFeatures[positionId]);
                            }
                          });
                        }
                      }
                    });
                  });

                  self.proxy.requestFunctions['request_' + itemUid] = {
                    'function': vectorSource.get('refreshFunction'),
                    'interval': refreshInterval
                  };

                  // Ende Einschub neue AJAX-Layer
                }
              } else {
                console.warn('Format type ' + contentData.format + ' in ol.format not found.');
              }
            }

            if (contentData.settings.cluster) {

              window.clusterSource = new ol.source.Cluster({
                distance: 40,
                //threshold: 2, //minimum element count
                source: vectorSource,
                zoom: contentData.cluster_zoom
              });
              //console.log(clusterSource);
              this.styleForCluster = styleForCluster;

              //vectorLayer = utils.getVectorLayer(clusterSource, styleForCluster);

              vectorLayer = new ol.layer.AnimatedCluster({ name: 'Cluster',
                source: window.clusterSource,
                // Use a style function for cluster symbolisation
                style: styleForCluster
              });
            } else {
              if (self.proxy.locationStyleController.arrLocStyles[contentData.locationStyle] && self.proxy.locationStyleController.arrLocStyles[contentData.locationStyle].fnStyleFunction) {

                vectorStyle = Function("feature", "data", "map", self.proxy.locationStyleController.arrLocStyles[contentData.locationStyle].fnStyleFunction);
                vectorLayer = _c4gMapsUtils.utils.getVectorLayer(vectorSource, vectorStyle);
              } else {
                vectorLayer = _c4gMapsUtils.utils.getVectorLayer(vectorSource, self.proxy.locationStyleController.arrLocStyles[contentData.locationStyle] ? self.proxy.locationStyleController.arrLocStyles[contentData.locationStyle].style : null);
              }
            }

            /* Fit to extend */
            if (contentData.settings && contentData.settings.fitToExtend) {

              self.fittingExtends = self.fittingExtends || {};

              vectorSource.on('change', function () {

                // check currently stored id's
                for (i in self.fittingExtends) {
                  if (self.fittingExtends.hasOwnProperty(i)) {
                    if (typeof self.proxy.activeLayerIds[i] === "undefined" || self.proxy.activeLayerIds[0] == "invisible") {
                      delete self.fittingExtends[i];
                    }
                  }
                }

                self.fittingExtends[itemUid] = vectorSource.getExtent(); //vectorSource.getFeatures();
                _c4gMapsUtils.utils.fitToExtents(self.fittingExtends, self.mapController.map);
              });
            }
            // end of fit to extend

            fnAttachDataToLayer(vectorLayer, contentData.data);
            layers.push(vectorLayer);
          } else if (this.arrLayers[itemUid].type === "table" || this.arrLayers[itemUid].type === "link") {
            var layerContent = this.arrLayers[itemUid].content;
            contentData = layerContent[0];
            if (contentData && contentData.data.properties && contentData.data.properties.projection) {
              dataProjection = contentData.data.properties.projection;
              featureProjection = this.mapController.map.getView().getProjection();
            } else {
              dataProjection = undefined;
            }

            // force all nodes into one layer

            var contentFeature = new ol.format[layerContent[i].format]({}).readFeatures(layerContent[i].data, {
              featureProjection: featureProjection,
              dataProjection: dataProjection
            })[0];
            contentFeature.set('cluster_zoom', contentData.cluster_zoom);
            contentFeature.set('cluster_popup', contentData.cluster_popup);
            contentFeature.set('loc_linkurl', contentData.loc_linkurl);
            contentFeature.set('hover_location', contentData.hover_location);
            contentFeature.set('hover_style', contentData.hover_style);
            contentFeature.set('popup', layerContent[i].data.properties.popup);
            contentFeature.set('zoom_onclick', contentData.zoom_onclick);
            contentFeatures.push(contentFeature);

            if (i + 1 === this.arrLayers[itemUid].content.length) {
              vectorSource = new ol.source.Vector({
                features: contentFeatures,
                projection: 'EPSG:3857',
                format: new ol.format.GeoJSON()

              });
              if (contentData && contentData.settings && contentData.settings.cluster) {
                clusterSource = new ol.source.Cluster({
                  distance: 40,
                  zoom: contentData.cluster_zoom,

                  //threshold: 2, //minimum element count
                  source: vectorSource
                });
                //vectorLayer = utils.getVectorLayer(clusterSource, styleForCluster);

                vectorLayer = new ol.layer.AnimatedCluster({ name: 'Cluster',
                  source: clusterSource,
                  // Use a style function for cluster symbolisation
                  style: styleForCluster
                });
              } else {
                vectorLayer = _c4gMapsUtils.utils.getVectorLayer(vectorSource, contentData && self.proxy.locationStyleController.arrLocStyles[contentData.locationStyle] ? self.proxy.locationStyleController.arrLocStyles[contentData.locationStyle].style : null);
              }
              layers.push(vectorLayer);
            }
            //return;
          } else {
            if (this.arrLayers[itemUid].content.length > 1) {
              //TODO: refactoren und kürzen!
              // we have overpass request with reassigned forum layers
              // forum layers can not be drawn via the normal drawLayer, because they do not have a Uid
              if (contentData && typeof ol.format[contentData.format] === "function") {
                if (contentData.data.properties && contentData.data.properties.projection) {
                  dataProjection = contentData.data.properties.projection;
                  featureProjection = this.mapController.map.getView().getProjection();
                } else {
                  dataProjection = undefined;
                }

                features = new ol.format[contentData.format]({}).readFeatures(contentData.data, {
                  featureProjection: featureProjection,
                  dataProjection: dataProjection
                });

                var missingStyles = [];
                var unstyledFeatures = [];
                for (var j = 0; j < features.length; j += 1) {
                  if (features[j].get('styleId')) {
                    if (self.proxy.locationStyleController.arrLocStyles[features[j].get('styleId')] && self.proxy.locationStyleController.arrLocStyles[features[j].get('styleId')].style) {
                      features[j].setStyle(self.proxy.locationStyleController.arrLocStyles[features[j].get('styleId')].style);
                    } else {
                      missingStyles.push(features[j].get('styleId'));
                      unstyledFeatures.push(features[j]);
                    }
                  }
                }

                vectorStyle = self.proxy.locationStyleController.arrLocStyles[contentData.locationStyle] && self.proxy.locationStyleController.arrLocStyles[contentData.locationStyle].style;

                if (missingStyles.length > 0) {
                  //TODO there are unstyled features because some styles were not loaded
                } else {
                  vectorSource = new ol.source.Vector({
                    features: features,
                    projection: 'EPSG:3857',
                    format: new ol.format.GeoJSON()
                  });
                  clusterSource = new ol.source.Cluster({
                    distance: 40,
                    zoom: contentData.cluster_zoom,

                    //threshold: 2, //minimum element count
                    source: vectorSource
                  });

                  vectorLayer = _c4gMapsUtils.utils.getVectorLayer(clusterSource, vectorStyle);
                  if (contentData.data && contentData.data.properties) {
                    if (contentData.data.properties.popup) {
                      vectorLayer.popup = contentData.data.properties.popup;
                    }
                    if (contentData.data.properties.tooltip) {
                      vectorLayer.tooltip = contentData.data.properties.tooltip;
                    }
                    if (contentData.data.properties.label) {
                      vectorLayer.label = contentData.data.properties.label;
                    }
                    if (contentData.data.properties.onclick_zoom) {
                      vectorLayer.onclick_zoom = contentData.data.properties.onclick_zoom;
                    }
                  }
                  layers.push(vectorLayer);
                }
              } else {
                if (contentData) {
                  console.warn('Format type ' + contentData.format + ' in ol.format not found.');
                } else {
                  //no contentData, maybe a link
                }
              }
            } else {
              // normal, not overpass layer
              self.drawLayer(itemUid);
              return;
            }
          }
        }
        // add vector layer group
        layerGroup = new ol.layer.Group({
          layers: layers
        });
        this.arrLayers[itemUid].vectorLayer = layerGroup;
        self.mapController.map.addLayer(layerGroup);
        //self.combine(self);
      } else if (this.arrLayers[itemUid].async_content == 1) {
        styleForCluster = function styleForCluster(feature, resolution) {
          var styleId, style, iconOffset, radius, fillcolor, fontcolor;
          if (feature && feature.get('features')) {
            if (styleId = feature.get('features')[0].get('locationStyle')) {
              if (self.proxy.locationStyleController.arrLocStyles[styleId] && self.proxy.locationStyleController.arrLocStyles[styleId].style) {
                style = self.proxy.locationStyleController.arrLocStyles[styleId].style(feature.get('features')[0], resolution);
              }
            }
            if (!style) {
              style = [];
            }
            if (feature.get('features').length > 1) {
              // calculate bubble-offset
              iconOffset = [0, 0];
              if (style[0]) {
                if (typeof style[0].getImage().getRadius === "function") {
                  radius = parseInt(style[0].getImage().getRadius(), 10);
                  if (radius) {
                    iconOffset = [0, radius];
                  }
                } else if (typeof style[0].getImage().getAnchor === "function") {
                  iconOffset = style[0].getImage().getAnchor() || [0, 0];
                }
              }

              fillcolor = _c4gMapsUtils.utils.getRgbaFromHexAndOpacity('4975A8', {
                unit: '%',
                value: 70
              });

              if (contentData.cluster_fillcolor) {
                fillcolor = _c4gMapsUtils.utils.getRgbaFromHexAndOpacity(contentData.cluster_fillcolor, {
                  unit: '%',
                  value: 70
                });
              }
              if (feature.get('features')[0].get('cluster_fillcolor')) {
                fillcolor = _c4gMapsUtils.utils.getRgbaFromHexAndOpacity(feature.get('features')[0].get('cluster_fillcolor'), {
                  unit: '%',
                  value: 70
                });
              }
              fontcolor = '#FFFFFF';
              if (feature.get('features')[0].get('cluster_fontcolor')) {
                fontcolor = _c4gMapsUtils.utils.getRgbaFromHexAndOpacity(feature.get('features')[0].get('cluster_fontcolor'), {
                  unit: '%',
                  value: 100
                });
              }

              style.push(new ol.style.Style({
                text: new ol.style.Text({
                  text: "●",
                  font: "60px sans-serif",
                  offsetX: -1 * iconOffset[0],
                  offsetY: -1 * iconOffset[1],
                  fill: new ol.style.Fill({
                    color: fillcolor
                  })
                })
              }));
              style.push(new ol.style.Style({
                text: new ol.style.Text({
                  text: feature.get('features').length.toString(),
                  offsetX: -1 * iconOffset[0],
                  offsetY: -1 * iconOffset[1] + 3,
                  fill: new ol.style.Fill({
                    color: fontcolor
                  })
                })
              }));
            }
          }

          if (style) {
            return style;
          }
        };
        requestVectorSource = new ol.source.Vector({
          loader: function loader(extent, resolution, projection) {
            var boundingArray, strBoundingBox, url;
            self.mapController.spinner.show();
            boundingArray = ol.proj.transformExtent(extent, projection, 'EPSG:4326');
            strBoundingBox = boundingArray[0] + ',' + boundingArray[1] + ';' + boundingArray[2] + ',' + boundingArray[3];
            if (self.layerRequests === undefined) {
              self.layerRequests = {};
            }
            if (self.layerRequests['layerDataRequest' + itemUid] !== undefined) {
              self.layerRequests['layerDataRequest' + itemUid].abort();
            }
            if (!self.proxy.locationStyleController.arrLocStyles[self.arrLayers[itemUid].locstyle]) {
              self.proxy.locationStyleController.loadLocationStyles([self.arrLayers[itemUid].locstyle], { done: function done() {} });
            }

            self.layerRequests['layerDataRequest' + itemUid] = jQuery.ajax({
              url: self.proxy.api_layercontentdata_url + '/' + self.arrLayers[itemUid].id + '/' + strBoundingBox
            }).done(function (data) {
              if (data.length > 0 && !contentFeatures) {
                contentFeatures = [];
              }
              var layer = self.arrLayers[itemUid];
              loopData: for (var _i = 0; _i < data.length; _i++) {
                contentData = data[_i];
                for (var _j = 0; _j < contentFeatures.length; _j++) {
                  if (contentData.id === contentFeatures[_j].id) continue loopData;
                }
                var resultCoordinate = ol.proj.transform([parseFloat(contentData['geox']), parseFloat(contentData['geoy'])], 'EPSG:4326', 'EPSG:3857');
                var point = new ol.geom.Point(resultCoordinate);
                contentFeature = new ol.Feature(point);
                contentFeature.setId(contentData.id);
                if (layer.cluster) {
                  contentFeature.set('cluster_zoom', layer.cluster.zoom);
                  contentFeature.set('cluster_popup', layer.cluster.popup);
                  contentFeature.set('cluster_fillcolor', layer.cluster.fillcolor);
                  contentFeature.set('cluster_fontcolor', layer.cluster.fontcolor);
                }

                contentFeature.set('loc_linkurl', layer.loc_linkurl);
                contentFeature.set('hover_location', layer.hover_location);
                contentFeature.set('hover_style', layer.hover_style);
                var popup = contentData['popup'] ? contentData['popup'] : jQuery.extend({}, layer.popup);
                if (popup && popup.content && popup.content.search && popup.content.search('itemId')) {
                  popup.content = popup.content.replace('itemId', contentData['id']);
                }
                if (contentData['label']) {
                  contentFeature.set('label', contentData['label']);
                }
                if (contentData['tooltip']) {
                  contentFeature.set('tooltip', contentData['tooltip']);
                }
                contentFeature.set('popup', popup);
                contentFeature.set('zoom_onclick', layer.zoom_onclick);
                contentFeature.set('tid', contentData['id']);
                var locstyle = contentData['locstyle'] || layer.locstyle;
                contentFeature.set('locationStyle', locstyle);
                if (locstyle && self.proxy.locationStyleController.arrLocStyles[locstyle] && self.proxy.locationStyleController.arrLocStyles[locstyle].style) {
                  contentFeature.setStyle(self.proxy.locationStyleController.arrLocStyles[locstyle].style);
                  contentFeatures.push(contentFeature);
                } else {
                  if (!unstyledFeatures) {
                    unstyledFeatures = [];
                  }
                  if (!missingStyles) {
                    missingStyles = [];
                  }
                  contentFeature.set('styleId', locstyle);
                  unstyledFeatures.push(contentFeature);
                  missingStyles[locstyle] = locstyle;
                }
              }
              if (missingStyles) {
                self.proxy.locationStyleController.loadLocationStyles(missingStyles, { done: function done() {
                    for (i = 0; i < unstyledFeatures.length; i++) {
                      var styleId = unstyledFeatures[i].get('styleId');
                      unstyledFeatures[i].setStyle(self.proxy.locationStyleController.arrLocStyles[styleId].style);
                      requestVectorSource.addFeature(unstyledFeatures[i]);
                    }
                    missingStyles = undefined;
                  } });
              }

              if (data.length > 0) {
                requestVectorSource.addFeatures(contentFeatures);
              }
            }).always(function () {
              self.mapController.spinner.hide();
            });
          },
          strategy: ol.loadingstrategy.bbox
        });

        if (this.arrLayers[itemUid].cluster) {
          var layer = self.arrLayers[itemUid];
          var map = self.mapController.map;
          var currentZoom = map.getView().getZoom();
          var clusterDistance = this.arrLayers[itemUid].cluster.distance || 20;
          if (currentZoom >= layer.cluster.zoom) {
            clusterDistance = 0;
          }

          clusterSource = new ol.source.Cluster({
            distance: clusterDistance,
            //threshold: 2, //minimum element count
            source: requestVectorSource
          });
          vectorLayer = new ol.layer.AnimatedCluster({ name: 'Cluster',
            source: clusterSource,
            // Use a style function for cluster symbolisation
            style: styleForCluster
          });
        } else {
          vectorLayer = new ol.layer.Vector({
            name: 'Layer',
            source: requestVectorSource
          });
        }
        layers = layers || [];
        layers.push(vectorLayer);
        layerGroup = new ol.layer.Group({
          layers: layers
        });
        this.arrLayers[itemUid].vectorLayer = layerGroup;
        self.mapController.map.addLayer(layerGroup);
      } else {
        self.mapController.spinner.show();
        jQuery.ajax({
          dataType: self.mapController.data.jsonp ? "jsonp" : "json",
          url: self.proxy.api_layercontent_url + '/' + self.arrLayers[itemUid].id
        }).done(function (data) {
          var j = void 0,
              newLocationStyles = void 0;

          if (data.length > 0) {
            newLocationStyles = [];

            for (j = 0; j < data.length; j += 1) {

              self.arrLayers[itemUid].content = self.arrLayers[itemUid].content || [];

              self.arrLayers[itemUid].content.push(data[j]);
              newLocationStyles.push(data[j].locationStyle);
            }

            self.proxy.checkLocationStyles({
              done: function done() {
                // @TODO: check this!
                self.loadLayerContent(itemUid);
              }
            });
          }
        }).always(function () {
          self.mapController.spinner.hide();
        });
      }
    } // end of "loadLayerContent()"

  }, {
    key: "featureFromOverpass",
    value: function featureFromOverpass(element, elements, contentData, forceNodes) {
      var _this = this;

      var feature = null;
      if (element.type == "node") {
        if (element.tags) {
          var point = new ol.geom.Point([element.lon, element.lat]).transform('EPSG:4326', 'EPSG:3857');
          feature = new ol.Feature({
            geometry: point
          });
          feature.setId(element.id);
          feature.set('osm_type', 'node');
        }
      } else if (element.type == "way") {
        if (element.tags) {
          feature = new ol.Feature(this.geomFromWay(element, elements, forceNodes));
        } else {
          var geom = this.geomFromWay(element, elements, forceNodes);
          feature = new ol.Feature(geom);
        }
      } else if (element.type === "relation") {
        var multiPolygon = null;
        var multiLineString = null;
        var arrCoords = null;
        var _point = null;

        var _loop = function _loop(i) {
          if (element.members[i].role === "outer") {
            //@ToDo add handling for outer border
            return "continue";
          }
          var member = elements.find(function (objMemb) {
            return objMemb.id === element.members[i].ref;
          });
          if (member) {
            var _geom = void 0;
            if (member.type === 'node') {
              _geom = new ol.geom.Point([member.lon, member.lat]).transform('EPSG:4326', 'EPSG:3857');
            } else {
              _geom = _this.geomFromWay(member, elements, true);
            }
            if (_geom instanceof ol.geom.Point) {
              if (!arrCoords) {
                arrCoords = [];
              }
              arrCoords.push(_geom.getCoordinates());
            } else if (_geom instanceof ol.geom.Polygon) {
              if (multiPolygon) {
                multiPolygon.appendPolygon(_geom);
              } else {
                multiPolygon = new ol.geom.MultiPolygon(_geom.getCoordinates());
              }
            } else if (_geom instanceof ol.geom.LineString) {
              if (multiLineString) {
                multiLineString.appendLineString(_geom);
              } else {
                multiLineString = new ol.geom.LineString(_geom.getCoordinates());
              }
            }
          }
        };

        for (var i = 0; i < element.members.length; i++) {
          var _ret = _loop(i);

          if (_ret === "continue") continue;
        }
        if (arrCoords) {
          var extent = ol.extent.boundingExtent(arrCoords);
          _point = new ol.geom.Point(ol.extent.getCenter(extent));
        }
        if (_point || multiPolygon || multiLineString) {
          feature = new ol.Feature(_point ? _point : multiLineString ? multiLineString : multiPolygon);
        }
      }
      if (feature) {
        feature.set('c4g_type', 'osm');
        feature.set('cluster_zoom', contentData.cluster_zoom || '');
        feature.set('cluster_popup', contentData.cluster_popup || '');
        feature.set('loc_linkurl', contentData.loc_linkurl || '');
        feature.set('hover_location', contentData.hover_location || '');
        feature.set('hover_style', contentData.hover_style || '');
        feature.set('tid', element.id);
        if (contentData.data) {
          feature.set('zoom_onclick', contentData.data.zoom_onclick || '');
          feature.set('label', contentData.data.label || '');
        }

        for (var tags in element.tags) {
          feature.set(tags, element.tags[tags]);
        }
        return feature;
      }
    }
  }, {
    key: "geomFromWay",
    value: function geomFromWay(element, elements, forceNodes) {
      var arrCoords = [];

      var _loop2 = function _loop2(i) {
        var node = elements.find(function (objNode) {
          return objNode.id === element.nodes[i];
        });
        if (node) {
          arrCoords.push(ol.proj.transform([node.lon, node.lat], 'EPSG:4326', 'EPSG:3857'));
        }
      };

      for (var i = 0; i < element.nodes.length; i++) {
        _loop2(i);
      }
      if (arrCoords && arrCoords[0] && arrCoords[0][0] == arrCoords[arrCoords.length - 1][0] && arrCoords[0][1] == arrCoords[arrCoords.length - 1][1]) {
        //polygon
        delete arrCoords[arrCoords.length - 1];
        arrCoords.length = arrCoords.length - 1;
        var polygon = new ol.geom.Polygon([arrCoords]);
        // polygon.transform('EPSG:4326','EPSG:3857');
        if (forceNodes) {
          // convert tracks and areas to points
          var tempPoint = polygon.getInteriorPoint();
          var tempCoords = tempPoint.getCoordinates();
          return new ol.geom.Point([tempCoords[0], tempCoords[1]]);
        } else {
          return polygon;
        }
      } else {
        //linestring
        var lineString = new ol.geom.LineString(arrCoords);
        if (forceNodes) {
          if (arrCoords.length > 0) {
            var lineExtent = ol.extent.boundingExtent(arrCoords);
            var lineCenter = ol.extent.getCenter(lineExtent);
            return new ol.geom.Point([lineCenter[0], lineCenter[1]]);
          }
        } else {
          return lineString;
        }
      }
    }
  }, {
    key: "hideLayer",
    value: function hideLayer(layerUid, keepLayer) {

      var layer, i, j;

      layer = this.arrLayers[layerUid];
      if (!layer) {
        //console.warn('Cannot hide unknown layer (' + layerUid + ')');
        return false;
      }

      // check if layer is listed as "active"
      // otherwise there is nothing to remove or change
      if (this.proxy.activeLayerIds[layerUid]) {
        // remove layer from map (if it was visible before)
        if (this.proxy.activeLayerIds[layerUid] === 'visible' && layer.vectorLayer) {
          // [info]: do not use "layer.vectorLayer.setVisible(false);"
          //         see "showLayer()" for more information
          this.mapController.map.removeLayer(layer.vectorLayer);
        }
        // only mark as "invisible" if "keepLayer" is "true"
        // this is needed for the zoom-bounds
        if (keepLayer) {
          this.proxy.activeLayerIds[layerUid] = 'invisible';
        } else {
          delete this.proxy.activeLayerIds[layerUid];
        }
      }

      // childs needed to be checked independent from its parents state


      //ToDo loading problem
      if (layer && layer.hasChilds) {
        for (i = 0; i < layer.childs.length; i += 1) {
          this.hideLayer(layer.childs[i].id);
        }
      }
      if (layer.isInactive) {
        _c4gMapsUtils.utils.callHookFunctions(this.proxy.hook_layer_visibility, layerUid);
        return;
      }
      layer.isInactive = true;

      if (this.layerRequests && typeof this.layerRequests['layer_request_' + layerUid] !== "undefined") {
        if (typeof this.layerRequests['layer_request_' + layerUid] == "number") {
          try {
            window.clearInterval(this.layerRequests['layer_request_' + layerUid]);
            delete this.layerRequests['layer_request_' + layerUid];
          } catch (e) {}
        }
      }
      //this.combineLayers(this);
      this.mapController.map.getView().setCenter([this.mapController.map.getView().getCenter()[0] + 0.001, this.mapController.map.getView().getCenter()[1]]);
      // hooks
      _c4gMapsUtils.utils.callHookFunctions(this.proxy.hook_layer_visibility, layerUid);
    } // end of "hideLayer()"

  }, {
    key: "hideChildLayer",
    value: function hideChildLayer(layerUid, childUid) {
      var layer = this.arrLayers[layerUid];
      childUid = childUid.replace(layerUid, '');
      var childLayer = layer.vectorLayer.getLayers().getArray()[childUid];
      childLayer.set('visible', false);
    }
  }, {
    key: "showChildLayer",
    value: function showChildLayer(layerUid, childUid) {
      var layer = this.arrLayers[layerUid];
      childUid = childUid.replace(layerUid, '');
      var childLayer = layer.vectorLayer.getLayers().getArray()[childUid];
      childLayer.set('visible', true);
    }
  }, {
    key: "showLayer",
    value: function showLayer(layerUid) {
      var layer, mapLayers, addLayer, i, j, activeForZoom;

      activeForZoom = this.proxy.checkLayerIsActiveForZoom(layerUid);
      layer = this.arrLayers[layerUid];

      if (activeForZoom) {
        if (this.proxy.activeLayerIds[layerUid] !== 'visible') {
          //if (layer.link_id) {
          //  this.proxy.activeLayerIds[layer.link_id] = 'visible';
          //} else
          if (layer && layer.vectorLayer) {
            // [info]: do not use: "layer.vectorLayer.setVisible(true);"
            //         Always add and remove Layers, so that the last
            //         clicked layer is always ontop of the others.

            // check if layer is really not already on the map
            // to prevent adding the same layer multiple times
            addLayer = true;
            mapLayers = this.mapController.map.getLayers();
            mapLayers.forEach(function (element, index, array) {
              if (element === layer.vectorLayer) {
                addLayer = false;
              }
            });
            if (addLayer) {
              if (layer.vectorLayer.getLayers().getArray()[0] && layer.vectorLayer.getLayers().getArray()[0].popup && layer.vectorLayer.getLayers().getArray()[0].popup.showPopupOnActive) {

                this.proxy.currentPopup.$content.html('');
                this.proxy.currentPopup.$popup.addClass(_c4gMapsConstant.cssConstants.ACTIVE).addClass(_c4gMapsConstant.cssConstants.LOADING);
                this.proxy.currentPopup.spinner.show();
                var popupInfos = layer.vectorLayer.getLayers().getArray()[0].popup;
                var features = layer.vectorLayer.getLayers().getArray()[0].getSource().getFeatures();
                var coord = features['0'].getGeometry().getCoordinates();
                if (popupInfos.async === false) {
                  var objPopup = {};
                  objPopup.popup = popupInfos;
                  objPopup.feature = features['0'];
                  objPopup.layer = layer.vectorLayer.getLayers().getArray()[0];
                  // Call the popup hook for plugin specific popup content
                  if (window.c4gMapsHooks !== undefined && _typeof(window.c4gMapsHooks.proxy_fillPopup) === 'object') {
                    _c4gMapsUtils.utils.callHookFunctions(window.c4gMapsHooks.proxy_fillPopup, objPopup);
                  }
                  this.proxy.setPopup(objPopup);
                } else {
                  var self = this;
                  jQuery.ajax({
                    dataType: "json",
                    url: self.api_infowindow_url + '/' + popupInfos.content,
                    done: function done(data) {
                      var popupInfo = {
                        async: popupInfos.async,
                        content: data.content,
                        popup: popupInfos.popup,
                        routing_link: popupInfos.routing_link
                      };

                      var objPopup = {};
                      objPopup.popup = popupInfo;
                      objPopup.feature = features['0'];
                      objPopup.layer = layer;

                      // Call the popup hook for plugin specific popup content
                      if (window.c4gMapsHooks !== undefined && _typeof(window.c4gMapsHooks.proxy_fillPopup) === 'object') {
                        _c4gMapsUtils.utils.callHookFunctions(window.c4gMapsHooks.proxy_fillPopup, objPopup);
                      }

                      self.proxy.setPopup(objPopup);
                    }
                  });
                }
              }
              this.mapController.map.addLayer(layer.vectorLayer);
            }
          } else {
            this.loadLayerContent(layerUid);
          }
          this.proxy.activeLayerIds[layerUid] = 'visible';
        } else {
          //if (layer.link_id) {
          //  this.proxy.activeLayerIds[layer.link_id] = 'invisible';
          //} else {
          //this.proxy.activeLayerIds[layerUid] = 'invisible';
          //}
        }
      }

      if (layer && layer.hasChilds && activeForZoom) {
        for (i = 0; i < layer.childs.length; i += 1) {
          this.showLayer(layer.childs[i].id);
        }
      }

      if (layer && activeForZoom) {
        layer.isInactive = false;
      }

      if (typeof this.proxy.requestFunctions['request_' + layerUid] !== "undefined") {

        if (this.layerRequests && typeof this.layerRequests['layer_request_' + layerUid] === "undefined") {
          this.layerRequests['layer_request_' + layerUid] = window.setInterval(this.proxy.requestFunctions['request_' + layerUid].function, this.proxy.requestFunctions['request_' + layerUid].interval);
        }
      }
      //this.combineLayers(this);
      // hooks
      _c4gMapsUtils.utils.callHookFunctions(this.proxy.hook_layer_visibility, layerUid);
    } // end of "showLayer()"

  }, {
    key: "drawLayer",
    value: function drawLayer(itemUid) {

      var self, element, elementContent, layers, i, j, missingStyles, unstyledFeatures, features, dataProjection, featureProjection, vectorSource, vectorLayer, vectorStyle, layerGroup;

      self = this;
      element = this.arrLayers[itemUid];

      // if (!element.hide) {

      layers = [];
      if (element.content && element.content.length > 0) {
        for (i = 0; i < element.content.length; i += 1) {

          elementContent = element.content[i];
          if (!elementContent) {
            continue;
          }
          if (typeof ol.format[elementContent.format] === "function") {

            // if (element.content[i].origType === 'single') {
            //   featureProjection = this.mapController.map.getView().getProjection();
            // } else {
            //   featureProjection = undefined;
            // }
            if (elementContent.data.properties && elementContent.data.properties.projection) {
              dataProjection = elementContent.data.properties.projection;
              featureProjection = this.mapController.map.getView().getProjection();
            } else {
              dataProjection = undefined;
            }

            if (elementContent.format === "OSMXML") {
              continue;
            }
            if (elementContent.data.geometry && elementContent.data.geometry.type === "Circle") {
              // draw circle geometries
              features = [];
              var feature = new ol.Feature(new ol.geom.Circle(ol.proj.fromLonLat(elementContent.data.geometry.center), parseFloat(elementContent.data.geometry.radius)));
              feature.set('styleId', elementContent.locationStyle);
              feature.set('label', elementContent.data.properties.label);
              features.push(feature);
            } else {
              // remaining geometries
              features = new ol.format[elementContent.format]({}).readFeatures(elementContent.data, {
                featureProjection: featureProjection,
                dataProjection: dataProjection
              });
            }

            missingStyles = [];
            unstyledFeatures = [];
            for (j = 0; j < features.length; j += 1) {
              // features[j].setId(utils.getUniqueId());
              // features[j].set('projection', this.mapController.map.getView().getProjection());
              // features[j].set('projection', "EPSG:4326");
              features[j].set('hover_location', elementContent.hover_location);
              features[j].set('hover_style', elementContent.hover_style);
              if (features[j].get('styleId')) {
                if (self.proxy.locationStyleController.arrLocStyles[features[j].get('styleId')] && self.proxy.locationStyleController.arrLocStyles[features[j].get('styleId')].style) {
                  features[j].setStyle(self.proxy.locationStyleController.arrLocStyles[features[j].get('styleId')].style);
                } else {
                  missingStyles.push(features[j].get('styleId'));
                  unstyledFeatures.push(features[j]);
                }
              } else if (elementContent.locationStyle) {
                // feature has no property styleId, but elementContent has locationstyle
                if (self.proxy.locationStyleController.arrLocStyles[elementContent.locationStyle] && self.proxy.locationStyleController.arrLocStyles[elementContent.locationStyle].style) {
                  //features[j].setStyle(self.proxy.locationStyleController.arrLocStyles[elementContent.locationStyle].style);
                } else {
                  missingStyles.push(elementContent.locationStyle);
                  unstyledFeatures.push(features[j]);
                  features[j].set('styleId', elementContent.locationStyle);
                }
              }
            }

            vectorStyle = self.proxy.locationStyleController.arrLocStyles[elementContent.locationStyle] && self.proxy.locationStyleController.arrLocStyles[elementContent.locationStyle].style;
            if (self.proxy.locationStyleController.arrLocStyles[elementContent.locationStyle] && self.proxy.locationStyleController.arrLocStyles[elementContent.locationStyle].fnStyleFunction) {

              vectorStyle = Function("feature", "data", "map", self.proxy.locationStyleController.arrLocStyles[elementContent.locationStyle].fnStyleFunction);
            }
            if (missingStyles.length > 0) {
              this.proxy.locationStyleController.loadLocationStyles(missingStyles, {
                done: function done() {
                  var f, fLayerGroup, fLayers, fVectorLayer, fVectorSource;
                  for (f = 0; f < unstyledFeatures.length; f += 1) {
                    if (self.proxy.locationStyleController.arrLocStyles[unstyledFeatures[f].get('styleId')]) {
                      unstyledFeatures[f].setStyle(self.proxy.locationStyleController.arrLocStyles[unstyledFeatures[f].get('styleId')].style);
                    }
                  }

                  fVectorSource = new ol.source.Vector({
                    features: features,
                    projection: 'EPSG:3857',
                    format: new ol.format.GeoJSON()
                  });

                  fVectorLayer = _c4gMapsUtils.utils.getVectorLayer(fVectorSource, vectorStyle);

                  // layers.push(vectorLayer);
                  if (self.arrLayers[itemUid].fVectorLayer) {
                    fLayerGroup = self.arrLayers[itemUid].vectorLayer;
                    fLayers = fLayerGroup.getLayers();

                    if (elementContent.data && elementContent.data.properties) {
                      if (elementContent.data.properties.popup) {
                        fVectorLayer.popup = elementContent.data.properties.popup;
                      }
                      if (elementContent.data.properties.tooltip) {
                        fVectorLayer.tooltip = elementContent.data.properties.tooltip;
                      }
                      if (elementContent.data.properties.label) {
                        fVectorLayer.label = elementContent.data.properties.label;
                      }
                      if (elementContent.data.properties.zoom_onclick) {
                        fVectorLayer.zoom_onclick = elementContent.data.properties.zoom_onclick;
                      }
                    }

                    fLayers.push(fVectorLayer);
                    fLayerGroup.setLayers(fLayers);
                  } else {
                    if (elementContent.data && elementContent.data.properties) {
                      if (elementContent.data.properties.popup) {
                        fVectorLayer.popup = elementContent.data.properties.popup;
                      }
                      if (elementContent.data.properties.tooltip) {
                        fVectorLayer.tooltip = elementContent.data.properties.tooltip;
                      }
                      if (elementContent.data.properties.label) {
                        fVectorLayer.label = elementContent.data.properties.label;
                      }
                      if (elementContent.data.properties.zoom_onclick) {
                        fVectorLayer.zoom_onclick = elementContent.data.properties.zoom_onclick;
                      }
                    }
                    fLayerGroup = new ol.layer.Group({
                      layers: [fVectorLayer]
                    });
                    self.arrLayers[itemUid].vectorLayer = fLayerGroup;
                    self.mapController.map.addLayer(fLayerGroup);
                  }
                }
              });
            } else {
              if (element.split_geojson) {
                for (var _i2 = 0; _i2 < features.length; _i2++) {
                  vectorSource = new ol.source.Vector({
                    projection: 'EPSG:3857',
                    format: new ol.format.GeoJSON()
                  });
                  vectorSource.addFeature(features[_i2]);
                  vectorLayer = _c4gMapsUtils.utils.getVectorLayer(vectorSource, vectorStyle);
                  for (var _j2 = 0; _j2 < element.geojson_attributes.split(',').length; _j2++) {
                    vectorLayer.set(element.geojson_attributes.split(',')[_j2], features[_i2].get(element.geojson_attributes.split(',')[_j2]));
                  }
                  layers.push(vectorLayer);
                  if (elementContent.data.properties.popup) {
                    vectorLayer.popup = elementContent.data.properties.popup;
                  }
                  if (elementContent.data.properties.tooltip) {
                    vectorLayer.tooltip = elementContent.data.properties.tooltip;
                  }
                  if (elementContent.data.properties.label) {
                    vectorLayer.label = elementContent.data.properties.label;
                  }
                  if (elementContent.data.properties.zoom_onclick) {
                    vectorLayer.zoom_onclick = elementContent.data.properties.zoom_onclick;
                  }
                }
              } else {
                vectorSource = new ol.source.Vector({
                  features: features,
                  projection: 'EPSG:3857',
                  format: new ol.format.GeoJSON()
                });
                vectorLayer = _c4gMapsUtils.utils.getVectorLayer(vectorSource, vectorStyle);

                if (elementContent.data && elementContent.data.properties) {
                  if (elementContent.data.properties.popup) {
                    vectorLayer.popup = elementContent.data.properties.popup;
                  }
                  if (elementContent.data.properties.tooltip) {
                    vectorLayer.tooltip = elementContent.data.properties.tooltip;
                  }
                  if (elementContent.data.properties.label) {
                    vectorLayer.label = elementContent.data.properties.label;
                  }
                  if (elementContent.data.properties.zoom_onclick) {
                    vectorLayer.zoom_onclick = elementContent.data.properties.zoom_onclick;
                  }
                }

                layers.push(vectorLayer);
              }
            }
          } else {
            console.warn('Format type ' + elementContent.format + ' in ol.format not found.');
          }
        }
      }

      layerGroup = new ol.layer.Group({
        layers: layers
      });

      this.arrLayers[itemUid].vectorLayer = layerGroup;
      this.mapController.map.addLayer(layerGroup);
      if (layerGroup.getLayers().getArray()[0] && layerGroup.getLayers().getArray()[0].popup && layerGroup.getLayers().getArray()[0].popup.showPopupOnActive) {
        this.proxy.currentPopup.$content.html('');
        this.proxy.currentPopup.$popup.addClass(_c4gMapsConstant.cssConstants.ACTIVE).addClass(_c4gMapsConstant.cssConstants.LOADING);
        this.proxy.currentPopup.spinner.show();
        var popupInfos = layerGroup.getLayers().getArray()[0].popup;
        var layer = layerGroup.getLayers().getArray()[0];
        var coord = features['0'].getGeometry().getCoordinates();
        if (popupInfos.async === false) {
          var objPopup = {};
          objPopup.popup = popupInfos;
          objPopup.feature = features['0'];
          objPopup.layer = layer;
          // Call the popup hook for plugin specific popup content
          if (window.c4gMapsHooks !== undefined && _typeof(window.c4gMapsHooks.proxy_fillPopup) === 'object') {
            _c4gMapsUtils.utils.callHookFunctions(window.c4gMapsHooks.proxy_fillPopup, objPopup);
          }
          self.proxy.setPopup(objPopup);
        } else {
          jQuery.ajax({
            dataType: "json",
            url: self.api_infowindow_url + '/' + popupInfos.content,
            done: function done(data) {
              var popupInfo = {
                async: popupInfos.async,
                content: data.content,
                popup: popupInfos.popup,
                routing_link: popupInfos.routing_link
              };

              var objPopup = {};
              objPopup.popup = popupInfo;
              objPopup.feature = features['0'];
              objPopup.layer = layer;

              // Call the popup hook for plugin specific popup content
              if (window.c4gMapsHooks !== undefined && _typeof(window.c4gMapsHooks.proxy_fillPopup) === 'object') {
                _c4gMapsUtils.utils.callHookFunctions(window.c4gMapsHooks.proxy_fillPopup, objPopup);
              }

              self.proxy.setPopup(objPopup);
            }
          });
        }
      }

      //hooks
      // }
    } // end of "drawLayer()"

  }, {
    key: "drawLayerInitial",
    value: function drawLayerInitial() {
      var layerId, layer;

      for (layerId in this.proxy.activeLayerIds) {
        if (this.proxy.activeLayerIds.hasOwnProperty(layerId)) {
          this.showLayer(layerId);
        }
      }
      for (var l in this.arrLayers) {
        if (this.arrLayers.hasOwnProperty(l)) {
          layer = this.arrLayers[l];
          if (layer.hide === "1") {
            this.hideLayer(layer.id);
          }
        }
      }
    } // end of "drawLayerInitial()"

  }]);

  return C4gLayerController;
}();

/***/ }),

/***/ "./Resources/public/js/c4g-layer.js":
/*!******************************************!*\
  !*** ./Resources/public/js/c4g-layer.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * This file is part of con4gis,
 * the gis-kit for Contao CMS.
 *
 * @package    con4gis
 * @version    6
 * @author     con4gis contributors (see "authors.txt")
 * @license    LGPL-3.0-or-later
 * @copyright  Küstenschmiede GmbH Software & Design
 * @link       https://www.con4gis.org
 */
var C4gLayer = exports.C4gLayer = function C4gLayer(layerArr) {
  _classCallCheck(this, C4gLayer);

  this.id = layerArr['id'];
  this.pid = layerArr['pid'];
  this.async_content = layerArr['async_content'];
  this.content = layerArr['content'];
  this.cssClass = layerArr['cssClass'];
  this.hide = layerArr['hide'];
  this.hide_child = layerArr['hide_child'];
  this.type = layerArr['type'];
  this.cluster = layerArr['cluster'];
  this.zoom = layerArr['zoom'];
  this.zoom_locations = layerArr['zoom_locations'];
  this.display = layerArr['display'];
  this.hasChilds = layerArr['hasChilds'];
  this.childs = layerArr['childs'];
  this.childsCount = layerArr['childsCount'];
  this.renderSpecial = layerArr['renderSpecial'];
  this.editable = true;
  this.type = layerArr['type'];
  this.locstyle = layerArr['locstyle'];
  this.name = layerArr['name'];
  this.tabId = layerArr['tabId'];
  this.split_geojson = layerArr['split_geojson'];
  this.geojson_attributes = layerArr['geojson_attributes'];
  this.geojson_zoom = layerArr['geojson_zoom'];
  this.layername = layerArr['layername'];
  this.visibleChilds = false;
  this.vectorLayer = null;
  this.hideWhenInTab = layerArr['hide_when_in_tab'];
  this.noFilter = layerArr['noFilter'];

  if (layerArr.projectId) {
    this.projectId = layerArr.projectId;
  }
  if (layerArr.popup) {
    this.popup = layerArr.popup;
  }
  this.awesomeicon = layerArr['awesomeicon'];
};

/***/ }),

/***/ "./Resources/public/js/c4g-locationstyle-controller.js":
/*!*************************************************************!*\
  !*** ./Resources/public/js/c4g-locationstyle-controller.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.C4gLocationStyleController = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * This file is part of con4gis,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * the gis-kit for Contao CMS.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @package    con4gis
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @version    6
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @author     con4gis contributors (see "authors.txt")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @license    LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @copyright  Küstenschmiede GmbH Software & Design
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @link       https://www.con4gis.org
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _c4gLocationstyle = __webpack_require__(/*! ./c4g-locationstyle */ "./Resources/public/js/c4g-locationstyle.js");

var _c4gMapsConstant = __webpack_require__(/*! ./c4g-maps-constant */ "./Resources/public/js/c4g-maps-constant.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var C4gLocationStyleController = exports.C4gLocationStyleController = function () {
    function C4gLocationStyleController(proxy) {
        _classCallCheck(this, C4gLocationStyleController);

        this.proxy = proxy;
        this.mapController = proxy.options.mapController;
        this.arrLocStyles = {};
    }

    _createClass(C4gLocationStyleController, [{
        key: "loadLocationStyles",
        value: function loadLocationStyles(arrIds, opt_options) {
            var options = void 0,
                complete = {},
                success = {},
                self = this,
                count = 1,
                makeAjax = void 0;

            if (opt_options && (typeof opt_options === "undefined" ? "undefined" : _typeof(opt_options)) === "object") {
                options = opt_options;
            } else {
                options = {};
            }

            // this.proxy.options.mapController.spinner.show();

            makeAjax = function makeAjax(styleIds, index) {
                if (index) {
                    complete[index] = false;
                    success[index] = false;
                }
                // get locationstyles over API
                jQuery.ajax({
                    dataType: self.proxy.options.mapController.data.jsonp ? "jsonp" : "json",
                    url: self.proxy.api_locstyle_url,
                    data: {
                        ids: styleIds
                    }
                }).done(function (data) {
                    var i = void 0,
                        styleData = void 0,
                        successful = true;

                    if (data.length > 0) {
                        for (i = 0; i < data.length; i += 1) {
                            styleData = data[i];
                            self.arrLocStyles[styleData.id] = new _c4gLocationstyle.C4gLocationStyle(styleData, self);
                        }
                    }
                    if (index) {
                        success[index] = true;
                        for (var key in success) {
                            if (success.hasOwnProperty(key)) {
                                if (!success[key]) {
                                    successful = false;
                                    break;
                                }
                            }
                        }
                    }
                    if (options.done && typeof options.done === "function" && (index ? successful : true)) {
                        options.done();
                    }
                }).always(function (jXhr, strStatus) {
                    var completed = true;

                    if (index) {
                        complete[index] = true;
                        for (var key in complete) {
                            if (complete.hasOwnProperty(key)) {
                                if (!complete[key]) {
                                    completed = false;
                                    break;
                                }
                            }
                        }
                    }
                    if (options.always && typeof options.always === "function" && (index ? completed : true)) {
                        options.always();
                    }
                    if (!jQuery(self.proxy.options.mapController.spinner.element).hasClass(_c4gMapsConstant.cssConstants.HIDE)) {
                        self.proxy.options.mapController.spinner.hide();
                    }
                }).fail(function (jqXHR, textStatus, errorThrown) {
                    console.warn(errorThrown);
                });
            };

            // split arrIds if it's too long
            if (arrIds.length > 100) {
                var n = 100;
                while (arrIds.length > 0) {
                    makeAjax(arrIds.splice(0, n), count);
                    count++;
                }
            } else {
                makeAjax(arrIds);
            }
            //});
        } // end of "loadLocationStyles()"

    }]);

    return C4gLocationStyleController;
}();

/***/ }),

/***/ "./Resources/public/js/c4g-locationstyle.js":
/*!**************************************************!*\
  !*** ./Resources/public/js/c4g-locationstyle.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.C4gLocationStyle = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * This file is part of con4gis,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * the gis-kit for Contao CMS.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @package    con4gis
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @version    6
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @author     con4gis contributors (see "authors.txt")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @license    LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @copyright  Küstenschmiede GmbH Software & Design
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @link       https://www.con4gis.org
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _c4gMapsUtils = __webpack_require__(/*! ./c4g-maps-utils */ "./Resources/public/js/c4g-maps-utils.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var C4gLocationStyle = exports.C4gLocationStyle = function () {
    function C4gLocationStyle(locStyleArr, controller) {
        _classCallCheck(this, C4gLocationStyle);

        this.id = locStyleArr['id'];
        this.style = this.getStyleFunction(locStyleArr);
        this.editor = this.getStyleEditorConfig(locStyleArr);
        this.name = locStyleArr['name'];
        this.tooltip = locStyleArr['tooltip'];
        this.label = locStyleArr['label'];
        this.minzoom = locStyleArr['minzoom'];
        this.maxzoom = locStyleArr['maxzoom'];
        this.fnStyleFunction = locStyleArr['style_function_js'];
        this.controller = controller;
        this.locStyleArr = locStyleArr;
    }

    _createClass(C4gLocationStyle, [{
        key: 'getStyleFunction',
        value: function getStyleFunction(styleData) {
            var self, styleFunction, imageStyle, strokeStyle, fillStyle, textStyle, textStyleOutline, backgroundFill, backgroundStroke;

            self = this;

            // general
            strokeStyle = new ol.style.Stroke({
                color: _c4gMapsUtils.utils.getRgbaFromHexAndOpacity(styleData.strokecolor, styleData.strokeopacity),
                width: parseInt(styleData.strokewidth.value, 10)
            });
            fillStyle = new ol.style.Fill({
                color: _c4gMapsUtils.utils.getRgbaFromHexAndOpacity(styleData.fillcolor, styleData.fillopacity)
            });

            // image
            switch (styleData.styletype) {
                case 'square':
                    imageStyle = new ol.style.RegularShape({
                        fill: fillStyle,
                        stroke: strokeStyle,
                        points: 4,
                        radius: styleData.radius.value || 10,
                        angle: Math.PI / 4
                    });
                    break;
                case 'star':
                    imageStyle = new ol.style.RegularShape({
                        fill: fillStyle,
                        stroke: strokeStyle,
                        radius1: styleData.radius.value || 10,
                        radius2: styleData.radius.value ? Math.floor(styleData.radius.value * 0.5) : 4,
                        points: 5,
                        angle: 0
                    });
                    break;
                case 'x':
                    imageStyle = new ol.style.RegularShape({
                        fill: fillStyle,
                        stroke: strokeStyle,
                        points: 4,
                        radius: styleData.radius.value || 10,
                        radius2: 0,
                        angle: Math.PI / 4
                    });
                    break;
                case 'cross':
                    imageStyle = new ol.style.RegularShape({
                        fill: fillStyle,
                        stroke: strokeStyle,
                        points: 4,
                        radius: styleData.radius.value || 10,
                        radius2: 0,
                        angle: 0
                    });
                    break;
                case 'triangle':
                    imageStyle = new ol.style.RegularShape({
                        fill: fillStyle,
                        stroke: strokeStyle,
                        points: 3,
                        radius: styleData.radius.value || 10,
                        rotation: Math.PI / 4,
                        angle: 0
                    });
                    break;
                case 'ol_icon': // fallthrough
                case 'cust_icon':
                    if (styleData.icon_src) {
                        var anchorX = 1 / (parseInt(styleData.icon_size[0]) / (parseInt(styleData.icon_offset[0]) * -1));
                        var anchorY = 1 / (parseInt(styleData.icon_size[1]) / (parseInt(styleData.icon_offset[1]) * -1));
                        imageStyle = new ol.style.Icon({
                            anchor: [anchorX, anchorY],
                            opacity: parseFloat(styleData.icon_opacity.value) / 100,
                            src: styleData.icon_src,
                            scale: parseFloat(styleData.icon_scale),
                            size: [parseInt(styleData.icon_size[0], 10), parseInt(styleData.icon_size[1], 10)]
                        });
                    }
                    break;
                case 'cust_icon_svg':
                    if (styleData.svgSrc && styleData.icon_scale && styleData.icon_size) {
                        var canvas = document.createElement('canvas');
                        var ctx = canvas.getContext("2d");
                        var width = styleData.icon_size[0] * styleData.icon_scale;
                        var height = styleData.icon_size[1] * styleData.icon_scale;

                        var strokewidth = 0;
                        if (styleData.strokewidth && styleData.strokewidth.value) {
                            strokewidth = styleData.strokewidth.value;
                        }
                        canvas.width = width + 2 * strokewidth;
                        canvas.height = height + 2 * strokewidth;
                        ctx.clearRect(0, 0, canvas.width, canvas.height);

                        if (styleData.fillcolor) {
                            ctx.fillStyle = _c4gMapsUtils.utils.getRgbaFromHexAndOpacity(styleData.fillcolor, styleData.fillopacity.value);
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                        }

                        if (strokewidth && styleData.strokecolor) {
                            ctx.strokeStyle = _c4gMapsUtils.utils.getRgbaFromHexAndOpacity(styleData.strokecolor, styleData.strokeopacity.value);
                            ctx.lineWidth = styleData.strokewidth.value;
                            ctx.strokeRect(0, 0, canvas.width, canvas.height);
                            ctx.translate(0.5, 0.5);
                        }

                        // if (styleData.icon_opacity.value && (styleData.icon_opacity.value > 0)) {
                        //     ctx.globalAlpha = (styleData.icon_opacity.value / 100);
                        // }

                        var img = new Image();
                        img.src = styleData.svgSrc;
                        img.zIndex = 100; //Test

                        img.onload = function () {
                            ctx.drawImage(img, strokewidth, strokewidth, width, height);
                        };

                        imageStyle = new ol.style.Icon({
                            img: canvas,
                            imgSize: [canvas.width, canvas.height] /*,
                                                                   opacity: (styleData.icon_opacity.value / 100)*/
                        });
                    }

                    break;
                case 'photo':
                    imageStyle = new ol.style.Photo({
                        kind: styleData.photoKind,
                        crop: true,
                        opacity: parseFloat(styleData.icon_opacity.value, 10) / 100,
                        radius: parseFloat(styleData.radius.value, 10),
                        shadow: true,
                        stroke: strokeStyle,
                        src: styleData.icon_src
                    });
                    break;
                case 'point':
                    imageStyle = new ol.style.Circle({
                        fill: fillStyle,
                        stroke: strokeStyle,
                        radius: styleData.radius.value || 7
                    });
                    break;
                default:
                    imageStyle = new ol.style.Circle({
                        fill: fillStyle,
                        stroke: strokeStyle,
                        radius: styleData.radius.value || 7
                    });
            }

            // build function
            styleFunction = function styleFunction(feature, projection, getId) {
                var stylesArray, label, arrowSize, arrowSizeUnit, segmentLength, arrows_minzoom, start_pixel, end_pixel;

                if (getId) {
                    return styleData.id;
                }

                // check if this is a feature.styleFunction
                if (!(feature instanceof ol.Feature)) {
                    projection = feature;
                    feature = this;
                }

                stylesArray = [];

                if (feature && typeof feature.get === 'function' && feature.get('label')) {
                    label = feature.get('label');
                } else if (styleData.label) {
                    label = styleData.label;
                } else {
                    label = false;
                }
                var defaultColor = self.controller.mapController.data.default_label_color;
                // label
                if (label) {
                    if (styleData.label_outl_color && styleData.label_outl_width.value) {
                        textStyleOutline = new ol.style.Stroke({
                            color: _c4gMapsUtils.utils.getRgbaFromHexAndOpacity(styleData.label_outl_color || defaultColor, {
                                unit: '%',
                                value: 100
                            }),
                            width: parseInt(styleData.label_outl_width.value, 10)
                        });
                        if (styleData.label_outl_box === "1") {
                            backgroundFill = new ol.style.Fill({
                                color: _c4gMapsUtils.utils.getRgbaFromHexAndOpacity(styleData.label_outl_color || defaultColor, {
                                    unit: '%',
                                    value: 100
                                })
                            });
                        }
                    }
                    if (!styleData.label_offset) {
                        styleData.label_offset = [0, 0, "px"];
                    }
                    if (styleData.label_outl_box === "1") {
                        textStyle = new ol.style.Text({
                            text: label,
                            font: (styleData.font_weight || 'normal') + ' ' + (styleData.font_style || 'normal') + ' ' + (styleData.font_size || '13') + 'px ' + (styleData.font_family || 'sans-serif'),
                            // scale: parseInt(styleData.font_size || 0, 10) || undefined,
                            offsetX: parseInt(styleData.label_offset[0] || 0, 10),
                            offsetY: parseInt(styleData.label_offset[1] || 0, 10),
                            textAlign: styleData.label_align_hor,
                            textBaseline: styleData.label_align_ver,
                            fill: new ol.style.Fill({
                                color: _c4gMapsUtils.utils.getRgbaFromHexAndOpacity(styleData.font_color || defaultColor, styleData.font_opacity)
                            }),
                            backgroundFill: backgroundFill,
                            backgroundStroke: textStyleOutline
                        });
                    } else {
                        textStyle = new ol.style.Text({
                            text: label,
                            font: (styleData.font_weight || 'normal') + ' ' + (styleData.font_style || 'normal') + ' ' + (styleData.font_size || '13') + 'px ' + (styleData.font_family || 'sans-serif'),
                            // scale: parseInt(styleData.font_size || 0, 10) || undefined,
                            offsetX: parseInt(styleData.label_offset[0] || 0, 10),
                            offsetY: parseInt(styleData.label_offset[1] || 0, 10),
                            textAlign: styleData.label_align_hor,
                            textBaseline: styleData.label_align_ver,
                            fill: new ol.style.Fill({
                                color: _c4gMapsUtils.utils.getRgbaFromHexAndOpacity(styleData.font_color || defaultColor, styleData.font_opacity)
                            }),
                            stroke: textStyleOutline
                        });
                    }
                }

                // create style-object
                // we need this check because textStyle is a var accessible from closure and will be set even if no label is set
                if (label) {
                    var zIndex = void 0;
                    if (feature && feature.get && typeof feature.get === "function" && feature.get('zIndex')) {
                        zIndex = feature.get('zIndex');
                    }
                    stylesArray.push(new ol.style.Style({
                        image: imageStyle,
                        text: textStyle,
                        stroke: strokeStyle,
                        fill: fillStyle,
                        zIndex: zIndex
                    }));
                } else {
                    stylesArray.push(new ol.style.Style({
                        image: imageStyle,
                        stroke: strokeStyle,
                        fill: fillStyle
                    }));
                }

                // add line-arrows
                if (styleData.line_arrows && feature && typeof feature.getGeometry === 'function' && !(feature.getGeometry() instanceof ol.geom.Point) && typeof feature.getGeometry().forEachSegment === 'function') {
                    arrowSize = styleData.line_arrows_radius ? parseInt(styleData.line_arrows_radius.value, 10) * 2 : 0;
                    arrowSizeUnit = arrowSize + styleData.line_arrows_radius.unit;
                    feature.getGeometry().forEachSegment(function (start, end) {
                        //if minzoom is 0 (unlimited), hide arrows if they are bigger than the segment
                        arrows_minzoom = parseInt(styleData.line_arrows_minzoom, 10);
                        start_pixel = self.controller.mapController.map.getPixelFromCoordinate(start);
                        end_pixel = self.controller.mapController.map.getPixelFromCoordinate(end);
                        // euclid-distance between start and end
                        segmentLength = Math.sqrt(Math.pow(end_pixel[1] - start_pixel[1], 2) + Math.pow(end_pixel[0] - start_pixel[0], 2));

                        if (arrows_minzoom < 0 && arrowSize + parseInt(styleData.strokewidth.value, 10) < segmentLength || arrows_minzoom >= 0 && self.controller.mapController.map.getView().getZoom() >= arrows_minzoom) {
                            // forward arrows
                            stylesArray.push(new ol.style.Style({
                                geometry: new ol.geom.Point(end),
                                text: new ol.style.Text({
                                    text: "ᐳ",
                                    font: arrowSizeUnit + " sans-serif",
                                    offsetX: 0,
                                    offsetY: 1,
                                    fill: fillStyle,
                                    stroke: strokeStyle,
                                    textAlign: 'right',
                                    rotateWithView: true,
                                    rotation: -Math.atan2(end[1] - start[1], end[0] - start[0])
                                })
                            }));
                            // backward arrows (if wanted)
                            if (styleData.line_arrows_back) {
                                stylesArray.push(new ol.style.Style({
                                    geometry: new ol.geom.Point(start),
                                    text: new ol.style.Text({
                                        text: "ᐳ",
                                        font: arrowSizeUnit + " sans-serif",
                                        offsetX: 0,
                                        offsetY: -1,
                                        fill: fillStyle,
                                        stroke: strokeStyle,
                                        textAlign: 'right',
                                        rotateWithView: true,
                                        rotation: -Math.atan2(start[1] - end[1], start[0] - end[0])
                                    })
                                }));
                            }
                        }
                    });
                }

                return stylesArray;
            };

            return styleFunction;
        } // end of "getStyleFunction()"


    }, {
        key: 'getStyleEditorConfig',
        value: function getStyleEditorConfig(styleData) {
            var editorConfig;

            // create editor-config
            editorConfig = {};
            editorConfig.collect = styleData.editor_collect || undefined;
            editorConfig.iconSrc = styleData.editor_icon || undefined;
            editorConfig.vars = styleData.editor_vars || undefined;

            editorConfig.sort = styleData.editor_sort || false;
            if (editorConfig.sort) {
                editorConfig.sort = parseInt(editorConfig.sort, 10) || false;
            }

            return editorConfig;
        } // end of "getStyleEditorConfig()"

    }]);

    return C4gLocationStyle;
}();

/***/ }),

/***/ "./Resources/public/js/c4g-maps-config.js":
/*!************************************************!*\
  !*** ./Resources/public/js/c4g-maps-config.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * This file is part of con4gis,
 * the gis-kit for Contao CMS.
 *
 * @package    con4gis
 * @version    6
 * @author     con4gis contributors (see "authors.txt")
 * @license    LGPL-3.0-or-later
 * @copyright  Küstenschmiede GmbH Software & Design
 * @link       https://www.con4gis.org
 */



Object.defineProperty(exports, "__esModule", {
  value: true
});
var config = exports.config = {
  osm: {

    CycleMap: {
      attributions: 'Style by <a target="_blank" href="http://www.opencyclemap.org/">OpenCycleMap</a>' + ' ' + ol.source.OSM.ATTRIBUTION,
      crossOrigin: 'anonymous',
      minZoom: 0,
      maxZoom: 19,
      url: 'https://{a-c}.tile.opencyclemap.org/cycle/{z}/{x}/{y}.png'
    },

    German: {
      attributions: 'Style by <a target="_blank" href="http://www.openstreetmap.de/germanstyle.html">openstreetmap.de</a>' + ' ' + ol.source.OSM.ATTRIBUTION,
      crossOrigin: 'anonymous',
      minZoom: 0,
      maxZoom: 19,
      url: 'https://{a-c}.tile.openstreetmap.de/tiles/osmde/{z}/{x}/{y}.png'
    },

    LandscapeMap: {
      attributions: 'Style by <a target="_blank" href="http://www.opencyclemap.org/">OpenCycleMap</a>' + ' ' + ol.source.OSM.ATTRIBUTION,
      crossOrigin: 'anonymous',
      minZoom: 0,
      maxZoom: 19,
      url: 'https://{a-c}.tile.opencyclemap.org/landscape/{z}/{x}/{y}.png'
    },

    Mapnik: {
      attributions: ol.source.OSM.ATTRIBUTION,
      crossOrigin: 'anonymous'
    },

    NONE: '' // last line
  },

  stamen: {
    Toner: {
      attributions: ol.source.OSM.ATTRIBUTION,
      layer: 'toner',
      minZoom: 0,
      maxZoom: 18,
      crossOrigin: 'anonymous'
    },

    TonerLabels: {
      attributions: ol.source.OSM.ATTRIBUTION,
      layer: 'toner-labels',
      minZoom: 0,
      maxZoom: 18,
      crossOrigin: 'anonymous'
    },

    TonerLines: {
      attributions: ol.source.OSM.ATTRIBUTION,
      layer: 'toner-lines',
      minZoom: 0,
      maxZoom: 18,
      crossOrigin: 'anonymous'
    },

    Terrain: {
      attributions: ol.source.OSM.ATTRIBUTION,
      layer: 'terrain',
      minZoom: 0,
      maxZoom: 18,
      crossOrigin: 'anonymous'
    },

    Watercolor: {
      attributions: ol.source.OSM.ATTRIBUTION,
      layer: 'watercolor',
      minZoom: 0,
      maxZoom: 18,
      crossOrigin: 'anonymous'
    },

    NONE: ''
  },

  mapquest: {

    MapQuestOpen: {
      layer: 'osm'
    },

    MapQuestHyb: {
      layer: 'hyb'
    },

    MapQuestSat: {
      layer: 'sat'
    },

    NONE: ''
  },

  mapbox: {

    Mapbox: {
      tileSize: [512, 512],
      attributions: '© <a target="_blank" href="https://www.mapbox.com/about/maps/">Mapbox</a>' + ' ' + ol.source.OSM.ATTRIBUTION,
      minZoom: 0,
      maxZoom: 22,
      crossOrigin: 'anonymous'
    },

    MapboxClassic: {
      attributions: '© <a target="_blank" href="https://www.mapbox.com/about/maps/">Mapbox</a>' + ' ' + ol.source.OSM.ATTRIBUTION,
      minZoom: 0,
      maxZoom: 22,
      crossOrigin: 'anonymous'
    }
  },

  klokan: {

    OpenMapTiles: {
      format: new ol.format.MVT(),
      tileGrid: ol.tilegrid.createXYZ({ tileSize: 512, maxZoom: 22 }), //ToDo maxZoom from configuration
      tilePixelRatio: 8,
      attributions: '© <a target="_blank" href="https://openmaptiles.org/">OpenMapTiles</a>' + ' ' + ol.source.OSM.ATTRIBUTION,
      minZoom: 0,
      maxZoom: 22,
      crossOrigin: 'anonymous'
    },

    TileHosting: {
      format: new ol.format.MVT(),
      tileGrid: ol.tilegrid.createXYZ({ tileSize: 512, maxZoom: 22 }), //ToDo maxZoom from configuration
      tilePixelRatio: 8,
      attributions: '© <a target="_blank" href="https://tilehosting.com/">TileHosting</a>' + ' ' + ol.source.OSM.ATTRIBUTION,
      minZoom: 0,
      maxZoom: 22,
      crossOrigin: 'anonymous'
    }
  },

  here: {

    HERE: {
      tileSize: [512, 512],
      attributions: 'Map Tiles © <a target="_blank" href="https://developer.here.com">HERE</a>' + ' ' + ol.source.OSM.ATTRIBUTION,
      minZoom: 0,
      maxZoom: 22,
      crossOrigin: 'anonymous'
    }

  },

  thunderforest: {

    Thunderforest: {
      tileSize: [512, 512],
      attributions: 'Map Tiles © <a target="_blank" href="https://www.thunderforest.com/">Thunderforest</a>' + ' ' + ol.source.OSM.ATTRIBUTION,
      minZoom: 0,
      maxZoom: 19,
      crossOrigin: 'anonymous'
    }

  }
};

/***/ }),

/***/ "./Resources/public/js/c4g-maps-constant-i18n-de.js":
/*!**********************************************************!*\
  !*** ./Resources/public/js/c4g-maps-constant-i18n-de.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * This file is part of con4gis,
 * the gis-kit for Contao CMS.
 *
 * @package    con4gis
 * @version    6
 * @author     con4gis contributors (see "authors.txt")
 * @license    LGPL-3.0-or-later
 * @copyright  Küstenschmiede GmbH Software & Design
 * @link       https://www.con4gis.org
 */



/**
 * Language constants (en)
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var langConstantsGerman = exports.langConstantsGerman = {

  LANG: 'de',

  NAME: 'Name',
  HIDE: 'Zuklappen',
  CLOSE: 'Schließen',
  POINT: 'POI',
  FREEHAND: 'Freihand',
  LINE: 'Linie',
  POLYGON: 'Fläche',
  CIRCLE: 'Radius',
  PERIMETER: 'Umfang',
  LENGTH: 'Länge',
  SURFACEAREA: 'Flächeninhalt',
  RADIUS: 'Radius',
  REFRESH: 'Aktualisieren',
  COPY_TO_CLIPBOARD: 'In Zwischenablage kopieren',

  CTRL_ZOOM_IN: 'Vergrößern',
  CTRL_ZOOM_OUT: 'Verkleinern',
  CTRL_ZOOM_EXT: 'Maximal verkleinern',
  CTRL_ZOOM_HOME: 'Zur ursprünglichen Position',
  CTRL_ZOOM_POS: 'Zum aktuellen Standort',
  CTRL_ZOOM_SLIDER: 'Zoom Slider',
  CTRL_RESET_ROTATION: 'Rotation (touch, ctrl+shift+mouse) zurücksetzen',
  CTRL_PORTSIDE: 'Portside ein-/ausblenden',
  CTRL_ROUTER: 'Router ein-/ausblenden',
  CTRL_EDITOR: 'Editor ein-/ausblenden',
  CTRL_MEASURETOOLS: 'Messwerkzeuge ein-/ausblenden',
  CTRL_INFOPAGE: 'Infoseite ein-/ausblenden',
  CTRL_ADDITIONALPANEL: 'Panel ein-/ausblenden',
  CTRL_ACCOUNT: 'Account ein-/ausblenden',
  CTRL_ZOOMLEVEL: 'Zoom',
  CTRL_MOUSECOORDS: 'Lon/Lat',
  CTRL_GEOSEARCH: 'Suche ein-/ausblenden',
  CTRL_START_SEARCH: 'Suche starten',
  CTRL_OVERVIEWMAP: 'Übersichtskarte ein-/ausblenden',
  CTRL_GEOBOOKMARKS: 'Favoriten verwalten',
  CTRL_SIDEBOARD: 'Sideboard ein-/ausblenden',
  CTRL_STARBOARD: 'Starboard ein-/ausblenden',
  CTRL_ATTRIBUTION: 'Attribution anzeigen',
  CTRL_GRID: 'Gitter ein-/ausblenden',
  CTRL_PERMALINK: 'Permalink generieren',
  CTRL_FULLSCREEN: 'Vollbildmodus ein-/ausschalten',
  CTRL_PRINT: 'Karte exportieren',

  STARBOARD: 'Starboard',
  STARBOARD_BASELAYER: 'Basiskarten',
  STARBOARD_LAYER: 'Ebenen',
  STARBOARD_VIEW_TRIGGER_BASELAYERSWITCHER: 'Basiskarten',
  STARBOARD_VIEW_TRIGGER_LAYERSWITCHER: 'Kartenelemente',

  SIDEBOARD: 'Sideboard',

  MEASURETOOLS: 'Messwerkzeuge',
  MEASURETOOLS_INFO: 'Wählen Sie weiter unten einen Messtyp aus und starten Sie die Messung durch das Klicken auf der Karte.',
  MEASURETOOLS_INFO_ADDITIONAL: '(Einzelne Messungen können mit einem Doppelklick beendet werden.)',
  MEASURETOOLS_VIEW_TRIGGER_SELECT: 'Auswahl Modus',
  MEASURETOOLS_VIEW_TRIGGER_DRAW_LINESTRING: 'Strecken messen',
  MEASURETOOLS_VIEW_TRIGGER_DRAW_POLYGON: 'Flächen messen',
  MEASURETOOLS_VIEW_TRIGGER_DRAW_CIRCLE: 'Radius messen',
  MEASURETOOLS_VIEW_TRIGGER_DRAW_FREEHAND: 'Freihand messen',

  GEOBOOKMARKS_PLACEHOLDER: 'Neue Bezeichnung',

  INFOPAGE: 'Informationen',
  ADDITIONALPANEL: 'Panel',
  ADDITIONALPANEL_VIEW_TRIGGER: 'Panel anzeigen',
  ACCOUNT: 'Account',
  ACCOUNT_VIEW_TRIGGER: 'Account anzeigen',

  SEARCH_NOT_FOUND: 'Die Lokation konnte nicht gefunden werden. Bitte versuchen Sie eine andere Eingabe.',

  NONE: '' // last line
};

/***/ }),

/***/ "./Resources/public/js/c4g-maps-constant-i18n-en.js":
/*!**********************************************************!*\
  !*** ./Resources/public/js/c4g-maps-constant-i18n-en.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/*
 * This file is part of con4gis,
 * the gis-kit for Contao CMS.
 *
 * @package    con4gis
 * @version    6
 * @author     con4gis contributors (see "authors.txt")
 * @license    LGPL-3.0-or-later
 * @copyright  Küstenschmiede GmbH Software & Design
 * @link       https://www.con4gis.org
 */

/**
 * Language constants (en)
 */
var langConstantsEnglish = exports.langConstantsEnglish = {

  LANG: 'en',

  NAME: 'Name',
  HIDE: 'Hide',
  CLOSE: 'Close',
  POINT: 'POI',
  FREEHAND: 'freehand',
  LINE: 'Line',
  POLYGON: 'Area',
  CIRCLE: 'Radius',
  PERIMETER: 'Perimeter',
  LENGTH: 'Length',
  SURFACEAREA: 'Surface area',
  RADIUS: 'Radius',
  REFRESH: 'Refresh',
  COPY_TO_CLIPBOARD: 'Copy to clipboard',

  CTRL_ZOOM_IN: 'Zoom in',
  CTRL_ZOOM_OUT: 'Zoom out',
  CTRL_ZOOM_EXT: 'Fit to extent',
  CTRL_ZOOM_HOME: 'jump to initial position',
  CTRL_ZOOM_POS: 'jump to browser/device position',
  CTRL_ZOOM_SLIDER: 'Zoom slider',
  CTRL_RESET_ROTATION: 'Reset rotation (touch, ctrl+shift+mouse)',
  CTRL_PORTSIDE: 'Toggle portside',
  CTRL_EDITOR: 'Toggle editor',
  CTRL_MEASURETOOLS: 'Toggle measuretools',
  CTRL_INFOPAGE: 'Toggle infopage',
  CTRL_ADDITIONALPANEL: 'Toggle panel',
  CTRL_ACCOUNT: 'Toggle account',
  CTRL_ZOOMLEVEL: 'Zoom',
  CTRL_MOUSECOORDS: 'Lon/Lat',
  CTRL_GEOSEARCH: 'Toggle geosearch',
  CTRL_START_SEARCH: 'start search',
  CTRL_OVERVIEWMAP: 'Toggle overviewmap',
  CTRL_GEOBOOKMARKS: 'Manage favorites',
  CTRL_SIDEBOARD: 'Toggle sideboard',
  CTRL_STARBOARD: 'Toggle starboard',
  CTRL_ATTRIBUTION: 'Show attribution',
  CTRL_GRID: 'Toggle grid',
  CTRL_PERMALINK: 'Generate Permalink',
  CTRL_FULLSCREEN: 'Toggle fullscreen-mode',
  CTRL_PRINT: 'Export map',

  EDITOR: 'Editor',
  EDITOR_ENABLE_INSTANT_MEASURE: 'Measure while drawing',
  EDITOR_ENABLE_FREEHAND_DRAW: 'Freehand draw',
  EDITOR_FEATURE_APPLY: 'End modification',
  EDITOR_FEATURE_DELETE: 'Delete feature',
  EDITOR_FEATURE_MODIFY: 'Modify feature',
  EDITOR_SELECT_INFO: 'Click an element on the map to select it.',
  EDITOR_SELECT_INFO_ADDITIONAL: '[ctrl] + [click] for multiselect <br>[shift] for boxselect',
  EDITOR_VIEW_TRIGGER_SELECT: 'Select-mode',
  EDITOR_VIEW_TRIGGER_DRAW_POINT: 'Add POIs',
  EDITOR_VIEW_TRIGGER_DRAW_FREEHAND: 'Draw freehand',
  EDITOR_VIEW_TRIGGER_DRAW_LINESTRING: 'Add tracks',
  EDITOR_VIEW_TRIGGER_DRAW_POLYGON: 'Add areas',
  EDITOR_VIEW_TRIGGER_DRAW_CIRCLE: 'Add circles',

  STARBOARD: 'Starboard',
  STARBOARD_BASELAYER: 'Baselayer',
  STARBOARD_LAYER: 'Layer',
  STARBOARD_VIEW_TRIGGER_BASELAYERSWITCHER: 'Baselayerswitcher',
  STARBOARD_VIEW_TRIGGER_LAYERSWITCHER: 'Layerswitcher',

  MEASURETOOLS: 'Measuretools',
  MEASURETOOLS_INFO: 'Select a measuretype below and start measuring by clicking on the map.',
  MEASURETOOLS_INFO_ADDITIONAL: '(To stop a measurement, double-click on the map.)',
  MEASURETOOLS_VIEW_TRIGGER_SELECT: 'Select-mode',
  MEASURETOOLS_VIEW_TRIGGER_DRAW_LINESTRING: 'Measure tracks',
  MEASURETOOLS_VIEW_TRIGGER_DRAW_POLYGON: 'Measure areas',
  MEASURETOOLS_VIEW_TRIGGER_DRAW_CIRCLE: 'Measure radius',
  MEASURETOOLS_VIEW_TRIGGER_DRAW_FREEHAND: 'Measure freehand',

  GEOBOOKMARKS_PLACEHOLDER: 'Enter new caption',

  INFOPAGE: 'Infopage',
  INFOPAGE_VIEW_TRIGGER: 'Show informations',

  ADDITIONALPANEL: 'Panel',
  ADDITIONALPANEL_VIEW_TRIGGER: 'Show panel',

  ACCOUNT: 'Account',
  ACCOUNT_VIEW_TRIGGER: 'Show account',

  SEARCH_NOT_FOUND: 'Location not found. Sorry... :(',

  NONE: '' // last line
};

/***/ }),

/***/ "./Resources/public/js/c4g-maps-constant.js":
/*!**************************************************!*\
  !*** ./Resources/public/js/c4g-maps-constant.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * This file is part of con4gis,
 * the gis-kit for Contao CMS.
 *
 * @package    con4gis
 * @version    6
 * @author     con4gis contributors (see "authors.txt")
 * @license    LGPL-3.0-or-later
 * @copyright  Küstenschmiede GmbH Software & Design
 * @link       https://www.con4gis.org
 */



Object.defineProperty(exports, "__esModule", {
  value: true
});
var cssConstants = exports.cssConstants = {

  OPEN: 'c4g-open',
  CLOSE: 'c4g-close',
  CLOSEABLE: 'c4g-closeable',
  ENABLED: 'c4g-enabled',
  DISABLED: 'c4g-disabled',
  HIDE: 'c4g-hide',
  ICON: 'c4g-icon',
  CONTROL: 'c4g-control',
  COPY: 'c4g-copy',
  REFRESH: 'c4g-refresh',
  ACTIVE: 'c4g-active',
  INACTIVE: 'c4g-inactive',
  LOADING: 'c4g-loading',
  ANIMATION_SPIN: 'c4g-animation-spin',
  LARGE: 'c4g-large',
  SMALL: 'c4g-small',
  HORIZONTAL: 'c4g-horizontal',
  VERTICAL: 'c4g-vertical',

  ATTRIBUTION_LOGO: 'c4g-attribution-logo',
  CONTROL_CONTAINER_TL: 'c4g-control-container-top-left',
  CONTROL_CONTAINER_TR: 'c4g-control-container-top-right',
  CONTROL_CONTAINER_BL: 'c4g-control-container-bottom-left',
  CONTROL_CONTAINER_BL_SUB: 'c4g-control-container-bottom-left-sub',
  CONTROL_CONTAINER_BR: 'c4g-control-container-bottom-right',

  GEOSEARCH: 'c4g-geosearch',
  GEOSEARCH_WRAPPER: 'c4g-geosearch-wrapper',
  GEOSEARCH_TRIGGER: 'c4g-geosearch-trigger',
  GEOSEARCH_START: 'c4g-geosearch-start',
  GRATICULE: 'c4g-graticule',
  MEASURETOOLS_VIEW_TRIGGER_SELECT: 'c4g-measuretools-view-trigger-select',
  MEASURETOOLS_VIEW_TRIGGER_DRAW_LINESTRING: 'c4g-measuretools-view-trigger-draw-line',
  MEASURETOOLS_VIEW_TRIGGER_DRAW_POLYGON: 'c4g-measuretools-view-trigger-draw-polygon',
  MEASURETOOLS_VIEW_TRIGGER_DRAW_CIRCLE: 'c4g-measuretools-view-trigger-draw-circle',
  MEASURETOOLS_VIEW_TRIGGER_DRAW_FREEHAND: 'c4g-measuretools-view-trigger-draw-freehand',
  PRINT: 'c4g-print',
  INFOPAGE_VIEW_TRIGGER: 'c4g-infopage-view-trigger',
  INFOPAGE: 'c4g-infopage',
  ADDITIONALPANEL_VIEW_TRIGGER: 'c4g-additionalpanel-view-trigger',
  ADDITIONALPANEL: 'c4g-additionalpanel',
  ACCOUNT_VIEW_TRIGGER: 'c4g-account-view-trigger',
  ACCOUNT: 'c4g-account',
  OVERVIEWMAP: 'c4g-overviewmap',
  OVERVIEWMAP_WRAPPER: 'c4g-overviewmap-wrapper',
  GEOBOOKMARKS: 'c4g-geobookmarks',
  PERMALINK: 'c4g-permalink',
  PERMALINK_POPUP: 'c4g-permalink-popup',
  POPUP_CLOSE: 'c4g-popup-close',
  POPUP_ROUTE_WRAPPER: 'c4g-popup-route-wrapper',
  POPUP_ROUTE_FROM: 'c4g-popup-route-from',
  POPUP_ROUTE_TO: 'c4g-popup-route-to',
  PORTSIDE: 'c4g-portside',
  PORTSIDE_CONTAINER: 'c4g-portside-container',
  PORTSIDE_CONTROL: 'c4g-portside-control',
  PORTSIDE_WRAPPER: 'c4g-portside-wrapper',
  PORTSIDE_TITLEBAR: 'c4g-portside-titlebar',
  PORTSIDE_TOP_TOOLBAR: 'c4g-portside-top-toolbar',
  PORTSIDE_CONTENT_CONTAINER: 'c4g-portside-content-container',
  PORTSIDE_BOTTOM_TOOLBAR: 'c4g-portside-bottom-toolbar',
  PORTSIDE_STATUSBAR: 'c4g-portside-statusbar',
  PORTSIDE_VIEWTRIGGERBAR: 'c4g-portside-viewtriggerbar',
  PORTSIDE_HEADLINE: 'c4g-portside-headline',
  PORTSIDE_BUTTONBAR: 'c4g-portside-buttonbar',
  PORTSIDE_BUTTON: 'c4g-portside-button',
  PORTSIDE_HIDE: 'c4g-portside-hide',
  PORTSIDE_CLOSE: 'c4g-portside-close',
  SPINNER: 'c4g-spinner',
  STARBOARD: 'c4g-starboard',
  STARBOARD_CONTAINER: 'c4g-starboard-container',
  STARBOARD_CONTROL: 'c4g-starboard-control',
  STARBOARD_WRAPPER: 'c4g-starboard-wrapper',
  STARBOARD_TITLEBAR: 'c4g-starboard-titlebar',
  STARBOARD_CONTENT_CONTAINER: 'c4g-starboard-content-container',
  STARBOARD_BOTTOM_TOOLBAR: 'c4g-starboard-bottom-toolbar',
  STARBOARD_STATUSBAR: 'c4g-starboard-statusbar',
  STARBOARD_VIEWTRIGGERBAR: 'c4g-starboard-viewtriggerbar',
  STARBOARD_HEADLINE: 'c4g-starboard-headline',
  STARBOARD_BUTTONBAR: 'c4g-starboard-buttonbar',
  STARBOARD_BUTTON: 'c4g-starboard-button',
  STARBOARD_VIEW_TRIGGER_BASELAYERSWITCHER: 'c4g-starboard-view-trigger-baselayerswitcher',
  STARBOARD_VIEW_TRIGGER_LAYERSWITCHER: 'c4g-starboard-view-trigger-layerswitcher',
  STARBOARD_CLOSE: 'c4g-starboard-close',
  STARBOARD_CONTENT_BASELAYERSWITCHER: 'c4g-content-baselayerswitcher',
  STARBOARD_BASELAYERTREE: 'c4g-baselayertree',
  STARBOARD_LAYERTREE: 'c4g-layertree',
  STARBOARD_CONTENT_LAYERSWITCHER: 'c4g-content-layerswitcher',
  TOOLTIP_POPUP: 'c4g-tooltip-popup',
  ZOOM_LEVEL: 'c4g-zoom-level',

  OL_CONTROL: 'ol-control',
  OL_UNSELECTABLE: 'ol-unselectable',

  OL_OVERLAYCONTAINER: 'ol-overlaycontainer',
  OL_OVERLAYCONTAINER_SE: 'ol-overlaycontainer-stopevent',
  OL_VIEWPORT: 'ol-viewport',
  OL_ZOOM: 'ol-zoom',
  OL_ZOOM_IN: 'ol-zoom-in',
  OL_ZOOM_EXT: 'ol-zoom-extent',
  OL_ZOOM_HOME: 'ol-zoom-home',
  OL_ZOOM_POS: 'ol-zoom-position',
  OL_ZOOM_WITH_EXT: 'ol-zoom-with-extent',
  OL_ZOOM_WITH_HOME: 'ol-zoom-with-home',
  OL_ZOOM_WITH_POS: 'ol-zoom-with-position',
  OL_ZOOM_SLIDER: 'ol-zoom-slider',
  OL_ZOOM_WITH_SLIDER: 'ol-zoom-with-slider',

  NONE: '' // last line
};

/***/ }),

/***/ "./Resources/public/js/c4g-maps-control-geosearch.js":
/*!***********************************************************!*\
  !*** ./Resources/public/js/c4g-maps-control-geosearch.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GeoSearch = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _c4gMapsConstant = __webpack_require__(/*! ./c4g-maps-constant */ "./Resources/public/js/c4g-maps-constant.js");

var _c4gMapsUtils = __webpack_require__(/*! ./c4g-maps-utils */ "./Resources/public/js/c4g-maps-utils.js");

var _c4gMapsI18n = __webpack_require__(/*! ./c4g-maps-i18n */ "./Resources/public/js/c4g-maps-i18n.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This file is part of con4gis,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * the gis-kit for Contao CMS.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @package    con4gis
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @version    6
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author     con4gis contributors (see "authors.txt")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @license    LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @copyright  Küstenschmiede GmbH Software & Design
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @link       https://www.con4gis.org
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

'use strict';

var GeoSearch = exports.GeoSearch = function (_ol$control$Control) {
  _inherits(GeoSearch, _ol$control$Control);

  /**
   * @TODO description
   *
   * @constructor
   * @extends  {ol.control.Control}
   *
   * @param    {Object}              opt_options  *optional* control options.
   */
  function GeoSearch(opt_options) {
    _classCallCheck(this, GeoSearch);

    var _this = _possibleConstructorReturn(this, (GeoSearch.__proto__ || Object.getPrototypeOf(GeoSearch)).call(this, opt_options));

    var self, options, element, button, searchWrapper, searchInput, searchButton, resultTrigger, resultWrapper;

    self = _this;
    // this.element = element;
    // this.searchWrapper = searchWrapper;
    // this.resultWrapper = resultWrapper;

    options = opt_options || {};
    var langConstants = (0, _c4gMapsI18n.getLanguage)(options.mapController.data);

    // default options
    options = jQuery.extend({
      mapController: undefined,
      className: _c4gMapsConstant.cssConstants.GEOSEARCH,
      extDiv: false,
      collapsible: true,
      collapsed: true,
      tipLabel: langConstants.CTRL_GEOSEARCH,
      label: '>>',
      collapsedLabel: '(?)',
      attribution: true,
      // customAttribution: '',
      // engineUrl: false,
      searchZoom: 12,
      zoomBounds: false,
      results: false,
      quicksearch: true,
      animate: true,
      markResult: true,
      popup: true,
      caching: 0,
      autopick: false
    }, options);

    // prepare search-configuration
    //
    _this.config = {};
    // searchEngineUrl
    // if (typeof options.engineUrl === 'string') {
    //   // if it is a string, then it is (hopefully) a URL, that we can use directly
    //   // @TODO add a URL-check
    //   this.config.url = options.engineUrl;
    // } else {
    //   // if it is none of the above, then use the default URL
    //   this.config.url = 'https://nominatim.openstreetmap.org/search';
    // }
    if (options.mapController.data.geosearch.searchKey && options.mapController.data.geosearch.url) {
      _this.config.url = options.mapController.data.geosearch.url + "search.php";
      _this.config.key = options.mapController.data.geosearch.searchKey;
    } else {
      _this.config.url = options.mapController.data.api.geosearch + "/" + options.mapController.data.profile;
    }
    // zoomlevel when centering the found location
    _this.config.zoomlevel = options.searchZoom;
    // zoom to bounds instead of zoomlevel when centering the found location
    _this.config.zoombounds = options.zoomBounds;
    // quicksearch-option (instantly jump to the first found location)
    _this.config.quicksearch = options.quicksearch;
    // animation (animate flight to targeted location)
    _this.config.animate = options.animate;
    // highlight the result location
    _this.config.markResult = options.markResult;
    _this.config.popup = options.popup;

    _this.config.autopick = options.autopick;
    _this.config.mapController = options.mapController;
    _this.config.results = options.results;

    _this.config.collapsed = options.collapsed;

    _this.config.caching = options.caching;

    // @TODO
    // Attribution

    // check extDiv
    if (options.extDiv && document.getElementById(options.extDiv)) {
      options.extDiv = document.getElementById(options.extDiv);
    } else {
      options.extDiv = false;
    }

    // controlwrapper div
    element = document.createElement('div');
    element.className = options.className + ' ' + _c4gMapsConstant.cssConstants.OL_UNSELECTABLE + ' ' + _c4gMapsConstant.cssConstants.OL_CONTROL;

    if ((options.collapsed && !options.extDiv) & !(_this.config.caching && _c4gMapsUtils.utils.getValue('geosearch') == '1')) {
      jQuery(element).addClass(_c4gMapsConstant.cssConstants.CLOSE);
    } else {
      jQuery(element).addClass(_c4gMapsConstant.cssConstants.OPEN);
    }

    if (options.collapsible && !options.extDiv) {
      // button
      button = document.createElement('button');
      button.className = _c4gMapsConstant.cssConstants.GEOSEARCH_TRIGGER;
      button.title = options.tipLabel;
      element.appendChild(button);

      // set onClick to the toggle-function
      jQuery(button).click(function () {
        try {
          this.blur();
        } catch (ignore) {}
        self.toggle();
      });
    } else if (options.extDiv) {
      options.target = options.extDiv;
    }

    // wrapper div
    _this.searchWrapper = document.createElement('div');
    _this.searchWrapper.className = _c4gMapsConstant.cssConstants.GEOSEARCH_WRAPPER;

    // search-field
    searchInput = document.createElement('input');
    searchInput.type = 'text';
    _this.searchWrapper.appendChild(searchInput);

    // search-button
    searchButton = document.createElement('button');
    searchButton.className = _c4gMapsConstant.cssConstants.GEOSEARCH_START;
    searchButton.title = langConstants.CTRL_START_SEARCH;
    _this.searchWrapper.appendChild(searchButton);

    jQuery(searchButton).click(function () {
      try {
        this.blur();
      } catch (ignore) {}
      if (searchInput.value) {
        self.findLocation(searchInput.value);
      }
    });

    jQuery(searchInput).keypress(function (e) {
      if (e.which === 13) {
        if (searchInput.value) {

          self.findLocation(searchInput.value);

          if (document.getElementById("resultcontainer")) {
            document.getElementById("resultcontainer").parentNode.removeChild(document.getElementById("resultcontainer"));
          }
          if (self.config.results) {

            var searchResultContainer = document.createElement('ul');
            searchResultContainer.setAttribute("id", "resultcontainer");
            if (self.results) {
              for (var i = 0; i < self.results.length; i++) {
                var searchResult = document.createElement('li');
                var searchResultButton = document.createElement('button');
                searchResultButton.setAttribute("id", i);
                searchResultButton.setAttribute('class', 'searchResultButton');
                searchResultButton.addEventListener('click', function () {
                  self.zoomTo(this.getAttribute("id"));
                });

                searchResultButton.setAttribute("name", self.results[i].display_name);
                searchResultButton.innerHTML = self.results[i].display_name;
                searchResult.appendChild(searchResultButton);
                searchResultContainer.appendChild(searchResult);
              }
              if (searchWrapper) {
                searchWrapper.appendChild(searchResultContainer);
              }
            }
          }
        }
        return false;
      }
    });

    element.appendChild(_this.searchWrapper);

    // inheritance-stuff
    ol.control.Control.call(_this, {
      element: element,
      target: options.target
    });

    return _this;
  }

  /**
   * @TODO
   *
   * @return  {[type]}  [description]
   */


  _createClass(GeoSearch, [{
    key: "open",
    value: function open() {
      if (jQuery(this.element).hasClass(_c4gMapsConstant.cssConstants.CLOSE)) {
        jQuery(this.element).addClass(_c4gMapsConstant.cssConstants.OPEN).removeClass(_c4gMapsConstant.cssConstants.CLOSE).find('input')[0].focus();
        if (this.config.caching) {
          _c4gMapsUtils.utils.storeValue('geosearch', '1');
        }
      }
    }

    /**
     * @TODO
     *
     * @return  {[type]}  [description]
     */

  }, {
    key: "close",
    value: function close() {
      if (jQuery(this.element).hasClass(_c4gMapsConstant.cssConstants.OPEN)) {
        jQuery(this.element).addClass(_c4gMapsConstant.cssConstants.CLOSE).removeClass(_c4gMapsConstant.cssConstants.OPEN);
        // this.closeResults();
        if (document.getElementById("resultcontainer")) {
          document.getElementById("resultcontainer").parentNode.removeChild(document.getElementById("resultcontainer"));
        }
        if (this.config.caching) {
          _c4gMapsUtils.utils.storeValue('geosearch', '0');
        }
      }
    }

    /**
     * @TODO
     *
     * @return  {[type]}  [description]
     */

  }, {
    key: "toggle",
    value: function toggle() {
      if (jQuery(this.element).hasClass(_c4gMapsConstant.cssConstants.CLOSE)) {
        this.open();
      } else {
        this.close();
      }
    }

    // /**
    //  * @TODO
    //  *
    //  * @return  {[type]}  [description]
    //  */
    // openResults: function () {
    //   if (jQuery(this.resultWrapper).hasClass(cssConstants.CLOSE)) {
    //     jQuery(this.resultWrapper).addClass(cssConstants.OPEN)
    //       .removeClass(cssConstants.CLOSE);
    //   }
    // },

    // /**
    //  * @TODO
    //  *
    //  * @return  {[type]}  [description]
    //  */
    // closeResults: function () {
    //   if (jQuery(this.resultWrapper).hasClass(cssConstants.OPEN)) {
    //     jQuery(this.resultWrapper).addClass(cssConstants.CLOSE)
    //       .removeClass(cssConstants.OPEN);
    //   }
    // },

    // /**
    //  * @TODO
    //  *
    //  * @return  {[type]}  [description]
    //  */
    // toggleResults: function () {
    //   if (jQuery(this.resultWrapper).hasClass(cssConstants.CLOSE)) {
    //     this.openResults();
    //   } else {
    //     this.closeResults();
    //   }
    // },

    /**
     * @TODO
     *
     * @return  {[type]}  [description]
     */

  }, {
    key: "clearResults",
    value: function clearResults() {
      this.resultWrapper.innerHTML = '';
    }

    /**
     * @TODO
     *
     * @param   {[type]}  location  [description]
     *
     * @return  {[type]}            [description]
     */

  }, {
    key: "zoomTo",
    value: function zoomTo(index) {
      var self, map, animate, markResult, result, resultCoordinate, flyTo, completeSearch, animationDuration, zoomType;

      flyTo = function flyTo(map, location, zoomlevel, zoombounds, boundingbox, markResult, animate) {
        var duration = 2000;
        var zoom = zoomlevel;
        var parts = 2;
        var called = false;
        var extent;

        function callback(complete) {
          --parts;
          if (called) {
            return;
          }
          if (parts === 0 || !complete) {
            called = true;

            if (zoombounds && boundingbox) {
              // translate osm-extent to ol3-extent

              var osmExtent = [];
              osmExtent.push(parseFloat(boundingbox[2]));
              osmExtent.push(parseFloat(boundingbox[0]));
              osmExtent.push(parseFloat(boundingbox[3]));
              osmExtent.push(parseFloat(boundingbox[1]));

              extent = ol.proj.transformExtent(osmExtent, 'EPSG:4326', 'EPSG:3857');
              window.setTimeout(function () {
                mapView.fit(extent, map.getSize(), {
                  minZoom: mapView.get('minZoom') || 2,
                  maxZoom: zoom || mapView.get('maxZoom') || 18,
                  duration: duration / 2,
                  easing: ol.easing.easeOut
                });
              }, duration);
            }

            completeSearch(markResult, animate);
          }
        }

        map.getView().animate({
          center: location,
          duration: duration
        }, callback);
        map.getView().animate({
          zoom: zoom - 1,
          duration: duration / 2
        }, {
          zoom: zoom,
          duration: duration / 2
        }, callback);
      };

      completeSearch = function completeSearch(markResult, animate) {
        var addMarker, markerSource, animateMarker;

        markerSource = new ol.source.Vector();
        map.addLayer(new ol.layer.Vector({
          style: new ol.style.Style(),
          source: markerSource
        }));

        addMarker = function addMarker() {
          markerSource.addFeature(new ol.Feature(new ol.geom.Point(resultCoordinate)));
        };

        animateMarker = function animateMarker(feature) {
          var animationStep, start, duration, listenerKey;

          start = new Date().getTime();
          duration = 3000;

          animationStep = function animationStep(event) {
            var vectorContext, frameState, elapsed, elapsedRatio, radius, opacity, marker, flashGeom;

            vectorContext = event.vectorContext;
            frameState = event.frameState;
            flashGeom = feature.getGeometry().clone();
            elapsed = frameState.time - start;
            elapsedRatio = elapsed / duration;
            radius = ol.easing.linear(1 - elapsedRatio) * 100;
            if (radius < 0) {
              radius = 0;
            }
            opacity = ol.easing.linear(elapsedRatio);

            marker = new ol.style.Style({
              image: new ol.style.Circle({
                radius: radius,
                snapToPixel: false,
                stroke: new ol.style.Stroke({
                  color: 'rgba(200, 0, 0, ' + opacity + ')',
                  width: 3,
                  opacity: opacity
                })
              })
            });

            vectorContext.setStyle(marker);
            vectorContext.drawGeometry(flashGeom, null);

            if (elapsed > duration) {
              markerSource.clear();
              ol.Observable.unByKey(listenerKey);
              return;
            }
            // continue postcompose animation
            frameState.animate = true;
          }; // end of "animationStep"

          listenerKey = map.on('postcompose', animationStep);
        }; // end of "animateMarker"

        markerSource.on('addfeature', function (event) {
          animateMarker(event.feature);
        });

        if (animate) {
          if (zoomType === 'zoom') {
            window.setTimeout(addMarker, animationDuration / 2);
          } else {
            window.setTimeout(addMarker, animationDuration);
          }
        } else {
          addMarker();
        }
      };

      self = this;
      map = this.getMap();

      result = self.results[index];
      resultCoordinate = ol.proj.transform([parseFloat(result.lon), parseFloat(result.lat)], 'EPSG:4326', 'EPSG:3857');

      if (animate) {
        var resolution = mapView.getResolution();
        var viewExtent = mapView.calculateExtent(map.getSize());
        if (ol.extent.containsCoordinate(viewExtent, resultCoordinate)) {
          zoomType = 'zoom';
        } else {
          if (Math.abs(currentCoordinate[0] - resultCoordinate[0]) > Math.abs(currentCoordinate[1] - resultCoordinate[1])) {
            var coordDif = Math.abs(currentCoordinate[0] - resultCoordinate[0]);
            var difContext = ol.extent.getWidth(viewExtent);
          } else {
            coordDif = Math.abs(currentCoordinate[1] - resultCoordinate[1]);
            difContext = ol.extent.getHeight(viewExtent);
          }
          if (coordDif > 0) {
            resolution *= coordDif / difContext;
          }
          zoomType = 'bounce';
        }

        flyTo(map, resultCoordinate, self.config.zoomlevel, self.config.zoombounds, result.boundingbox, this.config.markResult, this.config.animate);
      } else {
        completeSearch(this.config.markResult, this.config.animate);
        map.getView().setCenter(resultCoordinate);
        if (self.config.zoomlevel >= 0) {
          map.getView().setZoom(self.config.zoomlevel);
        }
      }
    }
  }, {
    key: "findLocation",
    value: function findLocation(location, opt_options) {
      var self, map, animate, animationDuration, markResult;

      self = this;
      map = this.getMap();

      // show spinner
      this.config.mapController.spinner.show();

      animate = this.config.animate;
      animationDuration = 2000;
      markResult = this.config.markResult;

      if ((typeof opt_options === "undefined" ? "undefined" : _typeof(opt_options)) === 'object') {
        if (opt_options.animate !== undefined) {
          animate = opt_options.animate;
        }
        if (opt_options.markResult !== undefined) {
          markResult = opt_options.markResult;
        }
      }

      // @TODO
      // check bounds
      //   are there restriction-bounds on the map?
      //   -> else use extent-bounds

      // @TODO
      // highlight found area/location


      if (this.config.quicksearch) {
        var data = {
          format: "json",
          q: location
        };
        if (this.config.key) {
          data.key = this.config.key;
        }
        // AJAX -> @nominatim
        jQuery.ajax({
          dataType: "json",
          url: this.config.url,
          data: data
        }).done(function (results) {

          var mapView, currentCoordinate, resultCoordinate, coordDif, difContext, viewExtent, result, osmExtent, resolution, zoomType, flyTo, completeSearch;

          mapView = map.getView();

          flyTo = function flyTo(map, location, zoomlevel, zoombounds, boundingbox, markResult, animate) {
            var duration = 2000;
            var zoom = zoomlevel;
            var parts = 2;
            var called = false;
            var extent;

            function callback(complete) {
              --parts;
              if (called) {
                return;
              }
              if (parts === 0 || !complete) {
                called = true;

                if (zoombounds && boundingbox) {
                  // translate osm-extent to ol3-extent

                  osmExtent = [];
                  osmExtent.push(parseFloat(boundingbox[2]));
                  osmExtent.push(parseFloat(boundingbox[0]));
                  osmExtent.push(parseFloat(boundingbox[3]));
                  osmExtent.push(parseFloat(boundingbox[1]));

                  extent = ol.proj.transformExtent(osmExtent, 'EPSG:4326', 'EPSG:3857');

                  window.setTimeout(function () {
                    var viewFit = mapView.fit(extent, map.getSize(), {
                      minZoom: mapView.get('minZoom') || 2,
                      maxZoom: zoom || mapView.get('maxZoom') || 18,
                      duration: duration / 2,
                      easing: ol.easing.easeOut
                    });
                  }, duration);
                }

                completeSearch(markResult, animate);
              }
            }

            map.getView().animate({
              center: location,
              duration: duration
            }, callback);

            map.getView().animate({
              zoom: zoom - 1,
              duration: duration / 2
            }, {
              zoom: zoom,
              duration: duration / 2
            }, callback);
          };

          completeSearch = function completeSearch(markResult, animate) {
            // result marker & animation
            if (markResult) {
              var addMarker, markerSource, animateMarker;

              markerSource = new ol.source.Vector();
              map.addLayer(new ol.layer.Vector({
                style: new ol.style.Style(),
                source: markerSource
              }));

              addMarker = function addMarker() {
                markerSource.addFeature(new ol.Feature(new ol.geom.Point(resultCoordinate)));
              };

              animateMarker = function animateMarker(feature) {
                var animationStep, start, duration, listenerKey;

                start = new Date().getTime();
                duration = 3000;

                animationStep = function animationStep(event) {
                  var vectorContext, frameState, elapsed, elapsedRatio, radius, opacity, marker, flashGeom;

                  vectorContext = event.vectorContext;
                  frameState = event.frameState;
                  flashGeom = feature.getGeometry().clone();
                  elapsed = frameState.time - start;
                  elapsedRatio = elapsed / duration;
                  radius = ol.easing.linear(1 - elapsedRatio) * 100;
                  if (radius < 0) {
                    radius = 0;
                  }
                  opacity = ol.easing.linear(elapsedRatio);

                  var marker = new ol.style.Style({
                    image: new ol.style.Circle({
                      radius: radius,
                      snapToPixel: false,
                      stroke: new ol.style.Stroke({
                        color: 'rgba(200, 0, 0, ' + opacity + ')',
                        width: 3,
                        opacity: opacity
                      })
                    })
                  });

                  vectorContext.setStyle(marker);
                  vectorContext.drawGeometry(flashGeom, null);

                  if (elapsed > duration) {
                    markerSource.clear();
                    ol.Observable.unByKey(listenerKey);
                    return;
                  }
                  // continue postcompose animation
                  frameState.animate = true;
                }; // end of "animationStep"

                listenerKey = map.on('postcompose', animationStep);
              }; // end of "animateMarker"

              markerSource.on('addfeature', function (event) {
                animateMarker(event.feature);
              });

              if (animate) {
                if (zoomType === 'zoom') {
                  window.setTimeout(addMarker, animationDuration / 2);
                } else {
                  window.setTimeout(addMarker, animationDuration);
                }
              } else {
                addMarker();
              }
            } // end of result marker & animation handling
          };

          if (results[0]) {
            result = results[0];
            self.results = results;
            currentCoordinate = mapView.getCenter();
            resultCoordinate = ol.proj.transform([parseFloat(result.lon), parseFloat(result.lat)], 'EPSG:4326', 'EPSG:3857');

            if (animate) {
              flyTo(map, resultCoordinate, self.config.zoomlevel, self.config.zoombounds, result.boundingbox, markResult, animate);
            } else {
              completeSearch(self.config.markResult, self.config.animate);
              mapView.setCenter(resultCoordinate);
              if (self.config.zoomlevel >= 0) {
                map.getView().setZoom(self.config.zoomlevel);
              }
            }

            var pixel = map.getPixelFromCoordinate(resultCoordinate);
            var feature = map.forEachFeatureAtPixel(pixel, function (feature, layer) {
              return feature;
            });
            var layer = map.forEachFeatureAtPixel(pixel, function (feature, layer) {
              return layer;
            });
            if (self.config.popup) {
              var popupInfos = {};
              if (feature && feature.get('popup')) {
                // single POI
                popupInfos = feature.get('popup');
              } else if (layer && layer.popup) {
                popupInfos = layer.popup;
              } else {
                feature = false;
              }
              if (feature) {
                var geometry = feature.getGeometry();
                if (geometry instanceof ol.geom.Point) {
                  var coord = geometry.getCoordinates();
                } else {
                  var coord = resultCoordinate;
                }

                window.c4gMapsPopup.popup.setPosition(coord);
                if (popupInfos.content) {
                  window.c4gMapsPopup.$content.html('');
                  window.c4gMapsPopup.popup.addClass(_c4gMapsConstant.cssConstants.ACTIVE).addClass(_c4gMapsConstant.cssConstants.LOADING);
                  window.c4gMapsPopup.spinner.show();

                  if (popupInfos.async === false || popupInfos.async == '0') {
                    var objPopup = {};
                    objPopup.popup = popupInfos;
                    objPopup.feature = feature;
                    objPopup.layer = layer;
                    // Call the popup hook for plugin specific popup content
                    if (window.c4gMapsHooks !== undefined && _typeof(window.c4gMapsHooks.proxy_fillPopup) === 'object') {
                      _c4gMapsUtils.utils.callHookFunctions(window.c4gMapsHooks.proxy_fillPopup, objPopup);
                    }
                    self.config.mapController.proxy.setPopup(objPopup);
                  } else {
                    jQuery.ajax({
                      dataType: "json",
                      url: self.api_infowindow_url + '/' + popupInfos.content,
                      done: function done(data) {
                        var popupInfo = {
                          async: popupInfos.async,
                          content: data.content,
                          popup: popupInfos.popup,
                          routing_link: popupInfos.routing_link
                        };

                        objPopup = {};
                        objPopup.popup = popupInfo;
                        objPopup.feature = feature;
                        objPopup.layer = layer;

                        // Call the popup hook for plugin specific popup content
                        if (window.c4gMapsHooks !== undefined && _typeof(window.c4gMapsHooks.proxy_fillPopup) === 'object') {
                          _c4gMapsUtils.utils.callHookFunctions(window.c4gMapsHooks.proxy_fillPopup, objPopup);
                        }

                        self.setPopup(objPopup);
                      }
                    });
                  }
                } else {
                  window.c4gMapsPopup.popup.removeClass(_c4gMapsConstant.cssConstants.ACTIVE);
                }
              } else if (window && window.c4gMapsPopup && window.c4gMapsPopup.popup) {
                jQuery(window.c4gMapsPopup.popup).removeClass(_c4gMapsConstant.cssConstants.ACTIVE);
              }
            }

            if (self.config.autopick && self.config.mapController.geopicker && typeof self.config.mapController.geopicker.pick === 'function') {
              self.config.mapController.geopicker.pick(resultCoordinate);
            }
          } else {
            var langConstants = (0, _c4gMapsI18n.getLanguage)(self.options.mapController.data);
            alert(langConstants.SEARCH_NOT_FOUND);
          }
          // self.resultWrapper.innerHTML = '@ console';

          if (document.getElementById("resultcontainer")) {
            document.getElementById("resultcontainer").parentNode.removeChild(document.getElementById("resultcontainer"));
          }
          if (self.config.results) {

            var searchResultContainer = document.createElement('ul');
            searchResultContainer.setAttribute("id", "resultcontainer");
            if (self.results) {
              for (var i = 0; i < self.results.length; i++) {
                var searchResult = document.createElement('li');
                var searchResultButton = document.createElement('button');
                searchResultButton.setAttribute("id", i);
                searchResultButton.setAttribute('class', 'searchResultButton');
                searchResultButton.addEventListener('click', function () {
                  self.zoomTo(this.getAttribute("id"));
                });

                searchResultButton.setAttribute("name", self.results[i].display_name);
                searchResultButton.innerHTML = self.results[i].display_name;
                searchResult.appendChild(searchResultButton);
                searchResultContainer.appendChild(searchResult);
              }
              self.searchWrapper.appendChild(searchResultContainer);
            }
          }
        })

        // AJAX-failure
        //
        .fail(function () {
          // @TODO
          // self.resultWrapper.innerHTML = 'ohoh!';
        })

        // AJAX-always
        //
        .always(function () {
          self.config.mapController.spinner.hide();
        });
      } else {
        // @TODO
      }
    }
  }]);

  return GeoSearch;
}(ol.control.Control);

/***/ }),

/***/ "./Resources/public/js/c4g-maps-control-grid.js":
/*!******************************************************!*\
  !*** ./Resources/public/js/c4g-maps-control-grid.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Grid = undefined;

var _c4gMapsConstant = __webpack_require__(/*! ./c4g-maps-constant */ "./Resources/public/js/c4g-maps-constant.js");

var _c4gMapsI18n = __webpack_require__(/*! ./c4g-maps-i18n */ "./Resources/public/js/c4g-maps-i18n.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This file is part of con4gis,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * the gis-kit for Contao CMS.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @package    con4gis
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @version    6
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author     con4gis contributors (see "authors.txt")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @license    LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @copyright  Küstenschmiede GmbH Software & Design
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @link       https://www.con4gis.org
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

'use strict';

var Grid = exports.Grid = function (_ol$control$Control) {
  _inherits(Grid, _ol$control$Control);

  /**
   * Control to toggle a grid on the map.
   *
   * @constructor
   * @extends  {ol.control.Control}
   *
   * @param    {Object}              opt_options  *optional* control options.
   */
  function Grid(opt_options) {
    _classCallCheck(this, Grid);

    var _this = _possibleConstructorReturn(this, (Grid.__proto__ || Object.getPrototypeOf(Grid)).call(this, opt_options));

    var self = _this;
    var options = opt_options || {};

    var element, button;

    var objGrid = new ol.Graticule({
      /*
      strokeStyle: new ol.style.Stroke({
          width: 2,
          lineDash: [0.5, 4]
      }),*/
      showLabels: true
    });

    var langConstants = (0, _c4gMapsI18n.getLanguage)(options.mapController.data);
    // default options
    options = jQuery.extend({
      className: _c4gMapsConstant.cssConstants.GRATICULE,
      switchable: true,
      tipLabel: langConstants.CTRL_GRID,
      label: '#',
      disableLabel: '[]'
    }, options);

    // @TODO move functions to prototype?
    //
    // function to enable the grid
    var enable = function enable() {
      objGrid.setMap(self.getMap());
      jQuery(element).addClass(_c4gMapsConstant.cssConstants.ENABLED);
      // if (options.caching) {
      //     c4g.maps.utils.storeValue('grid', '1');
      // }
    };

    // function to disable the grid
    var disable = function disable() {
      objGrid.setMap(null);
      jQuery(element).removeClass(_c4gMapsConstant.cssConstants.ENABLED);
      // if (options.caching) {
      //     c4g.maps.utils.storeValue('grid', '0');
      // }
    };

    // function to toggle the grid
    var toggle = function toggle(event) {
      event.stopPropagation();
      // loose focus, otherwise it looks messy
      this.blur();
      if (objGrid.getMap()) {
        disable();
      } else {
        enable();
      }
    };

    // wrapper div
    element = document.createElement('div');
    element.className = options.className + ' ' + _c4gMapsConstant.cssConstants.OL_UNSELECTABLE + ' ' + _c4gMapsConstant.cssConstants.OL_CONTROL;

    if (options.switchable) {
      // button
      button = document.createElement('button');
      button.title = options.tipLabel;
      element.appendChild(button);

      // set onClick to the toggle-function
      button.addEventListener('click', toggle, false);
      button.addEventListener('touchstart', toggle, false);
    }

    // inheritance-stuff
    ol.control.Control.call(_this, {
      element: element,
      target: options.target
    });
    return _this;
  }

  return Grid;
}(ol.control.Control);

/***/ }),

/***/ "./Resources/public/js/c4g-maps-control-home.js":
/*!******************************************************!*\
  !*** ./Resources/public/js/c4g-maps-control-home.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Home = undefined;

var _c4gMapsUtils = __webpack_require__(/*! ./c4g-maps-utils */ "./Resources/public/js/c4g-maps-utils.js");

var _c4gMapsConstant = __webpack_require__(/*! ./c4g-maps-constant */ "./Resources/public/js/c4g-maps-constant.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This file is part of con4gis,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * the gis-kit for Contao CMS.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @package    con4gis
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @version    6
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author     con4gis contributors (see "authors.txt")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @license    LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @copyright  Küstenschmiede GmbH Software & Design
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @link       https://www.con4gis.org
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

'use strict';

var Home = exports.Home = function (_ol$control$Control) {
  _inherits(Home, _ol$control$Control);

  /**
   * Control to toggle the intial map position on the map.
   *
   * @constructor
   * @extends  {ol.control.Control}
   *
   * @param    {Object}              opt_options  *optional* control options.
   */
  function Home(opt_options) {
    _classCallCheck(this, Home);

    var _this = _possibleConstructorReturn(this, (Home.__proto__ || Object.getPrototypeOf(Home)).call(this, opt_options));

    var self = _this;
    var options = opt_options || {};

    var element, button;

    // default options
    options = jQuery.extend({
      className: _c4gMapsConstant.cssConstants.OL_ZOOM_HOME,
      switchable: true,
      enabled: true,
      mapController: undefined
    }, options);

    if (!options.mapController) {
      var _ret;

      return _ret = false, _possibleConstructorReturn(_this, _ret);
    }

    var view = options.mapController.map.getView();
    var mapData = options.mapController.data;

    var toggle = function toggle(event) {
      event.stopPropagation();
      // loose focus, otherwise it looks messy
      this.blur();

      view.setCenter(ol.proj.transform([parseFloat(mapData.center.lon), parseFloat(mapData.center.lat)], 'EPSG:4326', 'EPSG:3857'));
      view.setZoom(parseInt(mapData.center.zoom, 10));
      view.setRotation(parseFloat(mapData.center.rotation));

      // check userposition
      var geoLocation;
      if (mapData.geolocation) {
        geoLocation = new ol.Geolocation({
          tracking: true,
          projection: view.getProjection()
        });

        geoLocation.on('change', function (evt) {
          view.setCenter(geoLocation.getPosition());
          if (mapData.geolocation_zoom) {
            view.setZoom(parseInt(mapData.geolocation_zoom, 10));
          }
          geoLocation.setTracking(false);
        });
      }

      options.mapController.map.setView(view);
      // utils.redrawMapView(options.mapController);
    };

    // wrapper div
    element = document.createElement('div');
    element.className = options.className + ' ' + _c4gMapsConstant.cssConstants.OL_UNSELECTABLE + ' button';

    if (options.switchable) {
      // button
      button = document.createElement('button');
      button.title = options.tipLabel;
      element.appendChild(button);

      // set onClick to the toggle-function
      button.addEventListener('click', toggle, false);
      button.addEventListener('touchstart', toggle, false);
    }

    ol.control.Control.call(_this, {
      element: element,
      target: options.target
    });
    ol.inherits(Home, ol.control.Control);
    return _this;
  }

  return Home;
}(ol.control.Control);

/***/ }),

/***/ "./Resources/public/js/c4g-maps-control-overviewmap.js":
/*!*************************************************************!*\
  !*** ./Resources/public/js/c4g-maps-control-overviewmap.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OverviewMap = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * This file is part of con4gis,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * the gis-kit for Contao CMS.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @package    con4gis
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @version    6
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @author     con4gis contributors (see "authors.txt")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @license    LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @copyright  Küstenschmiede GmbH Software & Design
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @link       https://www.con4gis.org
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _c4gMapsConstant = __webpack_require__(/*! ./c4g-maps-constant */ "./Resources/public/js/c4g-maps-constant.js");

var _c4gMapsI18n = __webpack_require__(/*! ./c4g-maps-i18n */ "./Resources/public/js/c4g-maps-i18n.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

'use strict';

var OverviewMap = exports.OverviewMap = function () {

  /**
   * Displays a overviewmap on the map.
   *   This class wraps the ovm a bit differently than
   *   the standard ol-overviemap, to allow proper css-transitions.
   *
   * @constructor
   * @extends  {ol.control.Control}
   *
   * @param    {Object}              opt_options  *optional* control options.
   */
  function OverviewMap(options) {
    _classCallCheck(this, OverviewMap);

    var element, trigger, triggerIcon, ovm;

    var langConstants = (0, _c4gMapsI18n.getLanguage)(options.mapController.data);
    // default options
    this.options = jQuery.extend({
      collapsed: true,
      tipLabel: langConstants.CTRL_OVERVIEWMAP,
      layers: [new ol.layer.Tile({ source: new ol.source.OSM() })]
    }, options);
    this.mapController = options.mapController;

    element = document.createElement('div');
    element.className = _c4gMapsConstant.cssConstants.OVERVIEWMAP + ' ' + _c4gMapsConstant.cssConstants.OL_UNSELECTABLE + ' ' + _c4gMapsConstant.cssConstants.OL_CONTROL;
    if (options.collapsed) {
      element.className += ' ' + _c4gMapsConstant.cssConstants.CLOSE;
    } else {
      element.className += ' ' + _c4gMapsConstant.cssConstants.OPEN;
    }
    options.target.appendChild(element);

    trigger = document.createElement('button');
    trigger.title = options.tipLabel;
    element.appendChild(trigger);

    triggerIcon = document.createElement('span');
    triggerIcon.className = _c4gMapsConstant.cssConstants.ICON;
    trigger.appendChild(triggerIcon);

    jQuery(trigger).click(function () {
      if (jQuery(element).hasClass(_c4gMapsConstant.cssConstants.CLOSE)) {
        jQuery(element).removeClass(_c4gMapsConstant.cssConstants.CLOSE).addClass(_c4gMapsConstant.cssConstants.OPEN);
      } else {
        jQuery(element).addClass(_c4gMapsConstant.cssConstants.CLOSE).removeClass(_c4gMapsConstant.cssConstants.OPEN);
      }
      try {
        this.blur();
      } catch (ignore) {}
    });

    this.ovm = new ol.control.OverviewMap({
      target: element,
      layers: options.layers,
      collapsed: options.collapsed || true
    });
    this.element = element;
  }

  _createClass(OverviewMap, [{
    key: "removeFromMap",
    value: function removeFromMap() {
      this.element.parentNode.removeChild(this.element);
    }
  }, {
    key: "getOverviewMap",
    value: function getOverviewMap() {
      return this.ovm;
    }
  }, {
    key: "isOpen",
    value: function isOpen() {
      if (jQuery(this.element).hasClass(_c4gMapsConstant.cssConstants.OPEN)) {
        return true;
      } else {
        return false;
      }
    }
  }]);

  return OverviewMap;
}();

/***/ }),

/***/ "./Resources/public/js/c4g-maps-control-permalink.js":
/*!***********************************************************!*\
  !*** ./Resources/public/js/c4g-maps-control-permalink.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Permalink = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _c4gMapsConstant = __webpack_require__(/*! ./c4g-maps-constant */ "./Resources/public/js/c4g-maps-constant.js");

var _c4gMapsUtils = __webpack_require__(/*! ./c4g-maps-utils */ "./Resources/public/js/c4g-maps-utils.js");

var _c4gMapsI18n = __webpack_require__(/*! ./c4g-maps-i18n */ "./Resources/public/js/c4g-maps-i18n.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This file is part of con4gis,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * the gis-kit for Contao CMS.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @package    con4gis
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @version    6
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author     con4gis contributors (see "authors.txt")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @license    LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @copyright  Küstenschmiede GmbH Software & Design
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @link       https://www.con4gis.org
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

'use strict';

var Permalink = exports.Permalink = function (_ol$control$Control) {
  _inherits(Permalink, _ol$control$Control);

  /**
   * Control to generate a permalink to the current Map state.
   *
   * @constructor
   * @extends  {ol.control.Control}
   *
   * @param    {Object}              options  control options.
   */
  function Permalink(options) {
    _classCallCheck(this, Permalink);

    var _this = _possibleConstructorReturn(this, (Permalink.__proto__ || Object.getPrototypeOf(Permalink)).call(this, options));

    var self, button, copyButton, refreshButton;

    _this.config = options || {};
    self = _this;

    var langConstants = (0, _c4gMapsI18n.getLanguage)(options.mapController.data);
    // default options
    _this.config = jQuery.extend({
      className: _c4gMapsConstant.cssConstants.PERMALINK,
      // mapController: undefined,
      tipLabel: langConstants.CTRL_PERMALINK,
      getParameter: false,
      label: 'P',
      target: undefined
    }, _this.config);

    if (!_this.config.mapController) {
      var _ret;

      return _ret = false, _possibleConstructorReturn(_this, _ret);
    }

    // wrapper div
    _this.element = document.createElement('div');
    _this.element.className = _this.config.className + ' ' + _c4gMapsConstant.cssConstants.OL_UNSELECTABLE + ' ' + _c4gMapsConstant.cssConstants.OL_CONTROL;

    // button
    button = document.createElement('button');
    button.title = _this.config.tipLabel;
    _this.element.appendChild(button);

    // set onClick to the toggle-function
    // button.addEventListener('click', this.toggle, false);
    // button.addEventListener('touchstart', this.toggle, false);
    jQuery(button).click(function () {
      try {
        this.blur();
      } catch (ignore) {}
      self.toggle();
    });

    // popup
    // will be attached when opened the first time
    // to make sure its really the last element in the container
    _this.popupAttached = false;
    _this.popup = document.createElement('div');
    _this.popup.className = _c4gMapsConstant.cssConstants.CONTROL + ' ' + _c4gMapsConstant.cssConstants.PERMALINK_POPUP + ' ' + _c4gMapsConstant.cssConstants.CLOSE;

    // textfield
    _this.textfield = document.createElement('input');
    _this.textfield.type = 'text';
    _this.popup.appendChild(_this.textfield);

    // copy button
    copyButton = document.createElement('button');
    copyButton.className = _c4gMapsConstant.cssConstants.COPY + ' ' + _c4gMapsConstant.cssConstants.ICON;
    copyButton.title = langConstants.COPY_TO_CLIPBOARD;
    copyButton.setAttribute('data-clipboard-target', '.' + _c4gMapsConstant.cssConstants.PERMALINK_POPUP + ' > input[type="text"]');
    _this.popup.appendChild(copyButton);
    new Clipboard(copyButton);

    // refresh button
    refreshButton = document.createElement('button');
    refreshButton.className = _c4gMapsConstant.cssConstants.REFRESH + ' ' + _c4gMapsConstant.cssConstants.ICON;
    refreshButton.title = langConstants.REFRESH;
    jQuery(refreshButton).click(function () {
      self.generateLinkFromCurrentState({ target: self.textfield });
    });
    _this.popup.appendChild(refreshButton);

    // inheritance-stuff
    ol.control.Control.call(_this, {
      element: _this.element,
      target: _this.config.target
    });
    return _this;
  }

  _createClass(Permalink, [{
    key: "open",
    value: function open() {
      if (!this.popupAttached) {
        jQuery(this.popup).slideDown(1);
        this.config.target.appendChild(this.popup);
        this.popupAttached = true;
      }
      jQuery(this.popup).removeClass(_c4gMapsConstant.cssConstants.CLOSE).addClass(_c4gMapsConstant.cssConstants.OPEN);
      jQuery(this.element).addClass(_c4gMapsConstant.cssConstants.OPEN);
      this.generateLinkFromCurrentState({ target: this.textfield });
    }
  }, {
    key: "close",
    value: function close() {
      jQuery(this.popup).removeClass(_c4gMapsConstant.cssConstants.OPEN).addClass(_c4gMapsConstant.cssConstants.CLOSE);
      jQuery(this.element).removeClass(_c4gMapsConstant.cssConstants.OPEN);
    }
  }, {
    key: "toggle",
    value: function toggle() {
      if (jQuery(this.popup).hasClass(_c4gMapsConstant.cssConstants.CLOSE)) {
        this.open();
      } else {
        this.close();
      }
    }
  }, {
    key: "generateLinkFromCurrentState",
    value: function generateLinkFromCurrentState(opt_options) {
      var options, proxy, mapView, parameters, link, center, baseLayerIdx, layerIdx, layers;

      options = opt_options || {};
      if (!options.paramCount || !(options.paramCount === 6 || options.paramCount === 2 || options.paramCount === 1)) {
        options.paramCount = 6;
      }

      parameters = [];
      mapView = this.config.mapController.map.getView();
      proxy = this.config.mapController.proxy;

      center = mapView.getCenter();
      center = ol.proj.transform([center[0], center[1]], 'EPSG:3857', 'EPSG:4326');

      parameters.push(+center[0].toFixed(5));
      parameters.push(+center[1].toFixed(5));
      parameters.push(mapView.getZoom());
      parameters.push(+mapView.getRotation().toFixed(2));

      // find active baselayer
      if (proxy.activeBaselayerId) {
        parameters.push(proxy.activeBaselayerId);
      } else {
        parameters.push(0);
      }

      // find active layers
      layers = [];
      for (layerIdx in proxy.activeLayerIds) {
        if (proxy.activeLayerIds.hasOwnProperty(layerIdx)) {
          layers.push(parseInt(layerIdx, 10));
        }
      }
      // delta-decode if there are more than one layer
      if (layers.length > 1) {
        layers = _c4gMapsUtils.utils.deltaEncode(layers);
        layers = layers.join(':');
      } else {
        layers = layers[0] || '0';
      }
      parameters.push(layers);
      parameters = parameters.join('/');

      // build link
      link = _c4gMapsUtils.utils.setUrlParam(parameters, this.config.getParameter);

      if (options.target) {
        options.target.value = link;
      } else {
        return link;
      }
    } // end of generateLinkFromCurrentState

  }, {
    key: "generateLink",
    value: function generateLink(parameters) {
      if (!parameters || !(parameters.length === 6 || parameters.length === 2 || parameters.length === 1)) {
        return false;
      }

      // build and return link
      return _c4gMapsUtils.utils.setUrlParam(parameters.join('/'), this.config.getParameter);
    } // end of generateLink


  }]);

  return Permalink;
}(ol.control.Control);

/***/ }),

/***/ "./Resources/public/js/c4g-maps-control-portside-account.js":
/*!******************************************************************!*\
  !*** ./Resources/public/js/c4g-maps-control-portside-account.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Account = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _c4gMapsControlSideboard = __webpack_require__(/*! ./c4g-maps-control-sideboard */ "./Resources/public/js/c4g-maps-control-sideboard.js");

var _c4gMapsConstant = __webpack_require__(/*! ./c4g-maps-constant */ "./Resources/public/js/c4g-maps-constant.js");

var _c4gMapsI18n = __webpack_require__(/*! ./c4g-maps-i18n */ "./Resources/public/js/c4g-maps-i18n.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This file is part of con4gis,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * the gis-kit for Contao CMS.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @package    con4gis
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @version    6
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author     con4gis contributors (see "authors.txt")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @license    LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @copyright  Küstenschmiede GmbH Software & Design
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @link       https://www.con4gis.org
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

'use strict';

var Account = exports.Account = function (_Sideboard) {
  _inherits(Account, _Sideboard);

  /**
   * Constructor
   *
   * @extends {c4g.maps.control.Sideboard}
   *
   * @param  {[type]}  mapController  [description]
   * @param  {[type]}  config         [description]
   */
  function Account(opt_options) {
    _classCallCheck(this, Account);

    // extend options
    var _this = _possibleConstructorReturn(this, (Account.__proto__ || Object.getPrototypeOf(Account)).call(this, opt_options));

    _this.langConstants = (0, _c4gMapsI18n.getLanguage)(opt_options.mapController.data);
    _this.options = jQuery.extend({
      className: _c4gMapsConstant.cssConstants.ACCOUNT,
      name: 'account',
      headline: _this.langConstants.ACCOUNT,
      create: true,
      mapController: undefined,
      direction: 'left'
    }, opt_options);

    if (!_this.options.mapController) {
      var _ret;

      return _ret = false, _possibleConstructorReturn(_this, _ret);
    }

    _this.mainSection = document.createElement('div');

    // call parent constructor
    _c4gMapsControlSideboard.Sideboard.call(_this, _this.options);
    return _this;
  }

  _createClass(Account, [{
    key: "init",


    /**
     * Executed when the panel will be opened for the first time.
     * [init description]
     *
     * @return  {boolean}  Returns |true| on success
     */
    value: function init() {
      var self = this;

      this.spinner.show();

      this.viewAccount = this.addAccountView();
      this.viewAccount.activate();

      var proxy = self.options.mapController.proxy;
      var map = self.options.mapController.map;

      this.mainSectionAccount = document.createElement('p');
      this.mainSectionAccount.innerHTML = self.options.mapController.data.account;
      this.mainSection.appendChild(this.mainSectionAccount);
      this.contentContainer.setElement(this.mainSection);

      this.spinner.hide();
      return true;
    } // end of "init()"


  }, {
    key: "addAccountView",
    value: function addAccountView() {
      var accountView;

      accountView = this.addView({
        name: 'account',
        triggerConfig: {
          tipLabel: this.langConstants.ACCOUNT_VIEW_TRIGGER,
          className: _c4gMapsConstant.cssConstants.ACCOUNT_VIEW_TRIGGER,
          withHeadline: false
        },
        sectionElements: [{ section: this.contentContainer, element: this.mainSection }, { section: this.topToolbar, element: this.viewTriggerBar }]
      });

      return accountView;
    } // end of "addAccountView()"

  }, {
    key: "addAccount",
    value: function addAccount(options) {
      var self, TRIGGER_ACCOUNT, viewAccount, source, interaction, features;

      self = this;

      //TRIGGER_ACCOUNT = 'ACCOUNT_VIEW_TRIGGER_' + options.type.toUpperCase();

      viewAccount = self.addAccount({
        name: 'Account',
        triggerConfig: {
          tipLabel: 'Account', //langConstants[TRIGGER_DRAW],
          className: 'c4g_account_trigger', //cssConstants[TRIGGER_DRAW]
          withHeadline: false
        },
        sectionElements: [{ section: self.topToolbar, element: self.viewTriggerBar }],
        initFunction: function initFunction() {

          // Show loading animation
          self.spinner.show();

          // printFunction = function (event) {
          //   var infoButton,
          //       featureGeometry,
          //       translateInteraction,
          //       modifyInteraction,
          //       modifyButton,
          //       applyButton;
          //
          //
          //     infoButton = event.target;
          //
          //   // add apply button
          //   applyButton = document.createElement('button');
          //   applyButton.className = cssConstants.ICON + ' ' + cssConstants.EDITOR_FEATURE_APPLY;
          //   applyButton.title = langConstants.EDITOR_FEATURE_APPLY;
          //   applyButton.setAttribute('feat_id', i);
          //
          // }; // end of "modifyFeatureFunction()"

          features = new ol.Collection();

          self.spinner.hide();
          return true;
        },
        activateFunction: function activateFunction() {},
        deactivateFunction: function deactivateFunction() {}
      });

      return viewAccount;
    } // end of "addAccount()"

  }]);

  return Account;
}(_c4gMapsControlSideboard.Sideboard);

/***/ }),

/***/ "./Resources/public/js/c4g-maps-control-portside-infopage.js":
/*!*******************************************************************!*\
  !*** ./Resources/public/js/c4g-maps-control-portside-infopage.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Infopage = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _c4gMapsControlSideboard = __webpack_require__(/*! ./c4g-maps-control-sideboard */ "./Resources/public/js/c4g-maps-control-sideboard.js");

var _c4gMapsConstant = __webpack_require__(/*! ./c4g-maps-constant */ "./Resources/public/js/c4g-maps-constant.js");

var _c4gMapsI18n = __webpack_require__(/*! ./c4g-maps-i18n */ "./Resources/public/js/c4g-maps-i18n.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This file is part of con4gis,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * the gis-kit for Contao CMS.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @package    con4gis
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @version    6
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author     con4gis contributors (see "authors.txt")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @license    LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @copyright  Küstenschmiede GmbH Software & Design
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @link       https://www.con4gis.org
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

'use strict';

var Infopage = exports.Infopage = function (_Sideboard) {
  _inherits(Infopage, _Sideboard);

  /**
   * Constructor
   *
   * @extends {c4g.maps.control.Sideboard}
   *
   * @param  {[type]}  mapController  [description]
   * @param  {[type]}  config         [description]
   */
  function Infopage(opt_options) {
    _classCallCheck(this, Infopage);

    // extend options
    var _this = _possibleConstructorReturn(this, (Infopage.__proto__ || Object.getPrototypeOf(Infopage)).call(this, opt_options));

    _this.options = jQuery.extend({
      className: _c4gMapsConstant.cssConstants.INFOPAGE,
      name: 'infopage',
      headline: _this.langConstants.INFOPAGE,
      create: true,
      mapController: undefined,
      direction: 'left'
    }, opt_options);

    if (!_this.options.mapController) {
      var _ret;

      return _ret = false, _possibleConstructorReturn(_this, _ret);
    }

    _this.mainSection = document.createElement('div');

    // call parent constructor
    _c4gMapsControlSideboard.Sideboard.call(_this, _this.options);
    return _this;
  }

  /**
   * Executed when the panel will be opened for the first time.
   * [init description]
   *
   * @return  {boolean}  Returns |true| on success
   */


  _createClass(Infopage, [{
    key: "init",
    value: function init() {
      //var infoButton;
      var self = this;

      this.spinner.show();

      this.viewInfopage = this.addInfoView();
      this.viewInfopage.activate();
      this.langConstants = (0, _c4gMapsI18n.getLanguage)(self.options.mapController.data);

      var proxy = self.options.mapController.proxy;
      var map = self.options.mapController.map;

      this.mainSectionInfo = document.createElement('p');
      this.mainSectionInfo.innerHTML = self.options.mapController.data.infopage;
      this.mainSection.appendChild(this.mainSectionInfo);
      this.contentContainer.setElement(this.mainSection);

      this.spinner.hide();
      return true;
    } // end of "init()"


  }, {
    key: "addInfoView",
    value: function addInfoView() {
      var infoView;

      infoView = this.addView({
        name: 'info',
        triggerConfig: {
          tipLabel: this.langConstants.INFOPAGE_VIEW_TRIGGER,
          className: _c4gMapsConstant.cssConstants.INFOPAGE_VIEW_TRIGGER,
          withHeadline: false
        },
        sectionElements: [{ section: this.contentContainer, element: this.mainSection }, { section: this.topToolbar, element: this.viewTriggerBar }]
      });

      return infoView;
    } // end of "addInfoView()"

  }, {
    key: "addInfopage",
    value: function addInfopage(options) {
      var self, TRIGGER_INFOPAGE, viewInfopage, source, interaction, features;

      self = this;

      //TRIGGER_INFOPAGE = 'INFOPAGE_VIEW_TRIGGER_' + options.type.toUpperCase();

      viewInfopage = self.addInfopage({
        name: 'Infopage',
        triggerConfig: {
          tipLabel: 'Infopage', //langConstants[TRIGGER_DRAW],
          className: 'c4g_infopage_trigger', //cssConstants[TRIGGER_DRAW]
          withHeadline: false
        },
        sectionElements: [{ section: self.topToolbar, element: self.viewTriggerBar }],
        initFunction: function initFunction() {

          // Show loading animation
          self.spinner.show();

          // printFunction = function (event) {
          //   var infoButton,
          //       featureGeometry,
          //       translateInteraction,
          //       modifyInteraction,
          //       modifyButton,
          //       applyButton;
          //
          //
          //     infoButton = event.target;
          //
          //   // add apply button
          //   applyButton = document.createElement('button');
          //   applyButton.className = cssConstants.ICON + ' ' + cssConstants.EDITOR_FEATURE_APPLY;
          //   applyButton.title = langConstants.EDITOR_FEATURE_APPLY;
          //   applyButton.setAttribute('feat_id', i);
          //
          // }; // end of "modifyFeatureFunction()"

          features = new ol.Collection();

          self.spinner.hide();
          return true;
        },
        activateFunction: function activateFunction() {},
        deactivateFunction: function deactivateFunction() {}
      });

      return viewInfopage;
    } // end of "addInfopage()"

  }]);

  return Infopage;
}(_c4gMapsControlSideboard.Sideboard);

/***/ }),

/***/ "./Resources/public/js/c4g-maps-control-portside-measuretools.js":
/*!***********************************************************************!*\
  !*** ./Resources/public/js/c4g-maps-control-portside-measuretools.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Measuretools = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _c4gMapsConstant = __webpack_require__(/*! ./c4g-maps-constant */ "./Resources/public/js/c4g-maps-constant.js");

var _c4gMapsUtils = __webpack_require__(/*! ./c4g-maps-utils */ "./Resources/public/js/c4g-maps-utils.js");

var _c4gMapsControlSideboard = __webpack_require__(/*! ./c4g-maps-control-sideboard */ "./Resources/public/js/c4g-maps-control-sideboard.js");

var _c4gMapsMiscTooltippopup = __webpack_require__(/*! ./c4g-maps-misc-tooltippopup */ "./Resources/public/js/c4g-maps-misc-tooltippopup.js");

var _c4gMapsI18n = __webpack_require__(/*! ./c4g-maps-i18n */ "./Resources/public/js/c4g-maps-i18n.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This file is part of con4gis,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * the gis-kit for Contao CMS.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @package    con4gis
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @version    6
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author     con4gis contributors (see "authors.txt")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @license    LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @copyright  Küstenschmiede GmbH Software & Design
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @link       https://www.con4gis.org
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

'use strict';

var Measuretools = exports.Measuretools = function (_Sideboard) {
  _inherits(Measuretools, _Sideboard);

  /**
   * Constructor
   *
   * @constructor
   * @extend {c4g.maps.control.Sideboard}
   *
   * @param  {[type]}  mapController  [description]
   */
  function Measuretools(opt_options) {
    _classCallCheck(this, Measuretools);

    // extend options
    var _this = _possibleConstructorReturn(this, (Measuretools.__proto__ || Object.getPrototypeOf(Measuretools)).call(this, opt_options));

    _this.langConstants = (0, _c4gMapsI18n.getLanguage)(opt_options.mapController.data);
    _this.options = jQuery.extend({
      name: 'measure',
      headline: _this.langConstants.MEASURETOOLS,
      create: true,
      mapController: undefined,
      direction: 'left',
      firstElement: true
    }, opt_options);

    _this.mainSection = document.createElement('div');
    // call parent constructor
    _c4gMapsControlSideboard.Sideboard.call(_this, _this.options);
    return _this;
  }

  /**
   * Methods
   */

  /**
   * Executed when the panel will be opened for the first time.
   * [init description]
   *
   * @return  {boolean}  Returns |true| on success
   */


  _createClass(Measuretools, [{
    key: "init",
    value: function init() {

      this.spinner.show();

      // Add measure layers
      this.measureLineLayer = new ol.layer.Vector({ source: new ol.source.Vector() });
      this.measurePolygonLayer = new ol.layer.Vector({ source: new ol.source.Vector() });
      this.measureCircleLayer = new ol.layer.Vector({ source: new ol.source.Vector() });
      this.measureFreehandLayer = new ol.layer.Vector({ source: new ol.source.Vector() });

      this.measureLayerGroup = new ol.layer.Group({
        layers: new ol.Collection([this.measureFreehandLayer, this.measureCircleLayer, this.measurePolygonLayer, this.measureLineLayer]),
        visible: true
      });
      this.options.mapController.map.addLayer(this.measureLayerGroup);

      // Add and activate measure-Views
      this.viewMeasureSelect = this.addSelectView();
      this.viewMeasureSelect.activate();
      this.viewMeasureLine = this.addMeasureView({ type: 'LineString' });
      this.viewMeasureArea = this.addMeasureView({ type: 'Polygon' });
      this.viewMeasureRadius = this.addMeasureView({ type: 'Circle' });
      this.viewMeasureFreehand = this.addMeasureView({ type: 'Freehand' });

      // set content-section
      this.mainSectionInfo = document.createElement('p');
      this.mainSectionInfo.innerHTML = this.langConstants.MEASURETOOLS_INFO;
      this.mainSectionInfo.innerHTML += '<br><br><sub>' + this.langConstants.MEASURETOOLS_INFO_ADDITIONAL + '<sub>';
      this.mainSection.appendChild(this.mainSectionInfo);
      this.contentContainer.appendChild(this.mainSection);

      this.spinner.hide();
      return true;
    } // end of "init()"

    /**
     * Executed before panel will be closed
     *
     * @return  {[type]}  [description]
     */

  }, {
    key: "preCloseFunction",
    value: function preCloseFunction() {
      var lineFeatures, polygonFeatures, circleFeatures, freehandFeatures, i;

      if (this.measureLayerGroup.getVisible()) {
        this.measureLayerGroup.setVisible(false);

        // hide line-feature tooltips
        lineFeatures = this.measureLineLayer.getSource().getFeatures();
        for (i = 0; i < lineFeatures.length; i += 1) {
          lineFeatures[i].get('tooltip').hide();
        }
        // hide polygon-feature tooltips
        polygonFeatures = this.measurePolygonLayer.getSource().getFeatures();
        for (i = 0; i < polygonFeatures.length; i += 1) {
          polygonFeatures[i].get('tooltip').hide();
        }
        // hide circle-feature tooltips
        circleFeatures = this.measureCircleLayer.getSource().getFeatures();
        for (i = 0; i < circleFeatures.length; i += 1) {
          circleFeatures[i].get('tooltip').hide();
        }
        // hide freehand-feature tooltips
        freehandFeatures = this.measureFreehandLayer.getSource().getFeatures();
        for (i = 0; i < freehandFeatures.length; i += 1) {
          freehandFeatures[i].get('tooltip').hide();
        }
      }
    } // end of "preCloseFunction()"

    /**
     * Executed before panel will be opened
     *
     * @return  {[type]}  [description]
     */

  }, {
    key: "preOpenFunction",
    value: function preOpenFunction() {
      var lineFeatures, polygonFeatures, circleFeatures, freehandFeatures, i;

      if (!this.measureLayerGroup.getVisible()) {
        this.measureLayerGroup.setVisible(true);

        // show line-feature tooltips
        lineFeatures = this.measureLineLayer.getSource().getFeatures();
        for (i = 0; i < lineFeatures.length; i += 1) {
          lineFeatures[i].get('tooltip').show();
        }
        // show polygon-feature tooltips
        polygonFeatures = this.measurePolygonLayer.getSource().getFeatures();
        for (i = 0; i < polygonFeatures.length; i += 1) {
          polygonFeatures[i].get('tooltip').show();
        }
        // show circle-feature tooltips
        circleFeatures = this.measureCircleLayer.getSource().getFeatures();
        for (i = 0; i < circleFeatures.length; i += 1) {
          circleFeatures[i].get('tooltip').show();
        }
        // show freehand-feature tooltips
        freehandFeatures = this.measureFreehandLayer.getSource().getFeatures();
        for (i = 0; i < freehandFeatures.length; i += 1) {
          freehandFeatures[i].get('tooltip').show();
        }
      }
    } // end of "preOpenFunction()"

    /**
     * @TODO: [addSelectView description]
     */

  }, {
    key: "addSelectView",
    value: function addSelectView() {
      var selectView;

      selectView = this.addView({
        name: 'select',
        triggerConfig: {
          tipLabel: this.langConstants.MEASURETOOLS_VIEW_TRIGGER_SELECT,
          className: _c4gMapsConstant.cssConstants.MEASURETOOLS_VIEW_TRIGGER_SELECT,
          withHeadline: true
        },
        sectionElements: [{ section: this.contentContainer, element: this.mainSection }, { section: this.topToolbar, element: this.viewTriggerBar }]
      });

      return selectView;
    } // end of "addSelectView()"

    /**
     * @TODO: [addMeasureView description]
     *
     * @param  {[type]}  options  [description]
     */

  }, {
    key: "addMeasureView",
    value: function addMeasureView(options) {
      var self, TRIGGER_DRAW, measureView, source, interaction, features, olType;

      self = this;

      options = jQuery.extend({
        type: 'LineString'
      }, options);

      TRIGGER_DRAW = 'MEASURETOOLS_VIEW_TRIGGER_DRAW_' + options.type.toUpperCase();

      measureView = self.addView({
        name: 'draw:' + options.type.toLowerCase(),
        triggerConfig: {
          tipLabel: this.langConstants[TRIGGER_DRAW],
          className: _c4gMapsConstant.cssConstants[TRIGGER_DRAW],
          withHeadline: true
        },
        sectionElements: [{ section: self.topToolbar, element: self.viewTriggerBar }],
        initFunction: function initFunction() {
          var featureIdCount, activeSketch, activeTooltip, addMeasureFeature, updateMeasureFeature, getValueOfGeometry, getLengthOfMeasure, removeMeasureFeature;

          // Show loading animation
          self.spinner.show();

          featureIdCount = 1;

          if (options.type.toLowerCase() === 'freehand') {
            source = self.measureFreehandLayer.getSource();
          } else if (options.type.toLowerCase() === 'circle') {
            source = self.measureCircleLayer.getSource();
          } else if (options.type.toLowerCase() === 'polygon') {
            source = self.measurePolygonLayer.getSource();
          } else {
            source = self.measureLineLayer.getSource();
          }

          features = new ol.Collection();

          olType = options.type;
          if (olType == 'Freehand') {
            olType = 'LineString';
          }
          interaction = new ol.interaction.Draw({
            features: features,
            source: source,
            type: olType,
            freehand: options.type == 'Freehand'
            // @TODO: use custom style? (BE-option)
            // style: use default style
          });

          addMeasureFeature = function addMeasureFeature(feature) {
            var listElement, headlineElement, labelElement, inputElement, paragraphElement, strongElement, spanElement, strLabel, strType, measureArea, measureRadius;

            if (!feature instanceof ol.Feature) {
              return false;
            }

            // check if the infomessage needs to be removed
            if (self.mainSection.childElementCount === 1 && self.mainSection.children[0] === self.mainSectionInfo) {
              self.mainSection.removeChild(self.mainSectionInfo);
            }

            // check feature-type
            if (feature.getGeometry() instanceof ol.geom.LineString) {
              strLabel = self.langConstants.LENGTH;
              strType = self.langConstants.LINE;
              measureArea = false;
              measureRadius = false;
            } else if (feature.getGeometry() instanceof ol.geom.Polygon) {
              strLabel = self.langConstants.PERIMETER;
              strType = self.langConstants.POLYGON;
              measureArea = true;
              measureRadius = false;
            } else if (feature.getGeometry() instanceof ol.geom.Circle) {
              strLabel = self.langConstants.RADIUS;
              strType = self.langConstants.CIRCLE;
              measureArea = true;
              measureRadius = true;
            } else {
              //freehand ist LineString too
              strLabel = self.langConstants.LENGTH;
              strType = self.langConstants.FREEHAND;
              measureArea = false;
              measureRadius = false;
            }

            // create list element
            listElement = document.createElement('div');

            // create and append headline
            headlineElement = document.createElement('div');
            headlineElement.className = 'c4g_maps_portside_measure_element';
            if (self.options.firstElement) {
              headlineElement.className = 'c4g_maps_portside_measure_element c4g_maps_portside_measure_element_first';
              self.options.firstElement = false;
            }
            listElement.appendChild(headlineElement);

            // create and append label for name-inputfield
            labelElement = document.createElement('label');
            labelElement.setAttribute('for', 'measureElement_' + featureIdCount);
            labelElement.innerHTML = self.langConstants.NAME + ': ';
            headlineElement.appendChild(labelElement);

            // create and append name-inputfield
            inputElement = document.createElement('input');
            inputElement.type = 'text';
            inputElement.name = 'measureElement_' + featureIdCount;
            inputElement.value = strType + ' ' + featureIdCount;
            // attach-change-handler
            jQuery(inputElement).change(function (event) {
              updateMeasureFeature(feature);
            });
            headlineElement.appendChild(inputElement);
            feature.set('listElementValueName', inputElement);

            // create and append paragraphs
            paragraphElement = document.createElement('p');
            paragraphElement.className = 'c4g_maps_portside_measure_paragraph';
            strongElement = document.createElement('strong');
            strongElement.innerHTML = strLabel + ': ';
            paragraphElement.appendChild(strongElement);
            spanElement = document.createElement('span');
            spanElement.innerHTML = '...';
            paragraphElement.appendChild(spanElement);
            listElement.appendChild(paragraphElement);
            feature.set('listElementValueLine', spanElement);

            if (measureArea) {
              paragraphElement = document.createElement('p');
              paragraphElement.className = 'c4g_maps_portside_measure_paragraph_surfacearea';
              strongElement = document.createElement('strong');
              strongElement.innerHTML = self.langConstants.SURFACEAREA + ': ';
              paragraphElement.appendChild(strongElement);
              spanElement = document.createElement('span');
              spanElement.innerHTML = '...';
              paragraphElement.appendChild(spanElement);
              listElement.appendChild(paragraphElement);
              feature.set('listElementValueArea', spanElement);
            }

            if (measureRadius) {
              // paragraphElement = document.createElement('p');
              // paragraphElement.className = 'c4g_maps_portside_measure_paragraph_surfacearea';
              // strongElement = document.createElement('strong');
              // strongElement.innerHTML = langConstants.SURFACEAREA + ': ';
              // paragraphElement.appendChild(strongElement);
              // spanElement = document.createElement('span');
              // spanElement.innerHTML = '...';
              // paragraphElement.appendChild(spanElement);
              // listElement.appendChild(paragraphElement);
              feature.set('listElementValueRadius', spanElement);
            }

            // increase the id-counter
            featureIdCount += 1;

            // append element to the list
            self.mainSection.appendChild(listElement);
            // attach element to the feature
            feature.set('listElement', listElement);

            self.update();
          }; // end of "addMeasureFeature()"

          updateMeasureFeature = function updateMeasureFeature(feature) {
            var featureTooltip, newContent, name, length, area, radius;

            featureTooltip = feature.get('tooltip');
            name = feature.get('listElementValueName').value;
            length = _c4gMapsUtils.utils.measureGeometry(feature.getGeometry(), true);
            newContent = '<strong>' + name + '</strong><br>';

            feature.set('measuredLength', length);
            feature.get('listElementValueLine').innerHTML = length.htmlValue;
            if (feature.get('geometryType') === 'circle') {
              radius = _c4gMapsUtils.utils.measureGeometry(feature.getGeometry());
              feature.set('measuredRadius', radius);
              feature.get('listElementValueRadius').innerHTML = radius.htmlValue;
              newContent += radius.htmlValue;

              area = _c4gMapsUtils.utils.measureGeometry(feature.getGeometry(), false, true);
              feature.set('measuredArea', area);
              feature.get('listElementValueArea').innerHTML = area.htmlValue;
              // newContent += area.htmlValue;
            } else if (feature.get('geometryType') === 'polygon') {
              area = _c4gMapsUtils.utils.measureGeometry(feature.getGeometry());
              feature.set('measuredArea', area);
              feature.get('listElementValueArea').innerHTML = area.htmlValue;
              newContent += area.htmlValue;
            } else {
              newContent += length.htmlValue;
            }
            featureTooltip.setContent(newContent);
          }; // end of "updateMeasureFeature()"

          removeMeasureFeature = function removeMeasureFeature(feature) {
            self.mainSection.removeChild(feature.get('listElement'));

            // last element? -> add infomessage
            if (self.mainSection.childElementCount < 1) {
              self.mainSection.appendChild(self.mainSectionInfo);
              self.update();
            }
          }; // end of "removeMeasureFeature()"

          //Start Workaround
          getValueOfGeometry = function getValueOfGeometry(feature) {
            var leng = _c4gMapsUtils.utils.measureGeometry(feature.getGeometry(), true);
            // feature.set('measuredLength', length);
            var val = leng.htmlValue;
            var valuenumb = val.match(/\d/g);
            valuenumb = valuenumb.join("");
            return valuenumb;
          };

          getLengthOfMeasure = function getLengthOfMeasure() {
            var length = '0.00 m';
            var lengthnumb = length.match(/\d/g);
            lengthnumb = lengthnumb.join("");
            lengthnumb = +8;
            return lengthnumb;
          }; // End Workaround

          interaction.on('drawstart', function (event) {
            activeSketch = event.feature;
            // create tooltip
            activeTooltip = new _c4gMapsMiscTooltippopup.TooltipPopUp({
              map: self.options.mapController.map,
              position: event.coordinate,
              horizontal: true,
              closeable: true,
              closeFunction: function closeFunction() {
                //Workaround, for small or zero values of Freehand
                var val = getValueOfGeometry(event.feature);
                var leng = getLengthOfMeasure();
                if (val != leng && val > leng) {
                  removeMeasureFeature(event.feature);
                  source.removeFeature(event.feature);
                } else {
                  removeMeasureFeature(event.feature);
                }
              }
            });

            activeSketch.set('tooltip', activeTooltip);
            activeSketch.set('geometryType', options.type.toLowerCase());
            addMeasureFeature(activeSketch);
          }, self);

          self.options.mapController.map.on('pointermove', function (event) {
            if (activeSketch && activeTooltip) {
              activeTooltip.setPosition(event.coordinate);
              updateMeasureFeature(activeSketch);
            }
          }, self);

          interaction.on('drawend', function (event) {
            if (activeSketch && activeTooltip) {
              updateMeasureFeature(activeSketch);
              activeSketch = null;
              activeTooltip = null;
            }
          }, self);

          self.spinner.hide();
          return true;
        },
        activateFunction: function activateFunction() {

          // disable mapHover
          self.options.mapController.mapHover.deactivate();

          features.clear();

          // Enable interaction
          self.options.mapController.map.addInteraction(interaction);
        },
        deactivateFunction: function deactivateFunction() {

          // reactivate mapHover
          self.options.mapController.mapHover.activate();

          if (options.type.toLowerCase() !== 'point') {
            try {
              interaction.finishDrawing();
            } catch (ignore) {
              // 0_o
            }
          }

          // Remove from map
          self.options.mapController.map.removeInteraction(interaction);
        }
      });

      return measureView;
    } // end of "addMeasureView()"

  }]);

  return Measuretools;
}(_c4gMapsControlSideboard.Sideboard);

/***/ }),

/***/ "./Resources/public/js/c4g-maps-control-position.js":
/*!**********************************************************!*\
  !*** ./Resources/public/js/c4g-maps-control-position.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Position = undefined;

var _c4gMapsConstant = __webpack_require__(/*! ./c4g-maps-constant */ "./Resources/public/js/c4g-maps-constant.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This file is part of con4gis,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * the gis-kit for Contao CMS.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @package    con4gis
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @version    6
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author     con4gis contributors (see "authors.txt")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @license    LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @copyright  Küstenschmiede GmbH Software & Design
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @link       https://www.con4gis.org
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

'use strict';

var Position = exports.Position = function (_ol$control$Control) {
  _inherits(Position, _ol$control$Control);

  /**
   * Control to toggle the browser/device position on the map.
   *
   * @constructor
   * @extends  {ol.control.Control}
   *
   * @param    {Object}              opt_options  *optional* control options.
   */
  function Position(opt_options) {
    _classCallCheck(this, Position);

    var _this = _possibleConstructorReturn(this, (Position.__proto__ || Object.getPrototypeOf(Position)).call(this, opt_options));

    var self = _this;
    var options = opt_options || {};

    var element, button;

    // default options
    options = jQuery.extend({
      className: _c4gMapsConstant.cssConstants.OL_ZOOM_POS,
      switchable: true,
      enabled: true,
      mapController: undefined
    }, options);

    if (!options.mapController) {
      var _ret;

      return _ret = false, _possibleConstructorReturn(_this, _ret);
    }

    var view = options.mapController.map.getView();
    var mapData = options.mapController.data;

    var enable = function enable() {
      jQuery(element).addClass(_c4gMapsConstant.cssConstants.ENABLED);
    };

    var disable = function disable() {
      jQuery(element).removeClass(_c4gMapsConstant.cssConstants.ENABLED);
    };

    var toggle = function toggle(event) {
      event.stopPropagation();
      // loose focus, otherwise it looks messy
      this.blur();

      var geoLocation = new ol.Geolocation({
        tracking: true,
        projection: view.getProjection()
      });

      geoLocation.on('change', function (evt) {
        view.setCenter(geoLocation.getPosition());
        // if (mapData.geolocation_zoom) {
        //    view.setZoom(mapData.geolocation_zoom);
        // } else {
        view.setZoom(18);
        //}
        geoLocation.setTracking(false);
        options.mapController.map.setView(view);
      });
    };

    // wrapper div
    element = document.createElement('div');
    element.className = options.className + ' ' + _c4gMapsConstant.cssConstants.OL_UNSELECTABLE + ' button';

    if (options.switchable) {
      // button
      button = document.createElement('button');
      button.title = options.tipLabel;
      element.appendChild(button);

      // set onClick to the toggle-function
      button.addEventListener('click', toggle, false);
      button.addEventListener('touchstart', toggle, false);
    }

    // inheritance-stuff
    ol.control.Control.call(_this, {
      element: element,
      target: options.target
    });
    ol.inherits(Position, ol.control.Control);
    return _this;
  }

  return Position;
}(ol.control.Control);

/***/ }),

/***/ "./Resources/public/js/c4g-maps-control-print.js":
/*!*******************************************************!*\
  !*** ./Resources/public/js/c4g-maps-control-print.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Print = undefined;

var _c4gMapsConstant = __webpack_require__(/*! ./c4g-maps-constant */ "./Resources/public/js/c4g-maps-constant.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This file is part of con4gis,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * the gis-kit for Contao CMS.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @package    con4gis
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @version    6
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author     con4gis contributors (see "authors.txt")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @license    LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @copyright  Küstenschmiede GmbH Software & Design
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @link       https://www.con4gis.org
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

'use strict';

var Print = exports.Print = function (_ol$control$Control) {
  _inherits(Print, _ol$control$Control);

  /**
   * Control to toggle the browser/desvice position on the map.
   *
   * @constructor
   * @extends  {ol.control.Control}
   *
   * @param    {Object}              opt_options  *optional* control options.
   */
  function Print(opt_options) {
    _classCallCheck(this, Print);

    var _this = _possibleConstructorReturn(this, (Print.__proto__ || Object.getPrototypeOf(Print)).call(this, opt_options));

    var self = _this;
    var options = opt_options || {};

    var element, button;

    // default options
    options = jQuery.extend({
      className: _c4gMapsConstant.cssConstants.PRINT,
      switchable: true,
      enabled: true,
      mapController: undefined
    }, options);

    if (!options.mapController) {
      var _ret;

      return _ret = false, _possibleConstructorReturn(_this, _ret);
    }

    var view = options.mapController.map.getView();
    var mapData = options.mapController.data;

    var toggle = function toggle(event) {
      event.stopPropagation();
      var canvas = document.getElementsByClassName("ol-unselectable")[0];

      canvas.toBlob(function (blob) {
        var a = document.createElement("a");
        document.body.appendChild(a);
        a.style = "display: none";
        var url = window.URL.createObjectURL(blob);
        a.href = url;
        a.download = 'map.png';
        a.click();
        window.URL.revokeObjectURL(url);
      });
    };

    // wrapper div
    element = document.createElement('div');
    element.className = options.className + ' ' + _c4gMapsConstant.cssConstants.OL_UNSELECTABLE + ' c4g-portside-control ol-control';

    if (options.switchable) {
      // button
      button = document.createElement('button');
      button.title = options.tipLabel;
      button.className = _c4gMapsConstant.cssConstants.PRINT;
      element.appendChild(button);

      // set onClick to the toggle-function
      button.addEventListener('click', toggle, false);
      button.addEventListener('touchstart', toggle, false);
    }

    // inheritance-stuff
    ol.control.Control.call(_this, {
      element: element,
      target: options.target
    });
    return _this;
  }

  return Print;
}(ol.control.Control);

/***/ }),

/***/ "./Resources/public/js/c4g-maps-control-sideboard.js":
/*!***********************************************************!*\
  !*** ./Resources/public/js/c4g-maps-control-sideboard.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Sideboard = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _c4gMapsUtils = __webpack_require__(/*! ./c4g-maps-utils */ "./Resources/public/js/c4g-maps-utils.js");

var _c4gMapsConstant = __webpack_require__(/*! ./c4g-maps-constant */ "./Resources/public/js/c4g-maps-constant.js");

var _c4gMapsMiscSpinner = __webpack_require__(/*! ./c4g-maps-misc-spinner */ "./Resources/public/js/c4g-maps-misc-spinner.js");

var _c4gMapsI18n = __webpack_require__(/*! ./c4g-maps-i18n */ "./Resources/public/js/c4g-maps-i18n.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This file is part of con4gis,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * the gis-kit for Contao CMS.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @package    con4gis
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @version    6
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author     con4gis contributors (see "authors.txt")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @license    LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @copyright  Küstenschmiede GmbH Software & Design
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @link       https://www.con4gis.org
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

"use strict";
/**
 * Base class for sideboard structures. Provides standard configurations which are equal for each sideboard element.
 */

var Sideboard = exports.Sideboard = function (_ol$control$Control) {
  _inherits(Sideboard, _ol$control$Control);

  /**
   * Constructor
   *
   * @extends {ol.control.Control}
   * @param   {object}              options  misc configuration options
   *
   */
  function Sideboard(options) {
    _classCallCheck(this, Sideboard);

    var _this = _possibleConstructorReturn(this, (Sideboard.__proto__ || Object.getPrototypeOf(Sideboard)).call(this, options));

    _this.options = jQuery.extend({
      create: true,
      extDiv: false,
      defaultOpen: false,
      mapController: undefined,
      name: 'sideboard',
      direction: 'right'
    }, options);
    _this.langConstants = (0, _c4gMapsI18n.getLanguage)(_this.options.mapController.data);

    //active Identifier (which side is this element on?)
    //cssname needed to set the css class correctly
    switch (_this.options.direction) {
      case 'left':
        _this.identifier = 'Portside';
        _this.cssname = 'portside';
        break;
      case 'right':
        _this.identifier = 'Starboard';
        _this.cssname = 'starboard';
        break;
    }
    //this.cssname = this.identifier.charAt(0).toLowerCase() + this.identifier.slice(1);
    _this.initialized = false;
    _this.options.tipLabel = _this.options.tipLabel || _this.options.headline || _this.langConstants.CTRL_SIDEBOARD;
    _this.container = document.createElement('div');
    _this.element = document.createElement('div');
    _this.button = undefined;
    _this.spinner = undefined;
    // mainstructure elements
    _this.wrapper = undefined;
    _this.titleBar = undefined;
    _this.headline = undefined;
    _this.topToolbar = undefined;
    _this.contentContainer = undefined;
    _this.bottomToolbar = undefined;
    _this.statusBar = undefined;

    _this.sections = [];
    _this.viewTriggerBar = undefined;
    _this.views = [];
    _this.activeView = undefined;
    _this.pausedView = undefined;

    if (_this.options.create && _this.options.mapController) {
      _this.create();
    }

    // inheritance-stuff
    // ol.control.Control.call(this, {
    //   element: element,
    //   target: options.target
    // });
    return _this;
  }

  _createClass(Sideboard, [{
    key: "create",


    /**
     * Creates the basic html-elements for the sideboard
     *
     * @return  {boolean}  'true' on success
     */
    value: function create() {
      var self, initClass, titleButtonBar, closeButton, capitalizedName, hideButton, caching;

      caching = this.options.caching;
      capitalizedName = _c4gMapsUtils.utils.capitalizeFirstLetter(this.options.name);
      self = this;

      // Do not hide when it is initialized open, or in an external div
      if (this.options.extDiv) {
        initClass = ' ' + _c4gMapsConstant.cssConstants.OPEN;
        // if (caching) {
        //     utils.storeValue(this.options.name, '1');
        // }
      } else {
        initClass = ' ' + _c4gMapsConstant.cssConstants.CLOSE;
        // if (caching) {
        //     utils.storeValue(this.options.name, '0');
        // }
        this.options.mapController["active" + this.identifier] = this.options.mapController["active" + this.identifier] || false;

        this.button = document.createElement('button');
        jQuery(this.button).on('click', function (event) {
          event.stopPropagation();
          // loose focus, otherwise it looks messy
          try {
            this.blur();
          } catch (e) {
            // [note] "this.blur()" does not work in IE-fullscreen-mode
            console.warn(e.name + ': ' + e.message);
          }
          if (capitalizedName === "Router" || capitalizedName === "Measure" || capitalizedName === "Editor") {
            self.toggle(true);
          } else {
            self.toggle();
          }
        });
        this.button.title = this.options.tipLabel;
        this.element.appendChild(this.button);
      }

      // Set attributes
      jQuery(this.container).addClass('c4g-' + this.options.name + ' ' + 'c4g-' + this.cssname + '-container' + ' ' + _c4gMapsConstant.cssConstants.OL_UNSELECTABLE + initClass);
      jQuery(this.element).addClass('c4g-' + this.options.name + ' ' + 'c4g-' + this.cssname + '-control' + ' ' + _c4gMapsConstant.cssConstants.OL_UNSELECTABLE + ' ' + _c4gMapsConstant.cssConstants.OL_CONTROL + initClass);

      // Set initial dimensions
      if (this.options.direction === 'right') {
        //this.container.style.minWidth = '250px';
        //this.container.style[this.options.direction] = '-1920px';
        this.container.style[this.options.direction] = '-100%';
      } else {
        //this.container.style.minWidth = '250px';
        //this.container.style[this.options.direction] = '-1920px';
        this.container.style[this.options.direction] = '-100%';
      }

      // Place container
      if (this.options.extDiv) {
        document.getElementById(this.options.extDiv).appendChild(this.container);
        //     this.options.mapController["active" + this.identifier] = this;
      } else {
        if (this.options.direction === 'left') {
          jQuery('#' + this.options.mapController.map.getTarget() + ' > div > div.' + _c4gMapsConstant.cssConstants.OL_OVERLAYCONTAINER_SE).append(this.container);
        } else {
          this.options.mapController.$overlaycontainer_stopevent.append(this.container);
        }
      }

      // Build content-area
      //
      // Wrapper
      this.wrapper = document.createElement('div');
      this.wrapper.className = 'c4g-' + this.cssname + '-wrapper';
      this.container.appendChild(this.wrapper);
      // Titlebar
      this.titleBar = document.createElement('div');
      this.titleBar.className = 'c4g-' + this.cssname + '-titlebar';
      this.wrapper.appendChild(this.titleBar);

      // Triggerbar
      this.viewTriggerBar = document.createElement('div');
      this.viewTriggerBar.className = 'c4g-' + this.cssname + '-viewtriggerbar';

      // Top-Toolbar
      this.topToolbar = this.addSection({
        className: 'c4g-' + this.cssname + '-top-toolbar',
        target: this.wrapper
      });

      // Content-Container
      this.contentContainer = this.addSection({
        className: 'c4g-' + this.cssname + '-content-container',
        target: this.wrapper
      });

      // add content headline
      this.contentHeadline = document.createElement('div');
      this.contentHeadline.className = 'contentHeadline';
      this.contentHeadline.innerHTML = '';
      this.contentContainer.appendChild(this.contentHeadline);

      // Bottom-Toolbar
      this.bottomToolbar = this.addSection({
        className: 'c4g-' + this.cssname + '-bottom-toolbar c4g-close',
        target: this.wrapper
      });

      // Statusbar
      this.statusBar = document.createElement('div');
      this.statusBar.className = 'c4g-' + this.cssname + '-statusbar c4g-close';
      this.wrapper.appendChild(this.statusBar);

      // Add spinner
      this.spinner = new _c4gMapsMiscSpinner.Spinner({
        target: this.contentContainer,
        className: _c4gMapsConstant.cssConstants.LARGE
      });

      // Fill titlebar
      //
      // Headline
      this.headline = document.createElement('span');
      this.headline.className = 'c4g-' + this.cssname + '-headline';
      this.headline.innerHTML = this.options.headline;
      this.titleBar.appendChild(this.headline);
      // Buttonbar
      titleButtonBar = document.createElement('div');
      titleButtonBar.className = _c4gMapsConstant.cssConstants.CONTROL + ' ' + 'c4g-' + this.cssname + '-buttonbar';
      this.titleBar.appendChild(titleButtonBar);

      if (this.options.direction === 'left') {
        // Hidebutton
        hideButton = document.createElement('button');
        hideButton.className = _c4gMapsConstant.cssConstants.PORTSIDE_HIDE;
        hideButton.title = this.langConstants.HIDE;
        jQuery(hideButton).click(function (event) {
          event.preventDefault();
          self.close(true);
          return false;
        });
        titleButtonBar.appendChild(hideButton);
      }

      // Closebutton
      closeButton = document.createElement('button');
      closeButton.className = 'c4g-' + this.cssname + '-close';
      closeButton.title = this.langConstants.CLOSE;
      jQuery(closeButton).click(function (event) {
        event.preventDefault();
        self.close();
        return false;
      });
      titleButtonBar.appendChild(closeButton);

      //Add spinner for left sided sideboard elements
      this.spinner = new _c4gMapsMiscSpinner.Spinner({
        target: this.contentContainer,
        className: _c4gMapsConstant.cssConstants.LARGE
      });

      // Handle external DIV and default state
      // catch touch events and stop their propagation
      // otherwise touch-scrolling will be stopped by ol3
      jQuery(this.container).on('touchstart touchmove touchend', function (event) {
        event.stopPropagation();
      });

      // Bind the update method to the map-resize event
      this.options.mapController.map.on('change:size', this.update, this);

      // Show open if desired
      // if ((this.options.defaultOpen) || (this.options.caching && (utils.getValue(this.options.name) == '1'))) {
      //   this.open();
      // }

      return true;
    } // end of "create"

    /**
     *   Update the sideboards html-elements
     *   resizes the content-container
     *   and the top-toolbar
     *
     * @param  {event-object}  opt_event  *optional*  Just needed by the ol-bind-method,
     *                                                but not used in the function
     */

  }, {
    key: "update",
    value: function update(opt_event) {

      var self, contentContainerOuterHeight, containerOffsetWidth;

      self = this;

      /*
      if (this.options && this.options.name) {
          capitalizedName = utils.capitalizeFirstLetter(this.options.name);
      }*/

      contentContainerOuterHeight = jQuery(this.wrapper).height() - (jQuery(this.titleBar).outerHeight(true) + jQuery(this.statusBar).outerHeight(true));
      if (this.options && this.options.direction && this.options.direction !== "undefined" && this.options.direction === 'left') {
        if (this !== this.options.mapController["active" + this.identifier]) {
          containerOffsetWidth = 0;
        }
      }

      // Top-Toolbar
      if (this.topToolbar) {
        if (this.topToolbar.innerHTML) {
          // this.topToolbar.style.display = 'block';
          this.topToolbar.style.display = '';
          contentContainerOuterHeight -= jQuery(this.topToolbar).outerHeight(true);
        } else {
          this.topToolbar.style.display = 'none';
        }
      }

      // Bottom-toolbar
      if (this.bottomToolbar) {
        if (this.bottomToolbar.innerHTML) {
          // this.bottomToolbar.style.display = 'block';
          this.bottomToolbar.style.display = '';
          contentContainerOuterHeight -= jQuery(this.bottomToolbar).outerHeight(true);
        } else {
          this.bottomToolbar.style.display = 'none';
        }
      }

      // Content-container
      jQuery(this.contentContainer).outerHeight(contentContainerOuterHeight);

      // Correct width
      if (this.options) {
        if (this.options.mapController["active" + this.identifier] === this) {
          //this.container.style.width = 'auto';
          containerOffsetWidth = this.container.offsetWidth;
          this.options.mapController[this.options.direction + "SlideElements"].forEach(function (element) {
            jQuery(element).css(self.options.direction, containerOffsetWidth);
          });

          //only move the toggle button on starboard elements
          if (this.options.direction === 'right') {
            jQuery(this.element).css(this.options.direction, containerOffsetWidth);
          }
        }
      }
    } // end of "update"

    /**
     * Opens this sideboard element
     *
     * @param   {object}    *optional* options to be passed to the initialize-function if it exists
     * @return  {boolean}  'true' an success
     */

  }, {
    key: "open",
    value: function open(opt_options) {
      var containerOffsetWidth, self;

      self = this;

      // Call initialize-functions, if existent
      if (!this.initialized) {
        if (typeof this.init === 'function') {
          this.initialized = this.init(opt_options);
        } else {
          this.initialized = true;
        }
      }

      // call preOpenFunctions
      if (typeof this.preOpenFunction === 'function') {
        this.preOpenFunction();
      }

      containerOffsetWidth = this.container.offsetWidth;

      if (this.options.extDiv) {
        // Not available on external divs
        console.warn('You cannot use this function on external embedded sideboard.');
      } else {
        if (this.options.mapController["active" + this.identifier]) {
          if (this.options.mapController["active" + this.identifier] === this) {
            return false;
          }
          //close other active sideboard on this side
          this.options.mapController["active" + this.identifier].close(true, true);
        } else {
          // slide other elements when no other sideboard was active on this side
          this.options.mapController[this.options.direction + "SlideElements"].forEach(function (element) {
            jQuery(element).css(self.options.direction, containerOffsetWidth);
          });
        }

        jQuery(this.container).removeClass(_c4gMapsConstant.cssConstants.CLOSE).addClass(_c4gMapsConstant.cssConstants.OPEN).css(this.options.direction, 0);
        if (this.options.direction === 'left') {
          jQuery(this.element).removeClass(_c4gMapsConstant.cssConstants.CLOSE).addClass(_c4gMapsConstant.cssConstants.OPEN);
        } else {
          jQuery(this.element).removeClass(_c4gMapsConstant.cssConstants.CLOSE).addClass(_c4gMapsConstant.cssConstants.OPEN).css(this.options.direction, containerOffsetWidth);
        }

        // set this as active Sideboard
        this.options.mapController["active" + this.identifier] = this;

        // check if a view needs to be reactivated
        if (this.activeView) {
          this.activeView.activate();
        }

        if (jQuery(this.statusBar).hasClass(_c4gMapsConstant.cssConstants.CLOSE)) {
          jQuery(this.statusBar).removeClass(_c4gMapsConstant.cssConstants.CLOSE).addClass(_c4gMapsConstant.cssConstants.OPEN);
        }

        if (jQuery(this.bottomToolbar).hasClass(_c4gMapsConstant.cssConstants.CLOSE)) {
          jQuery(this.bottomToolbar).removeClass(_c4gMapsConstant.cssConstants.CLOSE).addClass(_c4gMapsConstant.cssConstants.OPEN);
        }

        // show container to fix resizing issue
        jQuery(this.container).css('visibility', 'visible');

        this.update();
        if (this.options.caching) {
          _c4gMapsUtils.utils.storeValue(this.options.name, '1');
        }

        // call postOpenFunctions
        if (typeof this.postOpenFunction === 'function') {
          this.postOpenFunction();
        }

        return true;
      }
      return false;
    } // end of "open"

  }, {
    key: "isOpen",
    value: function isOpen() {
      return this.options.mapController["active" + this.identifier] && this.options.mapController["active" + this.identifier] === this;
    }

    /**
     * Closes this sideboard element
     *
     * @param   {boolean}  opt_hide               *optional* Choose if this function should trigger |preHideFunction|
     *                                            instead of |preCloseFunction|. Default is |false|.
     * @param   {boolean}  opt_openOtherSideboard  *optional* Indicates if another sideboard element will be opened instead.
     *                                            Default is |false|.
     *
     * @return  {boolean}                         |true| on success.
     */

  }, {
    key: "close",
    value: function close(opt_hide, opt_openOtherSideboard) {
      var containerOffsetWidth, direction;

      direction = this.options.direction;

      if (opt_hide && !opt_openOtherSideboard) {
        if (typeof this.preHideFunction === 'function') {
          this.preHideFunction();
        }
      } else {
        if (typeof this.preCloseFunction === 'function') {
          this.preCloseFunction();
        }
      }

      containerOffsetWidth = this.container.offsetWidth;

      if (this.options.extDiv) {
        // Not available on external divs
        console.warn('You cannot use this function on external embedded sideboard.');
      } else {
        if (this.options.mapController["active" + this.identifier] !== this) {
          console.warn('This ' + this.options.name + '-element (' + this.options.name + ') is already closed.');
          return false;
        }
        jQuery(this.container).removeClass(_c4gMapsConstant.cssConstants.OPEN).addClass(_c4gMapsConstant.cssConstants.CLOSE).css(direction, -containerOffsetWidth);
        jQuery(this.element).removeClass(_c4gMapsConstant.cssConstants.OPEN).addClass(_c4gMapsConstant.cssConstants.CLOSE).css(direction, 0);

        if (!opt_openOtherSideboard) {
          // slide other elements
          this.options.mapController[direction + "SlideElements"].forEach(function (element) {
            jQuery(element).css(direction, 0);
          });
        }

        // hide container to fix resizing issue
        jQuery(this.container).css('visibility', 'hidden');

        // check if a view needs to be deactivated
        if (this.activeView) {
          this.activeView.deactivate(opt_hide && !opt_openOtherSideboard);
        }

        // Remove active Sideboardentry
        this.options.mapController["active" + this.identifier] = false;

        if (this.options.caching) {
          _c4gMapsUtils.utils.storeValue(this.options.name, '0');
        }
        return true;
      }
      return false;
    } // end of "close"

    /**
     * Toggle this sideboard element
     *
     * @return  {boolean}  Returns |true| on success.
     */

  }, {
    key: "toggle",
    value: function toggle(opt_hide) {
      if (this.options.mapController["active" + this.identifier] === this) {
        return this.close(opt_hide);
      }
      return this.open();
    } // end of "toggle"

    /**
     * Creates a button which characteristics are defined by the options parameter
     * These options include e.g. the target container where the button will be appended and the click action of the button
     *
     * @param   {object}  opt_options  The button configuration
     *
     * @return  {[type]}           [description]
     */

  }, {
    key: "makeButton",
    value: function makeButton(opt_options) {

      var options, button;

      options = jQuery.extend({
        label: undefined,
        tipLabel: undefined,
        className: '',
        target: undefined,
        clickAction: undefined
      }, opt_options);

      if (options.className) {
        options.className = ' ' + options.className;
      }

      button = document.createElement('button');
      button.className = 'c4g-' + this.options.name + '-button' + options.className;
      if (options.id) {
        button.id = options.id;
      }

      if (typeof options.tipLabel === 'string') {
        button.title = options.tipLabel;
      }

      if (typeof options.label === 'string') {
        button.innerHTML = options.label;
      } else if (_typeof(options.label) === 'object') {
        button.appendChild(options.label);
      }

      if (typeof options.clickAction === 'function') {
        jQuery(button).click(function () {
          try {
            this.blur();
          } catch (e) {
            console.warn(e.message);
          }
          options.clickAction();
        });
      }

      if (options.target) {
        jQuery(options.target).append(button);
      }

      return button;
    } // end of "makeButton"

    /**
     * @TODO
     * [addSection description]
     *
     * @param  {[type]}  opt_options  [description]
     */

  }, {
    key: "addSection",
    value: function addSection(opt_options) {

      var options, section, element;

      options = jQuery.extend({
        type: 'div',
        className: '',
        target: undefined
      }, opt_options);

      // try to create the new section
      try {
        section = document.createElement(options.type);
      } catch (e) {
        console.warn('Cannot create section. "' + options.type + ' is not a valid HTML-node.');
        return false;
      }

      section.className = options.className;

      // try to append the section to the given target
      if (options.target) {
        try {
          options.target.appendChild(section);
        } catch (e) {
          console.warn(e.message);
        }
      }

      section.getElement = function () {
        return element || false;
      };

      section.setElement = function (newElement) {
        if (newElement && (typeof newElement === "undefined" ? "undefined" : _typeof(newElement)) === 'object') {
          if (!(element && element === newElement)) {
            if (element) {
              this.removeChild(element);
            }
            this.appendChild(newElement);
            element = newElement;
          }
        }
      };

      // add to sections-array
      this.sections.push(section);
      return section;
    } // end of "addSection"

    /**
     * @TODO
     * [addView description]
     *
     * @param  {[type]}  options  [description]
     */

  }, {
    key: "addView",
    value: function addView(options, opt_viewScope) {

      var self, viewScope, additionalTriggerClass, trigger, view;

      self = this;
      viewScope = opt_viewScope || this;

      options = jQuery.extend({
        // name: undefined,
        triggerConfig: undefined, // @TODO doku format: {opt_target: [string|htmlObject], opt_className: [string], opt_tipLabel: [string]}
        sectionElements: [], // @TODO doku format: [{section: [sectionObject], element: [elementObject]}]
        initFunction: undefined,
        activateFunction: undefined,
        deactivateFunction: undefined
      }, options);

      if (typeof options.name !== 'string') {
        console.warn('Cannot add a view without a name (of type "string").');
        return false;
      }

      view = {};

      view.initialized = false;
      view.paused = false;

      view.activate = function (opt_openSideboard) {
        var i;

        if (options.triggerConfig.withHeadline) {
          self.contentHeadline.innerHTML = options.triggerConfig.tipLabel;
        }

        // open Sideboard if closed
        if (opt_openSideboard && !self.isOpen()) {
          self.open();
        }

        // Deactivate current activeView, if existent
        if (_typeof(viewScope.activeView) === 'object' && viewScope.activeView !== view) {
          viewScope.activeView.deactivate();
        }
        viewScope.activeView = view;

        // Handle sub-views
        if (view.activeView) {
          view.activeView.activate();
        }

        // Call initialize-functions, if existent
        if (!view.initialized) {
          if (typeof options.initFunction === 'function') {
            view.initialized = options.initFunction();
          } else {
            view.initialized = true;
          }
        }

        // Display elements in given sections
        if (options.sectionElements && options.sectionElements.length > 0) {
          for (i = 0; i < options.sectionElements.length; i += 1) {
            options.sectionElements[i].section.setElement(options.sectionElements[i].element);
          }
        }

        // Change trigger-state, if existent
        if (trigger) {
          jQuery(trigger).addClass('c4g-active');
        }

        // Call activate function, if existent
        if (typeof options.activateFunction === 'function') {
          if (!options.activateFunction(view.paused)) {
            return false;
          }
        }

        view.paused = false;
        self.update();
        return true;
      };

      view.deactivate = function (opt_pause) {

        view.paused = opt_pause || false;

        if (_typeof(viewScope.activeView) === 'object' && viewScope.activeView === view) {
          if (trigger && !view.paused) {
            jQuery(trigger).removeClass('c4g-active');
          }

          // Handle sub-views
          if (view.activeView) {
            view.activeView.deactivate(view.paused);
          }

          // Call deactivate function, if existent
          if (typeof options.deactivateFunction === 'function') {
            return options.deactivateFunction(view.paused);
          }
        }

        return true;
      };

      if (_typeof(options.triggerConfig) === 'object') {
        options.triggerConfig = jQuery.extend({
          target: this.viewTriggerBar,
          tipLabel: options.name
        }, options.triggerConfig);

        options.triggerConfig.clickAction = view.activate;
        if (options.triggerConfig.className) {
          additionalTriggerClass = ' ' + options.triggerConfig.className;
        } else {
          additionalTriggerClass = '';
        }
        options.triggerConfig.className = _c4gMapsConstant.cssConstants.ICON + additionalTriggerClass;
        trigger = this.makeButton(options.triggerConfig);
      }

      this.views.push(view);
      return view;
    } // end of "addView"

  }]);

  return Sideboard;
}(ol.control.Control); // end of "add methods"

/***/ }),

/***/ "./Resources/public/js/c4g-maps-control-starboard.js":
/*!***********************************************************!*\
  !*** ./Resources/public/js/c4g-maps-control-starboard.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Starboard = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _c4gMapsControlSideboard = __webpack_require__(/*! ./c4g-maps-control-sideboard */ "./Resources/public/js/c4g-maps-control-sideboard.js");

var _c4gMapsUtils = __webpack_require__(/*! ./c4g-maps-utils */ "./Resources/public/js/c4g-maps-utils.js");

var _c4gMapsControlStarboardpluginBaselayerswitcher = __webpack_require__(/*! ./c4g-maps-control-starboardplugin-baselayerswitcher */ "./Resources/public/js/c4g-maps-control-starboardplugin-baselayerswitcher.js");

var _c4gMapsControlStarboardpluginLayerswitcher = __webpack_require__(/*! ./c4g-maps-control-starboardplugin-layerswitcher */ "./Resources/public/js/c4g-maps-control-starboardplugin-layerswitcher.js");

var _c4gMapsControlStarboardpluginCustomtab = __webpack_require__(/*! ./c4g-maps-control-starboardplugin-customtab */ "./Resources/public/js/c4g-maps-control-starboardplugin-customtab.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This file is part of con4gis,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * the gis-kit for Contao CMS.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @package    con4gis
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @version    6
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author     con4gis contributors (see "authors.txt")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @license    LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @copyright  Küstenschmiede GmbH Software & Design
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @link       https://www.con4gis.org
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

'use strict';

var Starboard = exports.Starboard = function (_Sideboard) {
  _inherits(Starboard, _Sideboard);

  /**
   * Constructor
   *
   * @extends {c4g.maps.control.Sideboard}
   * @param   {object}              opt_options  *optional* misc configuration options
   */
  function Starboard(opt_options) {
    _classCallCheck(this, Starboard);

    var _this = _possibleConstructorReturn(this, (Starboard.__proto__ || Object.getPrototypeOf(Starboard)).call(this, opt_options));
    //call Sideboard (parent) constructor


    _this.options = jQuery.extend({
      create: true,
      extDiv: false,
      defaultOpen: false,
      mapController: undefined,
      name: 'starboard',
      direction: 'right',
      filter: false
    }, opt_options);

    //window.c4gMapsHooks.starboard_loadPlugins = [];

    //set headline, since the definition above does not work for headline
    if (!_this.options.headline || _this.options.headline.length === 0) {
      //this.options.headline = c4g.maps.constant.i18n.STARBOARD;
    }

    _this.hook_layerswitcher_loaded = _this.hook_layerswitcher_loaded || [];
    return _this;
  }

  _createClass(Starboard, [{
    key: "init",


    /**
     * Creates the basic html-elements for the starboard
     *
     * @return  {boolean}  'true' on success
     */
    value: function init() {

      var plugin,
          renderLayertree,
          key,
          layer,
          self,
          fnRender,
          displayLayerswitcher = false;

      if (this.initialized) {
        return true;
      }

      self = this;

      // Load Starboard plugins
      this.plugins = {};

      // creates and renders the starboard plugins
      fnRender = function fnRender() {
        // loop through layers and check if there is any normal layertree to render
        for (key in self.options.mapController.proxy.layerController.arrLayers) {
          if (self.options.mapController.proxy.layerController.arrLayers.hasOwnProperty(key)) {
            layer = self.options.mapController.proxy.layerController.arrLayers[key];
            if (!layer.renderSpecial) {
              renderLayertree = true;
              break;
            }
          }
        }

        if (renderLayertree) {
          // do not display layerswitcher if there is nothing to switch
          if (self.options.mapController.proxy.layerController.arrLayers) {
            for (var id in self.options.mapController.proxy.layerController.arrLayers) {
              if (self.options.mapController.proxy.layerController.arrLayers[id].display) {
                displayLayerswitcher = true;
              }
            }
          }
        }

        // - load "Layerswitcher"
        if (self.options.layerSwitcherCreate && renderLayertree && displayLayerswitcher) {
          self.plugins.layerswitcher = new _c4gMapsControlStarboardpluginLayerswitcher.Layerswitcher(self);
        }

        // call hook to load additional starboard tabs (layers)
        _c4gMapsUtils.utils.callHookFunctions(self.hook_layerswitcher_loaded);

        // - check & load other Starboard-plugins (via hook)
        // called functions have to add themselves to this.plugins
        if (window.c4gMapsHooks !== undefined && _typeof(window.c4gMapsHooks.starboard_loadPlugins) === 'object') {
          _c4gMapsUtils.utils.callHookFunctions(window.c4gMapsHooks.starboard_loadPlugins, self);
          // - activate new plugins if they are not activated already
          for (plugin in self.plugins) {
            // Check if plugin is a real plugin and not a property of the object prototype
            if (self.plugins.hasOwnProperty(plugin)) {
              self.plugins[plugin].activate();
            }
          }
        }

        // - load "Baselayerswitcher"
        if (self.options.baselayerSwitcherCreate) {
          self.plugins.baselayerswitcher = new _c4gMapsControlStarboardpluginBaselayerswitcher.Baselayerswitcher(self);
          self.plugins.baselayerswitcher.activate();
        }
        if (self.plugins.layerswitcher) {
          self.plugins.layerswitcher.activate();
        }
      }; // end of "fnRender()"


      if (!this.options.mapController.proxy.layers_loaded) {
        this.spinner.show();
        window.c4gMapsHooks.proxy_layer_loaded.push(function (layerIds) {
          self.spinner.hide();
          fnRender();
        });
      } else {
        // layers are already loaded
        fnRender();
      }

      this.initialized = true;

      return true;
    } // end of "init"

  }]);

  return Starboard;
}(_c4gMapsControlSideboard.Sideboard);

/***/ }),

/***/ "./Resources/public/js/c4g-maps-control-starboardplugin-baselayerswitcher.js":
/*!***********************************************************************************!*\
  !*** ./Resources/public/js/c4g-maps-control-starboardplugin-baselayerswitcher.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Baselayerswitcher = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * This file is part of con4gis,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * the gis-kit for Contao CMS.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @package    con4gis
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @version    6
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @author     con4gis contributors (see "authors.txt")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @license    LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @copyright  Küstenschmiede GmbH Software & Design
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @link       https://www.con4gis.org
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _c4gMapsConstant = __webpack_require__(/*! ./c4g-maps-constant */ "./Resources/public/js/c4g-maps-constant.js");

var _c4gMapsUtils = __webpack_require__(/*! ./c4g-maps-utils */ "./Resources/public/js/c4g-maps-utils.js");

var _c4gMapsI18n = __webpack_require__(/*! ./c4g-maps-i18n */ "./Resources/public/js/c4g-maps-i18n.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

'use strict';

var Baselayerswitcher = exports.Baselayerswitcher = function () {

  /**
   * Constructor
   *
   * @extends {ol.control.Control}
   * @param   {object}              starboard
   */
  function Baselayerswitcher(starboard) {
    _classCallCheck(this, Baselayerswitcher);

    if (!starboard) {
      console.warn('Cannot initialize Baselayerswitcher without a starboard.');
      return false;
    }

    this.initialized = false;
    this.baselayers = {};

    this.starboard = starboard;
    this.proxy = starboard.options.mapController.proxy;

    this.create();
    this.loadContent();
  }

  /**
   * @TODO: [create description]
   *
   * @return  {[type]}  [description]
   */


  _createClass(Baselayerswitcher, [{
    key: "create",
    value: function create() {
      var self, contentWrapper, contentHeadline, contentInfo;

      self = this;
      var langConstants = (0, _c4gMapsI18n.getLanguage)(this.starboard.options.mapController.data);

      contentWrapper = document.createElement('div');

      contentHeadline = document.createElement('div');
      contentHeadline.innerHTML = this.starboard.options.baselayerSwitcherTitle || langConstants.STARBOARD_VIEW_TRIGGER_BASELAYERSWITCHER;
      contentHeadline.className = 'contentHeadline';
      contentWrapper.appendChild(contentHeadline);

      this.contentDiv = document.createElement('div');
      this.contentDiv.className = _c4gMapsConstant.cssConstants.STARBOARD_CONTENT_BASELAYERSWITCHER;
      contentInfo = document.createElement('p');
      this.contentDiv.appendChild(contentInfo);
      contentWrapper.appendChild(this.contentDiv);

      self.view = self.starboard.addView({
        name: 'layerswitcher',
        triggerConfig: {
          tipLabel: this.starboard.options.baselayerSwitcherTitle || langConstants.STARBOARD_VIEW_TRIGGER_BASELAYERSWITCHER,
          className: _c4gMapsConstant.cssConstants.STARBOARD_VIEW_TRIGGER_BASELAYERSWITCHER,
          withHeadline: false
        },
        sectionElements: [{ section: self.starboard.contentContainer, element: contentWrapper }, { section: self.starboard.topToolbar, element: self.starboard.viewTriggerBar }]
      });
    }

    /**
     * @TODO: [activate description]
     *
     * @return  {[type]}  [description]
     */

  }, {
    key: "activate",
    value: function activate() {
      this.view.activate();
    }

    /**
     * @TODO: [setContent description]
     *
     * @param  {[type]}  newContent  [description]
     */

  }, {
    key: "setContent",
    value: function setContent(newContent) {
      if (newContent) {
        if (typeof newContent === "string") {
          this.contentDiv.innerHTML = newContent;
        } else {
          try {
            if (this.contentDiv.firstChild) {
              this.contentDiv.replaceChild(newContent, this.contentDiv.firstChild);
            } else {
              this.contentDiv.appendChild(newContent);
            }
          } catch (e) {
            // @TODO
            console.warn(e.message);
            // return false;
          }
        }
      }
      return this.contentDiv.innerHTML;
    }
  }, {
    key: "loadContent",
    value: function loadContent() {
      var self, fnDrawContent;

      self = this;
      this.starboard.spinner.show();

      fnDrawContent = function fnDrawContent(baselayerIds) {
        self.baseLayerControl = document.createElement('div');
        jQuery(self.baseLayerControl).addClass(_c4gMapsConstant.cssConstants.STARBOARD_BASELAYERTREE);
        self.setContent(self.baseLayerControl);

        self.addItems(baselayerIds, self.baseLayerControl);

        self.initialized = true;
        self.starboard.spinner.hide();
        self.starboard.update();
      }; // end of "fnDrawContent()"

      if (this.proxy.baselayers_loaded) {
        fnDrawContent(this.proxy.baselayerController.baselayerIds);
      } else {
        this.proxy.hook_baselayer_loaded.push(fnDrawContent);
      }
    } // end of "loadContent()"

    /**
     * @TODO: [drawContent description]
     *
     * @param   {[type]}  contentData  [description]
     */

  }, {
    key: "drawContent",
    value: function drawContent(contentData) {}
    // PASS
    // end of "drawContent()"

    /**
     * @TODO: [addItems description]
     *
     * @param  {[type]}  itemData        [description]
     * @param  {[type]}  wrapperElement  [description]
     * @param  {[type]}  options         [description]
     */

  }, {
    key: "addItems",
    value: function addItems(itemData, wrapperElement, options) {
      var i, j, self, wrapper, item, uid, listItem, childList, childItem, childEntry, toggle, entry, $entry, filter, handleEntryClick, handleChangeBaselayerVisibility;

      self = this;

      if ((typeof options === "undefined" ? "undefined" : _typeof(options)) !== "object") {
        options = {
          parseAsList: true
        };
      }

      handleEntryClick = function handleEntryClick(event) {
        event.preventDefault();

        var itemUid, siblings, baselayerItem;
        siblings = jQuery(this).parent().siblings();
        for (var i = 0; i < siblings.length; i++) {
          if (siblings[i] && jQuery(siblings[i]).hasClass(_c4gMapsConstant.cssConstants.OPEN)) {
            if (self.proxy.baselayerController.arrBaselayers[self.proxy.activeBaselayerId] && self.proxy.baselayerController.arrBaselayers[self.proxy.activeBaselayerId].hasOverlays) {
              for (var _j in self.proxy.baselayerController.arrBaselayers[self.proxy.activeBaselayerId].overlayController.arrOverlays) {
                if (self.proxy.baselayerController.arrBaselayers[self.proxy.activeBaselayerId].overlayController.arrOverlays.hasOwnProperty(_j)) self.proxy.options.mapController.map.removeLayer(self.proxy.baselayerController.arrBaselayers[self.proxy.activeBaselayerId].overlayController.arrOverlays[_j].layer);
              }
            }
            jQuery(siblings[i]).removeClass(_c4gMapsConstant.cssConstants.OPEN).addClass(_c4gMapsConstant.cssConstants.CLOSE);
          }
        }
        itemUid = jQuery(this).data('uid');

        if (self.starboard.options.caching) {
          _c4gMapsUtils.utils.storeValue('baselayer', itemUid);
        }

        if (jQuery(this).parent().hasClass(_c4gMapsConstant.cssConstants.CLOSE)) {
          jQuery(this).parent().removeClass(_c4gMapsConstant.cssConstants.CLOSE).addClass(_c4gMapsConstant.cssConstants.OPEN);
        } else {
          jQuery(this).parent().removeClass(_c4gMapsConstant.cssConstants.OPEN).addClass(_c4gMapsConstant.cssConstants.CLOSE);
        }

        if (self.proxy.options.mapController.rightSlideElements) {
          self.proxy.options.mapController.rightSlideElements.forEach(function (element) {
            jQuery(element).css('right', self.starboard.container.offsetWidth);
          });
        }
        jQuery(self.starboard.element).css('right', self.starboard.container.offsetWidth);

        if (self.proxy.activeBaselayerId !== itemUid) {
          self.proxy.baselayerController.showBaseLayer(itemUid);
          if (self.proxy.baselayerController.arrBaselayers[itemUid].hasOverlays) {
            for (var _j2 in self.proxy.baselayerController.arrBaselayers[itemUid].overlayController.arrOverlays) {
              if (self.proxy.baselayerController.arrBaselayers[itemUid].overlayController.arrOverlays.hasOwnProperty(_j2)) {
                var overlay = self.proxy.baselayerController.arrBaselayers[itemUid].overlayController.arrOverlays[_j2];
                try {
                  self.proxy.options.mapController.map.addLayer(overlay.layer);
                } catch (error) {
                  // layer is already on map
                  overlay.layer.setOpacity(overlay.opacity);
                }
              }
            }
          }
          jQuery(this).addClass(_c4gMapsConstant.cssConstants.ACTIVE).removeClass(_c4gMapsConstant.cssConstants.INACTIVE);
          window.c4gMapsHooks.baselayer_changed = window.c4gMapsHooks.baselayer_changed || [];
          _c4gMapsUtils.utils.callHookFunctions(window.c4gMapsHooks.baselayer_changed, itemUid);
        }
      }; // end of "handleEntryClick()"

      handleChangeBaselayerVisibility = function handleChangeBaselayerVisibility(baselayerConfig) {
        var id;

        for (id in self.baselayers) {
          if (self.baselayers.hasOwnProperty(id)) {
            if (id === baselayerConfig.id) {
              self.baselayers[id].$entry.addClass(_c4gMapsConstant.cssConstants.ACTIVE).removeClass(_c4gMapsConstant.cssConstants.INACTIVE);
            } else {
              self.baselayers[id].$entry.addClass(_c4gMapsConstant.cssConstants.INACTIVE).removeClass(_c4gMapsConstant.cssConstants.ACTIVE);
            }
          }
        }
      };

      wrapper = options.parseAsList ? document.createElement('ul') : document.createElement('div');

      if (itemData.length > 0) {

        for (i = 0; i < itemData.length; i += 1) {

          uid = itemData[i];
          this.baselayers[uid] = {};

          listItem = options.parseAsList ? document.createElement('li') : document.createElement('div');
          this.baselayers[uid].entryWrapper = listItem;
          entry = document.createElement('a');
          entry.setAttribute('href', '#');
          entry.appendChild(document.createTextNode(self.proxy.baselayerController.arrBaselayers[uid].name));
          jQuery(entry).data('id', uid);
          if (self.proxy.baselayerController.arrBaselayers[uid].hasOverlays) {

            childList = document.createElement('ul');
            options.parseAsList ? document.createElement('ul') : document.createElement('div');
            for (j = 0; j < self.proxy.baselayerController.arrBaselayers[uid].overlays.length; j++) {
              childItem = options.parseAsList ? document.createElement('li') : document.createElement('div');
              childEntry = document.createElement('a');
              if (self.proxy.activeBaselayerId === uid) {
                jQuery(childEntry).addClass(_c4gMapsConstant.cssConstants.ACTIVE);
                var overlayId = self.proxy.baselayerController.arrBaselayers[uid].overlays[j].id;
                self.proxy.baselayerController.arrBaselayers[uid].overlayController.arrOverlays[overlayId].changeOpacity(self.proxy.baselayerController.arrBaselayers[uid].overlays[j].opacity);
              } else {
                jQuery(childEntry).addClass(_c4gMapsConstant.cssConstants.INACTIVE);
              }

              childEntry.appendChild(document.createTextNode(self.proxy.baselayerController.arrBaselayers[uid].overlays[j].name));
              jQuery(childEntry).data('id', self.proxy.baselayerController.arrBaselayers[uid].overlays[j].id);
              jQuery(childEntry).data('pid', uid);
              toggle = document.createElement('input');
              toggle.className = 'c4g-overlay-toggle';
              toggle.setAttribute('type', 'range');
              toggle.setAttribute('min', 0);
              toggle.setAttribute('max', 100);
              toggle.setAttribute('value', self.proxy.baselayerController.arrBaselayers[uid].overlays[j].opacity);
              toggle.setAttribute('steps', 10);
              jQuery(toggle).on('input', function (event) {
                self.proxy.baselayerController.arrBaselayers[jQuery(this).parent().data('pid')].overlayController.arrOverlays[jQuery(this).parent().data('id')].changeOpacity(this.value);
              });

              childEntry.appendChild(toggle);
              childItem.appendChild(childEntry);
              childList.appendChild(childItem);
            }
          }
          listItem.appendChild(entry);
          if (childList) {
            listItem.appendChild(childList);
            childList = undefined;
          }

          $entry = jQuery(entry);
          this.baselayers[uid].$entry = $entry;

          if (this.starboard.options.mapController.data.default_baselayer && parseInt(uid, 10) === parseInt(self.starboard.options.mapController.data.default_baselayer, 10)) {
            $entry.addClass(_c4gMapsConstant.cssConstants.ACTIVE);
            jQuery(listItem).addClass(_c4gMapsConstant.cssConstants.OPEN);
            if (self.proxy.baselayerController.arrBaselayers[uid].hasOverlays) {
              for (var _j3 in self.proxy.baselayerController.arrBaselayers[uid].overlayController.arrOverlays) {
                if (self.proxy.baselayerController.arrBaselayers[uid].overlayController.arrOverlays.hasOwnProperty(_j3)) {
                  self.proxy.baselayerController.arrBaselayers[uid].overlayController.arrOverlays[_j3].changeOpacity(self.proxy.baselayerController.arrBaselayers[uid].overlayController.arrOverlays[_j3].opacity);
                }
              }
            }
          } else {
            $entry.addClass(_c4gMapsConstant.cssConstants.INACTIVE);
            jQuery(listItem).addClass(_c4gMapsConstant.cssConstants.CLOSE);
          }

          $entry.data('uid', uid);
          $entry.click(handleEntryClick);

          wrapper.appendChild(listItem);
        }
        // Starboard Filter
        if (this.starboard.options.filter) {
          var dv = document.createElement('div');
          dv.className = "c4g-starboard-filter c4g-content-select";
          var filter = document.createElement('input');
          filter.type = 'text';
          filter.placeholder = ""; //Font Awesome
          var i = document.createElement('i');
          i.className = 'fas fa-filter';
          i.setAttribute("aria-hidden", "true");
          dv.appendChild(filter);
          dv.appendChild(i);
          filter.onkeyup = function () {
            function filter_ulli(element, showSubtree) {

              // do not apply filter for short search terms

              showSubtree = showSubtree || false; // used while traversing down the tree

              /**
               * Returns an array (modified: first element) of the given elements. Only finds children of the given parent element, but
               * no further descendants like getElementsByTagName does.
               */
              function getChildrenByTagName(element, tagName) {
                var found = [];
                for (var i = 0; i < element.children.length; i++) {
                  if (element.children[i].tagName.toUpperCase() == tagName.toUpperCase()) {
                    found.push(element.children[i]);
                  }
                }
                if (found.length > 0) {
                  return found[0]; // !!!
                } else {
                  return false;
                }
              }

              var matchFlagUl = false;
              var subtreeMatches = false;
              // for each LI do
              if (element.children) {
                for (var i = 0; i < element.children.length; i++) {
                  element.children[i].style.display = "block";

                  var isMatch = false;

                  // search current LI for filter term
                  if (element.children[i].getElementsByTagName('a')[0].innerHTML.toUpperCase().indexOf(filter.value.toUpperCase()) >= 0) {
                    // it's a match
                    isMatch = true;
                  }

                  // recurse if a subtree (UL) exists in current LI (max 1 expected)
                  var ul = getChildrenByTagName(element.children[i], "ul");

                  if (ul) {
                    // recursion
                    var hasSubtree = true;
                    subtreeMatches = filter_ulli(ul, showSubtree || isMatch);
                  } else {
                    var hasSubtree = false;
                  }

                  if (isMatch || subtreeMatches || showSubtree) {
                    matchFlagUl = true; // used while traversing up the tree again
                    // set current LI visible and open
                    element.children[i].style.display = "";

                    if (filter.value.length > 2) {
                      element.children[i].classList.remove("c4g-close");
                      element.children[i].classList.add("c4g-open");
                    }

                    element.children[i].classList.remove("c4g-starboard-filter-match"); // always remove
                    if (isMatch && filter.value.length > 0) {
                      element.children[i].classList.add("c4g-starboard-filter-match");
                    }
                    ;
                  } else {
                    // set current LI invisible
                    element.children[i].style.display = "none";
                    element.children[i].classList.remove("c4g-open");
                    element.children[i].classList.add("c4g-close");
                    element.children[i].classList.remove("c4g-starboard-filter-match");
                  }
                }

                if (matchFlagUl) {
                  return true;
                } else {
                  return false;
                }
              }
            }

            // do not react immediately but allow for some keystrokes
            setTimeout(function () {
              // two or zero letters are required
              if (filter.value.length != 1) filter_ulli(document.querySelector('.c4g-baselayertree > ul:nth-child(2)'));
            }, 350);
          };

          wrapperElement.appendChild(dv);
        }

        this.proxy.hook_baselayer_visibility.push(handleChangeBaselayerVisibility);
      }
      wrapperElement.appendChild(wrapper);
    } // end of "addItems()"

  }]);

  return Baselayerswitcher;
}();

/***/ }),

/***/ "./Resources/public/js/c4g-maps-control-starboardplugin-customtab.js":
/*!***************************************************************************!*\
  !*** ./Resources/public/js/c4g-maps-control-starboardplugin-customtab.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Customtab = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * This file is part of con4gis,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * the gis-kit for Contao CMS.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @package    con4gis
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @version    6
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @author     con4gis contributors (see "authors.txt")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @license    LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @copyright  Küstenschmiede GmbH Software & Design
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @link       https://www.con4gis.org
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _c4gMapsConstant = __webpack_require__(/*! ./c4g-maps-constant */ "./Resources/public/js/c4g-maps-constant.js");

var _c4gMapsI18n = __webpack_require__(/*! ./c4g-maps-i18n */ "./Resources/public/js/c4g-maps-i18n.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

"use strict";

var Customtab = exports.Customtab = function () {

  /**
   *
   * @param starboard
   * @param plugin
   * @param projectConf
   * @returns {boolean}
   * @constructor
   */
  function Customtab(starboard, projectConf) {
    _classCallCheck(this, Customtab);

    if (!starboard) {
      console.warn('Cannot initialize Project-tab without a starboard.');
      return false;
    }
    projectConf = jQuery.extend({
      tabId: null,
      name: "Customtab",
      awesomeicon: ''
    }, projectConf);

    if (!projectConf.tabId) {
      console.warn('Cannot initialize Project-tab without an id.');
      return false;
    }

    this.initialized = false;
    //this.plugin = plugin || false;
    this.contentLoaded = false;
    this.starboard = starboard;
    this.proxy = starboard.options.mapController.proxy;
    this.map = this.proxy.options.mapController.map;
    this.layers = {};
    this.tabId = projectConf.tabId;
    this.name = projectConf.name;
    this.awesomeicon = projectConf.awesomeicon.replace('&#92;', "\\");
    starboard.plugins["customTab" + this.tabId] = this;
    this.create();
  }

  /**
   * @TODO: [create description]
   *
   * @return  {[type]}  [description]
   */


  _createClass(Customtab, [{
    key: "create",
    value: function create() {
      var self, contentWrapper, contentHeadline, contentHeadlineLink, selector, layerSwitcherTitle;

      self = this;
      var langConstants = (0, _c4gMapsI18n.getLanguage)(this.proxy.options.mapController.data);
      contentWrapper = document.createElement('div');
      contentHeadline = document.createElement('div');
      contentHeadline.className = 'contentHeadline';

      layerSwitcherTitle = this.starboard.options.layerSwitcherTitle;

      if (self.name) {
        layerSwitcherTitle = self.name;
      }

      if (!this.starboard.options.button) {
        contentHeadline.innerHTML = layerSwitcherTitle || langConstants.STARBOARD_VIEW_TRIGGER_LAYERSWITCHER;
      } else {
        jQuery(contentHeadline).addClass("c4g-starboard-headline");
        contentHeadlineLink = document.createElement('a');
        contentHeadlineLink.onclick = function () {
          if (jQuery(this).hasClass("c4g-active") !== false) {
            for (var i = 0; i < self.proxy.layerIds.length; i++) {
              self.proxy.layerController.hideLayer(self.proxy.layerIds[i]);
            }
            jQuery(this).removeClass("c4g-active");
            jQuery(this).addClass("c4g-inactive");
          } else {
            for (var i = 0; i < self.proxy.layerIds.length; i++) {
              self.proxy.layerController.showLayer(self.proxy.layerIds[i]);
            }
            jQuery(this).removeClass("c4g-inactive");
            jQuery(this).addClass("c4g-active");
          }
        };
        jQuery(contentHeadlineLink).addClass("c4g-inactive c4g-starboard-headline-link");
        contentHeadlineLink.innerHTML = layerSwitcherTitle || langConstants.STARBOARD_VIEW_TRIGGER_LAYERSWITCHER;
        contentHeadlineLink.innerHTML = contentHeadlineLink.innerHTML + ' ';
        contentHeadline.appendChild(contentHeadlineLink);
      }

      contentWrapper.appendChild(contentHeadline);

      this.contentDiv = document.createElement('div');
      this.contentDiv.className = 'c4g_starboardplugin_content';
      contentWrapper.appendChild(this.contentDiv);

      self.view = self.starboard.addView({
        name: self.name,
        triggerConfig: {
          tipLabel: self.name,
          className: 'c4g-starboard-view-trigger-starboardplugin-' + self.tabId,
          withHeadline: false
        },
        sectionElements: [{ section: self.starboard.contentContainer, element: contentWrapper }, { section: self.starboard.topToolbar, element: self.starboard.viewTriggerBar }]
      });
      if (this.awesomeicon.substring(0, 1) === "\\") {
        this.awesomeicon = this.awesomeicon.substring(1, this.awesomeicon.length);
      }
      selector = 'button.c4g-starboard-view-trigger-starboardplugin-' + self.tabId;
      //ToDo möglicherweise standard icon ?
      if (this.awesomeicon.length > 0) {
        var styleEl = document.createElement('style'),
            styleSheet;

        // Append style element to head
        document.head.appendChild(styleEl);

        // Grab style sheet
        styleSheet = styleEl.sheet;
        // catch firefox, because FF does not know "addRule"
        if (styleSheet.addRule && typeof document.styleSheets[0].addRule === 'function') {
          styleSheet.addRule(selector + ':before', 'content: "\\' + this.awesomeicon + '";');
        } else {
          styleSheet.insertRule(selector + ':before { content: "\\' + this.awesomeicon + '";}', 0);
        }
      }
      this.activate();
    }

    /**
     * @TODO: [activate description]
     *
     * @return  {[type]}  [description]
     */

  }, {
    key: "activate",
    value: function activate() {
      this.view.activate();
      if (!this.contentLoaded) {
        this.loadContent();
      }
    }

    /**
     * @TODO: [setContent description]
     *
     * @param  {Node}  newContent  [description]
     */

  }, {
    key: "setContent",
    value: function setContent(newContent) {
      if (newContent) {
        if (typeof newContent === "string") {
          this.contentDiv.innerHTML = newContent;
        } else {
          try {
            if (this.contentDiv.firstChild) {
              this.contentDiv.replaceChild(newContent, this.contentDiv.firstChild);
            } else {
              this.contentDiv.appendChild(newContent);
            }
          } catch (e) {
            // @TODO
            console.warn(e.message);
            // return false;
          }
        }
      }
      return this.contentDiv.innerHTML;
    }

    /**
     * @TODO: [loadContent description]
     *
     * @return  {[type]}  [description]
     */

  }, {
    key: "loadContent",
    value: function loadContent() {
      var self, fnDrawContent;

      self = this;
      this.starboard.spinner.show();

      fnDrawContent = function fnDrawContent(layerIds) {
        self.treeControl = document.createElement('div');
        jQuery(self.treeControl).addClass(_c4gMapsConstant.cssConstants.STARBOARD_LAYERTREE);
        self.setContent(self.treeControl);
        self.addItems(layerIds, self.treeControl, { parseAsList: true });
        self.initialized = true;
        self.contentLoaded = true;
        self.starboard.spinner.hide();
        self.starboard.update();
      }; // end of "fnDrawContent()"

      fnDrawContent(this.proxy.layerIds);
    } // end of "loadContent()"

    /**
     * @TODO: [addItems description]
     *
     * @param  {[type]}  itemData        [description]
     * @param  {[type]}  wrapperElement  [description]
     * @param  {[type]}  options         [description]
     */

  }, {
    key: "addItems",
    value: function addItems(itemData, wrapperElement, options) {
      var i, wrapper, item, layer, uid, listItem, entry, $entry, handleEntryClick, self, pWrapper, toggle, childWrapper;

      options = options || {};
      options = jQuery.extend({
        parseAsList: true
      }, options);

      self = this;

      handleEntryClick = function handleEntryClick(event) {
        var itemUid;

        event.preventDefault();
        // "this" is the event sending entry
        itemUid = jQuery(this).data('uid');
        if (self.proxy.activeLayerIds[itemUid]) {
          // hide layer
          jQuery(this).removeClass(_c4gMapsConstant.cssConstants.ACTIVE);
          jQuery(this).addClass(_c4gMapsConstant.cssConstants.INACTIVE);
          self.hideLayer(itemUid);
        } else {
          // show layer
          jQuery(this).removeClass(_c4gMapsConstant.cssConstants.INACTIVE);
          jQuery(this).addClass(_c4gMapsConstant.cssConstants.ACTIVE);
          self.showLayer(itemUid);
        }
      };

      // register hook to switch childs of layers as well
      this.proxy.hook_layer_visibility.push(function (layerId) {
        var j, changedLayer;

        changedLayer = self.layers[layerId];
        if (changedLayer && changedLayer.$entries) {
          for (j = 0; j < changedLayer.$entries.length; j += 1) {
            if (self.proxy.activeLayerIds[layerId]) {
              changedLayer.$entries[j].addClass(_c4gMapsConstant.cssConstants.ACTIVE).removeClass(_c4gMapsConstant.cssConstants.INACTIVE);
            } else {
              changedLayer.$entries[j].addClass(_c4gMapsConstant.cssConstants.INACTIVE).removeClass(_c4gMapsConstant.cssConstants.ACTIVE);
            }
          }
        }
      }); // end of hook

      // add hook function for changed zoom
      //   needed to change the entry-classes
      this.proxy.hook_map_zoom.push(function () {
        var j, id, layer;

        for (id in self.layers) {
          if (self.layers.hasOwnProperty(id)) {
            layer = self.layers[id];
            if (layer && layer.$entries) {
              for (j = 0; j < layer.$entries.length; j += 1) {
                if (self.proxy.checkLayerIsActiveForZoom(id)) {
                  layer.$entries[j].removeClass(_c4gMapsConstant.cssConstants.DISABLED);
                } else {
                  layer.$entries[j].addClass(_c4gMapsConstant.cssConstants.DISABLED);
                }
              }
            }
          }
        }
      }); // end of hook

      // build the layer tree
      wrapper = options.parseAsList ? document.createElement('ul') : document.createElement('div');
      if (itemData && itemData.length > 0) {
        for (i = 0; i < itemData.length; i += 1) {
          uid = itemData[i];
          //layer = this.plugin.customTabs[this.tabId].drawnFeatures[uid];
          layer = this.proxy.layerController.arrLayers[uid];
          // skip layer if it doesn't belong to this tab
          if (!(layer.renderSpecial == true && layer.tabId == this.tabId)) {
            continue;
          }
          // do not render the startab layer itself as parent level
          if (layer.type === "startab") {
            continue;
          }
          // check if layer wants to be displayed in starboard tab
          if (layer.hideWhenInTab === true) {
            continue;
          }
          if (layer.hide === "1") {
            if (this.proxy.activeLayerIds[layer.id]) {
              // this.hideLayer(layer.id);
            }
          }
          // check if the layer should be displayed
          if (!layer.display) {
            continue;
          }
          item = {};
          this.layers[uid] = item;
          listItem = options.parseAsList ? document.createElement('li') : document.createElement('div');
          item.entryWrappers = item.entryWrappers || [];
          item.entryWrappers.push(listItem);
          entry = document.createElement('a');
          entry.setAttribute('href', '#');
          entry.appendChild(document.createTextNode(layer.layername || layer.name));
          listItem.appendChild(entry);
          $entry = jQuery(entry);
          item.$entries = item.$entries || [];
          item.$entries.push($entry);
          $entry.data('uid', uid);
          $entry.click(handleEntryClick);

          // prepare insertion of childs
          if (layer.visibleChilds) {
            toggle = document.createElement('span');
            jQuery(listItem).addClass(_c4gMapsConstant.cssConstants.CLOSE);
            jQuery(toggle).addClass(_c4gMapsConstant.cssConstants.ICON);
            jQuery(toggle).click(function () {
              if (jQuery(this).parent().hasClass(_c4gMapsConstant.cssConstants.CLOSE)) {
                jQuery(this).parent().removeClass(_c4gMapsConstant.cssConstants.CLOSE).addClass(_c4gMapsConstant.cssConstants.OPEN);
              } else {
                jQuery(this).parent().removeClass(_c4gMapsConstant.cssConstants.OPEN).addClass(_c4gMapsConstant.cssConstants.CLOSE);
              }
              if (self.proxy.options.mapController.rightSlideElements) {
                self.proxy.options.mapController.rightSlideElements.forEach(function (element) {
                  jQuery(element).css('right', self.starboard.container.offsetWidth);
                });
              }
              jQuery(self.starboard.element).css('right', self.starboard.container.offsetWidth);
            });
            jQuery(toggle).insertBefore($entry);
            childWrapper = options.parseAsList ? document.createElement('ul') : document.createElement('div');
            item.childWrappers = item.childWrappers || [];
            item.childWrappers.push(childWrapper);
            listItem.appendChild(childWrapper);
          }

          if (this.proxy.activeLayerIds[uid]) {
            $entry.addClass(_c4gMapsConstant.cssConstants.ACTIVE);
          } else {
            $entry.addClass(_c4gMapsConstant.cssConstants.INACTIVE);
          }
          if (this.layers[layer.pid]) {
            // is child-element
            pWrapper = this.layers[layer.pid].childWrappers;
            if (pWrapper) {
              pWrapper[pWrapper.length - 1].appendChild(listItem);
            }
          } else {
            wrapper.appendChild(listItem);
          }
        } // end of for-loop
        // Starboard Filter
        if (this.starboard.options.filter) {
          var dv = document.createElement('div');
          dv.className = "c4g-starboard-filter c4g-content-select";
          var filter = document.createElement('input');
          filter.type = 'text';
          filter.placeholder = ""; //Font Awesome
          var i = document.createElement('i');
          i.className = 'fas fa-filter';
          i.setAttribute("aria-hidden", "true");
          dv.appendChild(filter);
          dv.appendChild(i);
          filter.onkeyup = function () {
            function filter_ulli(element, showSubtree) {

              // do not apply filter for short search terms

              showSubtree = showSubtree || false; // used while traversing down the tree

              /**
               * Returns an array (modified: first element) of the given elements. Only finds children of the given parent element, but
               * no further descendants like getElementsByTagName does.
               */
              function getChildrenByTagName(element, tagName) {
                var found = [];
                for (var i = 0; i < element.children.length; i++) {
                  if (element.children[i].tagName.toUpperCase() == tagName.toUpperCase()) {
                    found.push(element.children[i]);
                  }
                }
                if (found.length > 0) {
                  return found[0]; // !!!
                } else {
                  return false;
                }
              }

              var matchFlagUl = false;
              var subtreeMatches = false;
              // for each LI do
              for (var i = 0; i < element.children.length; i++) {
                element.children[i].style.display = "block";

                var isMatch = false;

                // search current LI for filter term
                if (element.children[i].getElementsByTagName('a')[0].innerHTML.toUpperCase().indexOf(filter.value.toUpperCase()) >= 0) {
                  // it's a match
                  isMatch = true;
                }

                // recurse if a subtree (UL) exists in current LI (max 1 expected)
                var ul = getChildrenByTagName(element.children[i], "ul");

                if (ul) {
                  // recursion
                  var hasSubtree = true;
                  subtreeMatches = filter_ulli(ul, showSubtree || isMatch);
                } else {
                  var hasSubtree = false;
                }

                if (isMatch || subtreeMatches || showSubtree) {
                  matchFlagUl = true; // used while traversing up the tree again
                  // set current LI visible and open
                  element.children[i].style.display = "";

                  if (filter.value.length > 2) {
                    element.children[i].classList.remove("c4g-close");
                    element.children[i].classList.add("c4g-open");
                  }

                  element.children[i].classList.remove("c4g-starboard-filter-match"); // always remove
                  if (isMatch && filter.value.length > 0) {
                    element.children[i].classList.add("c4g-starboard-filter-match");
                  }
                } else {
                  // set current LI invisible
                  element.children[i].style.display = "none";
                  element.children[i].classList.remove("c4g-open");
                  element.children[i].classList.add("c4g-close");
                  element.children[i].classList.remove("c4g-starboard-filter-match");
                }
              }

              if (matchFlagUl) {
                return true;
              } else {
                return false;
              }
            }

            // do not react immediately but allow for some keystrokes
            setTimeout(function () {
              // two or zero letters are required
              if (filter.value.length != 1) filter_ulli(document.querySelector('.c4g-layertree > ul:nth-child(2)'));
            }, 350);
          };

          wrapperElement.appendChild(dv);
        }
        wrapperElement.appendChild(wrapper);
      }
    } // end of "addItems()"

  }, {
    key: "showLayer",
    value: function showLayer(itemUid) {
      if (this.proxy.activeLayerIds[itemUid]) {
        return true;
      } else {
        this.proxy.layerController.showLayer(itemUid);
      }
    } // end of "showLayer()"


  }, {
    key: "hideLayer",
    value: function hideLayer(itemUid) {
      if (!this.proxy.activeLayerIds[itemUid]) {
        return true;
      } else {
        this.proxy.layerController.hideLayer(itemUid);
      }
    } // end of "hideLayer()"

  }]);

  return Customtab;
}();

/***/ }),

/***/ "./Resources/public/js/c4g-maps-control-starboardplugin-layerswitcher.js":
/*!*******************************************************************************!*\
  !*** ./Resources/public/js/c4g-maps-control-starboardplugin-layerswitcher.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Layerswitcher = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * This file is part of con4gis,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * the gis-kit for Contao CMS.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @package    con4gis
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @version    6
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @author     con4gis contributors (see "authors.txt")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @license    LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @copyright  Küstenschmiede GmbH Software & Design
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @link       https://www.con4gis.org
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _c4gMapsConstant = __webpack_require__(/*! ./c4g-maps-constant */ "./Resources/public/js/c4g-maps-constant.js");

var _c4gMapsUtils = __webpack_require__(/*! ./c4g-maps-utils */ "./Resources/public/js/c4g-maps-utils.js");

var _c4gMapsI18n = __webpack_require__(/*! ./c4g-maps-i18n */ "./Resources/public/js/c4g-maps-i18n.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

'use strict';

var Layerswitcher = exports.Layerswitcher = function () {

  /**
   * Constructor
   *
   * @extends {ol.control.Control}
   * @param   {object}              starboard
   */
  function Layerswitcher(starboard) {
    _classCallCheck(this, Layerswitcher);

    if (!starboard) {
      console.warn('Cannot initialize Layerswitcher without a starboard.');
      return false;
    }

    this.initialized = false;
    this.layers = {};

    this.starboard = starboard;
    this.proxy = starboard.options.mapController.proxy;
    this.create();
    this.loadContent();
  }

  _createClass(Layerswitcher, [{
    key: "create",
    value: function create() {
      var self, contentWrapper, contentHeadline, contentHeadlineLink, contentInfo, layerSwitcherTitle;

      layerSwitcherTitle = this.starboard.options.layerSwitcherTitle;
      var langConstants = (0, _c4gMapsI18n.getLanguage)(this.starboard.options.mapController.data);
      self = this;

      contentWrapper = document.createElement('div');
      contentHeadline = document.createElement('div');
      contentHeadline.className = 'contentHeadline';

      if (!this.starboard.options.button) {
        contentHeadline.innerHTML = layerSwitcherTitle || langConstants.STARBOARD_VIEW_TRIGGER_LAYERSWITCHER;
      } else {
        jQuery(contentHeadline).addClass("c4g-starboard-headline");
        contentHeadlineLink = document.createElement('a');
        contentHeadlineLink.onclick = function () {
          if (jQuery(this).hasClass("c4g-active") !== false) {
            for (var i = 0; i < self.proxy.layerIds.length; i++) {
              self.proxy.layerController.hideLayer(self.proxy.layerIds[i]);
            }
            jQuery(this).removeClass("c4g-active");
            jQuery(this).addClass("c4g-inactive");
          } else {
            for (var i = 0; i < self.proxy.layerIds.length; i++) {
              self.proxy.layerController.showLayer(self.proxy.layerIds[i]);
            }
            jQuery(this).removeClass("c4g-inactive");
            jQuery(this).addClass("c4g-active");
          }
        };
        jQuery(contentHeadlineLink).addClass("c4g-inactive c4g-starboard-headline-link");
        contentHeadlineLink.innerHTML = layerSwitcherTitle || langConstants.STARBOARD_VIEW_TRIGGER_LAYERSWITCHER;
        contentHeadlineLink.innerHTML = contentHeadlineLink.innerHTML + ' ';
        contentHeadline.appendChild(contentHeadlineLink);
      }

      contentWrapper.appendChild(contentHeadline);

      this.contentDiv = document.createElement('div');
      this.contentDiv.className = _c4gMapsConstant.cssConstants.STARBOARD_CONTENT_LAYERSWITCHER;
      contentInfo = document.createElement('p');
      this.contentDiv.appendChild(contentInfo);
      contentWrapper.appendChild(this.contentDiv);

      self.view = self.starboard.addView({
        name: 'layerswitcher',
        triggerConfig: {
          tipLabel: layerSwitcherTitle || langConstants.STARBOARD_VIEW_TRIGGER_LAYERSWITCHER,
          className: _c4gMapsConstant.cssConstants.STARBOARD_VIEW_TRIGGER_LAYERSWITCHER,
          withHeadline: false
        },
        sectionElements: [{ section: self.starboard.contentContainer, element: contentWrapper }, { section: self.starboard.topToolbar, element: self.starboard.viewTriggerBar }]
      });
    }

    /**
     * @TODO: [activate description]
     *
     * @return  {[type]}  [description]
     */

  }, {
    key: "activate",
    value: function activate() {
      this.view.activate();
    } // end of "activate()"

    /**
     * @TODO: [setContent description]
     *
     * @param  {[type]}  newContent  [description]
     */

  }, {
    key: "setContent",
    value: function setContent(newContent) {
      if (newContent) {
        if (typeof newContent === "string") {
          this.contentDiv.innerHTML = newContent;
        } else {
          try {
            if (this.contentDiv.firstChild) {
              this.contentDiv.replaceChild(newContent, this.contentDiv.firstChild);
            } else {
              this.contentDiv.appendChild(newContent);
            }
          } catch (e) {
            // @TODO
            console.warn(e.message);
            // return false;
          }
        }
      }
      return this.contentDiv.innerHTML;
    } // end of "setContent()"

    /**
     * @TODO: [loadContent description]
     *
     * @return  {[type]}  [description]
     */

  }, {
    key: "loadContent",
    value: function loadContent() {
      var self, fnDrawContent;

      self = this;
      this.starboard.spinner.show();

      fnDrawContent = function fnDrawContent(layerIds) {
        self.treeControl = document.createElement('div');
        jQuery(self.treeControl).addClass(_c4gMapsConstant.cssConstants.STARBOARD_LAYERTREE);
        self.setContent(self.treeControl);

        self.addItems(layerIds, self.treeControl);

        self.initialized = true;
        self.starboard.spinner.hide();
        self.starboard.update();
      }; // end of "fnDrawContent()"

      if (this.proxy.layers_loaded) {
        fnDrawContent(this.proxy.layerIds);
      } else {
        this.proxy.hook_layer_loaded.push(fnDrawContent);
      }
    } // end of "loadContent()"

    /**
     * @TODO: [drawContent description]
     */

  }, {
    key: "drawContent",
    value: function drawContent(contentData) {}
    // PASS
    // end of "drawContent()"

    /**
     * @TODO: [addItems description]
     *
     * @param  {[type]}  itemData        [description]
     * @param  {[type]}  wrapperElement  [description]
     * @param  {[type]}  options         [description]
     */

  }, {
    key: "addItems",
    value: function addItems(itemData, wrapperElement, options) {
      var i, self, filter, wrapper, childWrapper, pWrapper, item, layer, uid, listItem, entry, $entry, toggle, fnHandleEntryClick, fnChildEntryClick, fnChildEntryShow, zoomToExtent, layerClass;

      self = this;

      options = options || {};
      options = jQuery.extend({
        parseAsList: true
      }, options);

      wrapper = options.parseAsList ? document.createElement('ul') : document.createElement('div');

      // create handler for entry-clicks
      fnHandleEntryClick = function fnHandleEntryClick(event) {
        var itemUid, layerItem;

        event.preventDefault();

        itemUid = jQuery(this).data('uid');
        layerItem = self.proxy.layerController.arrLayers[itemUid];

        if (self.proxy.activeLayerIds[itemUid]) {
          // hide layer
          self.proxy.layerController.hideLayer(itemUid);
          if (parseInt(layer.pid, 10) == 0) {
            // hide all childs, because clicked layer is the map itself
            for (var id in self.proxy.activeLayerIds) {
              if (self.proxy.activeLayerIds.hasOwnProperty(id)) {
                self.proxy.layerController.hideLayer(id);
              }
            }
          }
        } else {
          // show layer
          self.proxy.layerController.showLayer(itemUid);
          //zooom to extent
          setTimeout(function () {
            zoomToExtent(itemUid);
          }, 200);
          // zoomToExtent(itemUid);
        }
        if (self.handleSelectedChilds(this)) {
          self.updateParentLayers(this, itemUid, layerItem);
        }

        // c4g.maps.layers[itemUid] = layerItem;
      }; // end of "fnHandleEntryClick()"
      fnChildEntryClick = function fnChildEntryClick(event) {
        event.preventDefault();
        var itemUid = jQuery(this).data('uid');
        var parent = jQuery(this).parent().parent().parent();
        var childs = jQuery(parent).children();
        var parentUid = jQuery(childs[1]).data('uid');
        if (jQuery(this).hasClass(_c4gMapsConstant.cssConstants.ACTIVE)) {
          self.proxy.layerController.hideChildLayer(parentUid, itemUid);
          jQuery(this).removeClass(_c4gMapsConstant.cssConstants.ACTIVE).addClass(_c4gMapsConstant.cssConstants.INACTIVE);
        } else if (jQuery(this).hasClass(_c4gMapsConstant.cssConstants.INACTIVE)) {
          self.proxy.layerController.showChildLayer(parentUid, itemUid);
          jQuery(this).removeClass(_c4gMapsConstant.cssConstants.INACTIVE).addClass(_c4gMapsConstant.cssConstants.ACTIVE);
        }
      };
      fnChildEntryShow = function fnChildEntryShow(event) {
        event.preventDefault();
        var parent = this.parentElement;
        var uid = jQuery(parent.firstChild).data('uid');
        parent = jQuery(this).parent().parent().parent();
        var childs = jQuery(parent).children();
        var parentUid = jQuery(childs[1]).data('uid');
        uid = uid.replace(parentUid, '');
        var layer = self.proxy.layerController.arrLayers[parentUid].vectorLayer;
        if (layer) {
          var singleLayer = layer.getLayers().getArray()[uid];
          var feature = singleLayer.getSource().getFeatures()[0];
          self.proxy.options.mapController.map.getView().fit(feature.getGeometry());
        }
      };

      zoomToExtent = function zoomToExtent(itemUid) {
        //function to zoom to the extent of a map structure and its children
        var layerItem,
            vectorArray,
            layerGroup,
            coords,
            geometry,
            featureList,
            featureArray,
            coordinates = [],
            extent,
            center,
            key;
        layerItem = self.proxy.layerController.arrLayers[itemUid];
        if (layerItem && layerItem.zoom_locations === "1") {
          if (layerItem.hasChilds) {
            for (key in layerItem.childs) {
              if (layerItem.childs.hasOwnProperty(key)) {
                layer = layerItem.childs[key];
                vectorArray = layer.content;
                if (vectorArray === undefined) {
                  // catch case of linked layers
                  continue;
                }
                if ((typeof vectorArray === "undefined" ? "undefined" : _typeof(vectorArray)) === "object") {
                  vectorArray = _c4gMapsUtils.utils.objectToArray(vectorArray);
                }
                layerGroup = layerItem.vectorLayer;
                if (vectorArray && vectorArray.forEach && typeof vectorArray.forEach === 'function') {
                  vectorArray.forEach(function (vectorLayer) {
                    if (vectorLayer && vectorLayer.data && vectorLayer.data.geometry && vectorLayer.data.geometry.coordinates) {
                      if (vectorLayer.data.geometry.type === "Point") {
                        coords = ol.proj.transform([parseFloat(vectorLayer.data.geometry.coordinates[0]), parseFloat(vectorLayer.data.geometry.coordinates[1])], 'EPSG:4326', 'EPSG:3857');
                        geometry = new ol.geom.Point(coords);
                        coordinates.push(geometry.getCoordinates());
                      }
                    }
                  });
                }
                if (layerGroup) {
                  // handle more complex geometries
                  featureList = layerGroup.getLayers();
                  featureArray = featureList.getArray();
                  featureArray.forEach(function (feature) {
                    if (layer.type === "kml") {
                      var source = feature.getSource();
                      //var sourceFeatures = source.getFeatures();
                      source.getExtent().forEach(function (coordinate) {
                        coordinates.push(coordinate);
                      });
                    } else {
                      if (ol.extent.getTopRight(feature.getSource().getExtent())['0'] != "Infinity" && ol.extent.getTopRight(feature.getSource().getExtent())['0'] != "-Infinity") {

                        coordinates.push(ol.extent.getTopRight(feature.getSource().getExtent()));
                        coordinates.push(ol.extent.getTopLeft(feature.getSource().getExtent()));
                        coordinates.push(ol.extent.getBottomRight(feature.getSource().getExtent()));
                        coordinates.push(ol.extent.getBottomLeft(feature.getSource().getExtent()));
                      }
                    }
                  });
                }
              }
            }
          }

          if (layerItem.vectorLayer) {

            layerGroup = layerItem.vectorLayer;
            vectorArray = layerGroup.getLayers().getArray();
            if (vectorArray && vectorArray.forEach && typeof vectorArray.forEach === 'function') {
              vectorArray.forEach(function (vectorLayer) {
                if (vectorLayer && vectorLayer.getSource() && vectorLayer.getSource().getFeatures()) {
                  var features = vectorLayer.getSource().getFeatures();
                  for (var id in features) {
                    coordinates.push(features[id].getGeometry().getCoordinates());
                  }
                }
              });
            }
            if (layerGroup) {
              // handle more complex geometries
              featureList = layerGroup.getLayers();
              featureArray = featureList.getArray();
              featureArray.forEach(function (feature) {
                if (layer.type !== "overpass") {
                  if (layer.type === "kml") {
                    var source = feature.getSource();
                    //var sourceFeatures = source.getFeatures();
                    source.getExtent().forEach(function (coordinate) {
                      coordinates.push(coordinate);
                    });
                  } else {
                    coordinates.push(ol.extent.getTopRight(feature.getSource().getExtent()));
                    coordinates.push(ol.extent.getTopLeft(feature.getSource().getExtent()));
                    coordinates.push(ol.extent.getBottomRight(feature.getSource().getExtent()));
                    coordinates.push(ol.extent.getBottomLeft(feature.getSource().getExtent()));
                  }
                }
              });
            }
          }

          extent = ol.extent.boundingExtent(coordinates);
          if (extent[0] === Infinity || extent[0] === -Infinity) {
            return;
          }
          self.proxy.options.mapController.map.getView().fit(extent, self.proxy.options.mapController.map.getSize());
          center = self.proxy.options.mapController.map.getView().getCenter();
          if (isNaN(center[0])) {
            self.proxy.options.mapController.map.getView().setCenter([50, 10]);
            self.proxy.options.mapController.map.getView().setZoom(mapData.minZoom || 10);
          }
        }
      }; //end of zoom to extent
      // add hook function for changed layer-visibility
      //   needed to change the entry-classes
      this.proxy.hook_layer_visibility.push(function (layerId) {
        var j, changedLayer;

        changedLayer = self.layers[layerId];
        if (changedLayer && changedLayer.$entries) {
          for (j = 0; j < changedLayer.$entries.length; j += 1) {
            if (self.proxy.activeLayerIds[layerId]) {
              changedLayer.$entries[j].addClass(_c4gMapsConstant.cssConstants.ACTIVE).removeClass(_c4gMapsConstant.cssConstants.INACTIVE);
            } else {
              changedLayer.$entries[j].addClass(_c4gMapsConstant.cssConstants.INACTIVE).removeClass(_c4gMapsConstant.cssConstants.ACTIVE);
            }
            self.handleSelectedChilds(changedLayer.$entries[j]);
          }
        }
      });

      // add hook function for changed zoom
      //   needed to change the entry-classes
      this.proxy.hook_map_zoom.push(function () {
        var j, id, layer;

        for (id in self.layers) {
          if (self.layers.hasOwnProperty(id)) {
            layer = self.layers[id];
            if (layer && layer.$entries) {
              for (j = 0; j < layer.$entries.length; j += 1) {
                if (self.proxy.checkLayerIsActiveForZoom(id)) {
                  layer.$entries[j].removeClass(_c4gMapsConstant.cssConstants.DISABLED);
                } else {
                  layer.$entries[j].addClass(_c4gMapsConstant.cssConstants.DISABLED);
                }
              }
            }
          }
        }
      }); // end of hook

      if (itemData && itemData.length > 0) {
        for (i = 0; i < itemData.length; i += 1) {
          uid = itemData[i];
          layer = self.proxy.layerController.arrLayers[uid];
          item = {};
          this.layers[uid] = item;
          // renderSpecial is set when a layer is rendered in its own tab
          if (layer.renderSpecial) {
            continue;
          }

          if (layer && layer.display) {
            listItem = options.parseAsList ? document.createElement('li') : document.createElement('div');
            jQuery(listItem).data('noFilter', layer['noFilter']);
            item.entryWrappers = item.entryWrappers || [];
            item.entryWrappers.push(listItem);

            entry = document.createElement('a');
            entry.setAttribute('href', '#');
            entry.appendChild(document.createTextNode(layer.name));
            listItem.appendChild(entry);

            $entry = jQuery(entry);
            item.$entries = item.$entries || [];
            item.$entries.push($entry);

            if (!this.proxy.checkLayerIsActiveForZoom(uid)) {
              $entry.addClass(_c4gMapsConstant.cssConstants.DISABLED);
            }

            $entry.data('uid', uid);
            $entry.click(fnHandleEntryClick);

            if (layer.visibleChilds || layer.split_geojson) {
              toggle = document.createElement('span');

              if (layer.hide_child !== '1') {
                jQuery(listItem).addClass(_c4gMapsConstant.cssConstants.CLOSE);
                jQuery(toggle).addClass(_c4gMapsConstant.cssConstants.ICON);
              }
              jQuery(toggle).click(function () {
                if (jQuery(this).parent().hasClass(_c4gMapsConstant.cssConstants.CLOSE)) {
                  jQuery(this).parent().removeClass(_c4gMapsConstant.cssConstants.CLOSE).addClass(_c4gMapsConstant.cssConstants.OPEN);
                } else {
                  jQuery(this).parent().removeClass(_c4gMapsConstant.cssConstants.OPEN).addClass(_c4gMapsConstant.cssConstants.CLOSE);
                }
                if (self.proxy.options.mapController.rightSlideElements) {
                  self.proxy.options.mapController.rightSlideElements.forEach(function (element) {
                    jQuery(element).css('right', self.starboard.container.offsetWidth);
                  });
                }
                jQuery(self.starboard.element).css('right', self.starboard.container.offsetWidth);
              });
              jQuery(toggle).insertBefore($entry);
              childWrapper = options.parseAsList ? document.createElement('ul') : document.createElement('div');
              item.childWrappers = item.childWrappers || [];
              item.childWrappers.push(childWrapper);
              if (layer.hide_child !== '1') {
                listItem.appendChild(childWrapper);
              }
              if (layer.split_geojson && layer.content[0]) {
                var data = layer.content[0].data;
                if (data && data.features) {
                  for (var _i = 0; _i < data.features.length; _i++) {
                    var feature = data.features[_i];
                    var childListItem = options.parseAsList ? document.createElement('li') : document.createElement('div');
                    var childItem = {};
                    childItem.entryWrappers = childItem.entryWrappers || [];
                    childItem.entryWrappers.push(childListItem);
                    var childEntry = document.createElement('a');
                    childEntry.setAttribute('href', '#');
                    childEntry.appendChild(document.createTextNode(feature.properties[layer.geojson_attributes.split(',')[0]]));
                    childListItem.appendChild(childEntry);
                    var childUid = uid + "" + _i;
                    var $childEntry = jQuery(childEntry);
                    childItem.$entries = item.$entries || [];
                    childItem.$entries.push($entry);
                    childWrapper.appendChild(childListItem);
                    $childEntry.data('uid', childUid);
                    if (layer.geojson_zoom) {
                      $childEntry.click(fnChildEntryShow);
                      $childEntry.addClass('c4g-geojson-button');
                    } else {
                      $childEntry.click(fnChildEntryClick);
                      if (this.proxy.activeLayerIds[uid]) {
                        $childEntry.addClass(_c4gMapsConstant.cssConstants.ACTIVE);
                      } else {
                        $childEntry.addClass(_c4gMapsConstant.cssConstants.INACTIVE);
                      }
                    }

                    if (window.c4gMapsHooks !== undefined && _typeof(window.c4gMapsHooks.addChilds) === 'object') {
                      _c4gMapsUtils.utils.callHookFunctions(window.c4gMapsHooks.addChilds);
                    }

                    if (window.c4gMapsHooks.starboard_layer_activate && window.c4gMapsHooks.starboard_layer_activate.length > 0) {
                      var paramObj = { 'feature': feature, 'parentItem': childListItem, 'entry': $childEntry };
                      _c4gMapsUtils.utils.callHookFunctions(window.c4gMapsHooks.starboard_layer_activate, paramObj);
                    }
                  }
                }
              }
            }

            if (this.proxy.activeLayerIds[uid]) {
              $entry.addClass(_c4gMapsConstant.cssConstants.ACTIVE);
            } else {
              $entry.addClass(_c4gMapsConstant.cssConstants.INACTIVE);
            }

            // [info]:  In order for this to work,
            //          the parent layers need to be
            //          listed before their childs
            if (this.layers[layer.pid]) {
              // is child-element
              pWrapper = this.layers[layer.pid].childWrappers;
              pWrapper[pWrapper.length - 1].appendChild(listItem);
            } else if (parseInt(layer.pid, 10) == 0) {
              // layer is map itself with a layer
              toggle = document.createElement('span');
              if (layer.hide_child !== '1') {
                jQuery(listItem).addClass(_c4gMapsConstant.cssConstants.CLOSE);
              }
              jQuery(toggle).addClass(_c4gMapsConstant.cssConstants.ICON);
              jQuery(toggle).click(function () {
                if (jQuery(this).parent().hasClass(_c4gMapsConstant.cssConstants.CLOSE)) {
                  jQuery(this).parent().removeClass(_c4gMapsConstant.cssConstants.CLOSE).addClass(_c4gMapsConstant.cssConstants.OPEN);
                } else {
                  jQuery(this).parent().removeClass(_c4gMapsConstant.cssConstants.OPEN).addClass(_c4gMapsConstant.cssConstants.CLOSE);
                }
              });
              jQuery(toggle).insertBefore($entry);
              childWrapper = options.parseAsList ? document.createElement('ul') : document.createElement('div');
              item.childWrappers = item.childWrappers || [];
              item.childWrappers.push(childWrapper);
              listItem.appendChild(childWrapper);
              wrapper.appendChild(listItem);
            } else {
              // is not a child-element (pid == mapId)
              wrapper.appendChild(listItem);
            }

            if (layer.id) {
              var idstr = layer.id.toString();
              layerClass = encodeURIComponent(idstr.toLowerCase()).replace(/%[0-9A-F]{2}/gi, '');
              jQuery(listItem).addClass('c4g_starboard_item_' + layerClass);
            }

            if (layer.cssClass) {
              jQuery(listItem).addClass(layer.cssClass);
            }

            // call hook "layerswitcher_forEachItem"
            if (window.c4gMapsHooks !== undefined && _typeof(window.c4gMapsHooks.layerswitcher_forEachItem) === "object") {
              _c4gMapsUtils.utils.callHookFunctions(window.c4gMapsHooks.layerswitcher_forEachItem, { that: this, item: item, entry: $entry });
            }
          }
        } // end of for-loop

        // Starboard Filter
        if (this.starboard.options.filter) {
          var dv = document.createElement('div');
          dv.className = "c4g-starboard-filter c4g-content-select";
          var filter = document.createElement('input');
          filter.type = 'text';
          filter.placeholder = ""; //Font Awesome
          var i = document.createElement('i');
          i.className = 'fas fa-filter';
          i.setAttribute("aria-hidden", "true");
          dv.appendChild(filter);
          dv.appendChild(i);
          filter.onkeyup = function () {
            function filter_ulli(element, showSubtree) {

              // do not apply filter for short search terms

              showSubtree = showSubtree || false; // used while traversing down the tree

              /**
               * Returns an array (modified: first element) of the given elements. Only finds children of the given parent element, but
               * no further descendants like getElementsByTagName does.
               */
              function getChildrenByTagName(element, tagName) {
                var found = [];
                for (var i = 0; i < element.children.length; i++) {
                  if (element.children[i].tagName.toUpperCase() == tagName.toUpperCase()) {
                    found.push(element.children[i]);
                  }
                }
                if (found.length > 0) {
                  return found[0]; // !!!
                } else {
                  return false;
                }
              }

              var matchFlagUl = false;
              var subtreeMatches = false;
              // for each LI do
              for (var i = 0; i < element.children.length; i++) {
                element.children[i].style.display = "block";

                var isMatch = false;

                // search current LI for filter term
                if (element.children[i].getElementsByTagName('a')[0].innerHTML.toUpperCase().indexOf(filter.value.toUpperCase()) >= 0 || jQuery(element.children[i]).data('noFilter')) {
                  // it's a match
                  isMatch = true;
                }

                // recurse if a subtree (UL) exists in current LI (max 1 expected)
                var ul = getChildrenByTagName(element.children[i], "ul");

                if (ul) {
                  // recursion
                  var hasSubtree = true;
                  subtreeMatches = filter_ulli(ul, showSubtree || isMatch);
                } else {
                  var hasSubtree = false;
                }

                if (isMatch || subtreeMatches || showSubtree) {
                  matchFlagUl = true; // used while traversing up the tree again
                  // set current LI visible and open
                  element.children[i].style.display = "";

                  if (filter.value.length > 2) {
                    element.children[i].classList.remove("c4g-close");
                    element.children[i].classList.add("c4g-open");
                  }

                  element.children[i].classList.remove("c4g-starboard-filter-match"); // always remove
                  if (isMatch && filter.value.length > 0) {
                    element.children[i].classList.add("c4g-starboard-filter-match");
                  }
                  ;
                } else {
                  // set current LI invisible
                  element.children[i].style.display = "none";
                  element.children[i].classList.remove("c4g-open");
                  element.children[i].classList.add("c4g-close");
                  element.children[i].classList.remove("c4g-starboard-filter-match");
                }
              }

              if (matchFlagUl) {
                return true;
              } else {
                return false;
              }
            }

            // do not react immediately but allow for some keystrokes
            setTimeout(function () {
              // two or zero letters are required
              if (filter.value.length != 1) filter_ulli(document.querySelector('.c4g-layertree > ul:nth-child(2)'));
            }, 350);
          };

          wrapperElement.appendChild(dv);
        }
        wrapperElement.appendChild(wrapper);
      }
    }

    // end of "addItems()"
    /**
     * Function which checks for a given layer id, if any of the childs are currently selected.
     * @param layerUid
     * @returns {boolean}
     */

  }, {
    key: "checkChildSelections",
    value: function checkChildSelections(layerUid) {
      var layer, childActive, self;
      self = this;
      childActive = 0;
      layer = self.proxy.layerController.arrLayers[layerUid];
      if (layer && layer.childs && layer.childs.length > 0) {
        // layer has childs
        layer.childs.forEach(function (child) {
          if (self.proxy.activeLayerIds[child.id]) {
            childActive = childActive + 1;
          } else {
            // check if any childs of childs are active
            childActive = childActive + self.checkChildSelections(child.uid);
          }
        });
      }
      return childActive;
    } // end of "checkChildSelections()"

    /**
     * Function for coloring the layerswitcher entries, if there are any sublayers selected
     * @param entry
     */

  }, {
    key: "handleSelectedChilds",
    value: function handleSelectedChilds(entry) {
      if (this.checkChildSelections(jQuery(entry).data('uid')) >= 1) {
        jQuery(entry).css('font-weight', 'bold');
      } else {
        jQuery(entry).css('font-weight', 'normal');
      }
      this.starboard.update();
      return true;
    }
  }, {
    key: "updateParentLayers",
    value: function updateParentLayers(entry, layerUid, clickedLayer) {
      var layer, parentEntry, parentLayer;

      layer = this.proxy.layerController.arrLayers[layerUid];
      if (layer.pid != this.starboard.options.mapController.data.mapId) {
        // the layer has parents
        // by this we can access only the single span where the parent entry is in
        parentLayer = this.proxy.layerController.arrLayers[layer.pid];
        if (parentLayer) {
          parentEntry = entry.parentNode.parentNode.parentNode.getElementsByTagName('a')[0];
          if (parentEntry) {
            if (this.proxy.activeLayerIds[clickedLayer.id]) {
              jQuery(parentEntry).css('font-weight', 'bold');
            } else {
              if (this.checkChildSelections(jQuery(parentEntry).data('uid')) >= 1) {
                jQuery(parentEntry).css('font-weight', 'bold');
              } else {
                jQuery(parentEntry).css('font-weight', 'normal');
                //jQuery(parentEntry).addClass(cssConstants.INACTIVE);
              }
            }
            this.updateParentLayers(parentEntry, parentLayer.id, parentLayer);
          }
        }
      } else {
        return false;
      }
    }
  }]);

  return Layerswitcher;
}(); // end of "add methods"

/***/ }),

/***/ "./Resources/public/js/c4g-maps-control-zoomlevel.js":
/*!***********************************************************!*\
  !*** ./Resources/public/js/c4g-maps-control-zoomlevel.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Zoomlevel = undefined;

var _c4gMapsConstant = __webpack_require__(/*! ./c4g-maps-constant */ "./Resources/public/js/c4g-maps-constant.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This file is part of con4gis,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * the gis-kit for Contao CMS.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @package    con4gis
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @version    6
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author     con4gis contributors (see "authors.txt")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @license    LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @copyright  Küstenschmiede GmbH Software & Design
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @link       https://www.con4gis.org
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

'use strict';

var Zoomlevel = exports.Zoomlevel = function (_ol$control$Control) {
  _inherits(Zoomlevel, _ol$control$Control);

  function Zoomlevel(options) {
    _classCallCheck(this, Zoomlevel);

    var _this = _possibleConstructorReturn(this, (Zoomlevel.__proto__ || Object.getPrototypeOf(Zoomlevel)).call(this, options));

    var self, element, updateZoomlevel;

    self = _this;

    if (!options || !options.mapController) {
      var _ret;

      console.warn('Zoomlevel control needs to know the map.');
      return _ret = false, _possibleConstructorReturn(_this, _ret);
    }

    // default options
    options = jQuery.extend({
      className: _c4gMapsConstant.cssConstants.ZOOM_LEVEL,
      undefinedHTML: ''
    }, options);

    var mapView = options.mapController.map.getView();

    element = document.createElement('div');
    element.className = options.className;
    element.innerHTML = mapView.getZoom();

    updateZoomlevel = function updateZoomlevel() {
      element.innerHTML = parseInt(mapView.getZoom());
    };

    options.mapController.map.getView().on('change:resolution', function () {
      updateZoomlevel();
    });

    _this.view = mapView;

    // inheritance-stuff
    ol.control.Control.call(_this, {
      element: element,
      target: options.target
    });
    return _this;
  }

  return Zoomlevel;
}(ol.control.Control);

/***/ }),

/***/ "./Resources/public/js/c4g-maps-i18n.js":
/*!**********************************************!*\
  !*** ./Resources/public/js/c4g-maps-i18n.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLanguage = getLanguage;

var _c4gMapsConstantI18nDe = __webpack_require__(/*! ./c4g-maps-constant-i18n-de */ "./Resources/public/js/c4g-maps-constant-i18n-de.js");

var _c4gMapsConstantI18nEn = __webpack_require__(/*! ./c4g-maps-constant-i18n-en */ "./Resources/public/js/c4g-maps-constant-i18n-en.js");

/*
 * This file is part of con4gis,
 * the gis-kit for Contao CMS.
 *
 * @package    con4gis
 * @version    6
 * @author     con4gis contributors (see "authors.txt")
 * @license    LGPL-3.0-or-later
 * @copyright  Küstenschmiede GmbH Software & Design
 * @link       https://www.con4gis.org
 */

/**
 *  This script imports all different languages and exports the one that is valid for the configured language.
 */
function getLanguage(mapData) {
  if (mapData.lang === "de") {
    return _c4gMapsConstantI18nDe.langConstantsGerman;
  } else if (mapData.lang === "en") {
    return _c4gMapsConstantI18nEn.langConstantsEnglish;
  } else {
    // fallback
    return _c4gMapsConstantI18nEn.langConstantsEnglish;
  }
}

/***/ }),

/***/ "./Resources/public/js/c4g-maps-interaction-geopicker.js":
/*!***************************************************************!*\
  !*** ./Resources/public/js/c4g-maps-interaction-geopicker.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * This file is part of con4gis,
 * the gis-kit for Contao CMS.
 *
 * @package    con4gis
 * @version    6
 * @author     con4gis contributors (see "authors.txt")
 * @license    LGPL-3.0-or-later
 * @copyright  Küstenschmiede GmbH Software & Design
 * @link       https://www.con4gis.org
 */



Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GeoPicker = exports.GeoPicker = function (_ol$interaction$Inter) {
  _inherits(GeoPicker, _ol$interaction$Inter);

  /**
   *
   * @param options
   * @returns {boolean}
   * @constructor
   */
  function GeoPicker(options) {
    _classCallCheck(this, GeoPicker);

    var mapData, mapContainer, lat, lon, latIdx, lonIdx, latRnd, lonRnd;

    var _this = _possibleConstructorReturn(this, (GeoPicker.__proto__ || Object.getPrototypeOf(GeoPicker)).call(this, { handleEvent: options.handleEvent }));

    _this.options = options || {};

    if (!_this.options.mapContainer || !_this.options.mapContainer.data) {
      var _ret;

      console.warn('The GeoPicker needs a "mapContainer" in order to work.');
      return _ret = false, _possibleConstructorReturn(_this, _ret);
    }

    mapData = _this.options.mapContainer.data;
    mapContainer = _this.options.mapContainer;
    // configurate geopicker
    _this.$fieldGeoX = jQuery(mapData.geopicker.input_geo_x);
    _this.$fieldGeoY = jQuery(mapData.geopicker.input_geo_y);

    _this.opticLayerSource = new ol.source.Vector({});
    _this.opticLayerVector = new ol.layer.Vector({
      source: _this.opticLayerSource,
      style: _this.geoPickerStyleFunction
    });
    _this.opticLayerFeature = null;

    if (_this.$fieldGeoX.val() && _this.$fieldGeoY.val()) {
      lat = _this.$fieldGeoY.val();
      lon = _this.$fieldGeoX.val();

      if (mapData.geopicker.anonymous) {
        _this.$fieldGeoY.remove();
        _this.$fieldGeoX.remove();

        latIdx = lat.indexOf('.');
        lonIdx = lon.indexOf('.');
        lat = lat.replace(/\D/g, "");
        lon = lon.replace(/\D/g, "");
        latRnd = Math.round(Math.random() * (99999999999 - 1) + 1);
        lonRnd = Math.round(Math.random() * (99999999999 - 1) + 1);
        if (latRnd > 49999999999) {
          lat = parseInt(lat) - latRnd;
        } else {
          lat = parseInt(lat) + latRnd;
        }
        if (lonRnd < 50000000000) {
          lon = parseInt(lon) - lonRnd;
        } else {
          lon = parseInt(lon) + lonRnd;
        }
        lat = lat + "";
        lon = lon + "";
        lat = lat.substr(0, latIdx) + '.' + lat.substr(latIdx, lat.length - latIdx);
        lon = lon.substr(0, lonIdx) + '.' + lon.substr(lonIdx, lon.length - lonIdx);
      }

      _this.opticLayerFeature = new ol.Feature({
        geometry: new ol.geom.Point(ol.proj.fromLonLat([parseFloat(lon), parseFloat(lat)])),
        pickerColor: [0, 180, 100, 1],
        anonymous: mapData.geopicker.anonymous
      });

      _this.opticLayerSource.addFeature(_this.opticLayerFeature);

      mapContainer.map.getView().fit(_this.opticLayerSource.getExtent(), mapContainer.map.getSize());
      // set zoom so we can see some tiles without error
      mapContainer.map.getView().setZoom(15);
    } else if (mapData.geoLocation && typeof mapData.geoLocation.setTracking === 'function') {
      mapData.geoLocation.setTracking(true);
    }
    mapContainer.map.addLayer(_this.opticLayerVector);

    //TODO wenn geopicker.clickDisabled (oder so) gesetzt ist, this.options.handleEvent = function(){}
    return _this;
  }

  _createClass(GeoPicker, [{
    key: 'geoPickerStyleFunction',
    value: function geoPickerStyleFunction(feature, projection, getId) {
      var color, white, result;

      if (getId) {
        return -1;
      }

      white = [255, 255, 255, 1];
      if (feature && typeof feature.get === 'function' && feature.get('pickerColor')) {
        color = feature.get('pickerColor');
      } else {
        color = [200, 0, 0, 0.7];
      }

      result = [];
      if (feature && typeof feature.get === 'function' && !feature.get('anonymous')) {
        result.push(new ol.style.Style({
          image: new ol.style.Circle({
            radius: 2,
            fill: new ol.style.Fill({
              color: color
            }),
            stroke: new ol.style.Stroke({
              color: white,
              width: 2
            })
          }),
          zIndex: Infinity
        }));
        result.push(new ol.style.Style({
          image: new ol.style.Circle({
            radius: 20,
            stroke: new ol.style.Stroke({
              color: white,
              width: 4
            })
          }),
          zIndex: Infinity
        }));
        result.push(new ol.style.Style({
          image: new ol.style.Circle({
            radius: 20,
            stroke: new ol.style.Stroke({
              color: color,
              width: 2
            })
          }),
          zIndex: Infinity
        }));
        result.push(new ol.style.Style({
          image: new ol.style.Circle({
            radius: 40,
            stroke: new ol.style.Stroke({
              color: white,
              width: 4
            })
          }),
          zIndex: Infinity
        }));
        result.push(new ol.style.Style({
          image: new ol.style.Circle({
            radius: 40,
            stroke: new ol.style.Stroke({
              color: color,
              width: 2
            })
          }),
          zIndex: Infinity
        }));
      }

      result.push(new ol.style.Style({
        image: new ol.style.Circle({
          radius: 60,
          stroke: new ol.style.Stroke({
            color: white,
            width: 4
          })
        }),
        zIndex: Infinity
      }));

      result.push(new ol.style.Style({
        image: new ol.style.Circle({
          radius: 60,
          stroke: new ol.style.Stroke({
            color: color,
            width: 2
          })
        }),
        zIndex: Infinity
      }));

      return result;
    }
  }, {
    key: 'handleEvent',
    value: function handleEvent(mapBrowserEvent) {
      if (mapBrowserEvent.type === "singleclick") {
        if (!this.options.disableClickEvent && !this.options.mapContainer.data.geopicker.disabled) {
          return !this.pick(mapBrowserEvent.coordinate);
        }
      }

      return true;
    }
  }, {
    key: 'pick',
    value: function pick(coordinate) {
      var arrLatLon;

      arrLatLon = ol.proj.toLonLat(coordinate);

      this.opticLayerFeature = new ol.Feature({
        geometry: new ol.geom.Point(coordinate)
      });

      this.opticLayerSource.clear();
      this.opticLayerSource.addFeature(this.opticLayerFeature);

      this.$fieldGeoX.val(arrLatLon[0]);
      this.$fieldGeoY.val(arrLatLon[1]);
      this.$fieldGeoX.change();
      this.$fieldGeoY.change();

      return true;
    }
  }]);

  return GeoPicker;
}(ol.interaction.Interaction);

/***/ }),

/***/ "./Resources/public/js/c4g-maps-main.js":
/*!**********************************************!*\
  !*** ./Resources/public/js/c4g-maps-main.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _c4gMaps = __webpack_require__(/*! ./c4g-maps */ "./Resources/public/js/c4g-maps.js");

window.initMaps = function (mapData) {
  for (var key in mapData) {
    if (mapData.hasOwnProperty(key)) {
      var mapController = new _c4gMaps.MapController(mapData[key]);
    }
  }
}; /*
    * This file is part of con4gis,
    * the gis-kit for Contao CMS.
    *
    * @package    con4gis
    * @version    6
    * @author     con4gis contributors (see "authors.txt")
    * @license    LGPL-3.0-or-later
    * @copyright  Küstenschmiede GmbH Software & Design
    * @link       https://www.con4gis.org
    */

jQuery(document).ready(function () {
  if (typeof window.mapData !== "undefined") {
    window.initMaps(window.mapData);
  }
});

/***/ }),

/***/ "./Resources/public/js/c4g-maps-misc-maphover.js":
/*!*******************************************************!*\
  !*** ./Resources/public/js/c4g-maps-misc-maphover.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MapHover = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * This file is part of con4gis,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * the gis-kit for Contao CMS.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @package    con4gis
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @version    6
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @author     con4gis contributors (see "authors.txt")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @license    LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @copyright  Küstenschmiede GmbH Software & Design
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @link       https://www.con4gis.org
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _c4gMapsMiscTooltippopup = __webpack_require__(/*! ./c4g-maps-misc-tooltippopup */ "./Resources/public/js/c4g-maps-misc-tooltippopup.js");

var _c4gMapsUtils = __webpack_require__(/*! ./c4g-maps-utils */ "./Resources/public/js/c4g-maps-utils.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

'use strict';

var MapHover = exports.MapHover = function () {

  /**
   * @TODO
   * [MapHover description]
   *
   * @constructor
   *
   * @param {Object=} opt_options Control options.
   */
  function MapHover(options) {
    _classCallCheck(this, MapHover);

    this.options = options || {};

    // default options
    this.options = jQuery.extend({
      // mapController: undefined,
      activate: true
    }, this.options);

    if (!this.options.mapController) {
      console.warn('MapHover needs a mapController');
      return false;
    }

    // set needed vars
    this.listenerKey = false;
    this.map = this.options.mapController.map;
    this.lastFeatureStyle = null;
    this.lastHoveredFeature = null;

    // create tooltip
    this.hoverTooltip = new _c4gMapsMiscTooltippopup.TooltipPopUp({
      map: this.map,
      offset: [10, 10],
      horizontal: true,
      closeable: false
    });
    this.hoverTooltip.hide();

    if (this.options.activate) {
      this.activate();
    }
  }

  /**
   * @TODO: [activate description]
   *
   * @return  {[type]}  [description]
   */


  _createClass(MapHover, [{
    key: "activate",
    value: function activate() {
      if (!this.listenerKey) {
        this.listenerKey = this.map.on('pointermove', this.getHoverFunction(), this);
        //this.map.on('pointermove', this.changeFeatureStyles(), this);
      }
    } // end of "activate()"


    /**
     * @TODO: [deactivate description]
     *
     * @return  {[type]}  [description]
     */

  }, {
    key: "deactivate",
    value: function deactivate() {
      if (this.listenerKey) {
        ol.Observable.unByKey(this.listenerKey);
        this.listenerKey = false;
      }
    } // end of "deactivate()"


    /**
     * @TODO: [isActive description]
     *
     * @return  {[type]}  [description]
     */

  }, {
    key: "isActive",
    value: function isActive() {
      if (this.listenerKey) {
        return true;
      }
      return false;
    } // end of "getState()"


    /**
     * @TODO: [getHoverFunction description]
     *
     * @return  {[type]}  [description]
     */

  }, {
    key: "getHoverFunction",
    value: function getHoverFunction() {

      var self = this;

      return function (event) {

        var hovered,
            clustered,
            tooltipContent,
            tooltipHelper,
            features,
            tooltipLength,
            resolution,
            canvas,
            mapData = self.options.mapController.data,
            proxy = self.options.mapController.proxy;

        clustered = false;
        hovered = self.map.forEachFeatureAtPixel(event.pixel, function (feature, layer) {
          return {
            feature: feature,
            layer: layer
          };
        });
        resolution = self.map.getView().getResolution();

        if (!hovered) {
          self.hoverTooltip.hide();
          canvas = document.querySelector("canvas");
          jQuery(canvas).css('cursor', 'default');
          if (mapData.hover_popups === '1' && mapData.hover_popups_stay != '1') {
            window.c4gMapsPopup.$popup.removeClass(c4g.maps.constant.css.ACTIVE);
          }

          if (self.lastHoveredFeature && self.lastFeatureStyle) {
            self.lastHoveredFeature.setStyle(self.lastFeatureStyle);
            self.lastHoveredFeature = null;
          }
          return false;
        }

        canvas = document.querySelector("canvas");
        jQuery(canvas).css('cursor', 'pointer');

        if (hovered.feature && typeof hovered.feature.get === 'function' && hovered.feature.get('features')) {
          if (hovered.feature.get('features')[1]) {
            clustered = true;
          } else {
            hovered.feature = hovered.feature.get('features')[0];
          }
        }
        if (hovered.feature.getGeometry() && hovered.feature.getGeometry() instanceof ol.geom.LineString) {
          return false;
        }
        if (hovered.feature.get("hover_location") || self.lastHoveredFeature && self.lastHoveredFeature.get("hover_location")) {
          if (self.lastHoveredFeature && hovered.feature === self.lastHoveredFeature) {
            return false;
          }

          //set back styles when the features are not hovered anymore
          if (self.lastFeatureStyle) {
            if (self.lastHoveredFeature) {
              if (hovered.feature !== self.lastHoveredFeature) {
                if (self.lastFeatureStyle) {
                  self.lastHoveredFeature.setStyle(self.lastFeatureStyle);
                  //console.log("Changed back feature style");
                } else if (self.lastLayerStyle) {
                  self.lastHoveredFeature.setStyle(self.lastLayerStyle);
                  //console.log("Changed back layer-feature style");
                }
              }
            }
          }

          if (hovered.feature && _typeof(hovered.feature.getStyleFunction) && typeof hovered.feature.getStyleFunction === 'function' && typeof hovered.feature.getStyleFunction() === 'function') {
            self.lastHoveredFeature = hovered.feature;

            self.lastLayerStyle = hovered.layer.getStyle();
            self.lastFeatureStyle = self.lastLayerStyle(self.lastHoveredFeature);
            //TODO get onhover style from db (vllt schon in proxy drin?)
            if (hovered.feature.get('hover_style') && proxy.locationStyleController.arrLocStyles[hovered.feature.get("hover_style")]) {
              if (proxy.locationStyleController.arrLocStyles[hovered.feature.get("hover_style")].fnStyleFunction) {
                hovered.feature.setStyle(Function("feature", "data", "map", proxy.locationStyleController.arrLocStyles[hovered.feature.get("hover_style")].fnStyleFunction)(hovered.feature));
              } else {
                hovered.feature.setStyle(proxy.locationStyleController.arrLocStyles[hovered.feature.get("hover_style")].style(hovered.feature));
              }
            }
          } else if (hovered.layer && _typeof(hovered.layer.getStyleFunction) && typeof hovered.layer.getStyleFunction === 'function' && typeof hovered.layer.getStyleFunction() === 'function') {

            if (hovered.feature) {
              self.lastHoveredFeature = hovered.feature;
            } else {
              self.lastHoveredFeature = hovered.layer.getSource().getFeatures()[0];
              self.lastHoveredFeature = self.lastHoveredFeature.get('features')[0];
            }

            self.lastLayerStyle = hovered.layer.getStyle();
            self.lastFeatureStyle = self.lastLayerStyle(self.lastHoveredFeature);
            if (hovered.feature.get('hover_style')) {
              if (!proxy.locationStyleController.arrLocStyles[hovered.feature.get("hover_style")]) {
                var arrIds = [];
                arrIds.push(hovered.feature.get("hover_style"));
                proxy.locationStyleController.loadLocationStyles(arrIds);
                self.lastHoveredFeature = null;
                return null;
              }
              if (proxy.locationStyleController.arrLocStyles[hovered.feature.get("hover_style")].fnStyleFunction) {
                hovered.feature.setStyle(Function("feature", "data", "map", proxy.locationStyleController.arrLocStyles[hovered.feature.get("hover_style")].fnStyleFunction)(hovered.feature));
              } else {
                hovered.feature.setStyle(proxy.locationStyleController.arrLocStyles[hovered.feature.get("hover_style")].style(hovered.feature));
              }
            }
          }
        }

        if (hovered && hovered.feature && hovered.feature.get('styleUrl')) {
          //if this property is set, we have a feature that has none of our styles => no tooltip
          return false;
        }
        // catch the case the layer is a baselayer (vector tiles)
        if (hovered && hovered.layer && hovered.layer.type === "VECTOR_TILE") {
          return false;
        }

        // set hover tooltips
        tooltipContent = false;
        if (!clustered && hovered.feature && typeof hovered.feature.get === 'function' && (hovered.feature.get('tooltip') || hovered.feature.get('graphicTitle'))) {
          tooltipContent = hovered.feature.get('tooltip');
          if (!tooltipContent) {
            tooltipContent = hovered.feature.get('graphicTitle');
          } else if ((typeof tooltipContent === "undefined" ? "undefined" : _typeof(tooltipContent)) === 'object' && tooltipContent.element && tooltipContent.element.childNodes[1]) {
            tooltipContent = tooltipContent.element.childNodes[1].innerHTML;
          }
          // @TODO: Check & fix
        } else if (hovered.feature && _typeof(hovered.feature.getStyleFunction) && typeof hovered.feature.getStyleFunction === 'function' && typeof hovered.feature.getStyleFunction() === 'function' && proxy.locationStyleController.arrLocStyles && proxy.locationStyleController.arrLocStyles[hovered.feature.getStyleFunction()(resolution)] && proxy.locationStyleController.arrLocStyles[hovered.feature.getStyleFunction()(resolution)].tooltip) {
          tooltipContent = proxy.locationStyleController.arrLocStyles[hovered.feature.getStyleFunction()(resolution)].tooltip;
          // @TODO: Check
        } else if (hovered.layer && _typeof(hovered.layer.getStyleFunction) && typeof hovered.layer.getStyleFunction === 'function' && typeof hovered.layer.getStyleFunction() === 'function' && proxy.locationStyleController.arrLocStyles && proxy.locationStyleController.arrLocStyles[hovered.layer.getStyleFunction()()] && proxy.locationStyleController.arrLocStyles[hovered.layer.getStyleFunction()()].tooltip) {
          tooltipContent = proxy.locationStyleController.arrLocStyles[hovered.layer.getStyleFunction()()].tooltip;
        } else if (hovered.layer && typeof hovered.layer.getStyleFunction === 'function' && typeof hovered.layer.getStyleFunction() === 'function' && proxy.locationStyleController.arrLocStyles && proxy.locationStyleController.arrLocStyles[hovered.layer.getStyleFunction()(null, null, 1)] && proxy.locationStyleController.arrLocStyles[hovered.layer.getStyleFunction()(null, null, 1)].tooltip) {
          tooltipContent = proxy.locationStyleController.arrLocStyles[hovered.layer.getStyleFunction()(null, null, 1)].tooltip;
        } else if (hovered.layer && hovered.layer.tooltip) {
          tooltipContent = hovered.layer.tooltip;
        }
        if (clustered && hovered.feature.get('features')) {
          features = hovered.feature.get('features');
          if (features[0].get('tooltip') && features[0].get('tooltip_length')) {
            tooltipContent = features[0].get('tooltip');
            tooltipLength = parseInt(features[0].get('tooltip_length'));
            for (var i = 1; i < features.length; i++) {
              if (features[i].get('tooltip') && features[i].get('tooltip') != '') {
                tooltipContent = tooltipContent + ', ' + features[i].get('tooltip');
              }
            }
            if (tooltipContent.length > tooltipLength + 3) {
              if (tooltipContent = tooltipContent.slice(0, tooltipLength)) {
                tooltipContent = tooltipContent + '...';
              }
            }
          } else if (hovered.layer.tooltip && hovered.layer.tooltip_length) {
            tooltipHelper = tooltipContent;
            tooltipContent = '';
            tooltipLength = parseInt(hovered.layer.tooltip_length);
            for (i = 0; i < features.length; i++) {
              var singleTooltip = _c4gMapsUtils.utils.replaceAllPlaceholders(tooltipHelper, features[i], hovered.layer, mapData.lang);
              if (singleTooltip != '') {
                if (tooltipContent == '') tooltipContent = singleTooltip;else tooltipContent = tooltipContent + ', ' + singleTooltip;
              }
            }
            if (tooltipContent.length > tooltipLength + 3) {
              if (tooltipContent = tooltipContent.slice(0, tooltipLength)) {
                tooltipContent = tooltipContent + '...';
              }
            }
          }
        }

        if (tooltipContent) {
          tooltipContent = _c4gMapsUtils.utils.decodeGeoJsonProperty(tooltipContent);

          // replace placeholders if possible
          if (hovered.feature.get('features')) {}
          tooltipContent = _c4gMapsUtils.utils.replaceAllPlaceholders(tooltipContent, hovered.feature, hovered.layer, mapData.lang);

          if (tooltipContent.trim()) {
            // popup config
            self.hoverTooltip.setPosition(event.coordinate);
            self.hoverTooltip.setContent(tooltipContent);
            self.hoverTooltip.show();
          } else {
            self.hoverTooltip.hide();
          }
        } else {
          self.hoverTooltip.hide();
        }
        if (mapData.hover_popups === '1' && !clustered && hovered.feature) {
          var popupInfos = {};

          if (hovered.feature.get('popup')) {
            popupInfos = hovered.feature.get('popup');
          } else if (hovered.feature.get('loc_linkurl')) {
            return;
          } else if (hovered.layer && hovered.layer.popup) {
            popupInfos = hovered.layer.popup;
          } else {
            return;
          }
          var coord = hovered.feature.getGeometry().getCoordinates();
          if (!coord || coord && coord[0] && coord[0].length) {
            var extent = hovered.feature.getGeometry().getExtent();
            coord = self.map.getCoordinateFromPixel(event.pixel);
            coord = [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
          }

          window.c4gMapsPopup.popup.setPosition(coord);

          if (popupInfos.content) {
            window.c4gMapsPopup.$content.html('');
            window.c4gMapsPopup.$popup.addClass(c4g.maps.constant.css.ACTIVE).addClass(c4g.maps.constant.css.LOADING);
            window.c4gMapsPopup.spinner.show();

            if (popupInfos.async === false) {
              var objPopup = {};
              objPopup.popup = popupInfos;
              objPopup.feature = hovered.feature;
              objPopup.layer = hovered.layer;
              // Call the popup hook for plugin specific popup content
              if (window.c4gMapsHooks !== undefined && _typeof(window.c4gMapsHooks.proxy_fillPopup) === 'object') {
                _c4gMapsUtils.utils.callHookFunctions(window.c4gMapsHooks.proxy_fillPopup, objPopup);
              }
              proxy.setPopup(objPopup, proxy);
            } else {
              jQuery.ajax({
                dataType: "json",
                url: proxy.api_infowindow_url + '/' + popupInfos.content,
                done: function done(data) {
                  var popupInfo = {
                    async: popupInfos.async,
                    content: data.content,
                    popup: popupInfos.popup,
                    routing_link: popupInfos.routing_link
                  };

                  var objPopup = {};
                  objPopup.popup = popupInfo;
                  objPopup.feature = hovered.feature;
                  objPopup.layer = hovered.layer;

                  // Call the popup hook for plugin specific popup content
                  if (window.c4gMapsHooks !== undefined && _typeof(window.c4gMapsHooks.proxy_fillPopup) === 'object') {
                    _c4gMapsUtils.utils.callHookFunctions(window.c4gMapsHooks.proxy_fillPopup, objPopup);
                  }

                  proxy.setPopup(objPopup, proxy);
                }
              });
            }
          } else {
            window.c4gMapsPopup.$popup.removeClass(c4g.maps.constant.css.ACTIVE);
          }
        }
      };
    } // end of "getHoverFunction()"

  }, {
    key: "changeFeatureStyles",
    value: function changeFeatureStyles() {
      //TODO: change style of features which are hovered and have the option to change style on hover enabled
    }
  }]);

  return MapHover;
}();

/***/ }),

/***/ "./Resources/public/js/c4g-maps-misc-spinner.js":
/*!******************************************************!*\
  !*** ./Resources/public/js/c4g-maps-misc-spinner.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Spinner = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * This file is part of con4gis,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * the gis-kit for Contao CMS.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @package    con4gis
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @version    6
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @author     con4gis contributors (see "authors.txt")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @license    LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @copyright  Küstenschmiede GmbH Software & Design
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @link       https://www.con4gis.org
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _c4gMapsConstant = __webpack_require__(/*! ./c4g-maps-constant */ "./Resources/public/js/c4g-maps-constant.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

'use strict';

var Spinner = exports.Spinner = function () {

  /**
   * @TODO
   * [Spinner description]
   *
   * @constructor
   *
   * @param {Object=} opt_options Control options.
   */
  function Spinner(opt_options) {
    _classCallCheck(this, Spinner);

    var options, target, spinnerSpan;

    options = opt_options || {};

    // default options
    options = jQuery.extend({
      className: '',
      target: '.' + _c4gMapsConstant.cssConstants.OL_VIEWPORT
    }, options);

    if (options.className) {
      options.className = ' ' + options.className;
    }

    this.element = document.createElement('div');
    this.element.className = _c4gMapsConstant.cssConstants.SPINNER + options.className + ' ' + _c4gMapsConstant.cssConstants.HIDE;
    jQuery(options.target).append(this.element);

    spinnerSpan = document.createElement('span');
    spinnerSpan.className = _c4gMapsConstant.cssConstants.ICON + ' ' + _c4gMapsConstant.cssConstants.ANIMATION_SPIN;
    this.element.appendChild(spinnerSpan);

    this.additionalActivationCounter = 0;
  }

  _createClass(Spinner, [{
    key: 'show',
    value: function show() {
      if (jQuery(this.element).hasClass(_c4gMapsConstant.cssConstants.HIDE)) {
        jQuery(this.element).removeClass(_c4gMapsConstant.cssConstants.HIDE);
      } else {
        this.additionalActivationCounter += 1;
      }
    }
  }, {
    key: 'hide',
    value: function hide() {
      if (jQuery(this.element).hasClass(_c4gMapsConstant.cssConstants.HIDE)) {
        //console.warn('Spinner is already hidden.');
      } else {
        if (this.additionalActivationCounter === 0) {
          jQuery(this.element).addClass(_c4gMapsConstant.cssConstants.HIDE);
        } else {
          this.additionalActivationCounter -= 1;
        }
      }
    }
  }]);

  return Spinner;
}();

/***/ }),

/***/ "./Resources/public/js/c4g-maps-misc-tooltippopup.js":
/*!***********************************************************!*\
  !*** ./Resources/public/js/c4g-maps-misc-tooltippopup.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TooltipPopUp = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * This file is part of con4gis,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * the gis-kit for Contao CMS.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @package    con4gis
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @version    6
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @author     con4gis contributors (see "authors.txt")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @license    LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @copyright  Küstenschmiede GmbH Software & Design
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @link       https://www.con4gis.org
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _c4gMapsConstant = __webpack_require__(/*! ./c4g-maps-constant */ "./Resources/public/js/c4g-maps-constant.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

'use strict';

var TooltipPopUp = exports.TooltipPopUp = function () {

  /**
   * @TODO
   * [TooltipPopUp description]
   *
   * @constructor
   *
   * @param {Object=} opt_options Control options.
   */
  function TooltipPopUp(opt_options) {
    _classCallCheck(this, TooltipPopUp);

    var self, addClassName, closeButton;

    self = this;
    this.options = opt_options || {};

    // default options
    this.options = jQuery.extend({
      // className: ''
      // closeFunction: null
      // map: null
      horizontal: false,
      closeable: false,
      offset: [1, -1],
      position: [0, 0]
    }, this.options);

    // prepare additional classes
    addClassName = '';
    if (this.options.className) {
      addClassName = ' ' + this.options.className;
    }
    if (this.options.horizontal) {
      addClassName += ' ' + _c4gMapsConstant.cssConstants.HORIZONTAL;
    }
    if (this.options.closeable) {
      addClassName += ' ' + _c4gMapsConstant.cssConstants.CLOSEABLE;
    }

    this.element = document.createElement('div');
    this.element.className = _c4gMapsConstant.cssConstants.TOOLTIP_POPUP + addClassName;

    if (this.options.closeable) {
      closeButton = document.createElement('button');
      closeButton.className = _c4gMapsConstant.cssConstants.ICON + ' ' + _c4gMapsConstant.cssConstants.POPUP_CLOSE;
      this.element.appendChild(closeButton);

      jQuery(closeButton).click(function () {
        self.close();
      });
    }

    this.contentContainer = document.createElement('div');
    this.element.appendChild(this.contentContainer);

    this.overlay = new ol.Overlay({
      element: this.element,
      insertFirst: false,
      offset: this.options.offset,
      positioning: 'bottom-left'
    });

    if (this.options.map) {
      this.options.map.addOverlay(this.overlay);
    }

    if (this.options.position) {
      this.overlay.setPosition(this.options.position);
    }
  }

  _createClass(TooltipPopUp, [{
    key: 'close',
    value: function close() {
      if (typeof this.options.closeFunction === 'function') {
        this.options.closeFunction();
      }

      if (this.options.map) {
        this.options.map.removeOverlay(this.overlay);
      }
    }

    /**
     * @TODO
     * [show description]
     *
     * @return  {[type]}  [description]
     */

  }, {
    key: 'show',
    value: function show() {
      if (jQuery(this.element).hasClass(_c4gMapsConstant.cssConstants.HIDE)) {
        jQuery(this.element).removeClass(_c4gMapsConstant.cssConstants.HIDE);
      }
    }

    /**
     * @TODO
     * [hide description]
     *
     * @return  {[type]}  [description]
     */

  }, {
    key: 'hide',
    value: function hide() {
      if (!jQuery(this.element).hasClass(_c4gMapsConstant.cssConstants.HIDE)) {
        jQuery(this.element).addClass(_c4gMapsConstant.cssConstants.HIDE);
      }
    }

    /**
     * @TODO
     * [getContent description]
     *
     */

  }, {
    key: 'getContent',
    value: function getContent() {
      return this.contentContainer.innerHTML;
    }

    /**
     * @TODO
     * [getPosition description]
     *
     */

  }, {
    key: 'getPosition',
    value: function getPosition() {
      return this.overlay.getPosition();
    }

    /**
     * @TODO
     * [setContent description]
     *
     * @param  {[type]}  content  [description]
     */

  }, {
    key: 'setContent',
    value: function setContent(content) {
      this.contentContainer.innerHTML = content;
    }

    /**
     * @TODO
     * [setPosition description]
     *
     * @param  {[type]}  coordinates  [description]
     */

  }, {
    key: 'setPosition',
    value: function setPosition(coordinates) {
      this.overlay.setPosition(coordinates);
    }
  }]);

  return TooltipPopUp;
}(); // End of "add methods to TooltipPopUp"

/***/ }),

/***/ "./Resources/public/js/c4g-maps-popup-info-de.js":
/*!*******************************************************!*\
  !*** ./Resources/public/js/c4g-maps-popup-info-de.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.trim = trim;
exports.isMobile = isMobile;
exports.fnHeader = fnHeader;
exports.fnFooter = fnFooter;
exports.fnGetTranslate_Type = fnGetTranslate_Type;
exports.fnArztInfo = fnArztInfo;
exports.fnKraftwerkInfo = fnKraftwerkInfo;
exports.fnWertstoffinfo = fnWertstoffinfo;
exports.fnAdditionalBuildingInfos = fnAdditionalBuildingInfos;
exports.fnSicherheitAdditional = fnSicherheitAdditional;
exports.fnWreckInfo = fnWreckInfo;
exports.fnKlosterAdditional = fnKlosterAdditional;
/*
 * This file is part of con4gis,
 * the gis-kit for Contao CMS.
 *
 * @package    con4gis
 * @version    6
 * @author     con4gis contributors (see "authors.txt")
 * @license    LGPL-3.0-or-later
 * @copyright  Küstenschmiede GmbH Software & Design
 * @link       https://www.con4gis.org
 */
function trim(b) {
    return b.replace(/^\s+/, "").replace(/\s+$/, "");
}
function isMobile() {
    return (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino|android|ipad|playbook|silk/i.test(navigator.userAgent || navigator.vendor || window.opera) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test((navigator.userAgent || navigator.vendor || window.opera).substr(0, 4))
    );
}function translate(b) {
    var a = trim(b);return "yes" == a || "Yes" == a ? "Ja" : "no" == a ? "Nein" : "No" == a ? "nein" : "limited" == a ? "Eingeschr\xE4nkt" : "designated" == a ? "Ja" : "wood" == a ? "Holz" : "metal" == a ? "Metall" : "concrete" == a ? "Beton" : "plastic" == a ? "Plastik" : "stone" == a ? "Stein" : "steel" == a ? "Stahl" : "brick" == a ? "Ziegel" : "reinforced_concrete" == a ? "Stahlbeton" : "masonry" == a ? "Mauerwerk" : b;
}
var fnStandardInfoPopup = exports.fnStandardInfoPopup = function fnStandardInfoPopup(b, a) {
    var c = b.getProperties(),
        d = "",
        e;if ("function" === typeof a) {
        var f = a.call(b)[0].getImage();if (f) try {
            e = f.getSrc();
        } catch (g) {
            e = "";
        }
    } else {
        f = a.getImage();try {
            e = f.getSrc();
        } catch (h) {
            e = "";
        }
    }d += fnHeader(c, e);d += fnContent(c);d += fnFooter(c, b.get("osm_type") + "/" + b.getId());return '<div class="c4g_popup_text">' + d + "</div>";
},
    fnReducedInfoPopup = exports.fnReducedInfoPopup = function fnReducedInfoPopup(b, a) {
    var c = b.getProperties(),
        d = "",
        e = !1,
        f;f = "function" === typeof a ? a.call(b)[0].getImage().getSrc() : a.getImage().getSrc();if ("restaurant" == c.amenity || "pub" == c.amenity || "biergarten" == c.amenity) e = !0;"hotel" == c.tourism && (e = !0);"guest_house" == c.tourism && (e = !0);"chalet" == c.tourism && (e = !0);"hostel" == c.tourism && (e = !0);"alpine_hut" == c.tourism && (e = !0);if ("artwork" == c.tourism || "artwork" == c.amenity) e = !0;if ("museum" == c.tourism || "museum" == c.amenity) e = !0;"cinema" == c.amenity && (e = !0);"theatre" == c.amenity && (e = !0);if ("attraction" == c.amenity || "fountain" == c.amenity || "monument" == c.historic || "city_gate" == c.historic || "ruins" == c.historic || "castle" == c.historic || "attraction" == c.tourism) e = !0;"playground" == c.leisure && (e = !0);c.aerialway && (e = !0);if ("swimming_pool" == c.amenity || "swimming_pool" == c.leisure || "swimming" == c.sport) e = !0;"station" == c.railway && (e = !0);"swimming" == c.sport && (e = !0);"swimming_pool" == c.leisure && (e = !0);"swimming_pool" == c.amenity && (e = !0);"waterpark" == c.leisure && (e = !0);c.water_park && (e = !0);"sports_centre" == c.leisure && (e = !0);switch (e) {case !1:
            d += fnHeader(c, f);d += fnContent(c);d += fnFooter(c, b.get("osm_type") + "/" + b.getId());break;case !0:
            d += fnHeader(c, f);}return '<div class="c4g_popup_text">' + d + "</div>";
};
function fnHeader(b, a) {
    var c = "",
        d = "32px";a && -1 != a.indexOf("icon_mapcil") && (d = "250px", a = a.replace("icon_mapcil", "logo_mapcil"));if (b.name || b["piste:name"] || b["xmas:name"] || b["xmas:location"]) {
        if (b.name) var e = b.name;b["piste:name"] && (e = b["piste:name"]);b["xmas:name"] && (e = b["xmas:name"]);b["xmas:location"] && (e = b["xmas:location"]);c += a ? '<img src="' + a + '" width="' + d + '" name="' + e + '" alt="' + e + '"><div class="c4g_popup_header_featurename">' + e + "</div>" : '<name="' + e + '" alt="' + e + '"><div class="c4g_popup_header_featurename">' + e + "</div>";
    } else a && (c += '<img src="' + a + '" width="' + d + '" name="' + a + '" alt="' + a + '">');c += fnGetTranslate_Type(b);return '<div class="c4g_popup_header">' + c + "</div>";
}
function fnFooter(b, a) {
    var c = "",
        d = !1;b["addr:housename"] && (c += "Geb\xE4udename: " + b["addr:housename"] + "<br/>", d = !0);b["addr:floor"] ? (c += "Etage: " + b["addr:floor"] + "<br/>", d = !0) : b["addr:level"] && (c += "Etage: " + b["addr:level"] + "<br/>", d = !0);b["addr:street"] && (c += b["addr:street"], c = b["addr:housenumber"] ? c + (" " + b["addr:housenumber"] + "<br/>") : c + "<br/>", d = !0);b["addr:postcode"] && (c += b["addr:postcode"] + " ");b["addr:city"] && (c += b["addr:city"] + "<br/>", d = !0);if (b.sqkm) if (b.sqkm = "" + b.sqkm, 3 < b.sqkm.length) {
        var e = b.sqkm.length % 3,
            f = 0 < e ? b.sqkm.substring(0, e) : "";for (var i = 0; i < Math.floor(b.sqkm.length / 3); i++) {
            f = 0 == e && 0 == i ? f + b.sqkm.substring(e + 3 * i, e + 3 * i + 3) : f + ("." + b.sqkm.substring(e + 3 * i, e + 3 * i + 3));
        }c += "Fl\xE4che: " + f + " Km\xB2<br/>";
    } else c += "Fl\xE4che " + b.sqkm + "<br/>";b["contact:phone"] && (c = isMobile() ? c + ('Telefon: <a href="tel:' + b["contact:phone"] + '">' + b["contact:phone"] + "</a><br/>") : c + ('Telefon: <a href="callto:' + b["contact:phone"] + '">' + b["contact:phone"] + "</a><br/>"), d = !0);b.phone && (c = isMobile() ? c + ('Telefon: <a href="tel:' + b.phone + '">' + b.phone + "</a><br/>") : c + ('Telefon: <a href="callto:' + b.phone + '">' + b.phone + "</a><br/>"), d = !0);b["contact:fax"] ? (c += "Telefax: " + b["contact:fax"] + "<br/>", d = !0) : b.fax && (c += "Telefax: " + b.fax + "<br/>", d = !0);b["contact:email"] ? (c += 'E-Mail-Adresse: <a href="mailto:' + b["contact:email"] + '">' + b["contact:email"] + "</a><br/>", d = !0) : b.email && (c += 'E-Mail-Adresse: <a href="mailto:' + b.email + '">' + b.email + "</a><br/>", d = !0);d && (c += "<br/>");if (b.opening_hours) {
        d = b.opening_hours;for (e = 0; 0 == e || 0 < d.indexOf(";");) {
            d = d.replace("PH", "FT"), d = d.replace("Tu", "Di"), d = d.replace("We", "Mi"), d = d.replace("Th", "Do"), d = d.replace("Su", "So"), d = d.replace("Mar", "M\xE4r"), d = d.replace("May", "Mai"), d = d.replace("Oct", "Okt"), d = d.replace("Dec", "Dez"), d = d.replace('"Please make a reservation"', '"Bitte vereinbaren Sie einen Termin"'), d = d.replace("off", "ausgenommen"), 0 < e && (d = d.replace(";", "<br/>")), e++;
        }c += "\xD6ffnungszeiten: <br/><div class=\"c4g_open_text\">" + d + "</div>";c = 0 < d.indexOf("FT") ? c + "(FT = Feiertag)<br/>" : c + "<br/>";
    }if (b["xmas:opening_hours"]) {
        d = b["xmas:opening_hours"];for (e = 0; 0 == e || 0 < d.indexOf(";");) {
            d = d.replace("PH", "FT"), d = d.replace("Tu", "Di"), d = d.replace("We", "Mi"), d = d.replace("Th", "Do"), d = d.replace("Su", "So"), d = d.replace("Mar", "M\xE4r"), d = d.replace("May", "Mai"), d = d.replace("Oct", "Okt"), d = d.replace("Dec", "Dez"), 0 < e && (d = d.replace(";", "<br/>")), e++;
        }c += "\xD6ffnungszeiten: <br/><div class=\"c4g_open_text\">" + d + "</div>";c = 0 < d.indexOf("FT") ? c + "(FT = Feiertag)<br/>" : c + "<br/>";
    }b["xmas:url"] && (d = "", d = b["xmas:url"], trim(d), -1 == d.indexOf("https://", 0) && -1 == d.indexOf("http://", 0) && (d = "http://" + d), c += 'Website: <a href="' + d + '" target="_blank">Link zur Website</a><br/>');b["contact:website"] ? (d = b["contact:website"], trim(d), -1 == d.indexOf("https://", 0) && -1 == d.indexOf("http://", 0) && (d = "http://" + d), c += 'Website: <a href="' + d + '" target="_blank">Link zur Website</a><br/>') : b.website && (d = b.website, trim(d), -1 == d.indexOf("https://", 0) && -1 == d.indexOf("http://", 0) && (d = "http://" + d), c += 'Website: <a href="' + d + '" target="_blank">Link zur Website</a><br/>');b.wikipedia && (d = b.wikipedia, trim(d), -1 == d.indexOf("https://", 0) && -1 == d.indexOf("http://", 0) && (d = "https://wikipedia.org/wiki/" + d), c += 'Wikipedia: <a href="' + d + '" target="_blank">Link zu Wikipedia</a><br/>');b.wikimedia_commons && (d = b.wikimedia_commons, trim(d), -1 == d.indexOf("https://", 0) && -1 == d.indexOf("http://", 0) && (d = "https://commons.wikimedia.org/wiki/" + d), c += 'Wikimedia: <a href="' + d + '" target="_blank">Link zu Wikimedia</a><br/>');b["contact:webcam"] && (d = b["contact:webcam"], trim(d), -1 == d.indexOf("https://", 0) && -1 == d.indexOf("http://", 0) && (d = "http://" + d), c += 'Webcam: <a href="' + d + '" target="_blank">Link zur Webcam</a><br/>');b.image && (c += '<img src="' + b.image + '" width="200px" name="' + b.name + '" alt="' + b.name + '"><br/>');d = "";b.internet_access && (d += "Internetzugriff: " + translate(b.internet_access) + "<br/>");b["internet_access:fee"] && (d += "Internet Geb\xFChr: " + translate(b["internet_access:fee"]) + "<br/>");b["wifi_access:operator"] && (d += "wifi Betreiber: " + b["wifi_access:operator"] + "<br/>");b["wifi_access:technology"] && (d += "wifi Technologie: " + b["wifi_access:technology"] + "<br/>");b["wifi_access:ssid"] && (d += "wifi ssid: " + b["wifi_access:ssid"] + "<br/>");"" != d && (c += 'Internetzugang vorhanden<br/><div class="c4g_shop_internet_access">' + d + "</div><br/>");b.wheelchair && (c += "rollstuhlgeeignet: " + translate(b.wheelchair) + "<br/>");b["wheelchair:description"] && (c += "Beschreibung: " + b["wheelchair:description"] + "<br/>");b["wheelchair:entrance_width"] && (c += "Breite des Eingangs in CM: " + b["wheelchair:entrance_width"] + "<br/>");b["wheelchair:step_height"] && (c += "H\xF6he der Stufe am Eingang in CM: " + b["wheelchair:step_height"] + "<br/>");b["wheelchair:rooms"] && (c += "Anzahl rollstuhlgerechter R\xE4ume: " + b["wheelchair:rooms"] + "<br/>");b["wheelchair:places"] && (c += "Anzahl der Rollstuhlpl\xE4tze: " + b["wheelchair:places"] + "<br/>");b["cent:places"] && (c += "Anzahl der Rollstuhlpl\xE4tze: " + b["wheelchair:places"] + "<br/>");b["ramp:wheelchair"] && (c += "Rampe f\xFCr Rollstuhlfahrer: " + b["ramp:wheelchair"] + "<br/>");b["capacity:disabled"] && (c += "Behindertenparkpl\xE4tze: " + translate(b["capacity:disabled"]) + "<br/>");b["toilets:wheelchair"] && (c += "Behinderdengerechte Toilette: " + translate(b["toilets:wheelchair"]) + "<br/>");b.centralkey && (c += "Zentralschl\xFCssel: " + b.centralkey + "<br/>");b.note && (c += b.note + "<br/>");b.description && (c += b.description + "<br/>");b.operator && (c += "Betreiber: " + b.operator + "<br/>");b.ref && (c += "Referenz: " + b.ref + "<br/>");"yes" == b.lit && (c += "Dieses Objekt ist beleuchtet.<br/>");b.shop && (d = "", b.brand && (d += "Markenzeichen: " + b.brand + "<br/>"), b.sells && (d += "Verkaufs: " + b.sells + "<br/>"), b.origin && (d += "Herkunftsl\xE4nder: " + b.origin + "<br/>"), "yes" == b.wholesale && (d += "Gro\xDFh\xE4ndler: Ja<br/>"), "" != d && (c += 'Weitere Angaben zum Shop: <br/><div class="c4g_shop_text">' + d + "</div><br/>"));a && (d = a, trim(d), d = d.replace(/\./, "/"), c = c + "<br/>" + ('OSM:    <a href="http://www.openstreetmap.org/' + d + '" target="_blank">Link zur OpenStreetMap</a><br/>'));return c = '<div class="c4g_popup_footer">' + c + "</div>";
}
function fnGetTranslate_Type(b) {
    var a = "";if ("doctors" == b.amenity || "doctor" == b.healthcare) a += "Arzt<br/>";if ("hospital" == b.amenity || "clinic" == b.amenity || "hospital" == b.healthcare || "clinic" == b.healthcare) a = "yes" == b.emergency ? a + "Krankenhaus mit Notaufnahme<br/>" : a + "Krankenhaus<br/>";"dentist" == b.amenity && (a += "Zahnarzt<br/>");if ("pharmacy" == b.amenity || "pharmacy" == b["health_facility:type"]) a += "Apotheke<br/>";if ("physiotherapist" == b.healthcare || "yes" == b["health_speciality:physiotherapy"]) a += "Physiotherapeut<br/>";
    if ("occupational_therapist" == b.healthcare || "yes" == b["health_speciality:occupational_therapy"] || "yes" == b["health_specialty:occupational_therapy"]) a += "Ergotherapeut<br/>";if ("psychotherapist" == b.healthcare || "yes" == b["health_speciality:psychotherapy"]) a += "Psychotherapeut<br/>";"alternative" == b.healthcare && (a += "Alternativ- und Komplement\xE4rmediziner<br/>");"midwife" == b.healthcare && (a += "Hebamme<br/>");if ("speech_therapist" == b.healthcare || "yes" == b["health_speciality:speech_therapy"]) a += "Logop\xE4de<br/>";
    "yes" == b["health_speciality:music_therapy"] && (a += "Musiktherapeut<br/>");"veterinary" == b.amenity && (a += "Tierarzt<br/>");"fire_station" == b.amenity && (a += "Feuerwehrhaus<br/>");"fire_extinguisher" == b.emergency && (a += "Feuerl\xF6scher<br/>");"aed" == b.emergency && (a += "Mobiler Defibrilator<br/>");"defibrillator" == b.emergency && (a += "Mobiler Defibrilator<br/>");"phone" == b.emergency && (a += "Notrufs\xE4ule<br/>");"police" == b.amenity && (a += "Polizeiwache<br/>");"ambulance_station" == b.emergency && (a += "Rettungswache<br/>");
    "technical" == b.emergency_service && (a += "Technisches Hilfswerk<br/>");"water" == b.emergency_service && (a += "Wasserrettungsstation<br/>");"baywatch" == b.waterway && (a += "Wasserwacht<br/>");"air" == b.emergency_service && (a += "Rettungshubschrauber<br/>");"emergency_access_point" == b.highway && (a += "Notfallpunkt<br/>");if ("lifeboat_station" == b.amenity || "lifeboat_station" == b.emergency) a += "Rettungsbootstation<br/>";"life_ring" == b.emergency && (a += "Rettungsring<br/>");"siren" == b.emergency && (a += "Sirene<br/>");"life_ring" == b.amenity && (a += "Rettungsring<br/>");"rescue_station" == b.amenity && (a += "Rettungsstation<br/>");"fire_hydrant" == b.emergency && ("underground" == b["fire_hydrant:type"] ? a += "Unterflurhydrant<br/>" : "pillar" == b["fire_hydrant:type"] ? a += "\xDCberflurhydrant<br/>" : "wall" == b["fire_hydrant:type"] ? a += "Wandhydrant<br/>" : "pond" == b["fire_hydrant:type"] && (a += "Saugstelle<br/>"));"suction_point" == b.emergency && (a += "Saugstelle<br/>");"fire_water_pond" == b.emergency && (a += "L\xF6schteich<br/>");"mountain" == b.emergency_service && (a += "Bergrettungsstation<br/>");"water_tank" == b.emergency && (a += "L\xF6schwassertank<br/>");"container" == b.recycling_type && (a += "Recycling Container<br/>");"recycling" == b.amenity && "yes" == b["recycling:excrement"] || "pump-out" == b["seamark:small_craft_facility:category"] ? a += "Absaugstation<br/>" : "recycling" == b.amenity && (a += "Wertstoffhof<br/>");"yes" == b["diet:pescetarian"] ? a += "pescetarische Gerichte vorhanden<br/>" : "only" == b["diet:pescetarian"] && (a += "nur pescetarische Gerichte<br/>");"yes" == b["diet:vegetarian"] ? a += "vegetarische Gerichte vorhanden<br/>" : "only" == b["diet:vegetarian"] && (a += "nur vegetarische Gerichte<br/>");"yes" == b["diet:lacto_vegetarian"] ? a += "lacto-vegetarische Gerichte vorhanden<br/>" : "only" == b["diet:lacto_vegetarian"] && (a += "nur lacto-vegetarische Gerichte<br/>");"yes" == b["diet:ovo_vegetarian"] ? a += "ovo-vegetarische Gerichte vorhanden<br/>" : "only" == b["diet:ovo_vegetarian"] && (a += "nur ovo-vegetarische Gerichte<br/>");"yes" == b["diet:vegan"] ? a += "vegane Gerichte vorhanden<br/>" : "only" == b["diet:vegan"] && (a += "nur vegane Gerichte<br/>");"yes" == b["diet:fruitarian"] ? a += "frutarische Gerichte vorhanden<br/>" : "only" == b["diet:fruitarian"] && (a += "nur frutarische Gerichte<br/>");"yes" == b["diet:raw"] ? a += "rohk\xF6stliche Gerichte vorhanden<br/>" : "only" == b["diet:raw"] && (a += "nur rohk\xF6stliche Gerichte<br/>");"yes" == b["diet:gluten_free"] ? a += "glutenfreie Gerichte vorhanden<br/>" : "only" == b["diet:gluten_free"] && (a += "nur glutenfreie Gerichte<br/>");"yes" == b["diet:dairy_free"] ? a += "milchfreie Gerichte vorhanden<br/>" : "only" == b["diet:dairy_free"] && (a += "nur milchfreie Gerichte<br/>");"yes" == b["diet:lactose_free"] ? a += "laktosefreie Gerichte vorhanden<br/>" : "only" == b["diet:lactose_free"] && (a += "nur laktosefreie Gerichte<br/>");"yes" == b["diet:halal"] ? a += "Hal\u0101l Gerichte vorhanden<br/>" : "only" == b["diet:halal"] && (a += "nur Hal\u0101l Gerichte<br/>");"yes" == b["diet:kosher"] ? a += "koschere Gerichte vorhanden<br/>" : "only" == b["diet:kosher"] && (a += "nur koschere Gerichte<br/>");"pub" == b.amenity && (a += "Gastst\xE4tte<br/>");"bar" == b.amenity && (a += "Bar<br/>");"yes" == b.frozen_yogurt && (a += "Frozen Yogurt im Angebot<br/>");"yes" == b.slush_ice && (a += "Slush Ice im Angebot<br/>");"yes" == b.cake && (a += "Kuchenteilchen, Geb\xE4ck etc. im Angebot<br/>");"yes" == b.coffee && (a += "Kaffeegetr\xE4nke im Angebot<br/>");"yes" == b.drinks && (a += "Getr\xE4nke im Angebot<br/>");"biergarten" == b.amenity && (a += "Biergarten<br/>");"restaurant" == b.amenity && (a += "Restaurant<br/>");"fast_food" == b.amenity && (a += "Fast Food Restaurant<br/>");if (("cafe" == b.amenity || "coffee_shop" == b.amenity) && "ice_cream" != b.cuisine) a += "Caf\xE9, Bistro<br/>";if ("cafe" == b.amenity && "ice_cream" == b.cuisine || "ice_cream" == b.amenity) a += "Eiscafe<br/>";"alpine_hut" == b.tourism && (a += "Bergh\xFCtte<br/>");"aquarium" == b.tourism && (a += "Aquarium<br/>");"apartment" == b.tourism && (a += "Ferienwohnung<br/>");"attraction" == b.tourism && (a += "Sehensw\xFCrdigkeit<br/>");"artwork" == b.tourism && (a += "Skulptur<br/>");"camp_site" == b.tourism && (a += "Campingplatz<br/>");"caravan_site" == b.tourism && (a += "Wohnmobilstellplatz<br/>");
    "chalet" == b.tourism && (a += "Ferienwohnung /-haus<br/>");"gallery" == b.tourism && (a += "Kunstgalerie<br/>");"guest_house" == b.tourism && (a += "Pension, Gasthaus, Bed & Breakfast<br/>");"hostel" == b.tourism && (a += "Jugendherberge, Hostel<br/>");"hotel" == b.tourism && (a += "Hotel<br/>");"motel" == b.tourism && (a += "Motel<br/>");"museum" == b.tourism && (a += "Museum<br/>");"picnic_site" == b.tourism && (a += "Rast- und Picknickplatz<br/>");"theme_park" == b.tourism && (a += "Freizeit- oder Themenpark<br/>");"viewpoint" == b.tourism && (a += "Aussichtspunkt<br/>");
    "wilderness_hut" == b.tourism && (a += "Schutzh\xFCtte<br/>");"wine_cellar" == b.tourism && (a += "Weinkeller<br/>");"zoo" == b.tourism && (a += "Zoo / Tierpark<br/>", "enclosure" == b.zoo && (a += "mit Wildgehege<br/>"), "petting_zoo" == b.zoo && (a += "mit Streichelzoo<br/>"), "falconry" == b.zoo && (a += "mit Falknerei<br/>"));"trail_riding_station" == b.tourism && (a += "Wanderreitstation<br/>");"fishing" == b.club && (a += "Angelverein<br/>");"sport" == b.club && "fishing" == b.sport && (a += "fishing club<br/>");"amateur_radio" == b.club && (a += "Amateurfunker<br/>");
    "art" == b.club && (a += "Kunstverein<br/>");"astronomy" == b.club && (a += "Astronomieverein<br/>");"automobile" == b.club && (a += "Automobilverein<br/>");"board_games" == b.club && (a += "Brettspielverein<br/>");"card_games" == b.club && (a += "Kartenspielverein<br/>");"charity" == b.club && (a += "Charity-Verein<br/>");"chess" == b.club && (a += "Schachverein<br/>");"cinema" == b.club && (a += "Kinoverein<br/>");"cooking" == b.club && (a += "Kochverein<br/>");"culture" == b.club && (a += "Kulturverein<br/>");"doityourself" == b.club && (a += "doityourself-Verein<br/>");
    "equestrian" == b.club && (a += "Reitverein<br/>");"ethnic" == b.club && (a += "Ethnischer Verein<br/>");"fan" == b.club && (a += "Fanverein<br/>");"freemasonry" == b.club && (a += "Freimaurer-Verein<br/>");"game" == b.club && (a += "Spieleverein<br/>");"history" == b.club && (a += "Historischer-Verein / Verein f\xFCr Geschichte<br/>");"hunting" == b.club && (a += "Jagdverein<br/>");"linux" == b.club && (a += "Linux-Verein<br/>");"motorcycle" == b.club && (a += "Motorradverein<br/>");"music" == b.club && (a += "Musikverein<br/>");"nature" == b.club && (a += "Naturverein<br/>");
    "nudism" == b.club && (a += "Nudisten-Verein / FKK-Verein<br/>");"photography" == b.club && (a += "Fotografieverein<br/>");"politics" == b.club && (a += "Verein f\xFCr Politik<br/>");"relegion" == b.club && (a += "Politischer-Verein<br/>");"scout" == b.club && (a += "Pfadfinderin/Pfadfinder<br/>");"smoke" == b.club && (a += "Raucherverein<br/>");"sport" == b.club && (a += "Sportverein<br/>");"theatre" == b.club && (a += "Theaterverein<br/>");"veterans" == b.club && (a += "Veteranen<br/>");"amusement_arcade" == b.leisure && (a += "Spielhalle<br/>");"beach_resort" == b.leisure && (a += "Standbad<br/>");"bird_hide" == b.leisure && (a += "Vogelbeobachtungspunkt<br/>");"common" == b.leisure && (a += "\xD6ffentliche Gr\xFCnfl\xE4chen<br/>");"club" == b.leisure && (a += "Club/Verein<br/>");"dance" == b.leisure && (a += "Tanzen<br/>");"dog_park" == b.leisure && (a += "Hundepark<br/>");"firepit" == b.leisure && (a += "Feuerstelle<br/>");"fishing" == b.leisure && (a += "Angelstelle<br/>");"garden" == b.leisure && (a += "Garten<br/>");"golf_course" == b.leisure && (a += "Golfplatz<br/>");"hackerspace" == b.leisure && (a += "Ort f\xFCr Hackertreffen<br/>");
    "horse_riding" == b.leisure && (a += "Reitstall / Reiterhof<br/>");"ice_rink" == b.leisure && (a += "Eislaufbahn<br/>");"nature_reserve" == b.leisure && (a += "Naturschutzgebiet (NSG)<br/>");"park" == b.leisure && (a += "Gr\xFCnanlage<br/>");"miniature_golf" == b.leisure && (a += "Minigolf<br/>");"pitch" == b.leisure && (a += "Spielfeld<br/>");"pitch" == b.leisure && "yes" == b.building && (a += "Sporthalle<br/>");"playground" == b.leisure && "yes" == b.building ? a += "Spielscheune<br/>" : "playground" == b.leisure && (a += "Spielplatz<br/>");"social_club" == b.leisure && (a += "Treffpunkt f\xFCr Freizeitgruppen<br/>");"spa" == b.leisure && (a += "Heilbad / Spa<br/>");"sports_centre" == b.leisure && (a += "Sportzentrum<br/>");"climbing_adventure" == b.sport && (a += "Seilgarten<br/>");"stadium" == b.leisure && (a += "Stadion<br/>");"swimming_pool" == b.leisure && (a += "Schwimmbecken<br/>");"track" == b.leisure && (a += "Rennbahn<br/>");"water_park" == b.leisure && (a += "Wasserpark<br/>");"wildlife_hide" == b.leisure && (a += "Wildbeobachtungspunkt<br/>");"adult_gaming_centre" == b.leisure && (a += "Spielothek<br/>");
    "bowling_alley" == b.leisure && "10pin" == b.sport && (a += "Bowlingcenter<br/>");"bowling_alley" == b.leisure && "9pin" == b.sport && (a += "Kegelbahn<br/>");if ("karting" == b.sport || "motor" == b.sport) a += "Kart-/Motorsport<br/>";if ("darts" == b.sport || "dart" == b.sport) a += "Darts<br/>";if (b["piste:type"]) switch (b["piste:type"]) {case "skitour":
            a += "Piste f\xFCr Skitouren<br/>";break;case "downhill":
            a += "Skiabfahrt<br/>";break;case "sled":
            a += "Rodelberg / Rodelstrecke<br/>";break;case "nordic":
            a += "Langlauf Piste<br/>";break;case "hike":
            a += "Schneeschuh- und Winterwanderweg<br/>";break;case "snow_park":
            a += "Snow-Park<br/>";}if (b.sport) switch (b.sport) {case "surfing":
            a += "Surfen<br/>";break;case "kitesurfing":
            a += "Kitesurfen<br/>";break;case "water_ski":
            a += "Wasserski<br/>";}if (b.aerialway) switch (b.aerialway) {case "cable_bar":
            a += "Lift mit Gondeln<br/>";break;case "gondola":
            a += "Lift mit Gondeln<br/>";break;case "chair_lift":
            a += "Sessellift<br/>";break;case "mixed_lift":
            a += "Lift mit Sesseln und Gondeln<br/>";break;case "drag_lift":
            a += "Skilift<br/>";
            break;case "t-bar":
            a += "T-Lift<br/>";break;case "t-bar":
            a += "T-Lift (einseitig)<br/>";break;case "platter":
            a += "Lift mit Sitzscheibe<br/>";break;case "rope_tow":
            a += "B\xFCgellift<br/>";break;case "magic_carpet":
            a += "Bef\xF6rderungsband<br/>";break;default:
            a += "unbekannt";}"mosque" == b.building && (a += "Moschee<br/>");"synagogue" == b.building && (a += "Synagoge<br/>");"apartments" == b.building && (a += "Wohnung<br/>");"farm" == b.building && (a += "Farm<br/>");"hotel" == b.building && (a += "Hotel<br/>");"house" == b.building && (a += "Haus<br/>");"detached" == b.building && (a += "Freistehend<br/>");"residential" == b.building && (a += "Residenz<br/>");if ("domitory" == b.building || "residential plus" == b.building) a += "Wohnheim<br/>";"terrace" == b.building && (a += "Terrasse<br/>");"houseboat" == b.building && (a += "Hausboot<br/>");"bungalow" == b.building && (a += "Bungalow<br/>");"static_caravan" == b.building && (a += "Stehender Wohnwagen<br/>");"commercial" == b.building && (a += "Kommerziell<br/>");"retail" == b.building && (a += "Verkauf<br/>");"warehouse" == b.building && (a += "Lagerhaus<br/>");"bakehouse" == b.building && (a += "Backstube<br/>");"temple" == b.building && (a += "Tempel<br/>");"shrine" == b.building && (a += "Schrein<br/>");"civic" == b.building && (a += "B\xFCrgerlich<br/>");"stadium" == b.building && (a += "Stadium<br/>");"train_station" == b.building && (a += "Bahnhof<br/>");"university" == b.building && (a += "Universit\xE4t<br/>");"public" == b.building && (a += "\xD6ffentliches Geb\xE4ude<br/>");"bridge" == b.building && (a += "Br\xFCcke<br/>");"bunker" == b.building && (a += "Bunker<br/>");"cabin" == b.building && (a += "H\xFCtte<br/>");"conservatory" == b.building && (a += "Wintergarten<br/>");"construction" == b.building && (a += "Im Bau<br/>");"garage" == b.building && (a += "Garage<br/>");"garages" == b.building && (a += "Garagen<br/>");"greenhouse" == b.building && (a += "Gew\xE4chshaus<br/>");"hangar" == b.building && (a += "Hangar<br/>");"hut" == b.building && (a += "H\xFCtte<br/>");"pavillion" == b.building && (a += "Pavillion<br/>");"roof" == b.building && (a += "\xDCberdacht<br/>");"shed" == b.building && (a += "Gartenh\xE4uschen<br/>");
    "transformer_tower" == b.building && (a += "Transformator Turm<br/>");"service" == b.building && (a += "Service-Stelle<br/>");"kiosk" == b.building && (a += "Kiosk<br/>");"carport" == b.building && (a += "Carport<br/>");"ruins" == b.building && (a += "Ruinen<br/>");"gambling" == b.amenity && (a += "Spielhalle<br/>");"library" == b.amenity && (a += "B\xFCcherei<br/>");"fountain" == b.amenity && (a += "Brunnen<br/>");"attraction" == b.amenity && (a += "Sehensw\xFCrdigkeit<br/>");if ("social_centre" == b.amenity || "club" == b.amenity) a += "Verein / Club<br/>";
    "townhall" == b.amenity && (a += "Rathaus / B\xFCrgerhaus<br/>");"bench" == b.amenity && (a += "Parkbank<br/>");if ("grave_yard" == b.amenity || "cemetery" == b.landuse) a += "Friedhof<br/>";"post_box" == b.amenity && (a += "Briefkasten<br/>");"post_office" == b.amenity && (a += "Postamt<br/>");"telephone" == b.amenity && (a += "Telefon<br/>");"atm" == b.amenity && (a += "Geldautomat<br/>");"bank" == b.amenity && (a += "Bankfiliale<br/>");"toilets" == b.amenity && "yes" == b.diaper ? a += "\xD6ffentliche Toilette mit Wickeltisch<br/>" : "toilets" == b.amenity && (a += "\xD6ffentliche Toilette<br/>");"school" == b.amenity && "1" == b["isced:level"] ? a += "Grundschule<br/>" : "school" == b.amenity && "2" == b["isced:level"] ? a += "Sekundarstufe I<br/>" : "school" == b.amenity && "3" == b["isced:level"] ? a += "Sekundarstufe II<br/>" : "school" == b.amenity && (a += "Schule<br/>");"kindergarten" == b.amenity && (a += "Kindergarten<br/>");"internet_cafe" == b.amenity && (a += "Internetcaf\xE9<br/>");"daycare" == b.amenity && (a += "Kinder- und Jugendtagesst\xE4tte<br/>");"childcare" == b.amenity && (a += "Kinder- und Jugendtagesst\xE4tte<br/>");
    "university" == b.amenity && (a += "Universit\xE4t/Hochschule<br/>");"college" == b.amenity && (a += "Universit\xE4t/Hochschule<br/>");"shelter" == b.amenity && (a += "Unterstand<br/>");"bbq" == b.amenity && (a += "Grillplatz<br/>");"nightclub" == b.amenity && (a += "Diskothek / Nachtklub<br/>");"bicycle_parking" == b.amenity && (a += "Fahrradparkplatz<br/>");"bicycle_rental" == b.amenity && (a += "Fahrradverleih<br/>");"boat_sharing" == b.amenity && (a += "Bootsverleih<br/>");"car_sharing" == b.amenity && (a += "Car-Sharing<br/>");"cinema" == b.amenity && (a += "Kino<br/>");"swimming_pool" == b.amenity && (a += "Schwimmbad<br/>");if ("embassy" == b.amenity || "embassy" == b.diplomatic) a += "Botschaft<br/>";"embassy" == b.amenity && "consulate" == b.diplomatic && (a += "Konsulate<br/>");"embassy" == b.amenity && "consulate_general" == b.diplomatic && (a += "Generalkonsulate<br/>");"embassy" == b.amenity && "honorary_consulate" == b.diplomatic && (a += "Honorarkonsulate<br/>");"embassy" == b.amenity && "permanent_mission" == b.diplomatic && (a += "St\xE4ndige Vertretung<br/>");"embassy" == b.amenity && "delegation" == b.diplomatic && (a += "Delegation<br/>");"embassy" == b.amenity && "high_commission" == b.diplomatic && (a += "Hochkommissariat<br/>");"Barfusspfad" == b.amenity && (a += "Barfu\xDFpfad<br/>");"casino" == b.amenity && (a += "Casino<br/>");"spa" == b.amenity && (a += "Heilbad / Spa<br/>");"stables" == b.amenity && (a += "Reitstall / Reiterhof<br/>");"watering_place" == b.amenity && (a += "Wasserstelle / Tr\xE4nke<br/>");"yes" == b.watering_place && (a += "Wasserstelle / Tr\xE4nke<br/>");"water_point" == b.amenity && (a += "gro\xDFe Trinkwasserstelle<br/>");
    "taxi" == b.amenity && (a += "Taxi<br/>");"car_wash" == b.amenity && (a += "Autowaschanlage<br/>");"brothel" == b.amenity && (a += "Bordell, Freudenhaus<br/>");"stripclub" == b.amenity && (a += "Stripclub<br/>");"swingerclub" == b.amenity && (a += "Swingerclub<br/>");"planetarium" == b.amenity && (a += "Planetarium<br/>");"courthouse" == b.amenity && (a += "Gericht<br/>");"crematorium" == b.amenity && (a += "Krematorium<br/>");if ("crypt" == b.amenity || "crypt" == b.building) a += "Krypta<br/>";"hunting_stand" == b.amenity && (a += "Hochsitz<br/>");"photo_booth" == b.amenity && (a += "Fotoautomat<br/>");"prison" == b.amenity && (a += "Gef\xE4ngnis<br/>");"ranger_station" == b.amenity && (a += "National Park Ranger Station<br/>");"register_office" == b.amenity && (a += "Standesamt<br/>");"marketplace" == b.amenity && (a += "Marktplatz / Wochenmarkt<br/>");"solarium" == b.amenity && (a += "Solarium<br/>");"sauna" == b.amenity && (a += "Sauna<br/>");"shower" == b.amenity && (a += "\xF6ffentliche Dusche<br/>");if ("waste_disposal" == b.amenity && (a += "M\xFCllentsorgung auf \xF6ffentlichen Pl\xE4tzen<br/>", b.waste)) switch (a += "Art: ", b.waste) {case "trash":
            a += "Allgemeiner M\xFCll<br/>";break;case "oil":
            a += "Oil<br/>";break;case "drugs":
            a += "Pharmazeutisch<br/>";break;case "organic":
            a += "Kompost<br/>";break;case "plastic":
            a += "Plastik<br/>";break;case "rubble":
            a += "Schutt<br/>";break;case "cigarettes":
            a += "Zigaretten<br/>";break;default:
            a += "Allgemeiner M\xFCll<br/>";}if ("waste_basket" == b.amenity || "dog_excrement" == b.waste) a += "Hunde-Code M\xFCllcontainer<br/>";if ("scout_camp" == b.amenity || "scout_hut" == b.amenity || "scout_hall" == b.amenity) a += "Pfadfinderheim<br/>";"ferry_terminal" == b.amenity && (a += "F\xE4hrhafen<br/>");"bureau_de_change" == b.amenity && (a += "Geldwechselstube<br/>");"youth_club" == b.amenity && (a += "Jugendzentrum<br/>");"festival_grounds" == b.amenity && (a += "Festivalgel\xE4nde<br/>");if ("yes" == b.openfire || "yes" == b.fireplace) a += "Offene Feuerstelle<br/>";if ("vending_machine" == b.amenity) if (b.vending) switch (b.vending) {case "admission_tickets":
            a += "Eintrittskartenautomat<br/>";break;case "animal_feed":
            a += "Tierfutterautomat<br/>";
            break;case "bicycle_tube":
            a += "Fahrradschlauchautomat<br/>";break;case "books":
            a += "B\xFCcherautomat<br/>";break;case "candles":
            a += "Kerzenautomat<br/>";break;case "cigarettes":
            a += "Zigarettenautomat<br/>";break;case "chemist":
            a += "Apotheken/Drogerie Automat<br/>";break;case "condoms":
            a += "Kondomautomat<br/>";break;case "drinks":
            a += "Getr\xE4nkeautomat<br/>";break;case "electronics":
            a += "Automat f\xFCr Elektro-Zubeh\xF6r<br/>";break;case "elongated_coin":
            a += "M\xFCnzpr\xE4gungsautomat<br/>";break;
        case "excrement_bags":
            a += "Hundet\xFCtenspender<br/>";break;case "feminine_hygiene":
            a += "Automat f\xFCr Damenhygieneprodukte<br/>";break;case "first_aid":
            a += "Erste-Hilfe-Automat<br/>";break;case "fishing_tackle":
            a += "Automat f\xFCr Angelzubeh\xF6r<br/>";break;case "fishing_bait":
            a += "Angelk\xF6derautomat<br/>";break;case "flowers":
            a += "Blumenautomat<br/>";break;case "food":
            a += "Lebensmittel-Automat<br/>";break;case "ice_cubes":
            a += "Eisw\xFCrfelautomat<br/>";break;case "ice_cream":
            a += "Automat f\xFCr Speiseeis<br/>";
            break;case "ink_cartridges":
            a += "Druckerpatronen Automat<br/>";break;case "laundry_detergent":
            a += "Waschmittelautomat<br/>";break;case "public_transport_tickets":
            a += "Fahrkartenautomat<br/>";break;case "newspaper":
            a += "Zeitungsautomat<br/>";break;case "parcel_pickup":
            a += "Packstation<br/>";break;case "parcel_mail_in":
            a += "Paketstation<br/>";break;case "parking_tickets":
            a += "Parkscheinautomat<br/>";break;case "photos":
            a += "Fotoautomat<br/>";break;case "sex_toys":
            a += "Automat f\xFCr Sexspielzeug<br/>";break;
        case "SIM_cards":
            a += "Automat f\xFCr SIM Karten<br/>";break;case "stamps":
            a += "Briefmarkenautomat<br/>";break;case "sweets":
            a += "S\xFC\xDFigkeitenautomat<br/>";break;case "syringes":
            a += "Spritzenautomat<br/>";break;case "toll":
            a += "Maut-Automat<br/>";break;case "toys":
            a += "Spielzeugautomat<br/>";break;case "umbrellas":
            a += "Regenschirmautomat<br/>";break;default:
            a += "Verkaufsautomat<br/>";} else a += "Verkaufsautomat<br/>";"arts_centre" == b.amenity && (a += "Kulturzentrum<br/>");"artwork" == b.amenity && (a += "Kunstwerk / Kunstobjekt<br/>");
    "museum" == b.amenity && (a += "Museum<br/>");"theatre" == b.amenity && (a += "Theater<br/>");"cathedral" == b.building && (a += "Kathedrale<br/>");"church" == b.building && (a += "Kirche<br/>");"chapel" == b.building && (a += "Kapelle<br/>");"place_of_worship" == b.amenity && (a += "Kirche / Kultst\xE4tte<br/>");"village" == b.abandoned && (a += "Verlassene Stadt<br/>");"theme_park" == b["abandoned:tourism"] && (a += "Verlassener Vergn\xFCgungspark<br/>");"prison_camp" == b["abandoned:amenity"] && "concentration_camp" == ["concentration_camp"] && (a += "KZ Gedenkst\xE4tte<br/>");"yes" == b.abandoned && "bunker" == b.military && (a += "Verlassene Bunkeranlage<br/>");"yes" == b.abandoned && "barracks" == b.military && (a += "Verlassene Milit\xE4rbaracken<br/>");"yes" == b.abandoned && "airfield" == b.military && (a += "Verlassene Milit\xE4rflugplatz<br/>");"monastery" == b.historic && (a += "Historisches Kloster<br/>");"monastery" == b.amenity && (a += "Kloster<br/>");"monastery" == b.building && (a += "Kloster<br/>");"manor" == b.historic && (a += "Gutshaus / Herrenhaus<br/>");"boundary_stone" == b.historic && (a += "Historischer Grenzstein<br/>");"milestone" == b.historic && (a += "Historischer Meilenstein<br/>");"monument" == b.historic && (a += "Monument<br/>");"palace" == b.historic && (a += "Palast<br/>");"mine" == b.historic && (a += "Verlassene Mine<br/>");"ruins" == b.historic && (a += "Ruine<br/>");"harbour" == b.historic_usage && (a += "historischer Hafen<br/>");"rune_stone" == b.historic && (a += "Runenstein<br/>");"battlefield" == b.historic && (a += "Schlachtfeld<br/>");"blacksmith" == b.historic && (a += "Historische Schmiede<br/>");
    if ("tree_shrine" == b.historic || "wayside_shrine" == b.historic) a += "Schrein / Bildstock<br/>";"city_gate" == b.historic && (a += "Stadttor<br/>");"wayside_cross" == b.historic && (a += "Wegkreuz<br/>");"monument" == b.amenity && (a += "Denkmal<br/>");"memorial" == b.historic && (a += "Denkmal<br/>");"optical_telegraph" == b.historic && (a += "Optischer Telegraph<br/>");if ("castle" == b.historic) if (b.castle_type) switch (b.castle_type) {case "defensive":
            a += "Burg<br/>";break;case "palace":
            a += "Palast<br/>";break;case "stately":
            a += "Schloss<br/>";
            break;case "manor":
            a += "Herrenhaus<br/>";break;case "fortress":
            a += "Festung<br/>";break;case "castrum":
            a += "R\xF6misches Milit\xE4rlager<br/>";break;case "shiro":
            a += "Shiro<br/>";break;case "kremlin":
            a += "Kreml<br/>";break;default:
            a += "Schloss / Burg<br/>";} else a += "Schloss / Burg<br/>";"archaeological_site" == b.historic && (a += "Arch\xE4ologische Fundst\xE4tte<br/>");if ("tomb" == b.historic) if (b.tomb) switch (b.tomb) {case "tumulus":
            a += "H\xFCgelgrab<br/>";break;case "rock-cut":
            a += "Felsgrab<br/>";break;
        case "hypogeum":
            a += "Hypog\xE4um<br/>";break;case "war_grave":
            a += "Soldatenfriedhof<br/>";break;case "mausoleum":
            a += "Mausoleum<br/>";break;case "columbarium":
            a += "Kolumbarium<br/>";break;case "crypt":
            a += "Krypta<br/>";break;case "pyramid":
            a += "Pyramide<br/>";break;case "sarcophagus":
            a += "Sarkophag<br/>";break;case "vault":
            a += "Gruft<br/>";break;case "tombstone":
            a += "Grabstein<br/>";break;default:
            a += "Historische Grabst\xE4tte<br/>";} else a += "Historische Grabst\xE4tte<br/>";"accountant" == b.office && (a += "Buchhalter / Wirtschaftpr\xFCfer<br/>");"administrative" == b.office && (a += "Kreis- bzw. Gemeindebeh\xF6rde<br/>");"architect" == b.office && (a += "Architekturb\xFCro<br/>");"association" == b.office && (a += "Verein, Vereinigung bzw. Interessengemeinschaft<br/>");"physician" == b.office && (a += "Arzt<br/>");"camping" == b.office && (a += "Rezeption Campingplatz oder B\xFCro Freizeitpark<br/>");"company" == b.office && (a += "Sitz einer privaten Firma<br/>");"educational_institution" == b.office && (a += "Bildungseinrichtung<br/>");
    "employment_agency" == b.office && (a += "Job-Center / Arbeitsvermittlung<br/>");"estate_agent" == b.office && (a += "Immobilienmakler / Wohnungsbaugenossenschaft<br/>");"forestry" == b.office && (a += "Forstamt<br/>");"foundation" == b.office && (a += "Gesch\xE4ftsstelle einer Stiftung<br/>");"government" == b.office && (a += "Beh\xF6rde / Regierungseinrichtung<br/>");"guide" == b.office && (a += "B\xFCro f\xFCr Touristenf\xFChrungen<br/>");"insurance" == b.office && (a += "Versicherungsb\xFCro<br/>");"it" == b.office && (a += "IT-Unternehmen<br/>");
    "lawyer" == b.office && (a += "Rechtsanwaltskanzlei<br/>");"newspaper" == b.office && (a += "Zeitungsredaktion<br/>");"ngo" == b.office && (a += "B\xFCro einer Nichtregierungsorganisation<br/>");"notary" == b.office && (a += "Notar<br/>");"political_party" == b.office && (a += "B\xFCro einer politischen Partei<br/>");"quango" == b.office && (a += "B\xFCro einer halbstaatlichen Organisation<br/>");"realtor" == b.office && (a += "Immobilienmakler / Wohnungsbaugenossenschaft<br/>");"real_estate_agent" == b.office && (a += "Immobilienmakler / Wohnungsbaugenossenschaft<br/>");
    "register" == b.office && (a += "Standesamt<br/>");"religion" == b.office && (a += "B\xFCro einer religi\xF6sen Instanz<br/>");"research" == b.office && (a += "Forschungsunternehmen oder -institut<br/>");"tax" == b.office && (a += "Finanzamt<br/>");"telecommunication" == b.office && (a += "Telekommunikationsfirma<br/>");"travel_agent" == b.office && (a += "Sitz eines Reiseunternehmens<br/>");"water_utility" == b.office && (a += "Wasserwirtschaftsamt<br/>");"therapist" == b.office && (a += "Therapeut<br/>");"city" == b.place && (a += "Gro\xDFstadt<br/>");
    "town" == b.place && (a += "Stadt/Kleinstadt<br/>");"village" == b.place && (a += "Dorf<br/>");"continent" == b.place && (a += "Kontinent<br/>");"ocean" == b.place && (a += "Ozean</br>");"track" == b.highway && (a += "Forst-, Wald und Feldweg<br/>");"raceway" == b.highway && (a += "Motorsportbahn<br/>");"designated" == b.bicycle && (a += "Radweg<br/>");"path" == b.highway && (a += "Fu\xDFweg<br/>");"parking" == b.amenity && (a += "Parkplatz<br/>");"services" == b.highway && (a += "Rastst\xE4tte<br/>");"rest_area" == b.highway && (a += "Rastplatz<br/>");"turning_circle" == b.highway && (a += "Wendeplatz/Wendehammer<br/>");"service" == b.highway && (a += "Zufahrtsstra\xDFe / Erschlie\xDFungsweg<br/>");"motorway" == b.highway && (a += "Autobahn<br/>");"motorway_junction" == b.highway && (a += "Autobahnauffahrt<br/>");"bridleway" == b.highway && (a += "Reitweg<br/>");"yes" == b.oneway && (a += "Einbahnstra\xDFe<br/>");"yes" == b.park_ride && (a += "Park and Ride<br/>");"unknown" == b.park_ride && (a += "Park and Ride<br/>");"bus" == b.park_ride && (a += "Park and Ride<br/>");"tram" == b.park_ride && (a += "Park and Ride<br/>");
    "bus_stop" == b.highway && (a += "Bushaltestelle<br/>");"pedestrian" == b.highway && (a += "Fu\xDFg\xE4ngerzone<br/>");"street_lamp" == b.highway && (a += "Strassenlaterne<br/>");"traffic_signals" == b.highway && (a += "Ampel<br/>");"traffic_signals" == b.crossing && (a += "Fu\xDFg\xE4ngerampel<br/>");"speed_camera" == b.highway && (a += "Blitzer<br/>");"yes" == b.traffic_calming && (ret += "Verkehrsberuhigter Bereich</br>");"bump" == b.traffic_calming && (a += "Kurze Bodenwelle</br>");"chicane" == b.traffic_calming && (a += "Zu umfahrendenes Hinderniss</br>");
    "choker" == b.traffic_calming && (a += "Fahrbahnverengung, zu umfahrende Hindernisse m\xF6glich</br>");"cushion" == b.traffic_calming && (a += "Bodenwelle mit L\xFCcken aus mehreren rechteckigen Huckeln</br>");"hump" == b.traffic_calming && (a += "vergleichbare Bodenwelle mit etwar einer L\xE4nge von 2-4M</br>");"island" == b.traffic_calming && (a += "Eine Verkehrsinsel</br>");"rumble_strip" == b.traffic_calming && (a += "Holperstreifen</br>");"table" == b.traffic_calming && (a += "lange Bodenwellen mit flachen Mittelst\xFCck</br>");
    "buoy_cardinal" == b["seamark:type"] && (a += "Kardinalstonne<br/>");"buoy_lateral" == b["seamark:type"] && (a += "Lateraltonne<br/>");"buoy_isolated_danger" == b["seamark:type"] && (a += "Gefahrentonne<br/>");"perch" == b["seamark:beacon_lateral:shape"] && (a += "Pricke<br/>");"fuel" == b.amenity && "fuel_station" == b["seamark:small_craft_facility:category"] ? a += "Schiffstankstelle<br/>" : "fuel" == b.amenity && (a += "Tankstelle<br/>");if ("charging_station" == b.amenity) {
        var a = a + "Ladestation / Stromtankstelle<br/>",
            c = b.voltage;if (b.car) {
            switch (b.car) {case "yes":
                    a += "F\xFCr Autos: Ja";break;case "no":
                    a += "F\xFCr Autos: Nein";break;default:
                    a += "F\xFCr Autos: Unbekannt";}a += "<br/>";
        } else a += "F\xFCr Autos: Unbekannt<br/>";if (b.bicycle) {
            switch (b.bicycle) {case "yes":
                    a += "F\xFCr E-Bike: Ja";break;case "no":
                    a += "F\xFCr E-Bike: Nein";break;default:
                    a += "F\xFCr E-Bike: Unbekannt";}a += "<br/>";
        } else a += "F\xFCr E-Bike: Unbekannt<br/>";"no" == b["socket:schuko"] && (a += "Stecker Schuko: Nein<br/>");"yes" == b["socket:schuko"] && (a += "Stecker Schuko: Ja<br/>");"no" == b["socket:cee_blue"] && (a += "Stecker CEE Blau: Nein<br/>");"yes" == b["socket:cee_blue"] && (a += "Stecker CEE Blau: Ja<br/>");"no" == b["socket:cee_red_16a"] && (a += "Stecker CEE Rot 16a: Nein<br/>");"yes" == b["socket:cee_red_16a"] && (a += "Stecker CEE Rot 16a: Ja<br/>");"no" == b["socket:cee_red_32a"] && (a += "Stecker CEE Rot 32a: Nein<br/>");"yes" == b["socket:cee_red_32a"] && (a += "Stecker CEE Rot 32a: Ja<br/>");"no" == b["socket:cee_red_64a"] && (a += "Stecker CEE Rot 64a: Nein<br/>");"yes" == b["socket:cee_red_64a"] && (a += "Stecker CEE Rot 64a: Ja<br/>");
        "no" == b["socket:cee_red_125a"] && (a += "Stecker CEE Rot 125a: Nein<br/>");"yes" == b["socket:cee_red_125a"] && (a += "Stecker CEE Rot 125a: Ja<br/>");"no" == b["socket:nema_5_15"] && (a += "Stecker Nema 5 15: Nein<br/>");"yes" == b["socket:nema_5_15"] && (a += "Stecker Nema 5 15: Ja<br/>");"no" == b["socket:nema_5_20"] && (a += "Stecker Nema 5 20: Nein<br/>");"yes" == b["socket:nema_5_20"] && (a += "Stecker Nema 5 20: Ja<br/>");"no" == b["socket:nema_14_30"] && (a += "Stecker Nema 14 30: Nein<br/>");"yes" == b["socket:nema_14_30"] && (a += "Stecker Nema 14 30: Ja<br/>");"Nein" == b["socket:nema_14_50"] && (a += "Stecker Nema 14  50: Nein<br/>");"yes" == b["socket:nema_14_50"] && (a += "Stecker Nema 14 50: Ja<br/>");"nein" == b["socket:bs1363"] && (a += "Stecker BS 1363: Nein<br/>");"yes" == b["socket:bs1363"] && (a += "Stecker BS 1363: Ja<br/>");"no" == b["socket:type1"] && (a += "Stecker Typ 1:Nein<br/>");"yes" == b["socket:type1"] && (a += "Stecker Typ 1: Ja<br/>");"no" == b["socket:type1_combo"] && (a += "Stecker Typ 1 Kombo: Nein<br/>");"yes" == b["socket:type1_combo"] && (a += "Stecker Typ 1 Kombo: Ja<br/>");"Nein" == b["socket:type2"] && (a += "Stecker Typ 2: Nein<br/>");"yes" == b["socket:type2"] && (a += "Stecker Typ 2: Ja<br/>");"no" == b["socket:type2_combo"] && (a += "Stecker Typ 2 Kombo: Nein<br/>");"yes" == b["socket:type2_combo"] && (a += "Stecker Typ 2 Kombo: Ja<br/>");"no" == b["socket:type3"] && (a += "Stecker Typ: Nein<br/>");"yes" == b["socket:type3"] && (a += "Stecker Typ 3: Ja<br/>");"no" == b["socket:chademo"] && (a += "Stecker CHAdeMO: Nein<br/>");"yes" == b["socket:chademo"] && (a += "Stecker CHAdeMO: Ja<br/>");
        "no" == b["socket:magne_charge"] && (a += "Stecker Magne : Nein<br/>");"yes" == b["socket:magne_charge"] && (a += "Stecker Magne : Ja<br/>");"no" == b["socket:tesla_standard"] && (a += "Stecker Tesla Standard: Nein<br/>");"yes" == b["socket:tesla_standard"] && (a += "Stecker Tesla Standard: Nein<br/>");"no" == b["socket:tesla_supercharge"] && (a += "Stecker Tesla Schnellladestation: Nein<br/>");"yes" == b["socket:tesla_supercharge"] && (a += "Stecker Tesla Schnellladestation: Ja<br/>");"no" == b["socket:tesla_roadster"] && (a += "Stecker Tesla Roadster: Nein<br/>");
        "yes" == b["socket:tesla_roadster"] && (a += "Stecker Tesla Roadster: Ja<br/>");b["socket:schuko"] && (a += "Stecker Schuko: " + b["socket:schuko"] + "<br/>");b["socket:cee_blue"] && (a += "Stecker CEE Blau: " + b["socket:cee_blue"] + "<br/>");b["socket:cee_red_16a"] && (a += "Stecker CEE Rot 16a: " + b["socket:cee_red_16a"] + "<br/>");b["socket:cee_red_32a"] && (a += "Stecker CEE Rot 32a: " + b["socket:cee_red_32a"] + "<br/>");b["socket:cee_red_64a"] && (a += "Stecker CEE Rot 64a: " + b["socket:cee_red_64a"] + "<br/>");b["socket:cee_red_125a"] && (a += "Stecker CEE Rot 125a: " + b["socket:cee_red_125a"] + "<br/>");b["socket:nema_5_15"] && (a += "Stecker Nema 5 15: " + b["socket:nema_5_15"] + "<br/>");b["socket:nema_5_20"] && (a += "Stecker Nema 5 20: " + b["socket:nema_5_20"] + "<br/>");b["socket:nema_14_30"] && (a += "Stecker Nema 14 30: " + b["socket:nema_14_30"] + "<br/>");b["socket:nema_14_50"] && (a += "Stecker Nema 14 50: " + b["socket:nema_14_50"] + "<br/>");b["socket:bs1363"] && (a += "Stecker BS 1363: " + b["socket:bs1363"] + "<br/>");b["socket:type1"] && (a += "Stecker Typ 1: " + b["socket:type1"] + "<br/>");b["socket:type1_combo"] && (a += "Stecker Typ 1 Kombo: " + b["socket:schuko"] + "<br/>");b["socket:type2"] && (a += "Stecker Typ 2: " + b["socket:type2"] + "<br/>");b["socket:type2_combo"] && (a += "Stecker Typ 2 Kombo: " + b["socket:type2_combo"] + "<br/>");b["socket:type3"] && (a += "Stecker Typ 3: " + b["socket:type3"] + "<br/>");b["socket:chademo"] && (a += "Stecker CHAdeMO: " + b["socket:chademo"] + "<br/>");b["socket:magne_charge"] && (a += "Stecker Magne : " + b["socket:magne_charge"] + "<br/>");b["socket:tesla_standard"] && (a += "Stecker Tesla Standard: " + b["socket:tesla_standard"] + "<br/>");b["socket:tesla_supercharge"] && (a += "Stecker Tesla Schnellladestation: " + b["socket:tesla_supercharge"] + "<br/>");b["socket:tesla_roadster"] && (a += "Stecker Tesla Roadster: " + b["socket:tesla_roadster"] + "<br/>");a += "<br/>";b.voltage && (a += "Volt: " + c + "<br/>");
    }"yes" == b.tunnel && (a += "Tunnel<br/>");if (b.bridge) switch (a += "Br\xFCcken-Typ: ", b.bridge) {case "swing":
            a += "Drehbr\xFCcke";break;case "aqueduct":
            a += "Historische Wasserpipeline";break;
        case "bascule":
            a += "Klapp bzw. Wippbr\xFCcke";break;case "boardwalk":
            a += "Bohlenweg";break;case "cantilever":
            a += "Auslegerbr\xFCcke";break;case "covered":
            a += "gedeckte Br\xFCcke";break;case "drawbridge":
            a += "Klappbr\xFCcke";break;case "humpback":
            a += "Drehbr\xFCcke";break;case "lift":
            a += "Hubbr\xFCcke";break;case "low_water_crossing":
            a += "Irische Br\xFCcke";break;case "moveable":
            a += "Bewegliche Br\xFCcken";break;case "pontoon":
            a += "Schwimmbr\xFCcke";break;case "suspension":
            a += "H\xE4ngebr\xFCcke";
            break;case "trestle":
            a += "Trestle-Br\xFCcke";break;case "viaduct":
            a += "Viadukt";}if (b["bridge:movable"]) switch (b["bridge:movable"]) {case "swing":
            a += "Drehbr\xFCcke";break;case "bascule":
            a += "Klapp bzw. Wippbr\xFCcke";break;case "drawbridge":
            a += "Klappbr\xFCcke";break;case "lift":
            a += "Hubbr\xFCcke";break;case "submersible":
            a += "Senkbr\xFCcke";break;case "transporter":
            a += "Schwebef\xE4hre";break;case "retractable":
            a += "Schubbr\xFCcke";}if ("nursing_home" == b.amenity || "retirement_home" == b.amenity) a += "Seniorenheim / Pflegeheim<br/>";"social_facility" == b.amenity && (a += "Allg. soziale Einrichtung<br/>");if (b.social_facility) {
        "group_home" == b.social_facility && "senior" == b["social_facility:for"] && (a += "Seniorenheim<br/>");"assisted_living" == b.social_facility && (a += "Betreutes Wohnen<br/>");"outreach" == b.social_facility && (a += "Beratungsstelle<br/>");"workshop" == b.social_facility && (a += "soziale Werkstatt<br/>");if ("ambulatory_care" == b.social_facility || "healthcare" == b.social_facility) a += "Ambulanter Pflegedienst<br/>";
        "shelter" == b.social_facility && "senior" == b["social_facility:for"] && (a += "Tages- u. Kurzzeitpflege<br/>");"shelter" == b.social_facility && "abused" == b["social_facility:for"] && (a += "Notunterkunft<br/>");"food_bank" == b.social_facility && (a += "Lebensmittelhilfe<br/>");"hospice" == b.social_facility && (a += "Hospiz<br/>");
    }b.brewery && (a += "Ausgeschenkte Biersorten: " + b.brewery + "<br/>");"alcohol" == b.shop && (a += "Spirituosenladen<br/>");"bakery" == b.shop && (a += "B\xE4ckerei<br/>");"beverages" == b.shop && (a += "Getr\xE4nkehandel<br/>");
    "butcher" == b.shop && (a += "Fleischerei<br/>");"cheese" == b.shop && (a += "K\xE4sefachgesch\xE4ft<br/>");"chocolate" == b.shop && (a += "Schokoladenfachgesch\xE4ft<br/>");"coffee" == b.shop && (a += "Kaffeefachgesch\xE4ft<br/>");"confectionery" == b.shop && (a += "S\xFC\xDFwarenladen<br/>");"convenience" == b.shop && (a += "Lebensmittelgesch\xE4ft<br/>");"deli" == b.shop && (a += "Feinkostladen<br/>");"dairy" == b.shop && (a += "Milchladen<br/>");"farm" == b.shop && (a += "Hofladen<br/>");"greengrocer" == b.shop && (a += "Gem\xFCseh\xE4ndler<br/>");
    "grocery" == b.shop && (a += "Lebensmittelgesch\xE4ft<br/>");"organic" == b.shop && (a += "Bio-Laden, Reformhaus<br/>");"pasta" == b.shop && (a += "Pastagesch\xE4ft<br/>");"seafood" == b.shop && (a += "Fischfachgesch\xE4ft<br/>");"tea" == b.shop && (a += "Teefachgesch\xE4ft<br/>");"wine" == b.shop && (a += "Weinhandlung<br/>");"department_store" == b.shop && (a += "Kaufhaus<br/>");"general" == b.shop && (a += "Gemischtwarenhandlung<br/>");"kiosk" == b.shop && (a += "Kiosk<br/>");"mall" == b.shop && (a += "Einkaufszentrum<br/>");"supermarket" == b.shop && (a += "Supermarkt<br/>");"baby_goods" == b.shop && (a += "Babyfachmarkt<br/>");"bag" == b.shop && (a += "Taschen und Koffer<br/>");"boutique" == b.shop && (a += "Boutique<br/>");"clothes" == b.shop && (a += "Bekleidung<br/>");"fabric" == b.shop && (a += "Textilgesch\xE4ft<br/>");"fashion" == b.shop && (a += "Fashion<br/>");"jewelry" == b.shop && (a += "Juwelier<br/>");"leather" == b.shop && (a += "Lederwaren<br/>");"shoes" == b.shop && (a += "Schuhfachgesch\xE4ft<br/>");"variety_store" == b.shop && (a += "Ein-Euro-Laden<br/>");"chemist" == b.shop && (a += "Drogerie<br/>");
    "cosmetics" == b.shop && (a += "Kosmetikfachgesch\xE4ft<br/>");"drugstore" == b.shop && (a += "Drogerie oder Apotheke (veraltet)<br/>");"perfumery" == b.shop && (a += "Parf\xFCmerie<br/>");"erotic" == b.shop && (a += "Erotikhandel<br/>");"hairdresser" == b.shop && (a += "Friseur<br/>");"hearing_aids" == b.shop && (a += "H\xF6rger\xE4te<br/>");"herbalist" == b.shop && (a += "Kr\xE4uterhandel<br/>");"massage" == b.shop && (a += "Massagesalon<br/>");"medical_supply" == b.shop && (a += "Sanit\xE4tshaus<br/>");"optician" == b.shop && (a += "Optiker<br/>");
    "tattoo" == b.shop && (a += "T\xE4towierer<br/>");"bathroom_furnishing" == b.shop && (a += "Badm\xF6bel und -accessoires<br/>");"doityourself" == b.shop && (a += "Baumarkt/Baustoffhandel<br/>");"energy" == b.shop && (a += "Energiehandel<br/>");"florist" == b.shop && (a += "Blumengesch\xE4ft<br/>");"furnace" == b.shop && (a += "Ofenfachgesch\xE4ft<br/>");"garden_centre" == b.shop && (a += "Gartencenter<br/>");"gas" == b.shop && (a += "Fachgesch\xE4ft f\xFCr technische Gase<br/>");"glaziery" == b.shop && (a += "Glaserei<br/>");"hardware" == b.shop && (a += "Eisenwaren<br/>");"houseware" == b.shop && (a += "Haushaltswaren und Inneneinrichtung<br/>");"locksmith" == b.shop && (a += "Schl\xFCsseldienst<br/>");"paint" == b.shop && (a += "Farbenfachgesch\xE4ft<br/>");"trade" == b.shop && (a += "Baustoffhandel<br/>");"antiques" == b.shop && (a += "Antiquit\xE4ten<br/>");"bed" == b.shop && (a += "Betten- und Matratzengesch\xE4ft<br/>");"candles" == b.shop && (a += "Kerzengesch\xE4ft<br/>");"carpet" == b.shop && (a += "Teppichfachhandel<br/>");"curtain" == b.shop && (a += "Gardinenfachgesch\xE4ft<br/>");
    "furniture" == b.shop && (a += "M\xF6bel- und Einrichtungshaus<br/>");"interior_decoration" == b.shop && (a += "Innendekoration / Raumausstattung<br/>");"kitchen" == b.shop && (a += "K\xFCchen<br/>");"window_blind" == b.shop && (a += "Jalousien und Roll\xE4den<br/>");"computer" == b.shop && (a += "Computer-Fachh\xE4ndler<br/>");"electronics" == b.shop && (a += "Elektronikmarkt<br/>");"hifi" == b.shop && (a += "Hifi-Fachh\xE4ndler<br/>");"mobile_phone" == b.shop && (a += "Handy-Shop<br/>");"radiotechnics" == b.shop && (a += "Radio- und Fernsehtechnik<br/>");
    "vacuum_cleaner" == b.shop && (a += "Staubsaugerfachgesch\xE4ft<br/>");"bicycle" == b.shop && (a += "Fahrradfachgesch\xE4ft<br/>");"car" == b.shop && (a += "Autohaus<br/>");"car_repair" == b.shop && (a += "Autowerkstatt<br/>");"car_parts" == b.shop && (a += "Autoteilefachgesch\xE4ft<br/>");if ("dive" == b.shop || "scuba_diving" == b.shop) a += "Tauchausr\xFCstung<br/>";"fishing" == b.shop && (a += "Angelfachgesch\xE4ft<br/>");"free_flying" == b.shop && (a += "Fallschirmausr\xFCstung<br/>");"hunting" == b.shop && (a += "Jagdausr\xFCstung<br/>");
    "motorcycle" == b.shop && (a += "Motorradgesch\xE4ft<br/>");"outdoor" == b.shop && (a += "Trekking-/Outdoorladen<br/>");"sports" == b.shop && (a += "Sportgesch\xE4ft<br/>");"tyres" == b.shop && (a += "Reifenfachhandel<br/>");"water_sports" == b.shop && (a += "Wassersportbedarf<br/>");"art" == b.shop && (a += "Kunstladen<br/>");"craft" == b.shop && (a += "Kunsthandwerk<br/>");"frame" == b.shop && (a += "Bilderrahmengesch\xE4ft<br/>");"music" == b.shop && (a += "Musikgesch\xE4ft<br/>");"music_instrument" == b.shop && (a += "Musikhaus<br/>");"photo" == b.shop && (a += "Fotofachgesch\xE4ft<br/>");"video" == b.shop && (a += "Videothek<br/>");"video_games" == b.shop && (a += "Videospiele<br/>");"anime" == b.shop && (a += "Anime<br/>");"books" == b.shop && (a += "Buchhandlung<br/>");"gift" == b.shop && (a += "Andenken, Reisemitbringsel, Souveniershop<br/>");"newsagent" == b.shop && (a += "Zeitungsh\xE4ndler<br/>");"stationery" == b.shop && (a += "Schreibwaren<br/>");"ticket" == b.shop && (a += "Ticketshop<br/>");"copyshop" == b.shop && (a += "Kopierladen<br/>");"funeral_directors" == b.shop && (a += "Bestattungsunternehmen<br/>");
    "laundry" == b.shop && (a += "Waschsalon / W\xE4scherei<br/>");"dry_cleaning" == b.shop && (a += "chemische Reinigung<br/>");"money_lender" == b.shop && (a += "Geldverleiher<br/>");"pawnbroker" == b.shop && (a += "Pfandhaus / Pfandleiher<br/>");"pet" == b.shop && (a += "Zoo- und Tierhandlung<br/>");"pyrotechnics" == b.shop && (a += "Feuerwerk<br/>");"religion" == b.shop && (a += "Religi\xF6se Artikel<br/>");"beauty" == b.shop && (a += "Sch\xF6nheitssalon<br/>");"solarium" == b.shop && (a += "Solarium<br/>");"tobacco" == b.shop && (a += "Tabakwaren<br/>");
    "toys" == b.shop && (a += "Spielwaren<br/>");"travel_agency" == b.shop && (a += "Reiseb\xFCro<br/>");"market_hall" == b.shop && (a += "Markthalle<br/>");"vacant" == b.shop && (a += "leerstehendes Ladenlokal<br/>");"weapons" == b.shop && (a += "Waffenladen<br/>");"lottery" == b.gambling && (a += "Lottoannahmestelle<br/>");"fish" == b.pet && (a += "Aquaristik<br/>");"agriucultural_engines" == b.craft && (a += "Landmaschinenbau<br/>");"basket_maker" == b.craft && (a += "Korbmacher<br/>");"beekeeper" == b.craft && (a += "Imker<br/>");"blacksmith" == b.craft && (a += "Schmied<br/>");"brewery" == b.craft && (a += "Brauerei<br/>");"yes" == b.microbrewery && (a += "Hausbrauerei<br/>");"boatbuilder" == b.craft && (a += "Bootsbauer<br/>");"bookbinder" == b.craft && (a += "Buchbinder<br/>");"builder" == b.craft && (a += "Hausbau<br/>");"carpenter" == b.craft && (a += "Tischler/Schreiner, Zimmermann<br/>");"carpet_layer" == b.craft && (a += "Teppichleger<br/>");"caterer" == b.craft && (a += "Catering<br/>");"clockmaker" == b.craft && (a += "Uhrmacher<br/>");"confectionery" == b.craft && (a += "Konditorei<br/>");"dressmaker" == b.craft && (a += "Schneider<br/>");"electrician" == b.craft && (a += "Elektriker<br/>");"gardener" == b.craft && (a += "Garten- und Landschaftsbauer<br/>");"glaziery" == b.craft && (a += "Glaserei<br/>");"handicraft" == b.craft && (a += "Handwerkskunst<br/>");"hvac" == b.craft && (a += "K\xE4lteanlagenbauer f\xFCr L\xFCftungs-, Heizungs- und Klimatechnik<br/>");"insulation" == b.craft && (a += "W\xE4rmed\xE4mmung von Geb\xE4uden<br/>");"jeweller" == b.craft && (a += "Juwelier, Gold-/Silber-Schmied<br/>");"key_cutter" == b.craft && (a += "Schl\xFCsselmacher<br/>");"locksmith" == b.craft && (a += "Schl\xFCsseldienst<br/>");"metal_construction" == b.craft && (a += "Metallbauer<br/>");"optician" == b.craft && (a += "Optiker<br/>");"painter" == b.craft && (a += "Maler<br/>");"parquet_layer" == b.craft && (a += "Parkettverleger<br/>");"photographer" == b.craft && (a += "Fotograf<br/>");"photographic_laboratory" == b.craft && (a += "Fotolabor<br/>");"plasterer" == b.craft && (a += "Gipser, Verputzer, Stuckateur<br/>");"plumber" == b.craft && (a += "Anlagenmechaniker Sanit\xE4r-, Heizungs- und Klimatechnik.<br/>");
    "pottery" == b.craft && (a += "T\xF6pferei<br/>");"rigger" == b.craft && (a += "Riggemacher (Takelage f\xFCr Segelschiffe)<br/>");"roofer" == b.craft && (a += "Dachdecker<br/>");"saddler" == b.craft && (a += "Sattler<br/>");"sailmaker" == b.craft && (a += "Segelmacher<br/>");"sawmill" == b.craft && (a += "Holzverarbeitungsbetrieb<br/>");"scaffolder" == b.craft && (a += "Ger\xFCstbauer<br/>");"sculptor" == b.craft && (a += "Bildhauer<br/>");"shoemaker" == b.craft && (a += "Schuhmacher<br/>");"stand_builder" == b.craft && (a += "Messe- / Standbauer<br/>");
    "stonemason" == b.craft && (a += "Steinmetz<br/>");"sun_protection" == b.craft && (a += "Rolladen- und Jalousiebauer<br/>");"sweep" == b.craft && (a += "Schornsteinfeger<br/>");"tailor" == b.craft && (a += "Schneider<br/>");"tiler" == b.craft && (a += "Fliesen-, Platten- und Mosaikleger<br/>");"tinsmith" == b.craft && (a += "Spengler, Klempner<br/>");"upholsterer" == b.craft && (a += "Polsterer<br/>");"watchmaker" == b.craft && (a += "Uhrmacher<br/>");"window_construction" == b.craft && (a += "Fensterbauer<br/>");"machines" == b.rental && (a += "Maschinenverleih<br/>");
    "car_rental" == b.amenity && (a += "Autoverleih<br/>");"allotments" == b.landuse && (a += "Schrebergarten<br/>");"basin" == b.landuse && (a += "Regenwasserr\xFCckhaltebecken<br/>");"brownfield" == b.landuse && (a += "Vorher bebautes Land<br/>");"commercial" == b.landuse && (a += "Industriegebiet<br/>");"construction" == b.landuse && (a += "Baugebiet<br/>");"farmland" == b.landuse && (a += "Ackerfl\xE4che<br/>");"farmyard" == b.landuse && (a += "landwirtschaftlicher Betrieb<br/>");"forest" == b.landuse && (a += "Forst<br/>");"garages" == b.landuse && (a += "Garagenkomplex<br/>");"grass" == b.landuse && (a += "Rasenfl\xE4chen<br/>");"greenfield" == b.landuse && (a += "Bauerwartungsland<br/>");"greenhouse_horticulture" == b.landuse && (a += "Gew\xE4chshaus-Fl\xE4che<br/>");"industrial" == b.landuse && (a += "Gewerbe-/Industriegebiet<br/>");"landfill" == b.landuse && (a += "M\xFClldeponie<br/>");"meadow" == b.landuse && (a += "Gr\xFCnfl\xE4che<br/>");"orchard" == b.landuse && (a += "Obstplantage<br/>");"plant_nursery" == b.landuse && (a += "Baumschule<br/>");"quarry" == b.landuse && (a += "Sand- und Kiesgrube<br/>");"railway" == b.landuse && (a += "Gebiet f\xFCr Eisenbahnnutzung<br/>");"recreation_ground" == b.landuse && (a += "Erholungsgebiet<br/>");"reservoir" == b.landuse && (a += "Wasserreservoir<br/>");"residential" == b.landuse && (a += "Wohngebiet<br/>");"retail" == b.landuse && (a += "Einkaufszentrum<br/>");"salt_pond" == b.landuse && (a += "Saline<br/>");"village_green" == b.landuse && (a += "Gr\xFCnfl\xE4che<br/>");"vineyard" == b.landuse && (a += "Weinberg<br/>");"pond" == b.landuse && (a += "kleiner Teich<br/>");"salt_pond" == b.landuse && (a += "Saline<br/>");"animal_keeping" == b.landuse && (a += "Weide, Paddock f\xFCr Tierhaltung<br/>");"yes" == b.entrance && (a += "Eingang zum Geb\xE4ude<br/>");"main" == b.entrance && (a += "Haupteingang<br/>");"service" == b.entrance && (a += "Hinterausgang f\xFCr Angestellte oder Zulieferer<br/>");"exit" == b.entrance && (a += "Ausgang des Geb\xE4udes<br/>");"emergency" == b.entrance && (a += "Notausgang<br/>");"bay" == b.natural && (a += "Bucht<br/>");"beach" == b.natural && (a += "Strand<br/>");"wood" == b.natural && (a += "nat\xFCrlicher Wald<br/>");
    "glacier" == b.natural && (a += "Gletscher<br/>");"cave_entrance" == b.natural && (a += "H\xF6hle<br/>");"spring" == b.natural && (a += "nat\xFCrliche Quelle<br/>");"waterfall" == b.natural && (a += "Wasserfall<br/>");"scrub" == b.natural && (a += "unkultiviertes Buschland<br/>");"grassland" == b.natural && (a += "unkultiviertes Grasland<br/>");"wetland" == b.natural && (a += "Feuchtgebiet<br/>");"tree" == b.natural && (a += "Baum");"peak" == b.natural && "yes" == b["summit:cross"] && (a += "Gipfelkreuz<br/>");"tree_row" == b.natural && (a += "Baumreihe / Allee<br/>");
    "heath" == b.natural && (a += "Heide<br/>");"moor" == b.natural && (a += "Hochmoor<br/>");"grassland" == b.natural && (a += "unkultiviertes Grasland<br/>");"fell" == b.natural && (a += "Grasland oberhalb der Baumgrenze<br/>");"bare_rock" == b.natural && (a += "Nackter Fels<br/>");"scree" == b.natural && (a += "Schutt (Hangschutt)<br/>");"volcano" == b.natural && (a += "Vulkan<br/>");"valley" == b.natural && (a += "Tal<br/>");"stone" == b.natural && (a += "Findling<br/>");"sea" == b.natural && (a += "Meer<br/>");"national_park" == b.boundary && (a += "Nationalpark<br/>");
    "protected_area" == b.boundary && (a += "Schutzgebiet<br/>");"yes" == b.mountain_pass && (a += "Gebirgspass<br/>");"waterfall" == b.waterway && (a += "Wasserfall<br/>");"canal" == b.waterway && (a += "Kanal<br/>");"canal" == b.water && (a += "Kanal<br/>");"river" == b.waterway && (a += "Fluss<br/>");"river" == b.water && (a += "Fluss<br/>");"riverbank" == b.waterway && (a += "Fluss<br/>");"ditch" == b.waterway && (a += "Entw\xE4sserungsgraben<br/>");"stream" == b.waterway && (a += "Bach<br/>");"ferry" == b.route && (a += "F\xE4hrverbindung<br/>");"turning_point" == b.waterway && (a += "Wendestelle<br/>");if ("lake" == b.water || "water" == b.natural) a += "See<br/>";"cove" == b.water && (a += "kleine Bucht<br/>");"lagoon" == b.water && (a += "Lagune<br/>");"pond" == b.water && (a += "Teich<br/>");"reservoir" == b.water && (a += "Wasserreservoir<br/>");"oxbow" == b.water && (a += "Altwassersee<br/>");"lock" == b.water && (a += "Schleusenkammer<br/>");"moat" == b.water && (a += "Burggraben<br/>");"wastewater" == b.water && (a += "Kl\xE4ranlage<br/>");"guest" == b.mooring && "pier" == b.man_made || "visitor_berth" == b["seamark:small_craft_facility:category"] ? a += "Gastliegeplatz<br/>" : "pier" == b.man_made && (a += "Anlegestelle<br/>");"boatyard" == b.waterway && (a += "Schiffswerft<br/>");"mooring" == b["seamark:type"] && "dolphin" == b["seamark:mooring:category"] && (a += "Dalben<br/>");"foot" == b.route && (a += "Wanderweg<br/>");"hiking" == b.route && (a += "Wanderweg<br/>");if ("yes" == b.hiking && "information" == b.tourism) a += "Wegweiser<br/>";else if ("information" == b.tourism && "information" == b.tourism) if (b.information) switch (b.information) {case "board":
            a += "Informationstafel<br/>";break;case "map":
            a += "Informationstafel mit Karte<br/>";break;case "office":
            a += "Touristeninformation<br/>";break;case "terminal":
            a += "Informationsterminal<br/>";break;case "audioguide":
            a += "Audioguide<br/>";break;case "guidepost":
            a += "Wegweiser<br/>";break;case "tactile_map":
            a += "Blindenkarte 2D<br/>";break;case "tactile_model":
            a += "Blindenkarte 3D<br/>";break;case "route_marker":
            a += "Wegerkennungsmarker<br/>";break;default:
            a += "Informationstafel<br/>";} else a += "Informationstafel<br/>";"bicycle" == b.route && (a += "Radwanderweg<br/>");
    "mtb" == b.route && (a += "Mountainbikeroute<br/>");"horse" == b.route && (a += "Reitwanderweg<br/>");"coastline" == b.natural && (a += "K\xFCstenlinie<br/>");"cliff" == b.natural && (a += "Klippe<br/>");"dam" == b.waterway && (a += "Staudamm<br/>");"weir" == b.waterway && (a += "Wehr<br/>");"lock_gate" == b.waterway && (a += "Schleusentor<br/>");"yes" == b.lock && (a += "Schleuse<br/>");"sluice_gate" == b.waterway && (a += "Siel<br/>");"pumping_station" == b.man_made && (a += "Sch\xF6pfwerk<br/>");"groyne" == b.man_made && (a += "Buhne<br/>");"dyke" == b.man_made && (a += "Deich<br/>");"levee" == b.man_made && (a += "Deich<br/>");"watermill" == b.man_made && (a += "Wasserm\xFChle<br/>");"airfield" == b.military && (a += "Milit\xE4rflugplatz<br/>");"naval_base" == b.military && (a += "Marinest\xFCtzpunkt<br/>");"range" == b.military && (a += "Waffen\xFCbungsplatz<br/>");"military" == b.landuse && (a += "milit\xE4risch genutztes Gebiet<br/>");"training_area" == b.military && (a += "Truppen\xFCbungsplatz<br/>");"exclusion_zone" == b.military && (a += "milit\xE4risch genutztes Gebiet<br/>");"danger_area" == b.military && (a += "milit\xE4rische Gefahrenzone<br/>");"barracks" == b.military && (a += "Kaserne<br/>");"nuclear_explosion_site" == b.military && (a += "Atomwaffentestgel\xE4nde<br/>");"yes" == b.construction ? a += "Baustelle<br/>" : "construction" == b.highway && (a += "Baustelle<br/>");"petroleum_well" == b.man_made && (a += "Erd\xF6lpumpe<br/>");"storage_tank" == b.man_made && (a += "Speichertank<br/>");"wastewater_plant" == b.man_made && (a += "Kl\xE4ranlage<br/>");"silo" == b.man_made && (a += "Silo<br/>");"water_tower" == b.man_made && (a += "Wasserturm<br/>");"windmill" == b.man_made && (a += "Windm\xFChle<br/>");"monitoring_station" == b.man_made && (a += "Messstation");"crane" == b.man_made && (a += "Kran");"lighthouse" == b.man_made && (a += "Leuchtturm");"beacon" == b.man_made && (a += "Leuchtfeuer");"breakwater" == b.man_made && (a += "Wellenbrecher");"lamp" == b.man_made && "street_lamp" == b["lamp:type"] && (a += "Strassenlaterne<br/>");"lantern" == b.light_source && (a += "Strassenlaterne<br/>");"floodlight" == b.light_source && (a += "Flutlicht<br/>");"signal_lamp" == b.light_source && (a += "Signallicht<br/>");"aviation" == b.light_source && (a += "Befeuerung<br/>");"warning" == b.light_source && (a += "Warnlicht<br/>");if (b.light_source && b["light:method"]) switch (a += "Licht Art: ", b["light:method"]) {case "gas":
            a += "Gas";break;case "electric":
            a += "Elektrisch";break;case "incandescent":
            a += "strahlend";break;case "halogen":
            a += "Halogen";break;case "discharge":
            a += "Entladungslicht";break;case "metal-halide":
            a += "Halogen-Metalldampflampe";break;case "neon":
            a += "Neon";break;case "sodium":
            a += "Natriumdampflampe";
            break;case "high_pressure_sodium":
            a += "Hochdruck Natriumdampflampe";break;case "low_pressure_sodium":
            a += "Niedrigdruck Natriumdampflampe";break;case "fluorescent":
            a += "Fluoreszenzlampe";break;case "mercury":
            a += "Quecksilberlampe";break;case "LED":
            a += "LED";break;case "laser":
            a += "Laser";break;case "arc":
            a += "Lichtbogen";break;default:
            a += "Unbekannt";}"drinking_water" == b.amenity && (a += "Trinkwasser<br/>");"yes" == b.drinking_water && (a += "Trinkwasser<br/>");"works" == b.man_made ? a += "Industriegeb\xE4ude<br/>" : "industrial" == b.building ? a += "Industriegeb\xE4ude<br/>" : "industrial" == b.landuse ? a += "Industriegebiet<br/>" : "industrial" == b.abutters ? a += "Industriegebiet<br/>" : "commercial" == b.abutters && (a += "Gewerbegebiet<br/>");if (b["generator:source"]) switch (a += "Anlagen-Typ: ", b["generator:source"]) {case "biomass":
            a += "Biogasanlage";break;case "biofuel":
            a += "Biogasanlage";break;case "biogas":
            a += "Biogasanlage";break;case "coal":
            a += "Kohlekraftwerk";break;case "oil":
            a += "\xD6lraffinerie";break;case "waste":
            a += "M\xFCllverbrennungsanlage";
            break;case "wind":
            a += "Windkraftwerk";break;case "solar":
            a += "Solarkraftwerk";break;case "hydro":
            a += "Wasserkraftwerk";break;case "tidal":
            a += "Gezeitenkraftwerk";break;case "wave":
            a += "Wellenkraftwerk";break;case "geothermal":
            a += "Geothermie";break;case "osmotic":
            a += "Osmosekraftwerk";break;case "nuclear":
            a += "Atomkraftwerk";break;default:
            a += "unbekannt<br/>";}"photovoltaic" == b.power_source && (a += "Solarkraftwerk");"line" == b.power && (a += "Hochspannungs-\xDCbertragungsleitung<br/>");"cable" == b.power && (a += "Untergrundkabel<br/>");
    "cable_distribution_cabinet" == b.power && (a += "Kabelverteilerschrank<br/>");"plant" == b.power && (a += "Elektrizit\xE4tskraftwerk<br/>");"station" == b.power && (a += "Elektrizit\xE4tskraftwerk<br/>");"sub_station" == b.power && (a += "Elektrizit\xE4tskraftwerk<br/>");"compensator" == b.power && (a += "Kompensator<br/>");"converter" == b.power && (a += "Konverter<br/>");"generator" == b.power && (a += "Generator<br/>");"heliostat" == b.power && (a += "Heliostat<br/>");"insulator" == b.power && (a += "Isulator<br/>");"busbar" == b.line && (a += "Sammelschiene<br/>");
    "bay" == b.line && (a += "Verbindung Schaltung und Sammelschiene<br/>");"minor_line" == b.power && (a += "Nebenlinie<br/>");"pole" == b.power && (a += "Pfahl<br/>");"portal" == b.power && (a += "H-f\xF6rmiger Mast<br/>");"catenary_mast" == b.power && (a += "Fahrleitungsmast<br/>");"substation" == b.power && (a += "Umspannwerk<br/>");"switch" == b.power && (a += "Lastschalter<br/>");"terminal" == b.power && (a += "Terminal / Anschluss<br/>");"tower" == b.power && (a += "Hochspannungsleitungs<br/>");"transformer" == b.power && (a += "Nebenlinie<br/>");if (b.barrier) switch (b.barrier) {case "bollard":
            a += "Poller, Pfosten<br/>";break;case "cycle_barrier":
            a += "Umlaufsperre, Dr\xE4ngelgitter<br/>";break;case "gate":
            a += "Tor, Schranke<br/>";break;case "chain":
            a += "Kette<br/>";break;case "lift_gate":
            a += "Schlagbaum<br/>";break;case "wall":
            a += "L\xE4rmschutzwand<br/>";break;case "toll_booth":
            a += "Mautstelle<br/>";break;case "fence":
            switch (b.fence_type) {case "barbed_wire":
                    a += "Stacheldrahtzaun<br/>";break;case "wood":
                    a += "Holzzaun<br/>";break;case "chain_link":
                    a += "Maschendrahtzaun<br/>";break;case "electric":
                    a += "Weidezaun<br/>";break;case "railing":
                    a += "Gel\xE4nder<br/>";break;case "wire":
                    a += "einfacher Drahtzaun<br/>";break;case "metal":
                    a += "Metallzaun<br/>";break;case "pole":
                    a += "Holzpf\xE4hle<br/>";break;default:
                    a += "Zaun<br/>";}break;case "block":
            a += "Block<br/>";break;case "ditch":
            a += "Graben<br/>";break;case "border_control":
            a += "Grenzkontrolle<br/>";break;case "hedge":
            a += "Hecke<br/>";break;case "retaining_wall":
            a += "St\xFCtzmauer<br/>";break;case "cattle_grid":
            a += "Weiderost<br/>";break;case "horse_stile":
            a += "Zaun\xFCbertritt<br/>";break;default:
            a += "unbekannt<br/>";}"noise_barrier" == b.wall && (a += "L\xE4rmschutzwand<br/>");"retaining_wall" == b.designation && (a += "L\xE4rmschutzwand<br/>");"noise_barrier" == b.designation && (a += "L\xE4rmschutzwand<br/>");"surveillance" == b.man_made && (a += "\xDCberwachter Bereich<br/>");if (b.aeroway) switch (a += "Flughafen: ", b.aeroway) {case "aerodrome":
            a += "Flugplatz";break;case "apron":
            a += "Vorfeld";break;case "gate":
            a += "gate";break;case "helipad":
            a += "Hubschrauberlandeplatz";break;
        case "hangar":
            a += "Hangar";break;case "runway":
            a += "Start-/Landebahn";break;case "taxiway":
            a += "Rollweg";break;case "terminal":
            a += "Flughafengeb\xE4ude";break;default:
            a += "unbekannt<br/>";}"halt" == b.railway && (a += "Bahn-Haltepunkt<br/>");"crossing" == b.railway && (a += "Bahn\xFCbergang<br/>");"level_crossing" == b.railway && (a += "Bahn\xFCbergang<br/>");"station" == b.railway && (a += "Bahnhof<br/>");"bus_station" == b.amenity && (a += "Busbahnhof<br/>");"bus_station" == !b.amenity && "station" == b.public_transport && "yes" == b.bus && (a += "Busbahnhof<br/>");"rail" == b.railway && (a += "Bahnlinie<br/>", "contact_line" == b.electrified && (a += "elektrifizierte Bahntrasse mit Oberleitung<br/>"));"tram" == b.railway && (a += "Stra\xDFenbahnlinie<br/>");if ("slipway" == b["seamark:small_craft_facility:category"] || "slipway" == b.harbour || "slipway" == b.leisure) a += "Slipanlage<br/>";if ("harbour" == b["seamark:type"]) if (b["seamark:harbour:category"]) switch (b["seamark:harbour:category"]) {case "ferry":
            a += "F\xE4hrhafen<br/>";break;case "container":
            a += "Containerhafen<br/>";
            break;case "marina":
            "marina" != b.leisure && (a += "Jachthafen<br/>");break;case "navel_base":
            a += "Marine-Hafen<br/>";break;case "tanker":
            a += "Hafen f\xFCr \xD6ltanker<br/>";break;case "passenger":
            a += "Personenschifffahrt<br/>";break;case "bulk":
            a += "Sch\xFCttgut-Hafen<br/>";break;default:
            a += "Hafen<br/>";} else a += "Hafen<br/>";"marina" == b.leisure && (a += "Jachthafen<br/>");"wreck" == b.historic && (a += "Wrack<br/>");"animal_shelter" == b.amenity && (a += "Tierheim<br/>");"shelter" == b.animal && (a += "Tierheim<br/>");"horse_walker" == b.animal && (a += "Pferdelauftrainer<br/>");"yes" == b.animal_shelter && (a += "Tierheim<br/>");"dog" == b.animal_shelter && (a += "Tierheim<br/>");"cat" == b.animal_shelter && (a += "Tierheim<br/>");"animal_boarding" == b.amenity && (a += "Tierpension<br/>");"yes" == b.animal_boarding && (a += "Tierpension<br/>");"dog" == b.animal_boarding && (a += "Tierpension<br/>");"horse" == b.animal_boarding && (a += "Tierpension<br/>");"cat" == b.animal_boarding && (a += "Tierpension<br/>");"dog;cat" == b.animal_boarding && (a += "Tierpension<br/>");"cat;dog" == b.animal_boarding && (a += "Tierpension<br/>");if ("school" == b.animal || "sport" == b.animal || "animal_training" == b.amenity) a += "Tiertraining<br/>";"swimming" == b.animal && (a += "Badestelle f\xFCr Hunde<br/>");if ("feeding_place" == b.amenity || "animal_feeding" == b.man_made || "animal_feeding" == b.amenity) a += "F\xFCtterungsstelle<br/>";if ("wildlife_feeding" == b.amenity || "deer_feeding" == b.amenity || "game_feeding" == b.amenity) a += "Wildf\xFCtterung<br/>";if ("cratch" == b.amenity || "cratch" == b.man_made || "feeding_rack" == b.amenity) a += "Futterraufe<br/>";
    "manger" == b.amenity && (a += "Krippe<br/>");"birdhouse" == b.man_made && (a += "Vogelhaus<br/>");"stork" == b.birds_nest && (a += "Storchennest<br/>");"nest_box" == b.amenity && (a += "Nistkasten<br/>");"wellness" == b.animal && (a += "Hundesalon<br/>");"cemetery" == b.animal && (a += "Kleintierfriedhof<br/>");if ("stable" == b.building || "stable" == b["building:use"]) a += "Pferdestall<br/>";"cowshed" == b.building && (a += "Kuhstall<br/>");"sty" == b.building && (a += "Schweinestall<br/>");"barn" == b.building && (a += "Scheune / landwirtsch. Lagerhalle<br/>");
    "farm_auxiliary" == b.building && (a += "landwirtschaftl. Nebengeb\xE4ude<br/>");if (b["river:waterway_distance"] || "milestone" == b.waterway) a += "Flusskilometer<br/>";"milestone" == b.highway && (a += "Strassenkilometer<br/>");"market" == b["xmas:feature"] && (a += "Weihnachtsmarkt<br/>");"tree" == b["xmas:feature"] && (a += "Weihnachtsbaumverkauf<br/>");"event" == b["xmas:feature"] && (a += "Weihnachtsevent<br/>");"pyramid" == b["xmas:feature"] && (a += "Weihnachtspyramide<br/>");return '<div class="c4g_popup_header_featuretype">' + a + "<br/> </div>";
}
var fnContent = exports.fnContent = function fnContent(b) {
    var a;a = "" + fnContentGeneralInformations(b);a += fnContentHealthcare(b);a += fnContentAerodrome(b);a += fnContentCuisine(b);a += fnContentShipping(b);a += fnContentHydrants(b);a += fnContentSports(b);a += fnContentStreetsTraffic(b);a += fnContentInformationCity(b);a += fnContentEmergency(b);a += fnContentStorage(b);a += fnContentAmenity(b);a += fnContentTourism(b);a += fnContentRoute(b);a += fnContentPetrol(b);a += fnContentBarriers(b);a += fnContentLanduse(b);a += fnContentNatural(b);a += fnKlosterAdditional(b);a += fnSicherheitAdditional(b);a += fnAdditionalBuildingInfos(b);a += fnKraftwerkInfo(b);a += fnMessstation(b);a += fnWertstoffinfo(b);(a += fnContentProtectedArea(b)) && (a = "<br/>" + a);return '<div class="c4g_popup_content">' + a + "</div>";
},
    fnContentAerodrome = exports.fnContentAerodrome = function fnContentAerodrome(b) {
    var a = "";b.aerodrome && ("international" == b.aerodrome && (a += "Flughafentype: internationaler Flugplatz<br/>"), "regional" == b.aerodrome && (a += "Flughafentype: regionaler Flugplatz<br/>"), "gliding" == b.aerodrome && (a += "Flughafentype: Segelflugplatz<br/>"), "private" == b.aerodrome && (a += "Flughafentype: Privatflugplatz<br/>"));b.iata && (a += "IATA-Code: " + b.iata + "<br/>");b.icao && (a += "ICAO-Code: " + b.icao + "<br/>");return a;
},
    fnContentNatural = exports.fnContentNatural = function fnContentNatural(b) {
    var a = "";if (b.forest || b.wood) {
        if ("broadleaved" == b.leaf_type || "deciduous" == b.wood) a += "Laubwald<br/>";if ("needleleaved" == b.leaf_type || "coniferous" == b.wood) a += "Nadelwald<br/>";if ("mixed" == b.leaf_type || "mixed" == b.wood) a += "Mischwald<br/>";"leafless" == b.leaf_type && (a += "Blattlose Vegetation<br/>");"evergreen" == b.wood && (a += "immergr\xFCn<br/>");
        "palm" == b.wood && (a += "Palmen<br/>");"nipa_palm" == b.wood && (a += "Nipapalmen<br/>");"eucalypt" == b.wood && (a += "Eukalypten<br/>");if ("filao" == b.wood || "casuarina" == b.wood) a += "Kasuarinengew\xE4chse<br/>";
    }if ("tree" == b.natural && (!b["genus:de"] && !b["species:de"] && b.leaf_type && (a = "broadleaved" == b.leaf_type || "deciduous" == b.leaf_type || "broadleafed" == b.leaf_type ? a + "Laubbaum<br/>" : a + "Nadelbaum<br/>"), b.genus && (a += b.genus + "<br/>"), b["genus:de"] && (a += b["genus:de"] + "<br/>"), b.species && (a += b.species + "<br/>"), b["species:de"] && (a += b["species:de"] + "<br/>"), "landmark" == b.denotation && (a += "durch Gr\xF6\xDFe und herausragender Position sich deutlich aus seinem Umfeld hervorhebender Baum.<br/>"), "natural_monument" == b.denotation || "yes" == b.monument)) a += "alter, unter besonderem Schutz stehender Baum.<br/>";"manger" == b["feeding:type"] && (a += "Futterbeh\xE4lter: Futterraufe<br/>");"automated" == b["feeding:type"] && (a += "Automat<br/>");if (b["feeding:for"]) switch (b["feeding:for"]) {case "sheep":
            a += "Tier: Schaaf<br/>";break;case "horse":
            a += "Tier: Pferd<br/>";break;case "cow":
            a += "Tier: Kuh<br/>";break;case "rabbit":
            a += "Tier: Kaninchen<br/>";break;case "bunny":
            a += "Tier: Hase<br/>";break;case "cat":
            a += "Tier: Katze </br>";break;case "swan":
            a += "Tier: Schwan </br>";break;case "guinea pig":
            a += "Tier: Meerschweinchen </br>";break;case "donkey":
            a += "Tier: Esel </br>";break;case "squirrel":
            a += "Tier: Eichh\xF6rnchen </br>";break;case "pig":
            a += "Tier: Schwein </br>";break;case "deer":
            a += "Tier: Reh </br>";break;case "guinea pig":
            a += "Tier: Meerschweinchen </br>";
            break;case "monkey":
            a += "Tier: Affe </br>";break;case "camel":
            a += "Tier: Kamel </br>";break;case "goat":
            a += "Tier: Ziege </br>";break;case "hamster":
            a += "Tier: Hamster </br>";break;case "alpaca":
            a += "Tier: Alpaka </br>";break;default:
            a += "Tiere: nicht bekannt<br/>";}if (b["feeding:fodder"]) switch (b["feeding:fodder"]) {case "hay":
            a += "F\xFCttern mit: Heu</br>";break;case "grain":
            a += "F\xFCttern mit: Getreide</br>";break;case "corn":
            a += "F\xFCttern mit: Korn</*br>";break;default:
            a += "F\xFCttern mit: nicht bekannt</br>";}"volcano" == b.natural && "active" == b.status && (a += "Aktiver Vulkan<br/>");"volcano" == b.natural && "dormant" == b.status && (a += "Ruhender Vulkan<br/>");"volcano" == b.natural && "extinct" == b.status && (a += "Erloschener Vulkan<br/>");"volcano" == b.natural && "stratovolcano" == b.type && (a += "Vulkantyp:Schichtvulkan<br/>");"volcano" == b.natural && "shield" == b.type && (a += "Vulkantyp:Schildvulkan<br/>");"volcano" == b.natural && "scoria" == b.type && (a += "Vulkantyp:Schlacken- und Aschenkegel<br/>");return a;
},
    fnContentProtectedArea = exports.fnContentProtectedArea = function fnContentProtectedArea(b) {
    var a = "",
        c = "";"protected_area" == b.boundary && (b.protect_class && (c = b.protect_class), b.protect_id && (c = b.protect_id), "1" == c && (a = "Beschreibung: Strenges Naturreservat, Wildnisgebiet<br/>"), "2" == c && (a = "Beschreibung: Nationalpark<br/>"), "3" == c && (a = "Beschreibung: Naturmonument<br/>"), "4" == c && (a = "Beschreibung: Biotop/Artenschutzgebiet mit Management<br/>"), "5" == c && (a = "Beschreibung: Gesch\xFCtzte Landschaft/Gesch\xFCtztes marines Gebiet<br/>"), "6" == c && (a = "Beschreibung: Ressourcenschutzgebiet mit Management<br/>"), "7" == c && (a = "Beschreibung: Lokal gesch\xFCtzte Bereiche<br/>"), "97" == c && (a = "Beschreibung: Gesch\xFCtzt oder ausgezeichnet durch Vereinbarungen auf kontinentaler Ebene<br/>"), "98" == c && (a = "Beschreibung: Gesch\xFCtzt oder ausgezeichnet durch zwischenstaatliche- oder internationale Vereinbarungen<br/>"), "99" == c && (a = "andere <br/>"), "21" == c && (a = "Beschreibung: Gemeindebefinden (heilige Orte, assoziatice Orte)<br/>"), "22" == c && (a = "Beschreibung: Kulturelle Werte (Kulturg\xFCter, historisches Erbe, Denkmalschutz)<br/>"), "23" == c && (a = "Beschreibung: Schutz zu Gundsten der Wirtschaft<br/>"), "24" == c && (a = "Beschreibung: Politische Schutzgebiete<br/>"), "25" == c && (a = "Beschreibung: Milit\xE4rische Schutzgebiete<br/>"), "26" == c && (a = "Beschreibung: Historische Schutzgebiete<br/>"), "29" == c && (a = "Beschreibung: Weitere gesellschaftliche Schutzgebiete<br/>"), "11" == c && (a = "Beschreibung: Bodenschutz (Vorgabe zum Fruchtbarkeitserhalt und Erosionsschutz)<br/>"), "12" == c && (a = "Beschreibung: Wasserschutzgebiet (Trinkwasserschutzgebiet, Heilquellenschutzgebiet,..)<br/>"), "13" == c && (a = "Beschreibung: Klima und Luft (Kaltluftenstehung/Frischluftversorgung, Immissionsschutz,..)<br/>"), "14" == c && (a = "Beschreibung: Artenschutzgebiet (Angelverbot, Fischereischutzzone, Jagdschutzgebiet, Vogelschutzgebiet,..)<br/>"), "15" == c && (a = "Beschreibung: \"Standortausstattung\": Retentionsraum (gesetzlich gesch\xFCtztes \xDCberschwemmungsgebiet) <br/>"), "16" == c && (a = "Beschreibung: Dauerhafte Gefahrenbereiche (Lebensschutz, Bodenbewegungsgebiet,..)<br/>"), "19" == c && (a = "Beschreibung: Weitere nationale Gebiete<br/>"));
    return a;
},
    fnContentLanduse = exports.fnContentLanduse = function fnContentLanduse(b) {
    var a = "";"quarry" == b.landuse && b.resource && (a += "Resource: " + b.resource + "<br/>");"open_stable" == b["animal_keeping:type"] && (a += "Offenstall<br/>");"field_shelter" == b["animal_keeping:type"] && (a += "Weide mit Unterstand<br/>");"paddock" == b["animal_keeping:type"] && (a += "Paddock<br/>");b.animal_keeping && (a += "Tiere: Perde<br/>");return a;
},
    fnMessstation = exports.fnMessstation = function fnMessstation(b) {
    var a = "";"yes" == b["monitoring:water_level"] && (a += "Pegelstand<br/>");"yes" == b["monitoring:seismic_activity"] && (a += "seismische Aktivit\xE4ten<br/>");"yes" == b["monitoring:tide_gauge"] && (a += "Tidestand<br/>");"yes" == b["monitoring:weather"] && (a += "Wetterdaten<br/>");"yes" == b["monitoring:air_quality"] && (a += "Luftqualit\xE4t<br/>");return a;
},
    fnContentRoute = exports.fnContentRoute = function fnContentRoute(b) {
    var a = "";b.route && ("yes" == b.roundtrip && (a += "Rundweg<br/>"), b.length && (a += "L\xE4nge/Distanz: " + b.length + "<br/>"), b.distance && (a += "L\xE4nge/Distanz: " + b.distance + "<br/>"), b.symbol && (a += "Symbol: " + b.symbol + "<br/>"));return a;
},
    fnContentPetrol = exports.fnContentPetrol = function fnContentPetrol(b) {
    var a = "";"fuel" == b.amenity && ("yes" == b["fuel:biodiesel"] && (a += "Biodiesel<br/>"), "yes" == b["fuel:e85"] && (a += "Ethanol<br/>"), "yes" == b["fuel:e10"] && (a += "E10<br/>"), "yes" == b["fuel:lpg"] && (a += "Autogas<br/>"), "yes" == b["fuel:cng"] && (a += "Erdgas<br/>"), "diesel" == b.fuel && (a += "Diesel<br/>"), "lpg" == b.fuel && (a += "Autogas<br/>"), "yes" == b["fuel:octane_95"] && (a += "Super Bleifrei<br/>"), "yes" == b["fuel:octane_98"] && (a += "Super Plus<br/>"), "yes" == b["fuel:octane_100"] && (a += "V-Power Racing<br/>"), "yes" == b["fuel:octane_102"] && (a += "Ultimate<br/>"), "yes" == b["fuel:diesel"] && (a += "Diesel<br/>"), "yes" == b["fuel:electricity"] && (a += "Ladestation / Stromtankstelle<br/>"));return a;
},
    fnContentHistoric = exports.fnContentHistoric = function fnContentHistoric(b) {
    var a = "";if ("archaeological_site" == b.historic && b.site_type) switch (b.site_type) {case "megalith":
            a += "Megalith<br/>";break;case "bigstone":
            a += "Findling<br/>";break;case "tumulus":
            a += "H\xFCgelgrab<br/>";break;case "fortification":
            a += "historischer Graben / Wall<br/>";break;default:
            a += "unbekannt<br/>";}return a;
},
    fnContentBarriers = exports.fnContentBarriers = function fnContentBarriers(b, a) {
    var c = "";if ("wall" == b.barrier || "bollard" == b.barrier) b.material && (c += "Material: " + translate(b.material) + "<br/>");return c;
},
    fnContentTourism = exports.fnContentTourism = function fnContentTourism(b) {
    var a = "";if ("camp_site" == b.tourism) {
        "yes" == b.dog && (a += "Hunde erlaubt<br/>");"no" == b.dog && (a += "Hunde nicht erlaubt<br/>");b.stars && (a += b.stars + "Sterne<br/>");b.caravans && (a += "Wohnmobilstellpl\xE4tze<br/>");if ("yes" == b.openfire || "yes" == b.fireplace) a += "Feuerstellen vorhanden<br/>";"yes" == b.washing_machine && (a += "Waschmaschinen<br/>");"yes" == b.dryer && (a += "Trockner<br/>");"yes" == b.group_only && (a += "Nutzung nur durch Gruppen<br/>");"reception" == b.camp_site && (a += "Reception vorhanden<br/>");
    }"information" == b.tourism && "map" == b.information && ("topo" == b.map_type && (a += "Topografische Karte</br>"), "street" == b.map_type && (a += "Stra\xDFenkarte</br>"), "scheme" == b.map_type && (a += "Schematische Karte</br>"), "toposcope" == b.map_type && (a += "Schematische Karte</br>"));"information" == b.tourism && "map" == b.information && ("site" == b.map_size && (a += "Karte einer Anlage</br>"), "city" == b.map_size && (a += "Stadtplan</br>"), "region" == b.map_size && (a += "Karte der Region</br>"));"geology" == b.board_type && (a += "Geologische Informationen<br/>");"history" == b.board_type && (a += "Historische Informationen<br/>");"nature" == b.board_type && (a += "Informationen \xFCber Natur<br/>");"notice" == b.board_type && (a += "Allgemeine Information<br/>");"plants" == b.board_type && (a += "Informationen \xFCber Pflanzen<br/>");"wildlife" == b.board_type && (a += "Informationen \xFCber Wild<br/>");return a;
},
    fnContentAmenity = exports.fnContentAmenity = function fnContentAmenity(b) {
    var a = "";"boat_sharing" == b.amenity && (a += b.boattype + "<br/>");"embassy" == b.amenity && (a += b.country + "<br/>");if (b.vending) switch (b.vending) {case "admission_tickets":
            a += "Tickets<br/>";break;case "animal_feed":
            a += "Tierfutter<br/>";break;case "books":
            a += "B\xFCcher<br/>";break;case "candles":
            a += "Kerzen<br/>";break;case "cigarettes":
            a += "Zigaretten<br/>";break;case "condoms":
            a += "Kondome<br/>";break;case "drinks":
            a += "Getr\xE4nke<br/>";break;case "first_aid":
            a += "Erste Hilfe Artikel<br/>";break;
        case "fishing_tackle":
            a += "Angelequipment<br/>";break;case "flowers":
            a += "Blumen<br/>";break;case "ice_cream":
            a += "Eis<br/>";break;case "laundry_detergent":
            a += "Waschmittel<br/>";break;case "newspapers":
            a += "Zeitung<br/>";break;case "SIM_cards":
            a += "SIM-Karten<br/>";break;case "sweets":
            a += "S\xFC\xDFigkeiten<br/>";break;case "parcel_pickup":
            a += "Paketstation<br/>";break;case "ice_cubes":
            a += "Eisw\xFCrfel<br/>";break;case "public_transport_tickets":
            a += "Tickets f\xFCr \xF6ffentliche Verkehrsmittel<br/>";
            break;case "parking_ticket":
            a += "Parkticket<br/>";break;case "sex_toys":
            a += "Sexspielzeug<br/>";break;case "stamps":
            a += "Briefmarken<br/>";break;case "toll":
            a += "Mauttickets<br/>";break;case "umbrellas":
            a += "Regenschirme<br/>";break;default:
            a += "Inhalt unbekannt<br/>";}"post_box" == b.amenity && (b.collection_times && (a += "Leerungszeiten: " + b.collection_times + "<br/>"), "yes" == b.drive_through && (a += "Vom Auto aus erreichbar. <br/>"));return a;
},
    fnContentStorage = exports.fnContentStorage = function fnContentStorage(b) {
    var a = "";if ("storage_tank" == b.man_made) {
        if (b.content) {
            var c = b.content;switch (c) {case "fuel":
                    c = "Diesel";break;case "oil":
                    c = "\xD6l";break;case "gas":
                    c = "Gas";break;case "slurry":
                    c = "G\xFClle";break;case "cement":
                    c = "Zement";break;case "water":
                    c = "Wasser";break;case "manure":
                    c = "D\xFCnger";break;case "silage":
                    c = "Silage";}a += "Inhalt: " + c + "<br/>";
        }if (b.contents) {
            c = b.contents;switch (c) {case "fuel":
                    c = "Diesel";break;case "oil":
                    c = "\xD6l";break;case "gas":
                    c = "Gas";break;case "slurry":
                    c = "G\xFClle";break;case "cement":
                    c = "Zement";break;case "water":
                    c = "Wasser";break;
                case "manure":
                    c = "D\xFCnger";break;case "silage":
                    c = "Silage";}a += "Inhalt: " + c + "<br/>";
        }
    }b.storage && ("gas" == b.storage && (a += "Inhalt: Gas<br/>"), "oil" == b.storage && (a += "Inhalt: \xD6l<br/>"));return a;
},
    fnContentInformationCity = exports.fnContentInformationCity = function fnContentInformationCity(b) {
    var a = "";b["name:de"] && (a += "deutscher Name: " + b["name:de"] + "<br/>");if (1E4 <= b.population) if (b.population = "" + b.population, 3 < b.population.length) {
        var c = b.population.length % 3,
            d = 0 < c ? b.population.substring(0, c) : "";for (var i = 0; i < Math.floor(b.population.length / 3); i++) {
            d = 0 == c && 0 == i ? d + b.population.substring(c + 3 * i, c + 3 * i + 3) : d + ("." + b.population.substring(c + 3 * i, c + 3 * i + 3));
        }a += "Einwohnerzahl: " + d + "<br/>";
    } else a += "Einwohnerzahl " + b.population + "<br/>";1E4 >= b.population && (a += "Einwohnerzahl: " + b.population + "<br/>");return a;
},
    fnContentEmergency = exports.fnContentEmergency = function fnContentEmergency(b) {
    var a = "";b.lifeboat && ("inshore" == b.lifeboat ? a += "Einsatzgebiet: Inshore (Binnen)<br/>" : "offshore" == b.lifeboat && (a += "Einsatzgebiet: Offshore (Buten)<br/>"));b["lifeboat:class"] && (a += "Bootstyp: " + b["lifeboat:class"] + "<br/>");if (b["siren:type"]) {
        var c = b["siren:type"];switch (c) {case "mechanical":
                c = "mechanisch";break;case "electronic":
                c = "elektronisch";break;case "pneumatic":
                c = "pneumatisch";break;case "electromechanic":
                c = "elektromechanisch";}a += "Typ: " + c + "<br/>";
    }if (b["siren:purpose"]) {
        c = b["siren:purpose"];switch (c) {case "air_raid":
                c = "Luftschutz";break;case "tornado":
                c = "Tornado";break;case "storm":
                c = "Sturm";break;case "civil_defense":
                c = "Bev\xF6lkerungsschutz";break;case "fire":
                c = "Feuer";}a += "Nutzung: " + c + "<br/>";
    }b["siren:model"] && (a += "Model: " + b["siren:model"] + "<br/>");b["siren:range"] && (a += "H\xF6rweite: " + b["siren:range"] + "<br/>");return a;
},
    fnContentCuisine = exports.fnContentCuisine = function fnContentCuisine(b) {
    var a = "";if (b.cuisine) {
        var c = "",
            a = ("supermarket" == b.shop || "convenience" == b.shop || "deli" == b.shop || "organic" == b.shop) && "restaurant" != b.amenity ? a + "Spezialit\xE4ten: " : a + "K\xFCche: ";"arabic" == b.cuisine && (c += "arabisch<br/>");"italian" == b.cuisine && (c += " italienisch<br/>");"international" == b.cuisine && (c += " international<br/>");"regional" == b.cuisine && (c += " regional<br/>");"chinese" == b.cuisine && (c += " chinesisch<br/>");"greek" == b.cuisine && (c += " griechisch<br/>");"african" == b.cuisine && (c += " afrikanisch<br/>");"german" == b.cuisine && (c += " deutsch<br/>");"mexican" == b.cuisine && (c += " mexikanisch<br/>");"french" == b.cuisine && (c += " franz\xF6sisch<br/>");"indian" == b.cuisine && (c += " indisch<br/>");"iranian" == b.cuisine && (c += " iranisch<br/>");"lebanese" == b.cuisine && (c += " libanesisch<br/>");"thai" == b.cuisine && (c += " thail\xE4ndisch<br/>");"balkan" == b.cuisine && (c += " balkan<br/>");"turkish" == b.cuisine && (c += " t\xFCrkisch<br/>");"bavarian" == b.cuisine && (c += " bayrisch<br/>");"czech" == b.cuisine && (c += " tschechisch<br/>");"portuguese" == b.cuisine && (c += " portugiesisch<br/>");"spanish" == b.cuisine && (c += " spanisch<br/>");"japanese" == b.cuisine && (c += " japanisch<br/>");"fish" == b.cuisine && (c += " Fisch<br/>");"brazilian" == b.cuisine && (c += " brasilianisch<br/>");"asian" == b.cuisine && (c += " asiatisch<br/>");"mediterranean" == b.cuisine && (c += " mediterran<br/>");"seafood" == b.cuisine && (c += " Meeresfr\xFCchte<br/>");"ice_cream" == b.cuisine && (c += " Eiscrem<br/>");"burger" == b.cuisine && (c += " Fast Food<br/>");"frozen_yogurt" == b.cuisine && (c += " Frozen Yogurt<br/>");"" == c && (c = b.cuisine + "<br/>");a += c;
    }return a;
},
    fnContentShipping = exports.fnContentShipping = function fnContentShipping(b) {
    var a = "";b.harbour = "yes";"yes" == b["access:tide"] && (a += "Zufahrtsbeschr\xE4nkung durch Tide</br>");"yes" == b["access:swell"] && (a += "Zufahrtsbeschr\xE4nkung durch Schwell</br>");"yes" == b["access:ice"] && (a += "Zufahrtsbeschr\xE4nkung durch Eis</br>");b.vhf_channel && (a += "UKW-Kanal: " + b.vhf_channel + "</br>");b.mmsi && (a += "MMSI-Nummer: " + b.mmsi + "</br>");b["harbour:information"] && (a += "Information :" + b["harbour:information"] + "</br>");"yes" == b.motorboat && (a += "Fahren mit Motor erlaubt</br>");"no" == b.motorboat && (a += "Fahren mit Motor nicht erlaubt</br>");b.CEMT && (a += "CEMT: " + b.CEMT + "</br>");"yes" == b.intermittent && (a += "Fluss zeitweise ausgetrocknet</br>");"yes" == b.tidal && (a += "Gezeiten beeinflussen die Str\xF6mung</br>");b.draft && (a += "Fahrwassertiefe: " + b.draft + " m</br>");if ("slipway" == b.leisure || "slipway" == b.harbour) "hand" == b.operating && (a += "Funktionsweise: Handbetrieb, Slipwagen<br/>"), "car" == b.operating && (a += "Funktionsweise: mit Auto, Bootsanh\xE4nger<br/>"), "cable_winch" == b.operating && (a += "Funktionsweise: Seilwinde<br/>"), "travellift" == b.operating && (a += "Funktionsweise: Travellift<br/>"), "crane" == b.man_made && (a += "mit Kran<br/>", b["crane:maxload"] && (a += "Maximale Last: " + b["crane:maxload"] + "<br/>"), b["ship:maxdraft"] && (a += "Maximaler Tiefgang: " + b["ship:maxdraft"] + "<br/>"), b["ship:maxlength"] && (a += "Maximale Bootsl\xE4nge: " + b["ship:maxlength"] + "<br/>")), "yes" == b.vehicle && (a += "Mit Fahrzeug erreichbar<br/>");a += fnWreckInfo(b);if ("ferry" == b.route || "ferry_terminal" == b.amenity || "yes" == b.ferry) {
        var c = b.duration;"" != c && "undefined" != c && null != c && (a += "Fahrtzeit in Std. : " + c + "<br/>");"yes" == b.motorcar && (a += "Autos erlaubt <br/>");"no" == b.motorcar && (a += "Autos nicht erlaubt <br/>");"no" == b.motor_vehicle && (a += "Fahrzeuge nicht erlaubt <br/>");"yes" == b.motor_vehicle && (a += "Fahrzeuge erlaubt <br/>");"yes" == b.vehicle && (a += "Fahrzeuge erlaubt <br/>");"no" == b.vehicle && (a += "Keine Fahrzeuge<br/>");"no" == b.bicycle && (a += "Keine Fahrr\xE4der<br/>");"no" == b.bicycle && (a += "Fahrr\xE4der erlaubt<br/>");"yes" == b.hgv && (a += "LKW erlaubt <br/>");"no" == b.hgv && (a += "LKW nicht erlaubt <br/>");"yes" == b.foot && (a += "Fussg\xE4nger erlaubt <br/>");"no" == b.foot && (a += "Fussg\xE4nger nicht erlaubt <br/>");"yes" == b.bicycle && (a += "Fahrradfahrer erlaubt <br/>");"no" == b.bicycle && (a += "Fahrradfahrer nicht erlaubt <br/>");"yes" == b["ferry:cable"] && (a += "Seilf\xE4hre<br/>");
    }if (b["seamark:light:1:colour"]) {
        c = b["seamark:light:1:colour"];switch (c) {case "white":
                c = "Wei\xDF";break;case "red":
                c = "Rot";break;case "green":
                c = "Gr\xFCn";break;case "blue":
                c = "Blau";break;case "yellow":
                c = "Gelb";break;case "amber":
                c = "Bernsteinfarben";}a += "Farbe des Lichts: " + c + "<br/>";
    }"lighthouse" == b.man_made && (b["seamark:light:1:character"] && (a += "Rhytmus des Lichtes: " + b["seamark:light:1:character"] + "<br/>"), b["seamark:light:1:period"] && (a += "Periode: " + b["seamark:light:1:period"] + "<br/>"), b["seamark:light:1:height"] && (a += "H\xF6he: " + b["seamark:light:1:height"] + " m<br/>"), b["seamark:light:1:range"] && (a += "Reichweite: " + b["seamark:light:1:range"] + " sm<br/>"));if (b["seamark:light:colour"]) {
        c = b["seamark:light:colour"];switch (c) {case "white":
                c = "Wei\xDF";break;case "red":
                c = "Rot";break;case "green":
                c = "Gr\xFCn";break;case "blue":
                c = "Blau";break;case "yellow":
                c = "Gelb";break;case "amber":
                c = "Bernsteinfarben";}a += "Farbe des Lichts: " + c + "<br/>";
    }"lighthouse" == b.man_made && (b["seamark:light:character"] && (a += "Rhytmus des Lichtes: " + b["seamark:light:character"] + "<br/>"), b["seamark:light:height"] && (a += "H\xF6he: " + b["seamark:light:height"] + " m<br/>"), b["seamark:light:range"] && (a += "Reichweite: " + b["seamark:light:range"] + " sm<br/>"), b["seamark:light:period"] && (a += "Periode: " + b["seamark:light:period"] + "<br/>"));return a;
},
    fnContentHydrants = exports.fnContentHydrants = function fnContentHydrants(b) {
    var a = "";if ("fire_hydrant" == b.emergency) {
        var c = b["fire_hydrant:count"];"undefined" != c && null != c && "" != c && (a += "Anzahl: " + c + "<br/>");c = b["fire_hydrant:diameter"];
        "undefined" != c && null != c && "" != c && (a += "Rohrdurchmesser: " + c + " mm<br/>");c = b["fire_hydrant:pressure"];"undefined" != c && null != c && "" != c && (a = "suction" == c ? a + "Druck in bar / Saugleitung: Saugleitung<br/>" : a + ("Druck in bar / Saugleitung: " + c + "<br/>"));c = b["fire_hydrant:position"];"undefined" != c && null != c && "" != c && ("lane" == c ? a += "Position: Fahrbahn<br/>" : "parking_lot" == c ? a += "Position: Parkbucht<br/>" : "sidewalk" == c ? a += "Position: B\xFCrgersteig<br/>" : "green" == c && (a += "Position: Wiese<br/>"));c = b.water_volume;
        "undefined" != c && null != c && "" != c && (a += "Volumen: " + c + "<br/>");c = b["fire_hydrant:awwa_class"];"undefined" != c && null != c && "" != c ? a += "AWWA Klasse: " + c + "<br/>" : (c = b.flow_rate, "undefined" != c && null != c && "" != c && (a += "Durchfluss: " + c + "<br/>"));c = b.water_source;"undefined" != c && null != c && "" != c && "main" != c && (a += "Wasserquelle: " + c + "<br/>");c = b["couplings:type"];"undefined" != c && null != c && "" != c && (a += "Kopplungstyp: " + c + "<br/>");c = b["couplings:diameter"];"undefined" != c && null != c && "" != c && (a += "Kopplungsdurchmesser: " + c + "<br/>");c = b["pillar:type"];"dry_barrel" === c && (a += "Typ \xDCberflurhydrant: " + c + "<br/>");"fire_hydrant" === b["disused:emergency"] && (a += "Aktuell unbrauchbar.");"" == a && (a = "Keine Details vorhanden.");
    }return a;
},
    fnContentStreetsTraffic = exports.fnContentStreetsTraffic = function fnContentStreetsTraffic(b) {
    var a = "";"yes" == b["red_turn:right"] && (a += "Ampel mit Gr\xFCnpfeil<br/>");"no" == b["red_turn:right"] && (a += "Ampel ohne Gr\xFCnpfeil<br/>");b.bridge && (b.height && (a += "H\xF6he \xFCber dem Grund: " + b.height + " m<br/>"), b.length && (a += "L\xE4nge der Br\xFCcke: " + b.length + " m<br/>"), b.bridge_ref && (a += "Bauwerksnummer: " + b.bridge_ref + "<br/>"), b.start_date && (a += "Baujahr: " + b.start_date + "</br>;"), b.maxweight && (a += "Tragf\xE4higkeit: " + b.maxweight + " t</br>"));b.highway && "yes" == b.toll && (a += "Mautpflichtige Stra\xDFe<br/>");"yes" == b["toll:hgv"] && (a += "Mautpflichtige Stra\xDFe f\xFCr LKWs<br/>");if (b.surface) {
        var c = b.surface,
            a = a + "Oberfl\xE4che: ";switch (c) {case "grass":
                a += "Gras<br/>";break;case "paved":
                a += "versiegelt<br/>";break;case "asphalt":
                a += "Asphalt<br/>";
                break;case "cobblestone":
                a += "Naturstein unbehauen<br/>";break;case "sett":
                a += "behauenes Steinpflaster<br/>";break;case "concrete":
                a += "Beton<br/>";break;case "unpaved":
                a += "ohne Stra\xDFenbelag<br/>";break;case "paving_stones":
                a += "Pflastersteine<br/>";break;case "compacted":
                a += "verdichtete Deckschicht aus Natursteinmaterial<br/>";break;case "dirt":
                a += "unbefestigt<br/>";break;case "fine_gravel":
                a += "Splitt/Kies<br/>";break;case "grass_paver":
                a += "Rasengittersteine<br/>";break;case "gravel":
                a += "Schotter<br/>";
                break;case "earth":
                a += "naturbelassene Oberfl\xE4che<br/>";break;case "ground":
                a += "naturbelassene Oberfl\xE4che<br/>";break;case "metal":
                a += "Metall<br/>";break;case "mud":
                a += "Matsch, Morast<br/>";break;case "sand":
                a += "Sand<br/>";break;case "wood":
                a += "Holz<br/>";break;case "tartan":
                a += "Tartan- oder Kunststoffbelag<br/>";break;case "artificial_turf":
                a += "Kunstrasen<br/>";break;case "clay":
                a += "Ascheplatz<br/>";break;default:
                a += "unbekannt<br/>";}
    }"grade1" == b.tracktype && (a += "Wegbeschaffenheit: Befestigter Weg (Asphalt, Beton oder Pflastersteine)<br/>");
    "grade2" == b.tracktype && (a += "Wegbeschaffenheit: Befestigter Weg (Schotter oder andere verdichtete Materialien)<br/>");"grade3" == b.tracktype && (a += "Wegbeschaffenheit: Befestigter oder ausgebesserter Weg, der harten und weichen Untergrund enth\xE4lt (z. B. Feinschotter-, Sand- oder Erdweg)<br/>");"grade4" == b.tracktype && (a += "Wegbeschaffenheit: Unbefestigter Weg, haupts\xE4chlich weiche Materialien, Pflanzenwuchs entlang der Spurmitte (z. B. Gras-, Sand- oder Erdweg)<br/>");"grade5" == b.tracktype && (a += "Wegbeschaffenheit: Unbefestigter Weg, Oberfl\xE4che besteht aus Sand, Erde etc., oft nur Abdruck in Gras, teilweise schwer von umgebendem Gel\xE4nde unterscheidbar<br/>");"yes" == b.motorcycle && (a += "<br/>mit dem Auto befahrbar.<br/>");"no" == b.motorcycle && (a += "<br/>keine motorisierten Fahrzeuge zugelassen.<br/>");"excellent" == b.trail_visibility && (a += "Wegerkennbarkeit: Gut ausgewiesener Weg<br/>");"good" == b.trail_visibility && (a += "Wegerkennbarkeit: Wegmarkierung sichbar, aber manchmal etwas schwer zu finden<br/>");
    "intermediate" == b.trail_visibility && (a += "Wegerkennbarkeit: Weg nicht durchgegend sichbar<br/>");"bad" == b.trail_visibility && (a += "Wegerkennbarkeit: Wegspur ist kaum zu erkennen<br/>");"horrible" == b.trail_visibility && (a += "Wegerkennbarkeit: Oft kein Weg vorhanden<br/>");"no" == b.trail_visibility && (a += "Wegerkennbarkeit: Meistens keine Wegspur zu erkennen<br/>");"hiking" == b.sac_scale && (a += "Weg: Weg gut gebahnt. (Schwierigskeitstyp: 1)</br>");"mountain_hiking" == b.sac_scale && (a += "Weg: Durchgehend gut ersichtlicher und gut begehbarer Weg (Schwierigskeitstyp: 2)</br>");
    "demanding_mountain_hiking" == b.sac_scale && (a += "Weg: Heikle Stellen k\xF6nnen mit Seilen oder Ketten gesichert sein. Leitern sind m\xF6glich. Eventuell sind die H\xE4nde f\xFCrs Gleichgewicht n\xF6tig. (Schwierigskeitstyp: 3)</br>");"alphine_hiking" == b.sac_scale && (a += "Weg: Wegspur kaum vorhanden. An gewissen Stellen ben\xF6tigt man die H\xE4nde zum weiterkommen (Schwierigskeitstyp: 4)</br>");"demanding_alphine_hiking" == b.sac_scale && (a += "Weg: Oft weglos, einzelne einfache Kletterstellen bis II. (Schwierigskeitstyp: 5)</br>");
    "difficult_alpine_hiking" == b.sac_scale && (a += "Weg: Schwieriges Alpinenwandern,Kletterstellen bis II. Schwierigskeitstyp: 6</br>");b["mtb:name"] && (a += "Fahrradstrecke :" + b["mtb:name"] + "</br>");"0" == b["mtb:scale"] && (a += "Mountainbikestrecke: Keine besondere Schwierigkeiten.</br>Wegbeschaffenheit: fester und griffiger Untergrund.</br>Hindernisse: Keine Hindernisse</br>Gef\xE4lle: Leicht bis m\xE4\xDFig</br>Kurven: weit</br>Fahrtechnik: keine besonderes fahrtechnisches K\xF6nnen n\xF6tig</br>");
    "1" == b["mtb:scale"] && (a += "Mountainbikestrecke: Der Weg enth\xE4lt flache Wurzeln und kleinere Steine. H\xE4ufig auch vereizelte Wasserrinnen und Erosionssch\xE4den</br>Wegbeschaffenheit: loserer Untergrund m\xF6glich, kleine Wurzeln und Steine</br>Hindernisse: kleine Hindernisse, Wasserrinnen, Erosionssch\xE4den</br>Gef\xE4lle: bis zu 40%</br>Kurven: eng</br>Fahrtechnik: Fahrtechnische Grundkentnisse n\xF6tig. Hindernisse k\xF6nnen \xFCberrollt werden</br>");"2" == b["mtb:scale"] && (a += "Mountainbikestrecke: Der Weg enth\xE4lt gr\xF6\xDFere Wurzeln und Steine. H\xE4ufig auch vereizelte Wasserrinnen und Erosionssch\xE4den</br>Wegbeschaffenheit: Untergrund meist nicht verfestigt, gr\xF6\xDFere Wurzeln und Steine</br>Hindernisse:  flache Abs\xE4tze und Treppen</br>Gef\xE4lle: bis zu 70%</br>Kurven: leichte Spitzkehren</br>Fahrtechnik: Fortgeschrittene Fahrtechnik n\xF6tig.</br>");"3" == b["mtb:scale"] && (a += "Mountainbikestrecke: Auf dem Weg findet man verblockte Singletrails mit vielen gr\xF6\xDFeren Felsbrocken und/oder Wurzelpassagen</br>Wegbeschaffenheit: verblockt, viele gro\xDFe Wurzeln/Felsen - rutschiger Untergrund, loses Ger\xF6ll</br>Hindernisse:  hohe Abs\xE4tze</br>Gef\xE4lle: 70% oder mehr</br>Kurven: enge Spitzkehren</br>Fahrtechnik: Sehr gute Bike-Beherrschung n\xF6tig.</br>");
    "4" == b["mtb:scale"] && (a += "Mountainbikestrecke: Auf dem Weg sind sehr steile und stark verblockte Singletrails mit gro\xDFen Felsbrocken und/oder anspruchsvollen Wurzelpassagen, dazwischen h\xE4ufig loses Ger\xF6ll und extreme Steilrampen</br>Wegbeschaffenheit: verblockt, viele gro\xDFe Wurzeln/Felsen - rutschiger Untergrund, loses Ger\xF6ll</br>Hindernisse:  Steilrampen, kaum fahrbare Abs\xE4tze</br>Gef\xE4lle: 70% oder mehr</br>Kurven:  \xD6senartige Spitzkehren</br>Fahrtechnik: Perfekte Bike-Beherrschung mit Trial-Techniken n\xF6tig.</br>");
    "5" == b["mtb:scale"] && (a += "Mountainbikestrecke: Der weg wird charakterisiert durch blockartiges Gel\xE4nde mit Gegenanstiegen, Ger\xF6llfeldern und Erdrutschen, \xF6senartigen Spitzkehren, mehreren hohen, direkt aufeinanderfolgenden Abs\xE4tzen und Hindernissen wie umgefallenen B\xE4umen</br>Wegbeschaffenheit: verblockt mit Gegenanstiegen / rutschiger Untergrund, loses Ger\xF6ll / der Weg ist eher ein Wandersteig</br>Hindernisse:  Steilrampen, kaum fahrbare Abs\xE4tze</br>Gef\xE4lle: 70% oder mehr</br>Kurven:  \xD6senartige Spitzkehren mit Hindernissen</br>Fahrtechnik: excellente Bike-Beherrschung spezieller Trial-Techniken n\xF6tig.</br>");
    "6" == b["mtb:scale"] && (a += "Mountainbikestrecke: Der weg ist hochanspruchsvoll, und selbst f\xFCr Profis und Trial-Fahrer nicht passierbar</br>Wegbeschaffenheit:  Gro\xDFteils nur noch kletterbar</br>Hindernisse: Abs\xE4tze > 2 m, Leitern, Trittstufen, Kletterstellen bei denen man beide H\xE4nde braucht.</br>Gef\xE4lle: 100% oder mehr</br>Kurven: - </br>Fahrtechnik:  hier reicht auch die beste Fahrtechnik nicht mehr</br>");"10" == b.maxspeed && (a += "Vekehrsber\xFChigter Bereich. Hier gilt eine maximale Fahrgeschwindigkeit von 10 Km/h sowie die Regel rechts vor links.</br>");
    "30" == b.maxspeed && (a += "Vekehrsber\xFChigter Bereich. Hier gilt rechts vor links sowie eine maximale Geschwindigkeit von 30 Km/h</br>");"50" == b.maxspeed && (a += "Maximal erlaubte Geschwindigkeit von 50 Km/h darf nicht \xFCberschritten werden </br>");"70" == b.maxspeed && (a += "Maximal erlaubte Geschwindigkeit von 50 Km/h darf nicht \xFCberschritten werden </br>");"80" == b.maxspeed && (a += "Maximale Geschwindigkeit von 80 Km/h darf nicht \xFCberschritten werden.</br>");"100" == b.maxspeed && (a += "Maximale Geschwindigkeit von 100 Km/h darf nicht \xFCberschritten werden.</br>");
    "no" == b.overtaking && (a += "\xDCberholverbot, Fahrzeuge d\xFCrfen nicht \xFCberholen !</br>");"yes" == b.noexit && (a += "Die Stra\xDFe endet hier, es handelt sich um eine Sackgasse</br>");"yes" == b.oneway && (a += "Es handelt sich hier um eine Einbahnstra\xDFe, sie d\xFCrfen diese Stra\xDFe nur in eine Richtung befahren</br>");"designated" == b.priority_road && (a += "Es handelt sich hierbei um eine Vorfahrtsstra\xDFe, derjenige, der sich auf dieser befindet, hat gegen\xFCber anderen Fahrzeugen die Vorfahrt!</br>");
    "end" == b.priority_road && (a += "Die Vorfahrtsstra\xDFe endet hier und die Regelung wird aufgehoben</br>");"emergency_bay" == b.highway && (a += "Hier befindet sich eine Bucht die nur in Notf\xE4llen zur Benuzung zur Verf\xFCgung steht</br>");"yes" == b.traffic_calming && (a += "Verkehrsberuhigter Bereich</br>");"bump" == b.traffic_calming && (a += "Kurze Bodenwelle</br>");"chicane" == b.traffic_calming && (a += "Zu umfahrendenes Hinderniss</br>");"choker" == b.traffic_calming && (a += "Fahrbahnverengung, zu umfahrende Hindernisse m\xF6glich</br>");
    "cushion" == b.traffic_calming && (a += "Bodenwelle mit L\xFCcken aus mehreren rechteckigen Huckeln</br>");"hump" == b.traffic_calming && (a += "vergleichbare Bodenwelle mit etwar einer L\xE4nge von 2-4M</br>");"island" == b.traffic_calming && (a += "Eine Verkehrsinsel</br>");"rumble_strip" == b.traffic_calming && (a += "Holperstreifen</br>");"table" == b.traffic_calming && (a += "lange Bodenwellen mit flachen Mittelst\xFCck</br>");if ("parking" == b.amenity && ("yes" == b.fee && (a += "kostenpflichtig<br/>"), c = b["capacity:women"], "" != c && "no" != c && null != c)) {
        var d = "unbekannt";"yes" != c && (d = c);a += "Frauenparkpl\xE4tze (Anzahl: " + d + ") <br/>";
    }b.park_ride && ("bus" == b.park_ride && (a += "Busanbindung<br/>"), "tram" == b.park_ride && (a += "Bahnanbindung<br/>"), "unknown" == b.park_ride && (a += "Verkehrsmittel unbekannt<br/>"));b["railway:position"] && (a += "Streckenkilometer<br/>Position: " + b["railway:position"] + "<br/>");b.uic_ref && (a += "UIC: " + b.uic_ref + "<br/>");return a;
},
    fnContentSports = exports.fnContentSports = function fnContentSports(b) {
    var a = "";"9pin" == b.sport && (a += "M\xF6gliche Sportart: Kegeln<br/>");
    "10pin" == b.sport && (a += "M\xF6gliche Sportart: Bowling<br/>");"american_football" == b.sport && (a += "M\xF6gliche Sportart: American Football<br/>");"aikido" == b.sport && (a += "M\xF6gliche Sportart: Aikido<br/>");"archery" == b.sport && (a += "M\xF6gliche Sportart: Bogenschie\xDFen<br/>");"athletics" == b.sport && (a += "M\xF6gliche Sportart: Leichtathletik<br/>");"australian_football" == b.sport && (a += "M\xF6gliche Sportart: Australian Football<br/>");"base" == b.sport && (a += "M\xF6gliche Sportart: Objektspringen<br/>");
    "badminton" == b.sport && (a += "M\xF6gliche Sportart: Badminton<br/>");"baseball" == b.sport && (a += "M\xF6gliche Sportart: Baseball<br/>");"basketball" == b.sport && (a += "M\xF6gliche Sportart: Basketball<br/>");"beachvolleyball" == b.sport && (a += "M\xF6gliche Sportart: Beachvolleyball<br/>");"bmx" == b.sport && (a += "M\xF6gliche Sportart: BMX<br/>");"boules" == b.sport && (a += "M\xF6gliche Sportart: Boccia<br/>");"boule" == b.sport && (a += "M\xF6gliche Sportart: Boccia<br/>");"bowls" == b.sport && (a += "M\xF6gliche Sportart: Bowls<br/>");
    "boxing" == b.sport && (a += "M\xF6gliche Sportart: Boxen<br/>");"canadian_football" == b.sport && (a += "M\xF6gliche Sportart: Canadian Football<br/>");"canoe" == b.sport && (a += "M\xF6gliche Sportart: Paddeln<br/>");"chess" == b.sport && (a += "M\xF6gliche Sportart: Schach<br/>");"cliff_diving" == b.sport && (a += "M\xF6gliche Sportart: Klippenspringen<br/>");"climbing" == b.sport && (a += "M\xF6gliche Sportart: Klettern<br/>");"climbing_adventure" == b.sport && (a += "M\xF6gliche Sportart: Klettern<br/>");"cricket" == b.sport && (a += "M\xF6gliche Sportart: Cricket<br/>");"cricket_nets" == b.sport && (a += "M\xF6gliche Sportart: Cricket Netz<br/>");"croquet" == b.sport && (a += "M\xF6gliche Sportart: Croquet<br/>");"curling" == b.sport && (a += "M\xF6gliche Sportart: Curling<br/>");"cycling" == b.sport && (a += "M\xF6gliche Sportart: Radrennen, Radsport<br/>");"dog_racing" == b.sport && (a += "M\xF6gliche Sportart: Hunderennen<br/>");if ("darts" == b.sport || "dart" == b.sport) a += "Darts<br/>";"fencing" == b.sport && (a += "M\xF6gliche Sportart: Fechten<br/>");
    "equestrian" == b.sport && (a += "M\xF6gliche Sportart: Reiten<br/>");"football" == b.sport && (a += "M\xF6gliche Sportart: American Football<br/>");"free_flying" == b.sport && (a += "M\xF6gliche Sportart: Freeflying<br/>");"gaelic_games" == b.sport && (a += "M\xF6gliche Sportart: Gaelic games<br/>");"golf" == b.sport && (a += "M\xF6gliche Sportart: Golf<br/>");"gymnastics" == b.sport && (a += "M\xF6gliche Sportart: Gymnastik<br/>");"hockey" == b.sport && (a += "M\xF6gliche Sportart: Hockey<br/>");"horseshoes" == b.sport && (a += "M\xF6gliche Sportart: Hufeisenwerfen<br/>");"horse_racing" == b.sport && (a += "M\xF6gliche Sportart: Pferderennen<br/>");"ice_stock" == b.sport && (a += "M\xF6gliche Sportart: Eisstockschie\xDFen<br/>");"judo" == b.sport && (a += "M\xF6gliche Sportart: Judo<br/>");"karting" == b.sport && (a += "M\xF6gliche Sportart: Kartfahren<br/>");"kitesurfing" == b.sport && (a += "M\xF6gliche Sportart: Kitesurfing<br/>");"korfball" == b.sport && (a += "M\xF6gliche Sportart: Korfball<br/>");"motor" == b.sport && (a += "M\xF6gliche Sportart: Motorsport<br/>");
    "multi" == b.sport && (a += "M\xF6gliche Sportart: Mehrfachsport<br/>");"obstacle_course" == b.sport && (a += "M\xF6gliche Sportart: Hindernislauf<br/>");"orienteering" == b.sport && (a += "M\xF6gliche Sportart: Orientierungslauf<br/>");"paddle_tennis" == b.sport && (a += "M\xF6gliche Sportart: Paddle-Tennis<br/>");"paragliding" == b.sport && (a += "M\xF6gliche Sportart: Gleitschirmfliegen<br/>");"Pelota" == b.sport && (a += "M\xF6gliche Sportart: Pelota<br/>");"rasquet" == b.sport && (a += "M\xF6gliche Sportart: Racquetball<br/>");
    "rowing" == b.sport && (a += "M\xF6gliche Sportart: Rudern<br/>");"rugby_league" == b.sport && (a += "M\xF6gliche Sportart: Rugby League<br/>");"rugby_union" == b.sport && (a += "M\xF6gliche Sportart: Rugby Union<br/>");"running" == b.sport && (a += "M\xF6gliche Sportart: Laufsport<br/>");"scuba_diving" == b.sport && (a += "M\xF6gliche Sportart: Sporttauchen<br/>");"shooting" == b.sport && (a += "M\xF6gliche Sportart: Sportschie\xDFen<br/>");"skating" == b.sport && (a += "M\xF6gliche Sportart: Eislaufsport<br/>");"skateboard" == b.sport && (a += "M\xF6gliche Sportart: Skateboard<br/>");"skiing" == b.sport && (a += "M\xF6gliche Sportart: Skifahren<br/>");"soccer" == b.sport && (a += "M\xF6gliche Sportart: Fu\xDFball<br/>");"surfing" == b.sport && (a += "M\xF6gliche Sportart: Surfen<br/>");"swimming" == b.sport && (a += "M\xF6gliche Sportart: Schwimmen<br/>");"table_tennis" == b.sport && (a += "M\xF6gliche Sportart: Tischtennis<br/>");"taekwondo" == b.sport && (a += "M\xF6gliche Sportart: Taekwondo<br/>");"team_handball" == b.sport && (a += "M\xF6gliche Sportart: Handball<br/>");
    "tennis" == b.sport && (a += "M\xF6gliche Sportart: Tennis<br/>");"toboggan" == b.sport && (a += "M\xF6gliche Sportart: Rodeln<br/>");"volleyball" == b.sport && (a += "M\xF6gliche Sportart: Volleyball<br/>");"water_ski" == b.sport && (a += "M\xF6gliche Sportart: Wasserski<br/>");"weightlifting" == b.sport && (a += "M\xF6gliche Sportart: Gewichtheben<br/>");"wrestling" == b.sport && (a += "M\xF6gliche Sportart: Ringen<br/>");return a;
};
function fnArztInfo(b) {
    var a = "",
        c = "",
        d = b["healthcare:speciality"];"" != d && ("general" == d && (c += "Allgemeinmedizin<br/>"), "allergology" == d && (c += "Allergologie<br/>"), "anaesthetics" == d && (c += "An\xE4sthesiologie<br/>"), "biochemistry" == d && (c += "Medizinische und chemische Labordiagnostik<br/>"), "biological_haematology" == d && (c += "Biologische H\xE4matologie<br/>"), "biology" == d && (c += "Medizinische Biologie<br/>"), "cardiology" == d && (c += "Kardiologie<br/>"), "cardiac_surgery" == d && (c += "Kardiovaskularchirurgie<br/>"), "child_psychiatry" == d && (c += "Kinder- u. Jugendpsychatrie<br/>"), "dental_oral_maxillo_facial_surgery" == d && (c += "Zahn-, Mund-, Kiefer- und Gesichtschirurgie<br/>"), "dermatology" == d && (c += "Hautkrankheiten<br/>"), "dermatovenereology" == d && (c += "Haut- und Geschlechtskrankheiten<br/>"), "diagnostic_radiology" == d && (c += "Diagnostische Radiologie<br/>"), "emergency" == d && (c += "Unfall- und Notfallmedizin<br/>"), "endocrinology" == d && (c += "Endokrinologie<br/>"), "gastroenterological_surgery" == d && (c += "Gastroenterologische Chirurgie<br/>"), "gastroenterology" == d && (c += "Gastroenterologie<br/>"), "geriatrics" == d && (c += "Geriatrie<br/>"), "gynaecology" == d && (c += "Geburtshilfe und Frauenheilkunde<br/>"), "haematology" == d && (c += "Allgemeine H\xE4matologie<br/>"), "hepatology" == d && (c += "Hepatologie<br/>"), "immunology" == d && (c += "Immunologie<br/>"), "infectious_diseases" == d && (c += "Ansteckende Krankheiten<br/>"), "intensive" == d && (c += "Intensivmedizin<br/>"), "internal" == d && (c += "Allgemeine (innere) Medizin<br/>"), "maxillofacial_surgery" == d && (c += "Mund-Kiefer-Gesichtschirurgie<br/>"), "nephrology" == d && (c += "Nierenkrankheiten<br/>"), "neurology" == d && (c += "Neurologie<br/>"), "neurophysiology" == d && (c += "Klinische Neurophysiologie<br/>"), "neuropsychiatry" == d && (c += "Neuropsychiatrie(Neurologie und Psychiatrie)<br/>"), "neurosurgery" == d && (c += "Neurochirurgie<br/>"), "nuclear" == d && (c += "Nuklearmedizin<br/>"), "occupational" == d && (c += "Arbeitsmedizin <br/>"), "oncology" == d && (c += "Onkologie<br/>"), "ophthalmology" == d && (c += "Augenheilkunde<br/>"), "orthopaedics" == d && (c += "Orthop\xE4die<br/>"), "otolaryngology" == d && (c += "Hals-Nasen-Ohren-Heilkunde<br/>"), "paediatric_surgery" == d && (c += "Kinderchirurgie<br/>"), "paediatrics" == d && (c += "Kinderheilkunde<br/>"), "palliative" == d && (c += "Palliativmedizin<br/>"), "physiatry" == d && (c += "Physikalischeund Rehabilitative Medizin<br/>"), "plastic_surgery" == d && (c += "Plastische Chirurgie<br/>"), "proctology" == d && (c += "Proktologie<br/>"), "psychiatry" == d && (c += "Psychiatrie<br/>"), "pulmonology" == d && (c += "Lungen- und Bronchialheilkunde<br/>"), "radiology" == d && (c += "Radiologie<br/>"), "radiotherapy" == d && (c += "Strahlentherapie<br/>"), "rheumatology" == d && (c += "Rheumatologie<br/>"), "stomatology" == d && (c += "Stomatologie<br/>"), "surgery" == d && (c += "Chirurgie<br/>"), "surgical_oncology" == d && (c += "Krebschirurgie<br/>"), "thoracic_surgery" == d && (c += "Thoraxchirurgie<br/>"), "transplant" == d && (c += "Transplantationsmedizin<br/>"), "trauma" == d && (c += "Unfallchirurgie<br/>"), "tropical" == d && (c += "Tropenmedizin<br/>"), "urology" == d && (c += "Urologie<br/>"), "vascular_surgery" == d && (c += "Gef\xE4\xDFchirurgie<br/>"), "venereology" == d && (c += "Geschlechtskrankheiten<br/>"), "acupuncture" == d && (c += "Akupunktur<br/>"), "naturopathy" == d && (c += "Naturheilkunde<br/>"), "chiropractic" == d && (c += "Chiropraktik <br/>"), "homeopathy" == d && (c += "Hom\xF6opathie<br/>"), "osteopathy" == d && (c += "Osteopathie<br/>"));"" != b.health_specialty && ("yes" == b["health_specialty:family_medicine"] && (c += "Allgemeinmedizin<br/>"), "yes" == b["health_specialty:emergency_medicine"] && (c += "Notfallmedizin<br/>"), "yes" == b["health_specialty:anaesthesiology"] && (c += "An\xE4sthesie<br/>"), "yes" == b["health_specialty:dermatology"] && (c += "Dermatologie<br/>"), "yes" == b["health_specialty:ear_nose_throat"] && (c += "Hals, Nasen, Ohren (HNO)<br/>"), "yes" == b["health_specialty:occupational_medicine"] && (c += "Arbeitsnmedizin<br/>"), "yes" == b["health_specialty:internal_medicine"] && (c += "innere Medizin<br/>"), "yes" == b["health_specialty:neurology"] && (c += "Neurologie<br/>"), "yes" == b["health_specialty:ophthalmology"] && (c += "Augenheilkunde<br/>"), "yes" == b["health_specialty:palliative_medicine"] && (c += "Palliativmedizin<br/>"), "yes" == b["health_specialty:psychiatry"] && (c += "Psychatrie<br/>"), "yes" == b["health_specialty:gynaecology"] && (c += "Gyn\xE4kologie<br/>"), "yes" == b["health_specialty:urology"] && (c += "Urologie<br/>"), "yes" == b["health_specialty:pain_medicine"] && (c += "Schmerzmedizin<br/>"), "yes" == b["health_specialty:environmental_medicine"] && (c += "Umweltmedizin<br/>"), "yes" == b["health_specialty:intensive_care_medicin"] && (c += "Intensivmedizin<br/>"), "yes" == b["health_specialty:paediatrics"] && (c += "Kinder- u. Jugendmedizin<br/>"), "yes" == b["health_specialty:physiatry"] && (c += "Physikalische und Rehabilitative Medizin<br/>"), "yes" == b["health_specialty:radiology"] && (c += "Radiologie<br/>"), "yes" == b["health_specialty:general"] && (c += "Allgemeinmedizin<br/>"), "yes" == b["health_specialty:occupational_therapy"] && (c += "Ergotherapie<br/>"), "yes" == b["health_specialty:pulmonology"] && (c += "Pneumologie<br/>"), "yes" == b["health_specialty:acupuncture"] && (c += "Akupunktur<br/>"), "yes" == b["health_specialty:orthopaedics"] && (c += "Orthop\xE4die<br/>"), "yes" == b["health_specialty:chiropractic"] && (c += "Chiropraktik<br/>"), "yes" == b["health_specialty:sports_medicine"] && (c += "Sportmedizin<br/>"));"" != c && (a = a + "Fachgebiete: " + ('<div class="c4g_open_text">' + c + "</div>"));return a;
}
function fnKraftwerkInfo(b) {
    var a = "";if (b["generator:method"]) {
        a += "Erzeugungsart: ";switch (b["generator:method"]) {case "combustion":
                a += "Verbrennung";break;case "thermal":
                a += "thermische Nutzung (z.B. Solarthermie)";break;case "pumping":
                a += "durch Pumpen (z.B. die Nutzung von Geothermie)";break;case "photovoltaic":
                a += "Photovoltaik";break;case "gasification":
                a += "Vergasung, danach Verbrennung";break;case "anaerobic_digestion":
                a += "Erzeugung von Biogas durch Verg\xE4rung";break;case "pyrolysis":
                a += "Pyrolyse, Aufspaltung durch hohe Temperaturen";
                break;case "fission":
                a += "Kernspaltung";break;case "fusion":
                a += "Kernfusion";break;default:
                a += "unbekannt<br/>";}a += "<br/>";
    }if (b.power_source) {
        a += "Erzeugungsart: ";switch (b.power_source) {case "photovoltaic":
                a += "Photovoltaik";break;default:
                a += "unbekannt<br/>";}a += "<br/>";
    }b["generator:output:electricity"] && (a += "elekt. Energieerzeugung: " + b["generator:output:electricity"] + "<br/>");b["generator:output:heat"] && (a += "therm. Energieerzeugung: " + b["generator:output:heat"] + "<br/>");b["generator:output:cold"] && (a += "therm. Energieerzeugung: " + b["generator:output:cold"] + "<br/>");b["generator:output"] && (a += "Nennleistung: " + b["generator:output"] + "<br/>");b["generator:output:hot_air"] && (a += "Art des Transportmediums: " + b["generator:output:hot_air"] + "<br/>");b["generator:output:cold_water"] && (a += "Art des Transportmediums: " + b["generator:output:cold_water"] + "<br/>");b["generator:output:cold_air"] && (a += "Art des Transportmediums: " + b["generator:output:cold_air"] + "<br/>");b["generator:output:compressed_air"] && (a += "Art des Transportmediums: " + b["generator:output:compressed_air"] + "<br/>");b["generator:output:steam"] && (a += "Art des Transportmediums: " + b["generator:output:steam"] + "<br/>");b["generator:output:vacuum"] && (a += "Art des Transportmediums: " + b["generator:output:vacuum"] + "<br/>");b["generator:output:battery_charging"] && (a += "Art des Transportmediums: " + b["generator:output:battery_charging"] + "<br/>");"PWR" == b["generator:type"] && (a += "Generatortyp: " + b["generator:type"] + "<br/>");"BWR-1" == b["generator:type"] && (a += "Generatortyp: " + b["generator:type"] + "<br/>");"BWR-2" == b["generator:type"] && (a += "Generatortyp: " + b["generator:type"] + "<br/>");"BWR-3" == b["generator:type"] && (a += "Generatortyp: " + b["generator:type"] + "<br/>");"BWR-4" == b["generator:type"] && (a += "Generatortyp: " + b["generator:type"] + "<br/>");"BWR-5" == b["generator:type"] && (a += "Generatortyp: " + b["generator:type"] + "<br/>");"BWR-6" == b["generator:type"] && (a += "Generatortyp: " + b["generator:type"] + "<br/>");"PHWR" == b["generator:type"] && (a += "Generatortyp: " + b["generator:type"] + "<br/>");"GCR" == b["generator:type"] && (a += "Generatortyp: " + b["generator:type"] + "<br/>");"FBR" == b["generator:type"] && (a += "Generatortyp: " + b["generator:type"] + "<br/>");"RBMK-1000" == b["generator:type"] && (a += "Generatortyp: " + b["generator:type"] + "<br/>");"RBMK-1500" == b["generator:type"] && (a += "Generatortyp: " + b["generator:type"] + "<br/>");"VVER" == b["generator:type"] && (a += "Generatortyp: " + b["generator:type"] + "<br/>");"CANDU" == b["generator:type"] && (a += "Generatortyp: " + b["generator:type"] + "<br/>");"CPR-1000" == b["generator:type"] && (a += "Generatortyp: " + b["generator:type"] + "<br/>");"EPR" == b["generator:type"] && (a += "Generatortyp: " + b["generator:type"] + "<br/>");"tokamak" == b["generator:type"] && (a += "Generatortyp: " + b["generator:type"] + "<br/>");"stellarator" == b["generator:type"] && (a += "Generatortyp: " + b["generator:type"] + "<br/>");"ICF" == b["generator:type"] && (a += "Generatortyp: " + b["generator:type"] + "<br/>");"cold-fusion" == b["generator:type"] && (a += "Generatortyp: " + b["generator:type"] + "<br/>");"wind_turbine" == b["generator:method"] && "horizontal_axis" == b["generator:type"] && (a += "Generatortyp: Horizontal-Achsen Windenergieanlage<br/>");"wind_turbine" == b["generator:method"] && "vertical_turbine" == b["generator:type"] && (a += "Generatortyp: Vertikalrotor<br/>");"francis_turbine" == b["generator:type"] && (a += "Generatortyp: Francis-Turbine<br/>");"kaplan_turbine" == b["generator:type"] && (a += "Generatortyp: Kaplan-Turbine<br/>");"pelton_turbine" == b["generator:type"] && (a += "Generatortyp: Pelton-Turbine<br/>");"stream" == b["generator:method"] && "horizontal_axis" == b["generator:type"] && (a += "Generatortyp: Gezeitenstromgenerator mit horizontaler Achse<br/>");"stream" == b["generator:method"] && "vertical_axis" == b["generator:type"] && (a += "Generatortyp: Gezeitenstromgenerator mit vertikaler Achse<br/>");"steam_turbine" == b["generator:type"] && (a += "Generatortyp: Dampfturbine<br/>");"heat_pump" == b["generator:type"] && (a += "Generatortyp: W\xE4rmepumpe<br/>");"solar_thermal_collector" == b["generator:type"] && (a += "Generatortyp: Sonnenkollektor<br/>");"solar_photovoltaic_panel" == b["generator:type"] && (a += "Generatortyp: Photovoltaic-System<br/>");"steam_generator" == b["generator:type"] && (a += "Generatortyp: Dampfgenerator<br/>");"gas_turbine" == b["generator:type"] && (a += "Generatortyp: Gasturbine<br/>");"combined_cycle" == b["generator:type"] && (a += "Generatortyp: Dampfgenerator<br/>");"reciprocating_engine" == b["generator:type"] && (a += "Generatortyp: Verbrennungsmotor/Blockheizkraftwerk<br/>");return a;
}
function fnWertstoffinfo(b) {
    var a = "";if ("container" == b.recycling_type || "centre" == b.recycling_type || "recycling" == b.amenity) "yes" == b["recycling:glass"] && (a += "Altglascontainer</br>"), "yes" == b["recycling:shoes"] && (a += "Schuhentsorgung</br>"), "yes" == b["recycling:cooking_oil"] && (a += "Speise-\xD6l-Entsorgung</br>"), "yes" == b["recycling:paper"] && (a += "Papierentsorgung</br>"), "yes" == b["recycling:engine_oil"] && (a += "\xD6l-Entsorgung (Maschinen-, Alt-und Motor\xF6l)</br>"), "yes" == b["recycling:clothes"] && (a += "Altkleidercontainer</br>"), "yes" == b["recycling:car_batteries"] && (a += "Auto-Batterien-Entsorgung</br>"), "yes" == b["recycling:cans"] && (a += "Blechdosenentsorgung</br>"), "yes" == b["recycling:scrap_metal"] && (a += "Altmetallentsorgung</br>"), "yes" == b["recycling:plastic"] && (a += "Plastikentsorgung</br>"), "yes" == b["recycling:batterries"] && (a += "Batterieentsorgung</br>"), "yes" == b["recycling:plastic_bottles"] && (a += "Plastikflaschenentsorgung</br>"), "yes" == b["recycling:green_waste"] && (a += "Gr\xFCnabf\xE4lle</br>"), "yes" == b["recycling:hardcore"] && (a += "Bauschutt und Stra\xDFenmaterial Entsorgung</br>");return a;
}
var fnContentGeneralInformations = function fnContentGeneralInformations(b) {
    var a = "";b.width && (a += "Breite: " + b.width + " m<br/>");b.height && (a += "H\xF6he: " + b.height + " m<br/>");b.maxwidth && (a += "Maximalbreite: " + b.maxwidth + " m<br/>");b.maxheight && (a += "Maximalh\xF6he: " + b.maxheight + " m<br/>");b.maxweight && (a += "Maximalgewicht: " + b.maxweight + " t<br/>");b.maxspeed && (a += "H\xF6chstgeschwindigkeit: " + b.maxspeed + " km/h<br/>");b.min_age && (a += "Mindestalter: " + b.min_age + "<br/>");b.max_age && (a += "Maximalalter: " + b.max_age + "<br/>");"yes" == b.nudism && (a += "Freik\xF6rperkultur<br/>");"yes" == b.ruins && (a += "Ruine<br/>");b.ele && (a += "H\xF6he \xFCber NN: " + b.ele + " m<br/>");b["xmas:day_date"] && (a += "Dauer von - bis: " + b["xmas:day_date"] + "<br/>");b["rotor:diameter"] && (a += "Rotordurchmesser: " + b["rotor:diameter"] + " m<br/>");b["xmas:note"] && (a += "Hinweis: " + b["xmas:note"] + "<br/>");"port" == b["seamark:beacon_lateral:category"] && (a += "Backbord<br/>");"starboard" == b["seamark:beacon_lateral:category"] && (a += "Steuerbord<br/>");"yes" == b["service:bicycle:retail"] && (a += "Fahrradverkauf<br/>");"yes" == b["service:bicycle:repair"] && (a += "Fahrradreparatur<br/>");"yes" == b["service:bicycle:rental"] && (a += "Fahrradverleih<br/>");"yes" == b["service:bicycle:pump"] && (a += "Benutzung einer Luftpumpe m\xF6glich<br/>");"yes" == b["service:bicycle:diy"] && (a += "Benutzung von Werkzeug m\xF6glich<br/>");"yes" == b["service:bicycle:cleaning"] && (a += "Fahrr\xE4der werden gewaschen<br/>");"yes" == b["service:bicycle:second_hand"] && (a += "Verkauf von gebrauchten Fahrr\xE4dern<br/>");"yes" == b["service:bicycle:charging"] && (a += "Elektro-Fahrr\xE4der k\xF6nnen geladen werden<br/>");"yes" == b.cafe && (a += "Kleine Caf\xE9-Ecke<br/>");"yes" == b.breakfast && (a += "Besonderes Fr\xFChst\xFCcksangebot<br/>");"yes" == b.snack && (a += "Back-Snacks warm oder kalt<br/>");"yes" == b.indoor_seating && (a += "Sitzm\xF6glichkeiten im Innenbereich<br/>");"yes" == b.outdoor_seating && (a += "Sitzm\xF6glichkeiten im Au\xDFenbereich<br/>");"yes" == b.self_service && (a += "Selbstbedienungsb\xE4ckerei<br/>");"yes" == b.bakehouse && (a += "Backstube<br/>");"yes" == b.pastry_shop && (a += "Geb\xE4ck aus der Konditorei<br/>");"yes" == b.fair_trade && (a += "einige Fair-Trade-Produkte im Sortiment<br/>");"only" == b.fair_trade && (a += "fast ausschlie\xDFlich Fair-Trade-Produkte im Sortiment<br/>");"no" == b.fair_trade && (a += "keine Fair-Trade-Produkte im Sortiment<br/>");return a;
},
    fnContentHealthcare = function fnContentHealthcare(b) {
    var a = "";if ("doctors" == b.amenity || "physician" == b.office || "doctor" == b.healthcare) a += fnArztInfo(b), b.medical_area && (a += b.medical_area + "<br/>"), b.type && (a += b.type + "<br/>"), b["doctors:de"] && (a += b["doctors:de"] + "<br/>"), b["note:de"] && (a += b["note:de"] + "<br/>");"yes" == b.dispensing && (a += "Apotheke mit Rezepteinl\xF6sung<br/>");"abused" == b["social_facility:for"] && (a += "Einrichtung f\xFCr: Menschen die Misshandlung erlitten haben<br/>");"child" == b["social_facility:for"] && (a += "Einrichtung f\xFCr: Kinder<br/>");"disabled" == b["social_facility:for"] && (a += "Einrichtung f\xFCr: Menschen mit k\xF6rperlicher oder geistiger Behinderung<br/>");"diseased" == b["social_facility:for"] && (a += "Einrichtung f\xFCr: Erkrankte Menschen<br/>");"drug_addicted" == b["social_facility:for"] && (a += "Einrichtung f\xFCr: Drogens\xFCchtige<br/>");"homeless" == b["social_facility:for"] && (a += "Einrichtung f\xFCr: Obdachlose<br/>");"juvenile" == b["social_facility:for"] && (a += "Einrichtung f\xFCr: Jugendliche und Teenager<br/>");"mental_health" == b["social_facility:for"] && (a += "Einrichtung f\xFCr: Menschen mit psychischen Problemen<br/>");"migrant" == b["social_facility:for"] && (a += "Einrichtung f\xFCr: Menschen mit Migrationshintergrund<br/>");"orphan" == b["social_facility:for"] && (a += "Einrichtung f\xFCr: Waisen<br/>");"senior" == b["social_facility:for"] && (a += "Einrichtung f\xFCr: Senioren<br/>");"underprivileged" == b["social_facility:for"] && (a += "Einrichtung f\xFCr: Arme oder benachteiligte Menschen<br/>");"unemployed" == b["social_facility:for"] && (a += "Einrichtung f\xFCr: Arbeitslose<br/>");"victim" == b["social_facility:for"] && (a += "Einrichtung f\xFCr: Opfer eines Verbrechens<br/>");
    return a;
};
function fnAdditionalBuildingInfos(b) {
    var a = "";b["building:color"] && (a += "Geb\xE4udenfarbe: " + b["building:color"] + "</br>");b["building:height"] && (a += "Geb\xE4udenh\xF6he: " + b["building:height"] + " m</br>");b["building:level"] && (a += "Etage: " + b["building:level"] + "</br>");b["building:part"] && (a += "Geb\xE4udeteile: " + b["building:part"] + "</br>");b["roof:color"] && (a += "Dachfarbe: " + b["roof:colour"] + "</br>");b["roof:shape"] && (a += "Dachform: " + b["roof:shape"] + "</br>");b["roof:height"] && (a += "Dachh\xF6he: " + b["roof:height"] + " m</br>");b["roof:material"] && (a += "Dachmaterial: " + b["roof:material"] + " </br>");b["roof:orientation"] && (a += "Dachausrichtung: " + b["roof:orientation"] + " </br>");b["roof:direction"] && (a += "Dachausrichtung: " + b["roof:direction"] + " </br>");b["building:type"] && (a += "Geb\xE4udentyp: " + b["building:type"] + "</br>");return a;
}
function fnSicherheitAdditional(b) {
    var a = "";"surveillance" == b.man_made && ("indoor" == b.surveillance && (a += "Innenbereich wird \xFCberwacht"), "outdoor" == b.surveillance && (a += "Au\xDFenbereich wird \xFCberwacht"), "public" == b.surveillance && (a += "\xD6ffentliche \xDCberwachung"), "camera" == b["surveillance:type"] && (a += "\xDCberwachungstyp: Kamera"), "guard" == b["surveillance:type"] && (a += "\xDCberwachungstyp: W\xE4chter"), "ALPR" == b["surveillance:type"] && (a += "\xDCberwachungstyp: ALPR"), "town" == b["surveillance:zone"] && (a += "\xDCberwachungsbereich: Ort"), "parking" == b["surveillance:zone"] && (a += "\xDCberwachungsbereich: Parkplatz"), "traffic" == b["surveillance:zone"] && (a += "\xDCberwachungsbereich: Verkehr"), "shop" == b["surveillance:zone"] && (a += "\xDCberwachungsbereich: Shops"), "bank" == b["surveillance:zone"] && (a += "\xDCberwachungsbereich: Bank"), "building" == b["surveillance:zone"] && (a += "\xDCberwachungsbereich: Geb\xE4ude"));return a;
}
function fnWreckInfo(b) {
    var a = "";"wreck" == b.historic && (b["wreck:date_sunk"] && (a += "Gesunken am: " + b["wreck:date_sunk"] + "<br/>"), b["wreck:depth"] && (a += "Tiefe: " + b["wreck:depth"] + "<br/>"), b["wreck:clearance"] && (a += "Freiraum: " + b["wreck:clearance"] + "<br/>"), b["wreck:date_commissioned"] && (a += "Anerkannt seit: " + b["wreck:date_commissioned"] + "<br/>"), b["wreck:gross_tonnage"] && (a += "Gewicht: " + b["wreck:gross_tonnage"] + "<br/>"), b["wreck:length"] && (a += "L\xE4nge: " + b["wreck:length"] + "<br/>"), b["wreck:width"] && (a += "Breite: " + b["wreck:width"] + "<br/>"), b["wreck:cargo"] && (a = "timber" == b["wreck:cargo"] ? a + "Ladung: Holz<br/>" : "coal" == b["wreck:cargo"] ? a + "Ladung: Kohle<br/>" : a + ("Ladung: " + b["wreck:cargo"] + "<br/>")), "yes" == b["wreck:visible_at_low_tide"] && (a += "Sichtbar bei Niedrigwasser: Ja<br/>"), "no" == b["wreck:visible_at_low_tide"] && (a += "Sichtbar bei Niedrigwasser: Nein<br/>"), "yes" == b["wreck:visible_at_high_tide"] && (a += "Sichtbar bei Hochwasser: Ja<br/>"), "no" == b["wreck:visible_at_high_tide"] && (a += "Sichtbar bei Hochwasser: Nein<br/>"), "yes" == b.access && (a += "Zutritt m\xF6glich<br/>"), "no" == b.access && (a += "Zutritt nicht m\xF6glich<br/>"), "permit_required" == b.access && (a += "Zutritt nur mit Genehmigung<br/>"));return a;
}
function fnKlosterAdditional(b) {
    var a = "";if (b["monastery:type"]) switch (b["monastery:type"]) {case "monastery":
            a += "Typ: Kl\xF6sterliche Gemeinschaft (monastery)<br/>";break;case "convent":
            a += "Typ: Bettelm\xF6nch Gemeinschaft (convent)<br/>";break;case "canonry":
            a += "Typ: Kanonikat (canonry)<br/>";break;case "commandry":
            a += "Typ: Milit\xE4r gef\xFChrt (commandry)<br/>";break;case "hermitage":
            a += "Typ: Einsiedelei (hermitage)<br/>";break;default:
            a += "Typ: unbekannt<br/>";}b["community:gender"] && ("male" == b["community:gender"] && (a += "Geschlecht: M\xE4nnergemeinschaft<br/>"), "female" == b["community:gender"] && (a += "Geschlecht: Frauengemeinschaft<br/>"));b.religious_rank && ("abbey" == b.religious_rank ? a += "Religi\xF6ser Rang: Abtei<br/>" : "abbey" == b.religious_rank && (a += "Religi\xF6ser Rang: Erzabtei<br/>"));"yes" == b.shrine && (a += "Besonderheit: Heiligengrab / Reliquienschrein<br/>");"yes" == b.sanctuary && (a += "Besonderheit: Heiligtum / Altarraum (Sanktuar)<br/>");if (b.religion) switch (b.religion) {case "animist":
            a += "Religion: animistisch<br/><br/>";break;case "bahai":
            a += "Religion: bahai<br/>";break;case "buddhist":
            a += "Religion: buddhistisch<br/>";break;case "christian":
            a += "Religion: christlich<br/>";break;case "hindu":
            a += "Religion: hinduistisch<br/>";break;case "IglesiaNiCristo":
            a += "Religion: IglesiaNiCristo<br/>";break;case "jain":
            a += "Religion: jain<br/>";break;case "jewish":
            a += "Religion: j\xFCdisch<br/>";break;case "multifaith":
            a += "Religion: pluralistisch<br/>";break;case "muslim":
            a += "Religion: muslimisch<br/>";
            type += "Moschee<br/>";break;case "pagan":
            a += "Religion: heidnisch<br/>";break;case "pastafarian":
            a += "Religion: pastafarisch<br/>";break;case "scientologist":
            a += "Religion: scientologisch<br/>";break;case "shinto":
            a += "Religion: schintoistisch<br/>";break;case "sikh":
            a += "Religion: sikh<br/>";break;case "spiritualist":
            a += "Religion: spiritistisch<br/>";break;case "taoist":
            a += "Religion: taoistisch<br/>";break;case "unitarian":
            a += "Religion: unitarian<br/>";break;case "yazidi":
            a += "Religion: yazidi<br/>";break;
        case "zoroastrian":
            a += "Religion: zoroastrisch<br/>";break;default:
            a += "Religion: unbekannt<br/>";}if (b.denomination) switch (b.denomination) {case "anglican":
            a += "Konfession: Anglikanische Gemeinschaft<br/><br/>";break;case "baptist":
            a += "Konfession: Baptisten<br/>";break;case "catholic":
            a += "Konfession: Katholische Kirche, ohne genauere Spezifizierung<br/>";break;case "roman_catholic":
            a += "Konfession: R\xF6misch-Katholische Kirche<br/>";break;case "old_catholic":
            a += "Konfession: Altkatholische Kirche (Schweiz: Christ-Katholisch)<br/>";
            break;case "greek_catholic":
            a += "Konfession: Griechisch-Katholische Kirche, Sammelbezeichnung f\xFCr die mit Rom unierten Ostkirchen des byzantinischen Ritus<br/>";break;case "evangelical":
            a += "Konfession: Evangelikalismus ist eine theologische Richtung innerhalb des Protestantismus. Achtung! Nicht verwechseln mit der evangelischen (= protestantischen) Kirche<br/>";break;case "jehovahs_witness":
            a += "Konfession: Zeugen Jehovas<br/>";break;case "lutheran":
            a += "Konfession: Lutheraner, evangelisch-lutherisch<br/>";
            break;case "mennonite":
            a += "Konfession: Mennoniten<br/>";break;case "messianic_jewish":
            a += "Konfession: Messianische Juden, stehen theologisch den evangelikalen Christen nahe.<br/>";break;case "methodist":
            a += "Konfession: Methodist Church (engl. Methodism)<br/>";break;case "mormon":
            a += "Konfession: Mormonen<br/>";break;case "new_apostolic":
            a += "Konfession: Neuapostolische Kirche<br/>";break;case "orthodox":
            a += "Konfession: Orthodox, ohne genauere Spezifizierung<br/>";break;case "greek_orthodox":
            a += "Konfession: Griechisch-Orthodox<br/>";
            break;case "coptic_orthodox":
            a += "Konfession: Koptische Kirche, ist die christliche altorientalische Kirche \xC4gyptens.<br/>";break;case "pentecostal":
            a += "Konfession: Pfingstbewegung<br/>";break;case "presbyterian":
            a += "Konfession: Presbyterianische Kirchen<br/>";break;case "protestant":
            a += "Konfession: Evangelische Kirchen<br/>";break;case "quaker":
            a += "Konfession: Qu\xE4ker<br/>";break;case "reformed":
            a += "Konfession: Evangelisch-reformierte<br/>";break;case "russian_orthodox":
            a += "Konfession: Russisch-Orthodox<br/>";
            break;case "seventh_day_adventist":
            a += "Konfession: Siebenten-Tags-Adventisten<br/>";break;case "christian_community":
            a += "Konfession: Die Christengemeinschaft ist eine christliche Kirche, die sich als selbst\xE4ndige Kultusgemeinschaft versteht.<br/>";break;case "adventist":
            a += "Konfession: Adventisten, nicht alle Adventisten sind Siebenten-Tags-Adventisten.<br/>";break;case "alliance":
            a += "Konfession: Christian and Missionary Alliance (C&MA) is an evangelical Protestant denomination within Christianity.<br/>";
            break;case "assemblies_of_god":
            a += "Konfession: Assemblies of God, ist eine pfingstlerische Denomination.<br/>";break;case "apostolic":
            a += "Konfession: Apostolische Kirche<br/>";break;case "armenian_apostolic":
            a += "Konfession: Armenische Apostolische Kirche, ist eine altorientalische Kirche.<br/>";break;case "assyrian":
            a += "Konfession: Assyrische Kirche des Ostens, auch Apostolische Kirche des Ostens, ist eine autokephale und v\xF6llig eigenst\xE4ndige Ostkirche syrischer Tradition in Nachfolge des altchristlichen Katholikats von Seleukia-Ktesiphon.<br/>";
            break;case "christ_scientist":
            a += "Konfession: Christian Science (deutsch: Christliche Wissenschaft) ging aus der Neugeist-Bewegung hervor.<br/>";break;case "church_of_scotland":
            a += "Konfession: Church of Scotland (dt. Kirche Schottlands) ist die Nationalkirche in Schottland. Im Sprachgebrauch auch \u201Ethe Kirk\u201C genannt.<br/>";break;case "czechoslovak_hussite":
            a += "Konfession: Tschechoslowakische Hussitische Kirche, ist eine christliche Kirche, die durch Abspaltung von der R\xF6misch-Katholischen Kirche entstanden ist. Oft auch Neuhussitische Kirche genannt, vornehmlich in Tschechien verbreitet, aber auch in der Slowakei<br/>";
            break;case "dutch_reformed":
            a += "Konfession: Niederl\xE4ndisch-reformierte Kirche, (einschlie\xDFlich NGK und \xE4hnliche Kirchen in S\xFCdafrika)<br/>";break;case "exclusive_brethren":
            a += "Konfession: Exclusive Brethren<br/>";break;case "foursquare":
            a += "Konfession: International Church of the Foursquare Gospel<br/>";break;case "kimbanguist":
            a += "Konfession: Kimbanguistenkirche, ist eine afrikanische, unabh\xE4ngige, christliche Kirche.<br/>";break;case "living_waters_church":
            a += "Konfession: Living Waters Christian Church<br/>";
            break;case "mariavite":
            a += "Konfession: Mariavitismus<br/>";break;case "maronite":
            a += "Konfession: Syrisch-maronitische Kirche, ist eine mit Rom unierte, christliche Kirche, die den r\xF6mischen Papst als Oberhaupt anerkennt.<br/>";break;case "moravian":
            a += "Konfession: Herrnhuter Br\xFCdergemeine, (auch: Unitas Fratrum, Evangelische oder Erneuerte Br\xFCder-Unit\xE4t, engl. Moravian Church) ist eine aus der b\xF6hmischen Reformation herkommende \xFCberkonfessionell-christliche Glaubensbewegung.<br/>";
            break;case "nazarene":
            a += "Konfession: Kirche des Nazareners, ist eine Freikirche und Heiligungsgemeinde in methodistischer Tradition.<br/>";break;case "nondenominational":
            a += "Konfession: Nondenominational Christianity<br/>";break;case "old_believers":
            a += "Konfession: Altorthodoxe, (h\xE4ufiger Altgl\xE4ubige) ist eine Sammelbezeichnung f\xFCr religi\xF6se Str\xF6mungen und Gruppen innerhalb der russisch-orthodoxen Tradition.<br/>";break;case "polish_catholic":
            a += "Konfession: Polnisch-Katholische Kirche<br/>";
            break;case "salvation_army":
            a += "Konfession: Heilsarmee, ist eine christliche Freikirche mit ausgepr\xE4gter sozialer T\xE4tigkeit.<br/>";break;case "santo_daime":
            a += "Konfession: Santo Daime, ist einer synkretistischen religi\xF6se Bewegung aus Brasilien.<br/>";break;case "serbian_orthodox":
            a += "Konfession: Serbisch-Orthodoxe Kirche, bezeichnet die orthodoxe Kirche von Serbien und die ihr nachgeordneten Kirchen.<br/>";break;case "spiritism":
            a += "Konfession: Spiritismus, oder Spiritualismus die Lehre des Spiritisten Allan Kardec<br/>";
            break;case "united":
            a += "Konfession: United Church of Canada, ist die zweitgr\xF6\xDFte Kirche in Kanada.<br/>";break;case "united_church_of_christ":
            a += "Konfession: United Church of Christ, ist eine Kirche in den USA.<br/>";break;case "united_free_church_of_scotland":
            a += "Konfession: United Free Church of Scotland, ist eine presbyterianische Freikirche in Schottland.<br/>";break;case "united_methodist":
            a += "Konfession: Evangelisch-methodistische Kirche, (engl. United Methodist Church (UMC)) ist eine christliche Kirche in der wesleyanischen Tradition.<br/>";
            break;case "united_reformed":
            a += "Konfession: United Reformed Church, (Vereinigte Reformierte Kirche, URC) ist eine reformierte Kirche in Gro\xDFbritannien.<br/>";break;case "uniting":
            a += "Konfession: Uniting Church in Australia (UCA) ist die drittgr\xF6\xDFte christliche Denomination in Australien.<br/>";break;case "church_of_sweden":
            a += "Konfession: Schwedische Kirche, ist die evangelisch-lutherische Kirche und ehemalige Staatskirche Schwedens.<br/>";break;case "mission_covenant_church_of_sweden":
            a += "Konfession: Schwedische Missionskirche ist eine reformierte Kirche in Schweden.<br/>";break;case "alternative":
            a += "Konfession: alternative<br/>";break;case "ashkenazi":
            a += "Konfession: ashkenazi<br/>";break;case "buchari":
            a += "Konfession: buchari<br/>";break;case "conservative":
            a += "Konfession: conservative<br/>";break;case "egalitarian":
            a += "Konfession: egalitarian<br/>";break;case "hasidic":
            a += "Konfession: hasidic<br/>";break;case "humanistic":
            a += "Konfession: humanistic<br/>";break;case "kabbalah":
            a += "Konfession: kabbalah<br/>";break;case "kabbalistic":
            a += "Konfession: kabbalistic<br/>";break;case "karaite":
            a += "Konfession: karaite<br/>";break;case "liberal":
            a += "Konfession: liberal<br/>";break;case "lubavitch":
            a += "Konfession: lubavitch<br/>";break;case "lubavitch_messianic":
            a += "Konfession: lubavitch_messianic<br/>";break;case "mizrachi_baghdadi":
            a += "Konfession: mizrachi_baghdadi<br/>";break;case "mizrachi_chida":
            a += "Konfession: mizrachi_chida<br/>";break;case "mizrachi_jerusalemite":
            a += "Konfession: mizrachi_jerusalemite<br/>";
            break;case "mizrachi_livorno":
            a += "Konfession: mizrachi_livorno<br/>";break;case "mizrachi_moroccan":
            a += "Konfession: mizrachi_moroccan<br/>";break;case "modern_orthodox":
            a += "Konfession: modern_orthodox<br/>";break;case "neo_orthodox":
            a += "Konfession: neo_orthodox<br/>";break;case "nondenominational":
            a += "Konfession: nondenominational<br/>";break;case "orthodox":
            a += "Konfession: orthodox<br/>";break;case "orthodox_ashkenaz":
            a += "Konfession: orthodox_ashkenaz<br/>";break;case "orthodox_sefard":
            a += "Konfession: orthodox_sefard<br/>";
            break;case "progressive":
            a += "Konfession: progressive<br/>";break;case "reconstructionist":
            a += "Konfession: reconstructionist<br/>";break;case "reform":
            a += "Konfession: reform<br/>";break;case "renewal":
            a += "Konfession: renewal<br/>";break;case "samaritan":
            a += "Konfession: samaritan<br/>";break;case "sefardi":
            a += "Konfession: sefardi<br/>";break;case "sefardi_amsterdam":
            a += "Konfession: sefardi_amsterdam<br/>";break;case "sefardi_london":
            a += "Konfession: sefardi_london<br/>";break;case "traditional":
            a += "Konfession: traditional<br/>";
            break;case "ultra_orthodox":
            a += "Konfession: ultra_orthodox<br/>";break;case "unaffiliated":
            a += "Konfession: unaffiliated<br/>";break;case "yemenite":
            a += "Konfession: yemenite<br/>";break;case "yemenite_baladi":
            a += "Konfession: yemenite_baladi<br/>";break;case "yemenite_shami":
            a += "Konfession: yemenite_shami<br/>";break;case "ahmadiya":
            a += "Konfession: ahmadiya<br/>";break;case "alaouite":
            a += "Konfession: alaouite<br/>";break;case "druze":
            a += "Konfession: druze<br/>";break;case "ibadi":
            a += "Konfession: ibadi<br/>";
            break;case "ismaili":
            a += "Konfession: ismaili<br/>";break;case "shia":
            a += "Konfession: shia<br/>";break;case "sunni":
            a += "Konfession: sunni<br/>";break;case "nichiren":
            a += "Konfession: nichiren<br/>";break;case "jodo_shinshu":
            a += "Konfession: jodo_shinshu<br/>";break;case "jodo_shu":
            a += "Konfession: jodo_shu<br/>";break;case "vajrayana":
            a += "Konfession: vajrayana<br/>";break;case "shingon_shu":
            a += "Konfession: shingon_shu<br/>";break;case "zen":
            a += "Konfession: zen<br/>";break;case "thai_mahanikaya":
            a += "Konfession: thai_mahanikaya<br/>";
            break;case "thai_thammayut":
            a += "Konfession: thai_thammayut<br/>";break;case "asatru":
            a += "Konfession: asatru<br/>";break;case "celtic":
            a += "Konfession: celtic<br/>";break;case "greco-roman":
            a += "Konfession: greco-roman<br/>";break;case "wicca":
            a += "Konfession: wicca<br/>";break;case "irani":
            a += "Konfession: irani<br/>";break;case "parsi":
            a += "Konfession: parsi<br/>";break;default:
            a += "unbekannt<br/>";}if (b.community) switch (b.community) {case "AA":
            a += "Ordensgemeinschaft (AA): Augustinians of the Assumption <br/>";
            break;case "BSCM":
            a += "Ordensgemeinschaft (BSCM): Adorers of the Sacred Heart of Jesus of Montmartre <br/>";break;case "CBMV":
            a += "Ordensgemeinschaft (CBMV): Augustiner-Chorfrauen B.M.V.<br/>";break;case "CO":
            a += "Ordensgemeinschaft (CO): Oratorians<br/>";break;case "CMC":
            a += "Ordensgemeinschaft (CMC): Congregation of the Mother Co-Redemptrix<br/>";break;case "CRSP":
            a += "Ordensgemeinschaft (CRSP): Kongregation der Regularkleriker vom hl. Paulus (Barnabiten)<br/>";break;case "CSJ":
            a += "Ordensgemeinschaft (CSJ): Carmel Saint-Joseph<br/>";
            break;case "CSSP":
            a += "Ordensgemeinschaft (CSSP): Congr\xE9gation du Saint-Esprit<br/>";break;case "CSSR":
            a += "Ordensgemeinschaft (CSSR): Congr\xE9gation du Tr\xE8s Saint R\xE9dempteur<br/>";break;case "FCJM":
            a += "Ordensgemeinschaft (FCJM): Franciscan Sisters, Daughters of the Sacred Heart of Jesus and Mary<br/>";break;case "FMGB":
            a += "Ordensgemeinschaft (FMGB): Suore Francescane Missionarie di Ges\xF9 Bambino<br/>";break;case "FMH":
            a += "Ordensgemeinschaft (FMH): Congregatio Filiarum Mariae Sanctissimae ab Horto<br/>";
            break;case "FMM":
            a += "Ordensgemeinschaft (FMM): Franciscaines missionnaires de Marie<br/>";break;case "FSC":
            a += "Ordensgemeinschaft (FSC): Fr\xE8res des \xC9coles chr\xE9tiennes<br/>";break;case "MCCI":
            a += "Ordensgemeinschaft (MCCI): Missionnaires comboniens du Sacr\xE9-C\u0153ur<br/>";break;case "MSFS":
            a += "Ordensgemeinschaft (MSFS): Missionnaires de Saint Fran\xE7ois de Sales<br/>";break;case "OCart":
            a += "Ordensgemeinschaft (OCart): Order of the Carthusians<br/>";break;case "OCC":
            a += "Ordensgemeinschaft (OCC): Ordre de Notre Dame du Mont-Carmel<br/>";
            break;case "OCD":
            a += "Ordensgemeinschaft (OCD): Ordre des Carmes d\xE9chaux<br/>";break;case "OCSO":
            a += "Ordensgemeinschaft (OCSO): Zisterzienserorden der strengeren Observanz (Trappisten)<br/>";break;case "OFM":
            a += "Ordensgemeinschaft (OFM): Ordre des Fr\xE8res Mineurs (Franziskaner)<br/>";break;case "OFMCap":
            a += "Ordensgemeinschaft (OFMCap): Ordre des Fr\xE8res Mineurs Capucins<br/>";break;case "OFMConv":
            a += "Ordensgemeinschaft (OFMConv): Ordre des Fr\xE8res Mineurs Conventuels<br/>";break;case "OFS":
            a += "Ordensgemeinschaft (OFS): Franciscans secular Third Order<br/>";break;case "OMI":
            a += "Ordensgemeinschaft (OMI): Oblats de Marie<br/>";break;case "OP":
            a += "Ordensgemeinschaft (OP): Ordre des Fr\xE8res Pr\xEAcheurs<br/>";break;case "OPraem":
            a += "Ordensgemeinschaft (OPraem): Ordre des chanoines r\xE9guliers de Pr\xE9montr\xE9<br/>";break;case "OSB":
            a += "Ordensgemeinschaft (OSB): Order of Saint Benedict<br/>";break;case "OSC":
            a += "Ordensgemeinschaft (OSC): Ordre de Sainte-Claire ou Ordre des Pauvres Dames<br/>";
            break;case "OSSS":
            a += "Ordensgemeinschaft (OSSS): Ordre de Sainte-Brigitte<br/>";break;case "OVM":
            a += "Ordensgemeinschaft (OVM): Order of the Visitation of Holy Mary (Salesianerinnen)<br/>";break;case "PSDP":
            a += "Ordensgemeinschaft (PSDP): Petites s\u0153urs des pauvres (Kleinen Schwestern der Armen)<br/>";break;case "PFJ":
            a += "Ordensgemeinschaft (PFJ): Petits Fr\xE8res de J\xE9sus<br/>";break;case "SDB":
            a += "Ordensgemeinschaft (SDB): Soci\xE9t\xE9 de Saint Fran\xE7ois de Sales<br/>";break;case "SJ":
            a += "Ordensgemeinschaft (SJ): Compagnie de J\xE9sus<br/>";break;case "SOC":
            a += "Ordensgemeinschaft (SOC): Order of Cistercians<br/>";break;case "SSCC":
            a += "Ordensgemeinschaft (SSCC): Congregation of the Sacred Hearts of Jesus and Mary<br/>";break;case "SSF":
            a += "Ordensgemeinschaft (SSF): Society of St Francis<br/>";break;case "SSJE":
            a += "Ordensgemeinschaft (SSJE): Society of St John the Evangelist<br/>";break;case "SSpS":
            a += "Ordensgemeinschaft (SSpS): Steyler Missionsschwestern<br/>";break;case "TOR":
            a += "Ordensgemeinschaft (TOR): Terzo Ordine Regolare di San Francesco<br/>";break;default:
            a += "unbekannt<br/>";}return a;
}var fnTestInfoPopup = function fnTestInfoPopup(b) {
    b = b.getProperties();var a = "",
        c;for (c in b) {
        a = a + c + "=" + b[c] + "<br/>";
    }return '<div class="c4g_popup_text" style="width:300px;">' + a + "</div>";
};

/***/ }),

/***/ "./Resources/public/js/c4g-maps-popup-info-en.js":
/*!*******************************************************!*\
  !*** ./Resources/public/js/c4g-maps-popup-info-en.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.trim = trim;
exports.isMobile = isMobile;
exports.fnHeader = fnHeader;
exports.fnFooter = fnFooter;
exports.fnGetTranslate_Type = fnGetTranslate_Type;
exports.fnArztInfo = fnArztInfo;
exports.fnKraftwerkInfo = fnKraftwerkInfo;
exports.fnWertstoffinfo = fnWertstoffinfo;
exports.fnAdditionalBuildingInfos = fnAdditionalBuildingInfos;
exports.fnSicherheitAdditional = fnSicherheitAdditional;
exports.fnWreckInfo = fnWreckInfo;
exports.fnKlosterAdditional = fnKlosterAdditional;
/*
 * This file is part of con4gis,
 * the gis-kit for Contao CMS.
 *
 * @package    con4gis
 * @version    6
 * @author     con4gis contributors (see "authors.txt")
 * @license    LGPL-3.0-or-later
 * @copyright  Küstenschmiede GmbH Software & Design
 * @link       https://www.con4gis.org
 */
function trim(b) {
    return b.replace(/^\s+/, "").replace(/\s+$/, "");
}
function isMobile() {
    return (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino|android|ipad|playbook|silk/i.test(navigator.userAgent || navigator.vendor || window.opera) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test((navigator.userAgent || navigator.vendor || window.opera).substr(0, 4))
    );
}function translate(b) {
    var a = trim(b);return "yes" == a || "Yes" == a ? "yes" : "no" == a || "No" == a ? "no" : "limited" == a ? "limited" : "designated" == a ? "designated" : "wood" == a ? "wood" : "metal" == a ? "metal" : "concrete" == a ? "concrete" : "plastic" == a ? "plastic" : "stone" == a ? "stone" : "steel" == a ? "steel" : "brick" == a ? "brick" : "reinforced_concrete" == a ? "reinforced_concrete" : "masonry" == a ? "masonry" : b;
}
var fnStandardInfoPopup = exports.fnStandardInfoPopup = function fnStandardInfoPopup(b, a) {
    var c = b.getProperties(),
        d = "",
        e;if ("function" === typeof a) {
        var f = a.call(b)[0].getImage();if (f) try {
            e = f.getSrc();
        } catch (g) {
            e = "";
        }
    } else {
        f = a.getImage();try {
            e = f.getSrc();
        } catch (h) {
            e = "";
        }
    }d += fnHeader(c, e);d += fnContent(c);d += fnFooter(c, b.get("osm_type") + "/" + b.getId());return '<div class="c4g_popup_text">' + d + "</div>";
},
    fnReducedInfoPopup = exports.fnReducedInfoPopup = function fnReducedInfoPopup(b, a) {
    var c = b.getProperties(),
        d = "",
        e = !1,
        f;f = "function" === typeof a ? a.call(b)[0].getImage().getSrc() : a.getImage().getSrc();if ("restaurant" == c.amenity || "pub" == c.amenity || "biergarten" == c.amenity) e = !0;"hotel" == c.tourism && (e = !0);"guest_house" == c.tourism && (e = !0);"chalet" == c.tourism && (e = !0);"hostel" == c.tourism && (e = !0);"alpine_hut" == c.tourism && (e = !0);if ("artwork" == c.tourism || "artwork" == c.amenity) e = !0;if ("museum" == c.tourism || "museum" == c.amenity) e = !0;"cinema" == c.amenity && (e = !0);"theatre" == c.amenity && (e = !0);if ("attraction" == c.amenity || "fountain" == c.amenity || "monument" == c.historic || "city_gate" == c.historic || "ruins" == c.historic || "castle" == c.historic || "attraction" == c.tourism) e = !0;"playground" == c.leisure && (e = !0);c.aerialway && (e = !0);if ("swimming_pool" == c.amenity || "swimming_pool" == c.leisure || "swimming" == c.sport) e = !0;"station" == c.railway && (e = !0);"swimming" == c.sport && (e = !0);"swimming_pool" == c.leisure && (e = !0);"swimming_pool" == c.amenity && (e = !0);"waterpark" == c.leisure && (e = !0);c.water_park && (e = !0);"sports_centre" == c.leisure && (e = !0);switch (e) {case !1:
            d += fnHeader(c, f);d += fnContent(c);d += fnFooter(c, b.get("osm_type") + "/" + b.getId());break;case !0:
            d += fnHeader(c, f);}return '<div class="c4g_popup_text">' + d + "</div>";
};
function fnHeader(b, a) {
    var c = "",
        d = "32px";a && -1 != a.indexOf("icon_mapcil") && (d = "250px", a = a.replace("icon_mapcil", "logo_mapcil"));if (b.name || b["piste:name"] || b["xmas:name"] || b["xmas:location"]) {
        if (b.name) var e = b.name;b["piste:name"] && (e = b["piste:name"]);b["xmas:name"] && (e = b["xmas:name"]);b["xmas:location"] && (e = b["xmas:location"]);c += a ? '<img src="' + a + '" width="' + d + '" name="' + e + '" alt="' + e + '"><div class="c4g_popup_header_featurename">' + e + "</div>" : '<name="' + e + '" alt="' + e + '"><div class="c4g_popup_header_featurename">' + e + "</div>";
    } else a && (c += '<img src="' + a + '" width="' + d + '" name="' + a + '" alt="' + a + '">');c += fnGetTranslate_Type(b);return '<div class="c4g_popup_header">' + c + "</div>";
}
function fnFooter(b, a) {
    var c = "",
        d = !1;b["addr:housename"] && (c += "housename: " + b["addr:housename"] + "<br/>", d = !0);b["addr:floor"] ? (c += "floor: " + b["addr:floor"] + "<br/>", d = !0) : b["addr:level"] && (c += "level: " + b["addr:level"] + "<br/>", d = !0);b["addr:street"] && (c += b["addr:street"], c = b["addr:housenumber"] ? c + (" " + b["addr:housenumber"] + "<br/>") : c + "<br/>", d = !0);b["addr:postcode"] && (c += b["addr:postcode"] + " ");b["addr:city"] && (c += b["addr:city"] + "<br/>", d = !0);if (b.sqkm) if (b.sqkm = "" + b.sqkm, 3 < b.sqkm.length) {
        var e = b.sqkm.length % 3,
            f = 0 < e ? b.sqkm.substring(0, e) : "";for (var i = 0; i < Math.floor(b.sqkm.length / 3); i++) {
            f = 0 == e && 0 == i ? f + b.sqkm.substring(e + 3 * i, e + 3 * i + 3) : f + ("." + b.sqkm.substring(e + 3 * i, e + 3 * i + 3));
        }c += "area: " + f + " Km\xB2<br/>";
    } else c += "area " + b.sqkm + "<br/>";b["contact:phone"] && (c = isMobile() ? c + ('phone: <a href="tel:' + b["contact:phone"] + '">' + b["contact:phone"] + "</a><br/>") : c + ('phone: <a href="callto:' + b["contact:phone"] + '">' + b["contact:phone"] + "</a><br/>"), d = !0);b.phone && (c = isMobile() ? c + ('phone: <a href="tel:' + b.phone + '">' + b.phone + "</a><br/>") : c + ('phone: <a href="callto:' + b.phone + '">' + b.phone + "</a><br/>"), d = !0);b["contact:fax"] ? (c += "fax: " + b["contact:fax"] + "<br/>", d = !0) : b.fax && (c += "fax: " + b.fax + "<br/>", d = !0);b["contact:email"] ? (c += 'email: <a href="mailto:' + b["contact:email"] + '">' + b["contact:email"] + "</a><br/>", d = !0) : b.email && (c += 'email: <a href="mailto:' + b.email + '">' + b.email + "</a><br/>", d = !0);d && (c += "<br/>");if (b.opening_hours) {
        d = b.opening_hours;for (e = 0; 0 == e || 0 < d.indexOf(";");) {
            0 < e && (d = d.replace(";", "<br/>")), e++;
        }c += 'opening hours: <br/><div class="c4g_open_text">' + d + "</div>";c = 0 < d.indexOf("PH") ? c + "(PH = public holiday)<br/>" : c + "<br/>";
    }if (b["xmas:opening_hours"]) {
        d = b["xmas:opening_hours"];for (e = 0; 0 == e || 0 < d.indexOf(";");) {
            0 < e && (d = d.replace(";", "<br/>")), e++;
        }c += 'opening hours: <br/><div class="c4g_open_text">' + d + "</div>";c = 0 < d.indexOf("PH") ? c + "(PH = public holiday)<br/>" : c + "<br/>";
    }b["xmas:url"] && (d = "", d = b["xmas:url"], trim(d), -1 == d.indexOf("https://", 0) && -1 == d.indexOf("http://", 0) && (d = "http://" + d), c += 'website: <a href="' + d + '" target="_blank">website link</a><br/>');
    b["contact:website"] ? (d = b["contact:website"], trim(d), -1 == d.indexOf("https://", 0) && -1 == d.indexOf("http://", 0) && (d = "http://" + d), c += 'website: <a href="' + d + '" target="_blank">website link</a><br/>') : b.website && (d = b.website, trim(d), -1 == d.indexOf("https://", 0) && -1 == d.indexOf("http://", 0) && (d = "http://" + d), c += 'website: <a href="' + d + '" target="_blank">website link</a><br/>');b.wikipedia && (d = b.wikipedia, trim(d), -1 == d.indexOf("https://", 0) && -1 == d.indexOf("http://", 0) && (d = "https://wikipedia.org/wiki/" + d), c += 'Wikipedia: <a href="' + d + '" target="_blank">Wikipedia link</a><br/>');b.wikimedia_commons && (d = b.wikimedia_commons, trim(d), -1 == d.indexOf("https://", 0) && -1 == d.indexOf("http://", 0) && (d = "https://commons.wikimedia.org/wiki/" + d), c += 'Wikimedia: <a href="' + d + '" target="_blank">Wikimedia link</a><br/>');b["contact:webcam"] && (d = b["contact:webcam"], trim(d), -1 == d.indexOf("https://", 0) && -1 == d.indexOf("http://", 0) && (d = "http://" + d), c += 'webcam: <a href="' + d + '" target="_blank">webcam link</a><br/>');b.image && (c += '<img src="' + b.image + '" width="200px" name="' + b.name + '" alt="' + b.name + '"><br/>');d = "";b.internet_access && (d += "internet access: " + translate(b.internet_access) + "<br/>");b["internet_access:fee"] && (d += "fee: " + translate(b["internet_access:fee"]) + "<br/>");b["wifi_access:operator"] && (d += "wifi operator: " + b["wifi_access:operator"] + "<br/>");b["wifi_access:technology"] && (d += "wifi technology: " + b["wifi_access:technology"] + "<br/>");b["wifi_access:ssid"] && (d += "wifi ssid: " + b["wifi_access:ssid"] + "<br/>");"" != d && (c += 'internet access available<br/><div class="c4g_shop_internet_access">' + d + "</div><br/>");b.wheelchair && (c += "wheelchair: " + translate(b.wheelchair) + "<br/>");b["wheelchair:description"] && (c += "description: " + b["wheelchair:description"] + "<br/>");b["wheelchair:entrance_width"] && (c += "entrance width (cm): " + b["wheelchair:entrance_width"] + "<br/>");b["wheelchair:step_height"] && (c += "step height (cm): " + b["wheelchair:step_height"] + "<br/>");b["wheelchair:rooms"] && (c += "rooms: " + b["wheelchair:rooms"] + "<br/>");
    b["wheelchair:places"] && (c += "places: " + b["wheelchair:places"] + "<br/>");b["cent:places"] && (c += "places: " + b["wheelchair:places"] + "<br/>");b["ramp:wheelchair"] && (c += "ramp: " + b["ramp:wheelchair"] + "<br/>");b["capacity:disabled"] && (c += "capacity parking: " + translate(b["capacity:disabled"]) + "<br/>");b["toilets:wheelchair"] && (c += "toilets: " + translate(b["toilets:wheelchair"]) + "<br/>");b.centralkey && (c += "centralkey: " + b.centralkey + "<br/>");b.note && (c += b.note + "<br/>");b.description && (c += b.description + "<br/>");
    b.operator && (c += "operator: " + b.operator + "<br/>");b.ref && (c += "reference: " + b.ref + "<br/>");"yes" == b.lit && (c += "This object is illuimanted.<br/>");b.shop && (d = "", b.brand && (d += "brand: " + b.brand + "<br/>"), b.sells && (d += "sells: " + b.sells + "<br/>"), b.origin && (d += "source market: " + b.origin + "<br/>"), "yes" == b.wholesale && (d += "distributor: yes<br/>"), "" != d && (c += 'further particulars: <br/><div class="c4g_shop_text">' + d + "</div><br/>"));a && (d = a, trim(d), d = d.replace(/\./, "/"), c = c + "<br/>" + ('OSM:    <a href="http://www.openstreetmap.org/' + d + '" target="_blank">OpenStreetMap link</a><br/>'));return c = '<div class="c4g_popup_footer">' + c + "</div>";
}
function fnGetTranslate_Type(b) {
    var a = "";if ("doctors" == b.amenity || "doctor" == b.healthcare) a += "doctor<br/>";if ("hospital" == b.amenity || "clinic" == b.amenity || "hospital" == b.healthcare || "clinic" == b.healthcare) a = "yes" == b.emergency ? a + "hospital with emergency facilities<br/>" : a + "hospital<br/>";"dentist" == b.amenity && (a += "dentist<br/>");if ("pharmacy" == b.amenity || "pharmacy" == b["health_facility:type"]) a += "pharmacy<br/>";if ("physiotherapist" == b.healthcare || "yes" == b["health_speciality:physiotherapy"]) a += "physiotherapist<br/>";
    if ("occupational_therapist" == b.healthcare || "yes" == b["health_speciality:occupational_therapy"] || "yes" == b["health_specialty:occupational_therapy"]) a += "occupational_therapist<br/>";if ("psychotherapist" == b.healthcare || "yes" == b["health_speciality:psychotherapy"]) a += "psychotherapist<br/>";"alternative" == b.healthcare && (a += "alternative<br/>");"midwife" == b.healthcare && (a += "midwife<br/>");if ("speech_therapist" == b.healthcare || "yes" == b["health_speciality:speech_therapy"]) a += "speech_therapist<br/>";"yes" == b["health_speciality:music_therapy"] && (a += "music_therapy<br/>");"veterinary" == b.amenity && (a += "veterinary<br/>");"fire_station" == b.amenity && (a += "fire station<br/>");"fire_extinguisher" == b.emergency && (a += "fire extinguisher<br/>");"aed" == b.emergency && (a += "aed<br/>");"defibrillator" == b.emergency && (a += "defibrillator<br/>");"phone" == b.emergency && (a += "call box<br/>");"police" == b.amenity && (a += "police<br/>");"ambulance_station" == b.emergency && (a += "ambulance station<br/>");"technical" == b.emergency_service && (a += "technical<br/>");"water" == b.emergency_service && (a += "water<br/>");"baywatch" == b.waterway && (a += "baywatch<br/>");"air" == b.emergency_service && (a += "rescue helicopter<br/>");"emergency_access_point" == b.highway && (a += "emergency access point<br/>");if ("lifeboat_station" == b.amenity || "lifeboat_station" == b.emergency) a += "lifeboat station<br/>";"life_ring" == b.emergency && (a += "life ring<br/>");"siren" == b.emergency && (a += "siren<br/>");"life_ring" == b.amenity && (a += "life ring<br/>");"rescue_station" == b.amenity && (a += "rescue station<br/>");"fire_hydrant" == b.emergency && ("underground" == b["fire_hydrant:type"] ? a += "underground hydrant<br/>" : "pillar" == b["fire_hydrant:type"] ? a += "pillar hydrant<br/>" : "wall" == b["fire_hydrant:type"] ? a += "wall hydrant<br/>" : "pond" == b["fire_hydrant:type"] && (a += "suction point<br/>"));"suction_point" == b.emergency && (a += "suction point<br/>");"fire_water_pond" == b.emergency && (a += "fire protection pond<br/>");"mountain" == b.emergency_service && (a += "mountain rescue service<br/>");"water_tank" == b.emergency && (a += "fire water tank<br/>");"container" == b.recycling_type && (a += "Recycling container<br/>");"recycling" == b.amenity && "yes" == b["recycling:excrement"] || "pump-out" == b["seamark:small_craft_facility:category"] ? a += "suction station<br/>" : "recycling" == b.amenity && (a += " buyback centre<br/>");"yes" == b["diet:pescetarian"] ? a += "pescetarian available<br/>" : "only" == b["diet:pescetarian"] && (a += "just pescetarian<br/>");"yes" == b["diet:vegetarian"] ? a += "vegetarian vorhanden<br/>" : "only" == b["diet:vegetarian"] && (a += "just vegetarian<br/>");"yes" == b["diet:lacto_vegetarian"] ? a += "lacto_vegetarian available<br/>" : "only" == b["diet:lacto_vegetarian"] && (a += "just lacto vegetarian<br/>");"yes" == b["diet:ovo_vegetarian"] ? a += "ovo vegetarian available<br/>" : "only" == b["diet:ovo_vegetarian"] && (a += "just ovo_vegetarian<br/>");"yes" == b["diet:vegan"] ? a += "vegan available<br/>" : "only" == b["diet:vegan"] && (a += "just vegan<br/>");"yes" == b["diet:fruitarian"] ? a += "fruitarian available<br/>" : "only" == b["diet:fruitarian"] && (a += "hust fruitarian<br/>");"yes" == b["diet:raw"] ? a += "raw availaibe<br/>" : "only" == b["diet:raw"] && (a += "just raw<br/>");
    "yes" == b["diet:gluten_free"] ? a += "gluten free available<br/>" : "only" == b["diet:gluten_free"] && (a += "just gluten free<br/>");"yes" == b["diet:dairy_free"] ? a += "dairy free available<br/>" : "only" == b["diet:dairy_free"] && (a += "just dairy free<br/>");"yes" == b["diet:lactose_free"] ? a += "lactose free available<br/>" : "only" == b["diet:lactose_free"] && (a += "just lactose free<br/>");"yes" == b["diet:halal"] ? a += "halal available<br/>" : "only" == b["diet:halal"] && (a += "just halal<br/>");"yes" == b["diet:kosher"] ? a += "kosher available<br/>" : "only" == b["diet:kosher"] && (a += "just kosher<br/>");"pub" == b.amenity && (a += "pub<br/>");"bar" == b.amenity && (a += "bar<br/>");"yes" == b.frozen_yogurt && (a += "frozen yogurt<br/>");"yes" == b.slush_ice && (a += "slush ice<br/>");"yes" == b.cake && (a += "cake<br/>");"yes" == b.coffee && (a += "coffee<br/>");"yes" == b.drinks && (a += "drinks<br/>");"biergarten" == b.amenity && (a += "biergarten<br/>");"restaurant" == b.amenity && (a += "restaurant<br/>");"fast_food" == b.amenity && (a += "fast food<br/>");if (("cafe" == b.amenity || "coffee_shop" == b.amenity) && "ice_cream" != b.cuisine) a += "cafe<br/>";if ("cafe" == b.amenity && "ice_cream" == b.cuisine || "ice_cream" == b.amenity) a += "ice cream<br/>";"alpine_hut" == b.tourism && (a += "alpine hut<br/>");"aquarium" == b.tourism && (a += "aquarium<br/>");"apartment" == b.tourism && (a += "apartment<br/>");"attraction" == b.tourism && (a += "attraction<br/>");"artwork" == b.tourism && (a += "artwork<br/>");"camp_site" == b.tourism && (a += "camp site<br/>");"caravan_site" == b.tourism && (a += "caravan site<br/>");"chalet" == b.tourism && (a += "chalet<br/>");"gallery" == b.tourism && (a += "gallery<br/>");"guest_house" == b.tourism && (a += "guest house<br/>");"hostel" == b.tourism && (a += "hostel<br/>");"hotel" == b.tourism && (a += "hotel<br/>");"motel" == b.tourism && (a += "motel<br/>");"museum" == b.tourism && (a += "museum<br/>");"picnic_site" == b.tourism && (a += "picnic site<br/>");"theme_park" == b.tourism && (a += "theme park<br/>");"viewpoint" == b.tourism && (a += "viewpoint<br/>");"wilderness_hut" == b.tourism && (a += "wilderness_hut<br/>");"wine_cellar" == b.tourism && (a += "wine cellar<br/>");"zoo" == b.tourism && (a += "zoo<br/>", "enclosure" == b.zoo && (a += "enclosure<br/>"), "petting_zoo" == b.zoo && (a += "petting zoo<br/>"), "falconry" == b.zoo && (a += "falconry<br/>"));"trail_riding_station" == b.tourism && (a += "trail riding station<br/>");"fishing" == b.club && (a += "fishing club<br/>");"sport" == b.club && "fishing" == b.sport && (a += "fishing club<br/>");"amateur_radio" == b.club && (a += "amateur radio club<br/>");"art" == b.club && (a += "art club<br/>");"astronomy" == b.club && (a += "astronomy club<br/>");"automobile" == b.club && (a += "automobile club<br/>");
    "board_games" == b.club && (a += "board games club<br/>");"card_games" == b.club && (a += "card games club<br/>");"charity" == b.club && (a += "charity club<br/>");"chess" == b.club && (a += "chess club<br/>");"cinema" == b.club && (a += "cinema club<br/>");"cooking" == b.club && (a += "cooking club<br/>");"culture" == b.club && (a += "culture club<br/>");"doityourself" == b.club && (a += "doityourself club<br/>");"equestrian" == b.club && (a += "equestrian club<br/>");"ethnic" == b.club && (a += "ethnic club<br/>");"fan" == b.club && (a += "fan club<br/>");"freemasonry" == b.club && (a += "freemasonry club<br/>");"game" == b.club && (a += "game club<br/>");"history" == b.club && (a += "history club<br/>");"hunting" == b.club && (a += "hunting club<br/>");"linux" == b.club && (a += "linux club<br/>");"motorcycle" == b.club && (a += "motorcycle club<br/>");"music" == b.club && (a += "music club<br/>");"nature" == b.club && (a += "nature club<br/>");"nudism" == b.club && (a += "nudism club<br/>");"photography" == b.club && (a += "photography club<br/>");"politics" == b.club && (a += "politics club<br/>");"religion" == b.club && (a += "religion club<br/>");
    "scout" == b.club && (a += "scout club<br/>");"smoke" == b.club && (a += "smoke club<br/>");"sport" == b.club && (a += "sport club<br/>");"theatre" == b.club && (a += "theatre club<br/>");"veterans" == b.club && (a += "veterans club<br/>");"amusement_arcade" == b.leisure && (a += "penny arcade / gambling hall<br/>");"beach_resort" == b.leisure && (a += "beach resort<br/>");"bird_hide" == b.leisure && (a += "bird hide<br/>");"common" == b.leisure && (a += "common<br/>");"club" == b.leisure && (a += "club<br/>");"dance" == b.leisure && (a += "dance<br/>");"dog_park" == b.leisure && (a += "dog_park<br/>");"firepit" == b.leisure && (a += "firepit<br/>");"fishing" == b.leisure && (a += "fishing<br/>");"garden" == b.leisure && (a += "garden<br/>");"golf_course" == b.leisure && (a += "golf course<br/>");"hackerspace" == b.leisure && (a += "hackerspace<br/>");"horse_riding" == b.leisure && (a += "horse riding<br/>");"ice_rink" == b.leisure && (a += "ice rink<br/>");"nature_reserve" == b.leisure && (a += "nature reserve<br/>");"park" == b.leisure && (a += "park<br/>");"miniature_golf" == b.leisure && (a += "miniature golf<br/>");"pitch" == b.leisure && (a += "pitch<br/>");"pitch" == b.leisure && "yes" == b.building && (a += "gym<br/>");"playground" == b.leisure && "yes" == b.building ? a += "playground<br/>" : "playground" == b.leisure && (a += "playground<br/>");"social_club" == b.leisure && (a += "social club<br/>");"spa" == b.leisure && (a += "spa<br/>");"sports_centre" == b.leisure && (a += "sports centre<br/>");"climbing_adventure" == b.sport && (a += "climbing adventure<br/>");"stadium" == b.leisure && (a += "stadium<br/>");"swimming_pool" == b.leisure && (a += "swimming pool<br/>");"track" == b.leisure && (a += "track<br/>");"water_park" == b.leisure && (a += "water park<br/>");"wildlife_hide" == b.leisure && (a += "wildlife hide<br/>");"adult_gaming_centre" == b.leisure && (a += "adult gaming_centre<br/>");"bowling_alley" == b.leisure && "10pin" == b.sport && (a += "10pin bowling_alley<br/>");"bowling_alley" == b.leisure && "9pin" == b.sport && (a += "9pin bowling_alley<br/>");if ("karting" == b.sport || "motor" == b.sport) a += "karting<br/>";if ("darts" == b.sport || "dart" == b.sport) a += "Darts<br/>";if (b["piste:type"]) switch (b["piste:type"]) {case "skitour":
            a += "skitour<br/>";break;case "downhill":
            a += "downhill<br/>";break;case "sled":
            a += "sled<br/>";break;case "nordic":
            a += "nordic<br/>";break;case "hike":
            a += "hike<br/>";break;case "snow_park":
            a += "snow park<br/>";}if (b.sport) switch (b.sport) {case "surfing":
            a += "surfing<br/>";break;case "kitesurfing":
            a += "kitesurfing<br/>";break;case "water_ski":
            a += "water ski<br/>";}if (b.aerialway) switch (b.aerialway) {case "cable_bar":
            a += "cable bar<br/>";break;case "gondola":
            a += "gondola<br/>";break;case "chair_lift":
            a += "chair lift<br/>";
            break;case "mixed_lift":
            a += "mixed lift<br/>";break;case "drag_lift":
            a += "drag lift<br/>";break;case "t-bar":
            a += "t-bar<br/>";break;case "t-bar":
            a += "t-bar<br/>";break;case "platter":
            a += "platter<br/>";break;case "rope_tow":
            a += "rope tow<br/>";break;case "magic_carpet":
            a += "magic carpet<br/>";break;default:
            a += "unknown";}"mosque" == b.building && (a += "mosque<br/>");"synagogue" == b.building && (a += "synagogue<br/>");"temple" == b.building && (a += "temple<br/>");"apartments" == b.building && (a += "apartments<br/>");"farm" == b.building && (a += "farm<br/>");"hotel" == b.building && (a += "hotel<br/>");"house" == b.building && (a += "house<br/>");"detached" == b.building && (a += "detached<br/>");"residential" == b.building && (a += "residential<br/>");if ("domitory" == b.building || "residential plus" == b.building) a += "domitory<br/>";"terrace" == b.building && (a += "terrace<br/>");"houseboat" == b.building && (a += "houseboat<br/>");"bungalow" == b.building && (a += "bungalow<br/>");"static_caravan" == b.building && (a += "static caravan<br/>");"commercial" == b.building && (a += "commercial<br/>");
    "retail" == b.building && (a += "retail<br/>");"warehouse" == b.building && (a += "warehouse<br/>");"bakehouse" == b.building && (a += "bakehouse<br/>");"shrine" == b.building && (a += "shrine<br/>");"civic" == b.building && (a += "civic<br/>");"stadium" == b.building && (a += "stadium<br/>");"train_station" == b.building && (a += "train station<br/>");"university" == b.building && (a += "university<br/>");"public" == b.building && (a += "public<br/>");"bridge" == b.building && (a += "bridge<br/>");"bunker" == b.building && (a += "bunker<br/>");"cabin" == b.building && (a += "cabin<br/>");"conservatory" == b.building && (a += "conservatory<br/>");"construction" == b.building && (a += "construction<br/>");"garage" == b.building && (a += "garage<br/>");"garages" == b.building && (a += "garages<br/>");"greenhouse" == b.building && (a += "greenhouse<br/>");"hangar" == b.building && (a += "hangar<br/>");"hut" == b.building && (a += "hut<br/>");"pavillion" == b.building && (a += "pavillion<br/>");"roof" == b.building && (a += "roof<br/>");"shed" == b.building && (a += "shed<br/>");"transformer_tower" == b.building && (a += "transformer tower<br/>");
    "service" == b.building && (a += "service<br/>");"kiosk" == b.building && (a += "kiosk<br/>");"carport" == b.building && (a += "carport<br/>");"ruins" == b.building && (a += "ruins<br/>");"gambling" == b.amenity && (a += "penny arcade<br/>");"library" == b.amenity && (a += "library<br/>");"fountain" == b.amenity && (a += "fountain<br/>");"attraction" == b.amenity && (a += "attraction<br/>");if ("social_centre" == b.amenity || "club" == b.amenity) a += "social centre<br/>";"townhall" == b.amenity && (a += "townhall<br/>");"bench" == b.amenity && (a += "bench<br/>");
    if ("grave_yard" == b.amenity || "cemetery" == b.landuse) a += "grave yard<br/>";"post_box" == b.amenity && (a += "post box<br/>");"post_office" == b.amenity && (a += "post office<br/>");"telephone" == b.amenity && (a += "telephone<br/>");"atm" == b.amenity && (a += "atm<br/>");"bank" == b.amenity && (a += "bank<br/>");"toilets" == b.amenity && "yes" == b.diaper ? a += "toilets with diaper changing table<br/>" : "toilets" == b.amenity && (a += "toilets<br/>");"school" == b.amenity && "1" == b["isced:level"] ? a += "primary school<br/>" : "school" == b.amenity && "2" == b["isced:level"] ? a += "secondary school<br/>" : "school" == b.amenity && "3" == b["isced:level"] ? a += "secondary schools<br/>" : "school" == b.amenity && (a += "school<br/>");"kindergarten" == b.amenity && (a += "kindergarten<br/>");"internet_cafe" == b.amenity && (a += "internet cafe<br/>");"daycare" == b.amenity && (a += "daycare<br/>");"childcare" == b.amenity && (a += "childcare<br/>");"university" == b.amenity && (a += "university<br/>");"college" == b.amenity && (a += "college<br/>");"shelter" == b.amenity && (a += "shelter<br/>");"bbq" == b.amenity && (a += "bbq<br/>");"nightclub" == b.amenity && (a += "nightclub<br/>");"bicycle_parking" == b.amenity && (a += "bicycle parking<br/>");"bicycle_rental" == b.amenity && (a += "bicycle rental<br/>");"boat_sharing" == b.amenity && (a += "boat sharing<br/>");"car_sharing" == b.amenity && (a += "car sharing<br/>");"cinema" == b.amenity && (a += "cinema<br/>");"swimming_pool" == b.amenity && (a += "swimming pool<br/>");if ("embassy" == b.amenity || "embassy" == b.diplomatic) a += "embassy<br/>";"embassy" == b.amenity && "consulate" == b.diplomatic && (a += "consulate<br/>");"embassy" == b.amenity && "consulate_general" == b.diplomatic && (a += "consulate general<br/>");"embassy" == b.amenity && "honorary_consulate" == b.diplomatic && (a += "honorary consulate<br/>");"embassy" == b.amenity && "permanent_mission" == b.diplomatic && (a += "permanent mission<br/>");"embassy" == b.amenity && "delegation" == b.diplomatic && (a += "delegation<br/>");"embassy" == b.amenity && "high_commission" == b.diplomatic && (a += "high commission<br/>");"Barfusspfad" == b.amenity && (a += "barefoodpath<br/>");"casino" == b.amenity && (a += "casino<br/>");"spa" == b.amenity && (a += "spa<br/>");"stables" == b.amenity && (a += "stables<br/>");"watering_place" == b.amenity && (a += "watering place<br/>");"yes" == b.watering_place && (a += "watering place<br/>");"water_point" == b.amenity && (a += "water point<br/>");"taxi" == b.amenity && (a += "taxi<br/>");"car_wash" == b.amenity && (a += "car wash<br/>");"brothel" == b.amenity && (a += "brothel<br/>");"stripclub" == b.amenity && (a += "stripclub<br/>");"swingerclub" == b.amenity && (a += "swingerclub<br/>");"planetarium" == b.amenity && (a += "planetarium<br/>");"courthouse" == b.amenity && (a += "court house<br/>");"crematorium" == b.amenity && (a += "crematorium<br/>");if ("crypt" == b.amenity || "crypt" == b.building) a += "crypt<br/>";"hunting_stand" == b.amenity && (a += "hunting stand<br/>");"photo_booth" == b.amenity && (a += "photo booth<br/>");"prison" == b.amenity && (a += "prison<br/>");"ranger_station" == b.amenity && (a += "ranger station<br/>");"register_office" == b.amenity && (a += "register office<br/>");"marketplace" == b.amenity && (a += "marketplace<br/>");"solarium" == b.amenity && (a += "solarium<br/>");"sauna" == b.amenity && (a += "sauna<br/>");"shower" == b.amenity && (a += "shower<br/>");if ("waste_disposal" == b.amenity && (a += "waste disposal<br/>", b.waste)) switch (a += "Typ: ", b.waste) {case "trash":
            a += "General<br/>";break;case "oil":
            a += "Oil<br/>";break;case "drugs":
            a += "Pharmaceutical<br/>";break;case "organic":
            a += "Organic<br/>";break;case "plastic":
            a += "Plastic<br/>";break;case "rubble":
            a += "Rubble<br/>";break;case "cigarettes":
            a += "Cigarettes<br/>";break;default:
            a += "General<br/>";}if ("waste_basket" == b.amenity || "dog_excrement" == b.waste) a += "dog waste station<br/>";if ("scout_camp" == b.amenity || "scout_hut" == b.amenity || "scout_hall" == b.amenity) a += "scout camp<br/>";"ferry_terminal" == b.amenity && (a += "ferry terminal<br/>");"bureau_de_change" == b.amenity && (a += "bureau de change<br/>");"youth_club" == b.amenity && (a += "youth club<br/>");"festival_grounds" == b.amenity && (a += "festival grounds<br/>");if ("yes" == b.openfire || "yes" == b.fireplace) a += "fireplace<br/>";if ("vending_machine" == b.amenity) if (b.vending) switch (b.vending) {case "admission_tickets":
            a += "vending machine admission tickets<br/>";
            break;case "animal_feed":
            a += "vending machine animal feed<br/>";break;case "bicycle_tube":
            a += "vending machine bicycle tube<br/>";break;case "books":
            a += "vending machine books<br/>";break;case "candles":
            a += "vending machine candles<br/>";break;case "cigarettes":
            a += "vending machine cigarettes<br/>";break;case "chemist":
            a += "vending machine chemist<br/>";break;case "condoms":
            a += "vending machine condoms<br/>";break;case "drinks":
            a += "vending machine drinks<br/>";break;case "electronics":
            a += "vending machine electronics<br/>";
            break;case "elongated_coin":
            a += "vending machine elongated_coin<br/>";break;case "excrement_bags":
            a += "vending machine excrement_bags<br/>";break;case "feminine_hygiene":
            a += "vending machine feminine_hygiene<br/>";break;case "first_aid":
            a += "vending machine first_aid<br/>";break;case "fishing_tackle":
            a += "vending machine fishing tackle<br/>";break;case "fishing_bait":
            a += "vending machine fishing bait<br/>";break;case "flowers":
            a += "vending machine flowers<br/>";break;case "food":
            a += "vending machine food<br/>";
            break;case "ice_cubes":
            a += "vending machine ice cubes<br/>";break;case "ice_cream":
            a += "vending machine ice cream<br/>";break;case "ink_cartridges":
            a += "vending machine ink cartridges<br/>";break;case "laundry_detergent":
            a += "vending machine laundry detergent<br/>";break;case "public_transport_tickets":
            a += "vending machine public transport tickets<br/>";break;case "newspaper":
            a += "vending machine newspaper<br/>";break;case "parcel_pickup":
            a += "vending machine parcel pickup<br/>";break;case "parcel_mail_in":
            a += "Packege station<br/>";break;case "parking_tickets":
            a += "vending machine parking tickets<br/>";break;case "photos":
            a += "vending machine photos<br/>";break;case "sex_toys":
            a += "vending machine sex_toys<br/>";break;case "SIM_cards":
            a += "vending machine SIM_cards<br/>";break;case "stamps":
            a += "vending machine stamps<br/>";break;case "sweets":
            a += "vending machine sweets<br/>";break;case "syringes":
            a += "vending machine syringes<br/>";break;case "toll":
            a += "vending machine toll<br/>";break;case "toys":
            a += "vending machine toys<br/>";
            break;case "umbrellas":
            a += "vending machine umbrellas<br/>";break;default:
            a += "vending machine<br/>";} else a += "vending machine<br/>";"arts_centre" == b.amenity && (a += "arts centre<br/>");"artwork" == b.amenity && (a += "artwork<br/>");"museum" == b.amenity && (a += "museum<br/>");"theatre" == b.amenity && (a += "theatre<br/>");"cathedral" == b.building && (a += "cathedral<br/>");"church" == b.building && (a += "church<br/>");"chapel" == b.building && (a += "chapel<br/>");"place_of_worship" == b.amenity && (a += "place of worship<br/>");"village" == b.abandoned && (a += "abandoned village<br/>");"theme_park" == b["abandoned:tourism"] && (a += "abandoned theme park<br/>");"prison_camp" == b["abandoned:amenity"] && "concentration_camp" == ["concentration_camp"] && (a += "abandoned concentration camp<br/>");"yes" == b.abandoned && "bunker" == b.military && (a += "abandoned bunker<br/>");"yes" == b.abandoned && "barracks" == b.military && (a += "abandoned barracks<br/>");"yes" == b.abandoned && "airfield" == b.military && (a += "abandoned airfield<br/>");"monastery" == b.historic && (a += "historic monastery<br/>");
    "monastery" == b.amenity && (a += "monastery<br/>");"monastery" == b.building && (a += "monastery<br/>");"manor" == b.historic && (a += "historic manor<br/>");"boundary_stone" == b.historic && (a += "historic boundary stone<br/>");"milestone" == b.historic && (a += "historic milestone<br/>");"monument" == b.historic && (a += "monument<br/>");"palace" == b.historic && (a += "historic palace<br/>");"mine" == b.historic && (a += "historic mine<br/>");"ruins" == b.historic && (a += "ruins<br/>");"harbour" == b.historic_usage && (a += "historic harbour<br/>");
    "rune stone" == b.historic && (a += "rune stone<br/>");"battlefield" == b.historic && (a += "historic battlefield<br/>");"blacksmith" == b.historic && (a += "historic blacksmith<br/>");if ("tree_shrine" == b.historic || "wayside_shrine" == b.historic) a += "shrine<br/>";"city_gate" == b.historic && (a += "historic city gate<br/>");"wayside_cross" == b.historic && (a += "historic wayside cross<br/>");"monument" == b.amenity && (a += "monument<br/>");"memorial" == b.historic && (a += "memorial<br/>");"optical_telegraph" == b.historic && (a += "historic optical telegraph<br/>");
    if ("castle" == b.historic) if (b.castle_type) switch (b.castle_type) {case "defensive":
            a += "defensive castle<br/>";break;case "palace":
            a += "palace<br/>";break;case "stately":
            a += "stately castle<br/>";break;case "manor":
            a += "manor<br/>";break;case "fortress":
            a += "fortress<br/>";break;case "castrum":
            a += "castrum<br/>";break;case "shiro":
            a += "shiro<br/>";break;case "kremlin":
            a += "kremlin<br/>";break;default:
            a += "castle<br/>";} else a += "castle<br/>";"archaeological_site" == b.historic && (a += "archaeological site<br/>");if ("tomb" == b.historic) if (b.tomb) switch (b.tomb) {case "tumulus":
            a += "tumulus<br/>";break;case "rock-cut":
            a += "rock<br/>";break;case "hypogeum":
            a += "hypogeum<br/>";break;case "war_grave":
            a += "war grave<br/>";break;case "mausoleum":
            a += "mausoleum<br/>";break;case "columbarium":
            a += "columbarium<br/>";break;case "crypt":
            a += "crypt<br/>";break;case "pyramid":
            a += "pyramid<br/>";break;case "sarcophagus":
            a += "sarcophagus<br/>";break;case "vault":
            a += "vault<br/>";break;case "tombstone":
            a += "tombstone<br/>";break;default:
            a += "historic tomb<br/>";} else a += "historic tomb<br/>";"accountant" == b.office && (a += "accountant<br/>");"administrative" == b.office && (a += "administrative<br/>");"architect" == b.office && (a += "architect<br/>");"association" == b.office && (a += "association<br/>");"physician" == b.office && (a += "physician<br/>");"camping" == b.office && (a += "camping office<br/>");"company" == b.office && (a += "company<br/>");"educational_institution" == b.office && (a += "educational institution<br/>");"employment_agency" == b.office && (a += "employment agency<br/>");"estate_agent" == b.office && (a += "estate agent<br/>");"forestry" == b.office && (a += "forestry<br/>");"foundation" == b.office && (a += "foundation<br/>");"government" == b.office && (a += "government<br/>");"guide" == b.office && (a += "guide office<br/>");"insurance" == b.office && (a += "insurance<br/>");"it" == b.office && (a += "it office<br/>");"lawyer" == b.office && (a += "lawyer<br/>");"newspaper" == b.office && (a += "newspaper<br/>");"ngo" == b.office && (a += "ngo office<br/>");"notary" == b.office && (a += "notary<br/>");"political_party" == b.office && (a += "political party<br/>");
    "quango" == b.office && (a += "quango office<br/>");"realtor" == b.office && (a += "realtor<br/>");"real_estate_agent" == b.office && (a += "real estate agent<br/>");"register" == b.office && (a += "register<br/>");"religion" == b.office && (a += "religious office<br/>");"research" == b.office && (a += "research office<br/>");"tax" == b.office && (a += "tax office<br/>");"telecommunication" == b.office && (a += "telecommunication office<br/>");"travel_agent" == b.office && (a += "travel agent<br/>");"water_utility" == b.office && (a += "water utility office<br/>");
    "therapist" == b.office && (a += "therapist<br/>");"city" == b.place && (a += "city<br/>");"town" == b.place && (a += "town<br/>");"village" == b.place && (a += "village<br/>");"continent" == b.place && (a += "continent<br/>");"ocean" == b.place && (a += "ocean</br>");"track" == b.highway && (a += "track<br/>");"raceway" == b.highway && (a += "raceway<br/>");"designated" == b.bicycle && (a += "cycle path<br/>");"path" == b.highway && (a += "food path<br/>");"parking" == b.amenity && (a += "parking<br/>");"services" == b.highway && (a += "services<br/>");"rest_area" == b.highway && (a += "rest area<br/>");"turning_circle" == b.highway && (a += "turning circle<br/>");"service" == b.highway && (a += "service road<br/>");"motorway" == b.highway && (a += "motorway<br/>");"motorway_junction" == b.highway && (a += "motorway junction<br/>");"bridleway" == b.highway && (a += "bridleway<br/>");"yes" == b.oneway && (a += "oneway<br/>");"yes" == b.park_ride && (a += "park and ride<br/>");"unknown" == b.park_ride && (a += "park and ride<br/>");"bus" == b.park_ride && (a += "park and ride<br/>");"tram" == b.park_ride && (a += "park and ride<br/>");
    "bus_stop" == b.highway && (a += "bus stop<br/>");"pedestrian" == b.highway && (a += "pedestrian<br/>");"street_lamp" == b.highway && (a += "street lamp<br/>");"traffic_signals" == b.highway && (a += "traffic signals<br/>");"traffic_signals" == b.crossing && (a += "traffic signals<br/>");"speed_camera" == b.highway && (a += "speed camera<br/>");"yes" == b.traffic_calming && (ret += "traffic calming</br>");"bump" == b.traffic_calming && (a += "bump</br>");"chicane" == b.traffic_calming && (a += "chicane</br>");"choker" == b.traffic_calming && (a += "choker</br>");
    "cushion" == b.traffic_calming && (a += "cushion</br>");"hump" == b.traffic_calming && (a += "hump</br>");"island" == b.traffic_calming && (a += "island</br>");"rumble_strip" == b.traffic_calming && (a += "rumble_strip</br>");"table" == b.traffic_calming && (a += "table</br>");"buoy_cardinal" == b["seamark:type"] && (a += "buoy cardinal<br/>");"buoy_lateral" == b["seamark:type"] && (a += "buoy lateral<br/>");"buoy_isolated_danger" == b["seamark:type"] && (a += "buoy isolated_danger<br/>");"perch" == b["seamark:beacon_lateral:shape"] && (a += "perch<br/>");
    "fuel" == b.amenity && "fuel_station" == b["seamark:small_craft_facility:category"] ? a += "fuel station<br/>" : "fuel" == b.amenity && (a += "fuel<br/>");if ("charging_station" == b.amenity) {
        var a = a + "charging station<br/>",
            c = b.voltage;if (b.car) {
            switch (b.car) {case "yes":
                    a += "Car: yes";break;case "no":
                    a += "Car: No";break;default:
                    a += "Cars: unkown";}a += "<br/>";
        } else a += "Cars: unkown<br/>";if (b.bicycle) {
            switch (b.bicycle) {case "yes":
                    a += "E-Bike: yes";break;case "no":
                    a += "E-Bike: no";break;default:
                    a += "E-Bike: unkown";}a += "<br/>";
        } else a += "E-Bike: unkown<br/>";b["socket:schuko"] && (a += "Schuko socket: " + b["socket:schuko"] + "<br/>");b["socket:cee_blue"] && (a += "Cee blue socket " + b["socket:cee_blue"] + "<br/>");b["socket:cee_red_16a"] && (a += "Cee red 16a socket " + b["socket:cee_red_16a"] + "<br/>");b["socket:cee_red_32a"] && (a += "Cee red 32a socket " + b["socket:cee_red_32a"] + "<br/>");b["socket:cee_red_64a"] && (a += "Cee red 64a socket " + b["socket:cee_red_64a"] + "<br/>");b["socket:cee_red_125a"] && (a += "Cee red 125a socket " + b["socket:cee_red_125a"] + "<br/>");
        b["socket:nema_5_15"] && (a += "Nema 5 15 socket " + b["socket:nema_5_15"] + "<br/>");b["socket:nema_5_20"] && (a += "Nema 5 20 socket " + b["socket:nema_5_20"] + "<br/>");b["socket:nema_14_30"] && (a += "Nema 14 30 socket " + b["socket:nema_14_30"] + "<br/>");b["socket:nema_14_50"] && (a += "Nema 14 50 socket " + b["socket:nema_14_50"] + "<br/>");b["socket:bs1363"] && (a += "Bs1363 socket " + b["socket:bs1363"] + "<br/>");b["socket:type1"] && (a += "Type 1 socket " + b["socket:type1"] + "<br/>");b["socket:type1_combo"] && (a += "Type 1 combo socket " + b["socket:schuko"] + "<br/>");b["socket:type2"] && (a += "Type 2 socket " + b["socket:type2"] + "<br/>");b["socket:type2_combo"] && (a += "Type 2 combo socket " + b["socket:type2_combo"] + "<br/>");b["socket:type3"] && (a += "Type 3 socket " + b["socket:type3"] + "<br/>");b["socket:chademo"] && (a += "Chademo socket " + b["socket:chademo"] + "<br/>");b["socket:magne_charge"] && (a += "Magne charge socket " + b["socket:magne_charge"] + "<br/>");b["socket:tesla_standard"] && (a += "Tesla standard socket " + b["socket:tesla_standard"] + "<br/>");b["socket:tesla_supercharge"] && (a += "Tesla supercharge: " + b["socket:tesla_supercharge"] + "<br/>");b["socket:tesla_roadster"] && (a += "Tesla_roadster socket " + b["socket:tesla_roadster"] + "<br/>");a += "<br/>";b.voltage && (a += "Volt: " + c + "<br/>");
    }"yes" == b.tunnel && (a += "tunnel<br/>");if (b.bridge) switch (a += "bridge: ", b.bridge) {case "swing":
            a += "swing";break;case "aqueduct":
            a += "aqueduct";break;case "bascule":
            a += "flap bridge";break;case "boardwalk":
            a += "boardwalk";break;case "cantilever":
            a += "cantilever";break;case "covered":
            a += "covered";break;case "drawbridge":
            a += "drawbridge";break;case "humpback":
            a += "humpback";break;case "lift":
            a += "lift";break;case "low_water_crossing":
            a += "low water crossing";break;case "moveable":
            a += "moveable";break;case "pontoon":
            a += "pontoon";break;case "suspension":
            a += "suspension";break;case "trestle":
            a += "trestle";break;case "viaduct":
            a += "viaduct";}if (b["bridge:movable"]) switch (b["bridge:movable"]) {case "swing":
            a += "swing";break;case "bascule":
            a += "bascule";break;case "drawbridge":
            a += "drawbridge";break;case "lift":
            a += "lift";break;case "submersible":
            a += "submersible";break;case "transporter":
            a += "transporter";break;case "retractable":
            a += "retractable";}if ("nursing_home" == b.amenity || "retirement_home" == b.amenity) a += "nursing home / retirement home<br/>";"social_facility" == b.amenity && (a += "social facility<br/>");if (b.social_facility) {
        "group_home" == b.social_facility && "senior" == b["social_facility:for"] && (a += "senior group home<br/>");"assisted_living" == b.social_facility && (a += "assisted living<br/>");"outreach" == b.social_facility && (a += "outreach<br/>");"workshop" == b.social_facility && (a += "workshop<br/>");if ("ambulatory_care" == b.social_facility || "healthcare" == b.social_facility) a += "ambulatory care<br/>";"shelter" == b.social_facility && "senior" == b["social_facility:for"] && (a += "senior shelter<br/>");"shelter" == b.social_facility && "abused" == b["social_facility:for"] && (a += "abused shelter<br/>");"food_bank" == b.social_facility && (a += "food bank<br/>");"hospice" == b.social_facility && (a += "hospice<br/>");
    }b.brewery && (a += "brand of beer: " + b.brewery + "<br/>");"alcohol" == b.shop && (a += "alcohol shop<br/>");"bakery" == b.shop && (a += "bakery shop<br/>");"beverages" == b.shop && (a += "beverages shop<br/>");"butcher" == b.shop && (a += "butcher shop<br/>");"cheese" == b.shop && (a += "cheese shop<br/>");"chocolate" == b.shop && (a += "chocolate shop<br/>");"coffee" == b.shop && (a += "coffee shop<br/>");"confectionery" == b.shop && (a += "confectionery shop<br/>");"convenience" == b.shop && (a += "convenience shop<br/>");"deli" == b.shop && (a += "deli shop<br/>");"dairy" == b.shop && (a += "dairy shop<br/>");"farm" == b.shop && (a += "farm shop<br/>");
    "greengrocer" == b.shop && (a += "greengrocer shop<br/>");"grocery" == b.shop && (a += "grocery shop<br/>");"organic" == b.shop && (a += "organic shop<br/>");"pasta" == b.shop && (a += "pasta shop<br/>");"seafood" == b.shop && (a += "seafood shop<br/>");"tea" == b.shop && (a += "tea shop<br/>");"wine" == b.shop && (a += "wine shop<br/>");"department_store" == b.shop && (a += "department store<br/>");"general" == b.shop && (a += "general shop<br/>");"kiosk" == b.shop && (a += "kiosk<br/>");"mall" == b.shop && (a += "mall<br/>");"supermarket" == b.shop && (a += "supermarket<br/>");
    "baby_goods" == b.shop && (a += "baby goods shop<br/>");"bag" == b.shop && (a += "bag shop<br/>");"boutique" == b.shop && (a += "boutique<br/>");"clothes" == b.shop && (a += "clothes shop<br/>");"fabric" == b.shop && (a += "fabric shop<br/>");"fashion" == b.shop && (a += "fashion shop<br/>");"jewelry" == b.shop && (a += "jewelry shop<br/>");"leather" == b.shop && (a += "leather shop<br/>");"shoes" == b.shop && (a += "shoes shop<br/>");"variety_store" == b.shop && (a += "variety store<br/>");"chemist" == b.shop && (a += "chemist<br/>");"cosmetics" == b.shop && (a += "cosmetics shop<br/>");
    "drugstore" == b.shop && (a += "drugstore<br/>");"perfumery" == b.shop && (a += "perfumery<br/>");"erotic" == b.shop && (a += "erotic shop<br/>");"hairdresser" == b.shop && (a += "hairdresser<br/>");"hearing_aids" == b.shop && (a += "hearing aids<br/>");"herbalist" == b.shop && (a += "herbalist<br/>");"massage" == b.shop && (a += "massage<br/>");"medical_supply" == b.shop && (a += "medical supply shop<br/>");"optician" == b.shop && (a += "optician<br/>");"tattoo" == b.shop && (a += "tattoo<br/>");"bathroom_furnishing" == b.shop && (a += "bathroom furnishing<br/>");
    "doityourself" == b.shop && (a += "doityourself<br/>");"energy" == b.shop && (a += "energy<br/>");"florist" == b.shop && (a += "florist<br/>");"furnace" == b.shop && (a += "furnace shop<br/>");"garden_centre" == b.shop && (a += "garden centre<br/>");"gas" == b.shop && (a += "gas<br/>");"glaziery" == b.shop && (a += "glaziery<br/>");"hardware" == b.shop && (a += "hardware shop<br/>");"houseware" == b.shop && (a += "houseware shop<br/>");"locksmith" == b.shop && (a += "locksmith<br/>");"paint" == b.shop && (a += "paint shop<br/>");"trade" == b.shop && (a += "trade<br/>");
    "antiques" == b.shop && (a += "antiques shop<br/>");"bed" == b.shop && (a += "bed shop<br/>");"candles" == b.shop && (a += "candles shop<br/>");"carpet" == b.shop && (a += "carpet shop<br/>");"curtain" == b.shop && (a += "curtain shop<br/>");"furniture" == b.shop && (a += "furniture store<br/>");"interior_decoration" == b.shop && (a += "interior decoration company<br/>");"kitchen" == b.shop && (a += "kitchen shop<br/>");"window_blind" == b.shop && (a += "window blind shop<br/>");"computer" == b.shop && (a += "computer shop<br/>");"electronics" == b.shop && (a += "electronics shop<br/>");"hifi" == b.shop && (a += "hifi shop<br/>");"mobile_phone" == b.shop && (a += "mobile phone shop<br/>");"radiotechnics" == b.shop && (a += "radiotechnics shop<br/>");"vacuum_cleaner" == b.shop && (a += "vacuum cleaner shop<br/>");"bicycle" == b.shop && (a += "bicycle shop<br/>");"car" == b.shop && (a += "car shop<br/>");"car repair" == b.shop && (a += "car repair<br/>");"car_parts" == b.shop && (a += "car parts shop<br/>");if ("dive" == b.shop || "scuba_diving" == b.shop) a += "scuba diving shop<br/>";"fishing" == b.shop && (a += "fishing shop<br/>");
    "free_flying" == b.shop && (a += "free flying shop<br/>");"hunting" == b.shop && (a += "hunting shop<br/>");"motorcycle" == b.shop && (a += "motorcycle shop<br/>");"outdoor" == b.shop && (a += "outdoor shop<br/>");"sports" == b.shop && (a += "sports shop<br/>");"tyres" == b.shop && (a += "tyres<br/>");"water_sports" == b.shop && (a += "water sports shop<br/>");"art" == b.shop && (a += "art<br/>");"craft" == b.shop && (a += "craft<br/>");"frame" == b.shop && (a += "frame shop<br/>");"music" == b.shop && (a += "music shop<br/>");"music_instrument" == b.shop && (a += "music instruments shop<br/>");
    "photo" == b.shop && (a += "photo shop<br/>");"video" == b.shop && (a += "video<br/>");"video_games" == b.shop && (a += "video games<br/>");"anime" == b.shop && (a += "anime<br/>");"books" == b.shop && (a += "books shop<br/>");"gift" == b.shop && (a += "gift shop<br/>");"newsagent" == b.shop && (a += "newsagent<br/>");"stationery" == b.shop && (a += "stationery<br/>");"ticket" == b.shop && (a += "ticket shop<br/>");"copyshop" == b.shop && (a += "copyshop<br/>");"funeral_directors" == b.shop && (a += "funeral directors<br/>");"laundry" == b.shop && (a += "laundry<br/>");
    "dry_cleaning" == b.shop && (a += "dry cleaning<br/>");"money_lender" == b.shop && (a += "money lender<br/>");"pawnbroker" == b.shop && (a += "pawnbroker<br/>");"pet" == b.shop && (a += "pet shop<br/>");"pyrotechnics" == b.shop && (a += "pyrotechnics shop<br/>");"religion" == b.shop && (a += "religion<br/>");"beauty" == b.shop && (a += "beauty<br/>");"solarium" == b.shop && (a += "solarium<br/>");"tobacco" == b.shop && (a += "tobacco shop<br/>");"toys" == b.shop && (a += "toys shop<br/>");"travel_agency" == b.shop && (a += "travel agency<br/>");"market_hall" == b.shop && (a += "market hall<br/>");"vacant" == b.shop && (a += "vacant<br/>");"weapons" == b.shop && (a += "weapons shop<br/>");"lottery" == b.gambling && (a += "lottery<br/>");"fish" == b.pet && (a += "fishkeeping<br/>");"agriucultural_engines" == b.craft && (a += "agriucultural engines<br/>");"basket_maker" == b.craft && (a += "basket maker<br/>");"beekeeper" == b.craft && (a += "beekeeper<br/>");"blacksmith" == b.craft && (a += "blacksmith<br/>");"brewery" == b.craft && (a += "brewery<br/>");"yes" == b.microbrewery && (a += "micro-brewery<br/>");"boatbuilder" == b.craft && (a += "boatbuilder<br/>");"bookbinder" == b.craft && (a += "bookbinder<br/>");"builder" == b.craft && (a += "housebuilding<br/>");"carpenter" == b.craft && (a += "carpenter, woodworker, joiner<br/>");"carpet_layer" == b.craft && (a += "carpet layer<br/>");"caterer" == b.craft && (a += "caterer<br/>");"clockmaker" == b.craft && (a += "clockmaker<br/>");"confectionery" == b.craft && (a += "confectionery<br/>");"dressmaker" == b.craft && (a += "dressmaker<br/>");"electrician" == b.craft && (a += "electrician<br/>");"gardener" == b.craft && (a += "gardener, landscaper<br/>");
    "glaziery" == b.craft && (a += "glaziery<br/>");"handicraft" == b.craft && (a += "handicraft<br/>");"hvac" == b.craft && (a += "heating, ventilation and air-conditioning technology (HVAC)<br/>");"insulation" == b.craft && (a += "thermal insulation<br/>");"jeweller" == b.craft && (a += "jeweller, gold-/silversmiths<br/>");"key_cutter" == b.craft && (a += "key cutter<br/>");"locksmith" == b.craft && (a += "locksmith<br/>");"metal_construction" == b.craft && (a += "metalworker<br/>");"optician" == b.craft && (a += "optician<br/>");"painter" == b.craft && (a += "painter<br/>");"parquet_layer" == b.craft && (a += "parquet layer<br/>");"photographer" == b.craft && (a += "photographer<br/>");"photographic_laboratory" == b.craft && (a += "photographic laboratory<br/>");"plasterer" == b.craft && (a += "plasterer<br/>");"plumber" == b.craft && (a += "plumber<br/>");"pottery" == b.craft && (a += "pottery<br/>");"rigger" == b.craft && (a += "ship rigger<br/>");"roofer" == b.craft && (a += "roofer<br/>");"saddler" == b.craft && (a += "saddler<br/>");"sailmaker" == b.craft && (a += "sailmaker<br/>");"sawmill" == b.craft && (a += "sawmill<br/>");"scaffolder" == b.craft && (a += "scaffolder<br/>");"sculptor" == b.craft && (a += "sculptor<br/>");"shoemaker" == b.craft && (a += "shoemaker<br/>");"stand_builder" == b.craft && (a += "exhibition stand builder<br/>");"stonemason" == b.craft && (a += "stonemason<br/>");"sun_protection" == b.craft && (a += "constructor for sun protection, venetian blind, shutter<br/>");"sweep" == b.craft && (a += "chimney sweep<br/>");"tailor" == b.craft && (a += "tailor<br/>");"tiler" == b.craft && (a += "tiler<br/>");"tinsmith" == b.craft && (a += "tinsmith, metalworker<br/>");
    "upholsterer" == b.craft && (a += "upholsterer<br/>");"watchmaker" == b.craft && (a += "watchmaker<br/>");"window_construction" == b.craft && (a += "window constructor<br/>");"machines" == b.rental && (a += "rental park for machines<br/>");"car_rental" == b.amenity && (a += "car rental company<br/>");"allotments" == b.landuse && (a += "allotment garden<br/>");"basin" == b.landuse && (a += "holding reservoir<br/>");"brownfield" == b.landuse && (a += "brownfield<br/>");"commercial" == b.landuse && (a += "commercial area<br/>");"construction" == b.landuse && (a += "construction area<br/>");"farmland" == b.landuse && (a += "farmland<br/>");"farmyard" == b.landuse && (a += "farmyard<br/>");"forest" == b.landuse && (a += "forest<br/>");"garages" == b.landuse && (a += "garages<br/>");"grass" == b.landuse && (a += "grass<br/>");"greenfield" == b.landuse && (a += "greenfield<br/>");"greenhouse_horticulture" == b.landuse && (a += "greenhouse horticulture<br/>");"industrial" == b.landuse && (a += "industry area<br/>");"landfill" == b.landuse && (a += "landfill<br/>");"meadow" == b.landuse && (a += "meadow<br/>");"orchard" == b.landuse && (a += "orchard<br/>");"plant_nursery" == b.landuse && (a += "plant nursery<br/>");"quarry" == b.landuse && (a += "quarry<br/>");"railway" == b.landuse && (a += "railway<br/>");"recreation_ground" == b.landuse && (a += "recreation ground<br/>");"reservoir" == b.landuse && (a += "reservoir<br/>");"residential" == b.landuse && (a += "residential<br/>");"retail" == b.landuse && (a += "retrail<br/>");"salt_pond" == b.landuse && (a += "salt pond<br/>");"village_green" == b.landuse && (a += "village green<br/>");"vineyard" == b.landuse && (a += "vineyard<br/>");
    "pond" == b.landuse && (a += "pond<br/>");"salt_pond" == b.landuse && (a += "salt pond<br/>");"animal_keeping" == b.landuse && (a += "animal keeping<br/>");"yes" == b.entrance && (a += "entrance<br/>");"main" == b.entrance && (a += "main-entrance<br/>");"service" == b.entrance && (a += "rear exit for staffing and suppliers<br/>");"exit" == b.entrance && (a += "exit<br/>");"emergency" == b.entrance && (a += "emergency<br/>");"bay" == b.natural && (a += "bay<br/>");"beach" == b.natural && (a += "beach<br/>");"wood" == b.natural && (a += "wood<br/>");"glacier" == b.natural && (a += "glacier<br/>");"cave_entrance" == b.natural && (a += "cave entrance<br/>");"spring" == b.natural && (a += "spring<br/>");"waterfall" == b.natural && (a += "waterfall<br/>");"scrub" == b.natural && (a += "scrub<br/>");"grassland" == b.natural && (a += "grassland<br/>");"wetland" == b.natural && (a += "wetland<br/>");"tree" == b.natural && (a += "tree");"peak" == b.natural && "yes" == b["summit:cross"] && (a += "cross on the summit of a mountain<br/>");"tree_row" == b.natural && (a += "tree row, alley of trees<br/>");"heath" == b.natural && (a += "heath<br/>");
    "moor" == b.natural && (a += "moor<br/>");"grassland" == b.natural && (a += "grassland<br/>");"fell" == b.natural && (a += "grasland above the tree land<br/>");"bare_rock" == b.natural && (a += "bare rock<br/>");"scree" == b.natural && (a += "scree<br/>");"volcano" == b.natural && (a += "volcano<br/>");"valley" == b.natural && (a += "valley<br/>");"stone" == b.natural && (a += "stone<br/>");"sea" == b.natural && (a += "sea<br/>");"national_park" == b.boundary && (a += "national park<br/>");"protected_area" == b.boundary && (a += "protected area<br/>");"yes" == b.mountain_pass && (a += "mountain pass<br/>");"waterfall" == b.waterway && (a += "waterfall<br/>");"canal" == b.waterway && (a += "canal<br/>");"canal" == b.water && (a += "canal<br/>");"river" == b.waterway && (a += "river<br/>");"river" == b.water && (a += "river<br/>");"riverbank" == b.waterway && (a += "river<br/>");"ditch" == b.waterway && (a += "ditch<br/>");"stream" == b.waterway && (a += "stream<br/>");"ferry" == b.route && (a += "ferry<br/>");"turning_point" == b.waterway && (a += "turning point<br/>");if ("lake" == b.water || "water" == b.natural) a += "lake<br/>";"cove" == b.water && (a += "cove<br/>");"lagoon" == b.water && (a += "lagoon<br/>");"pond" == b.water && (a += "pond<br/>");"reservoir" == b.water && (a += "waterreservoir<br/>");"oxbow" == b.water && (a += "oxbow lake<br/>");"lock" == b.water && (a += "lock chamber<br/>");"moat" == b.water && (a += "castle moat<br/>");"wastewater" == b.water && (a += "wastewater treatment plant<br/>");"guest" == b.mooring && "pier" == b.man_made || "visitor_berth" == b["seamark:small_craft_facility:category"] ? a += "gastrointestinal<br/>" : "pier" == b.man_made && (a += "pier<br/>");"boatyard" == b.waterway && (a += "boatyard<br/>");"mooring" == b["seamark:type"] && "dolphin" == b["seamark:mooring:category"] && (a += "dolphin<br/>");"foot" == b.route && (a += "footpath<br/>");"hiking" == b.route && (a += "hiking trail<br/>");if ("yes" == b.hiking && "information" == b.tourism) a += "direction board<br/>";else if ("information" == b.tourism && "information" == b.tourism) if (b.information) switch (b.information) {case "board":
            a += "direction board<br/>";break;case "map":
            a += "direction board with a map<br/>";break;case "office":
            a += "tourist information office<br/>";
            break;case "terminal":
            a += "tourist information terminal<br/>";break;case "audioguide":
            a += "audioguide<br/>";break;case "guidepost":
            a += "guidepost<br/>";break;case "tactile_map":
            a += "tactile map<br/>";break;case "tactile_model":
            a += "tactile model<br/>";break;case "route_marker":
            a += "route marker<br/>";break;default:
            a += "direction board<br/>";} else a += "direction board<br/>";"bicycle" == b.route && (a += "cycle track<br/>");"mtb" == b.route && (a += "mountain bike route<br/>");"horse" == b.route && (a += "bridleway<br/>");"coastline" == b.natural && (a += "coastline<br/>");"cliff" == b.natural && (a += "cliff<br/>");"dam" == b.waterway && (a += "dam<br/>");"weir" == b.waterway && (a += "weir<br/>");"lock_gate" == b.waterway && (a += "lock gate<br/>");"yes" == b.lock && (a += "lock<br/>");"sluice_gate" == b.waterway && (a += "sluice gate<br/>");"pumping_station" == b.man_made && (a += "pumping station<br/>");"groyne" == b.man_made && (a += "groyne<br/>");"dyke" == b.man_made && (a += "dyke<br/>");"levee" == b.man_made && (a += "levee<br/>");"watermill" == b.man_made && (a += "watermill<br/>");"airfield" == b.military && (a += "military airfield<br/>");"naval_base" == b.military && (a += "naval base<br/>");"range" == b.military && (a += "military range<br/>");"military" == b.landuse && (a += "military land use<br/>");"training_area" == b.military && (a += "military training area<br/>");"exclusion_zone" == b.military && (a += "military exclusion zone<br/>");"danger_area" == b.military && (a += "military danger area<br/>");"barracks" == b.military && (a += "barracks<br/>");"nuclear_explosion_site" == b.military && (a += "military nuclear explosion site<br/>");
    "yes" == b.construction ? a += "construction<br/>" : "construction" == b.highway && (a += "construction<br/>");"petroleum_well" == b.man_made && (a += "petroleum well<br/>");"storage_tank" == b.man_made && (a += "storage tank<br/>");"wastewater_plant" == b.man_made && (a += "wastewater plant<br/>");"silo" == b.man_made && (a += "silo<br/>");"water_tower" == b.man_made && (a += "water tower<br/>");"windmill" == b.man_made && (a += "windmill<br/>");"monitoring_station" == b.man_made && (a += "monitoring station");"crane" == b.man_made && (a += "crane");"lighthouse" == b.man_made && (a += "lighthouse");"beacon" == b.man_made && (a += "beacon");"breakwater" == b.man_made && (a += "breakwater");"lamp" == b.man_made && "street_lamp" == b["lamp:type"] && (a += "street lamp<br/>");"lantern" == b.light_source && (a += "street lamp");"floodlight" == b.light_source && (a += "floodlight<br/>");"signal_lamp" == b.light_source && (a += "signal lamp<br/>");"aviation" == b.light_source && (a += "aviation<br/>");"warning" == b.light_source && (a += "warning<br/>");if (b.light_source && b["light:method"]) switch (a += "Light Typ: ", b["light:method"]) {case "gas":
            a += "Gas";break;case "electric":
            a += "electric";break;case "incandescent":
            a += "incandescent";break;case "halogen":
            a += "halogen";break;case "discharge":
            a += "discharge";break;case "metal-halide":
            a += "metal-halide";break;case "neon":
            a += "neon";break;case "sodium":
            a += "Natriumdampflampe";break;case "high_pressure_sodium":
            a += "high pressure sodium";break;case "low_pressure_sodium":
            a += "low pressure sodium";break;case "fluorescent":
            a += "Fluorescent";break;case "mercury":
            a += "Mercury";break;case "LED":
            a += "LED";break;case "laser":
            a += "Laser";break;case "arc":
            a += "Arc";break;default:
            a += "Unkown";}"drinking_water" == b.amenity && (a += "drinking water<br/>");"yes" == b.drinking_water && (a += "drinking water<br/>");"works" == b.man_made ? a += "industrial building<br/>" : "industrial" == b.building ? a += "industrial building<br/>" : "industrial" == b.landuse ? a += "industrial area<br/>" : "industrial" == b.abutters ? a += "industrial area<br/>" : "commercial" == b.abutters && (a += "commercial<br/>");if (b["generator:source"]) switch (a += "installation: ", b["generator:source"]) {case "biomass":
            a += "biomass";break;case "biofuel":
            a += "biofuel";break;case "biogas":
            a += "biogas";break;case "coal":
            a += "coal";break;case "oil":
            a += "oil";break;case "waste":
            a += "waste";break;case "wind":
            a += "wind";break;case "solar":
            a += "solar";break;case "hydro":
            a += "hydro";break;case "tidal":
            a += "tidal";break;case "wave":
            a += "wave";break;case "geothermal":
            a += "geothermal";break;case "osmotic":
            a += "osmotic";break;case "nuclear":
            a += "nuclear";break;default:
            a += "unknown<br/>";}"photovoltaic" == b.power_source && (a += "photovoltaic");"line" == b.power && (a += "power line<br/>");"cable" == b.power && (a += "cable<br/>");"cable_distribution_cabinet" == b.power && (a += "cable distribution cabinet<br/>");"plant" == b.power && (a += "plant<br/>");"station" == b.power && (a += "station<br/>");"sub_station" == b.power && (a += "substation<br/>");"compensator" == b.power && (a += "compensator<br/>");"converter" == b.power && (a += "converter<br/>");"generator" == b.power && (a += "generator<br/>");"heliostat" == b.power && (a += "heliostat<br/>");"insulator" == b.power && (a += "insulator<br/>");"busbar" == b.line && (a += "busbar<br/>");"bay" == b.line && (a += "bay<br/>");"minor_line" == b.power && (a += "minor line<br/>");"pole" == b.power && (a += "pole<br/>");"portal" == b.power && (a += "portal<br/>");"catenary_mast" == b.power && (a += "catenary mast<br/>");"substation" == b.power && (a += "substation<br/>");"switch" == b.power && (a += "switch<br/>");"terminal" == b.power && (a += "terminal<br/>");"tower" == b.power && (a += "tower<br/>");"transformer" == b.power && (a += "transformer<br/>");if (b.barrier) switch (b.barrier) {case "bollard":
            a += "bollard<br/>";
            break;case "cycle_barrier":
            a += "cycle barrier<br/>";break;case "gate":
            a += "gate<br/>";break;case "chain":
            a += "chain<br/>";break;case "lift_gate":
            a += "lift gate<br/>";break;case "wall":
            a += "wall<br/>";break;case "toll_booth":
            a += "toll booth<br/>";break;case "fence":
            switch (b.fence_type) {case "barbed_wire":
                    a += "barbed wire<br/>";break;case "wood":
                    a += "wood<br/>";break;case "chain_link":
                    a += "chain link<br/>";break;case "electric":
                    a += "electric<br/>";break;case "railing":
                    a += "railing<br/>";break;case "wire":
                    a += "wire<br/>";
                    break;case "metal":
                    a += "metal<br/>";break;case "pole":
                    a += "pole<br/>";break;default:
                    a += "fence<br/>";}break;case "block":
            a += "block<br/>";break;case "ditch":
            a += "ditch<br/>";break;case "border_control":
            a += "border control<br/>";break;case "hedge":
            a += "hedge<br/>";break;case "retaining_wall":
            a += "retaining wall<br/>";break;case "cattle_grid":
            a += "cattle grid<br/>";break;case "horse_stile":
            a += "horse stile<br/>";break;default:
            a += "unknown<br/>";}"noise_barrier" == b.wall && (a += "noise barrier<br/>");"retaining_wall" == b.designation && (a += "noise barrier<br/>");"noise_barrier" == b.designation && (a += "noise barrier<br/>");"surveillance" == b.man_made && (a += "surveillance<br/>");if (b.aeroway) switch (a += "airport: ", b.aeroway) {case "aerodrome":
            a += "airport";break;case "apron":
            a += "apron";break;case "gate":
            a += "gate";break;case "helipad":
            a += "helipad";break;case "hangar":
            a += "hangar";break;case "runway":
            a += "runway";break;case "taxiway":
            a += "taxiway";break;case "terminal":
            a += "terminal";break;default:
            a += "unknown<br/>";}"stop" == b.railway && (a += "railway stop<br/>");"crossing" == b.railway && (a += "crossing<br/>");"level_crossing" == b.railway && (a += "lvel crossing<br/>");"station" == b.railway && (a += "station<br/>");"bus_station" == b.amenity && (a += "bus station<br/>");"bus_station" == !b.amenity && "station" == b.public_transport && "yes" == b.bus && (a += "bus station<br/>");"rail" == b.railway && (a += "railway<br/>", "contact_line" == b.electrified && (a += "overhead contact line<br/>"));"tram" == b.railway && (a += "tram<br/>");if ("slipway" == b["seamark:small_craft_facility:category"] || "slipway" == b.harbour || "slipway" == b.leisure) a += "slipway<br/>";if ("harbour" == b["seamark:type"]) if (b["seamark:harbour:category"]) switch (b["seamark:harbour:category"]) {case "ferry":
            a += "ferry<br/>";break;case "container":
            a += "container<br/>";break;case "marina":
            "marina" != b.leisure && (a += "marina<br/>");break;case "navel_base":
            a += "navel base<br/>";break;case "tanker":
            a += "tanker<br/>";break;case "passenger":
            a += "passenger<br/>";break;case "bulk":
            a += "bulk<br/>";break;default:
            a += "habour<br/>";} else a += "habour<br/>";
    "marina" == b.leisure && (a += "marina<br/>");"wreck" == b.historic && (a += "wreck<br/>");"animal_shelter" == b.amenity && (a += "animal shelter<br/>");"shelter" == b.animal && (a += "shelter<br/>");"horse_walker" == b.animal && (a += "horse walker<br/>");"yes" == b.animal_shelter && (a += "animal shelter<br/>");"dog" == b.animal_shelter && (a += "animal shelter<br/>");"cat" == b.animal_shelter && (a += "animal shelter<br/>");"animal_boarding" == b.amenity && (a += "animal boarding<br/>");"yes" == b.animal_boarding && (a += "animal boarding<br/>");"dog" == b.animal_boarding && (a += "animal boarding<br/>");"horse" == b.animal_boarding && (a += "animal boarding<br/>");"cat" == b.animal_boarding && (a += "animal boarding<br/>");"dog;cat" == b.animal_boarding && (a += "animal boarding<br/>");"cat;dog" == b.animal_boarding && (a += "animal boarding<br/>");if ("school" == b.animal || "sport" == b.animal || "animal_training" == b.amenity) a += "animal training<br/>";"swimming" == b.animal && (a += "swimming for dogs<br/>");if ("feeding_place" == b.amenity || "animal_feeding" == b.man_made || "animal_feeding" == b.amenity) a += "animal feeding<br/>";if ("wildlife_feeding" == b.amenity || "deer_feeding" == b.amenity || "game_feeding" == b.amenity) a += "wildlife feeding<br/>";if ("cratch" == b.amenity || "cratch" == b.man_made || "feeding_rack" == b.amenity) a += "feeding rack<br/>";"manger" == b.amenity && (a += "manger<br/>");"birdhouse" == b.man_made && (a += "birdhouse<br/>");"stork" == b.birds_nest && (a += "storck<br/>");"nest_box" == b.amenity && (a += "nest box<br/>");"wellness" == b.animal && (a += "dog parlour<br/>");"cemetery" == b.animal && (a += "small animal cemetery<br/>");
    if ("stable" == b.building || "stable" == b["building:use"]) a += "stable<br/>";"cowshed" == b.building && (a += "cowshed<br/>");"sty" == b.building && (a += "sty<br/>");"barn" == b.building && (a += "barn<br/>");"farm_auxiliary" == b.building && (a += "farm auxiliary<br/>");if (b["river:waterway_distance"] || "milestone" == b.waterway) a += "milestone of waterway distance<br/>";"milestone" == b.highway && (a += "milestone<br/>");"market" == b["xmas:feature"] && (a += "Christmas fair<br/>");"tree" == b["xmas:feature"] && (a += "sale of Chrismas trees<br/>");
    "event" == b["xmas:feature"] && (a += "Chrismas event<br/>");"pyramid" == b["xmas:feature"] && (a += "Chrismas pyramid<br/>");return '<div class="c4g_popup_header_featuretype">' + a + "<br/> </div>";
}
var fnContent = exports.fnContent = function fnContent(b) {
    var a;a = "" + fnContentGeneralInformations(b);a += fnContentHealthcare(b);a += fnContentAerodrome(b);a += fnContentCuisine(b);a += fnContentShipping(b);a += fnContentHydrants(b);a += fnContentSports(b);a += fnContentStreetsTraffic(b);a += fnContentInformationCity(b);a += fnContentEmergency(b);a += fnContentStorage(b);a += fnContentAmenity(b);a += fnContentTourism(b);a += fnContentRoute(b);a += fnContentPetrol(b);a += fnContentBarriers(b);a += fnContentLanduse(b);a += fnContentNatural(b);a += fnKlosterAdditional(b);
    a += fnSicherheitAdditional(b);a += fnAdditionalBuildingInfos(b);a += fnKraftwerkInfo(b);a += fnMessstation(b);a += fnWertstoffinfo(b);(a += fnContentProtectedArea(b)) && (a = "<br/>" + a);return '<div class="c4g_popup_content">' + a + "</div>";
},
    fnContentAerodrome = exports.fnContentAerodrome = function fnContentAerodrome(b) {
    var a = "";b.aerodrome && ("international" == b.aerodrome && (a += "type of airport: international<br/>"), "regional" == b.aerodrome && (a += "type of airport: regional<br/>"), "gliding" == b.aerodrome && (a += "type of airport: gliding<br/>"), "private" == b.aerodrome && (a += "type of airport: private<br/>"));b.iata && (a += "IATA-Code: " + b.iata + "<br/>");b.icao && (a += "ICAO-Code: " + b.icao + "<br/>");return a;
},
    fnContentNatural = exports.fnContentNatural = function fnContentNatural(b) {
    var a = "";if (b.forest || b.wood) {
        if ("broadleaved" == b.leaf_type || "deciduous" == b.wood) a += "broadleaved<br/>";if ("needleleaved" == b.leaf_type || "coniferous" == b.wood) a += "needleleaved<br/>";if ("mixed" == b.leaf_type || "mixed" == b.wood) a += "mixed<br/>";"leafless" == b.leaf_type && (a += "leafless<br/>");"evergreen" == b.wood && (a += "evergreen<br/>");"palm" == b.wood && (a += "palm<br/>");"nipa_palm" == b.wood && (a += "nipa palm<br/>");"eucalypt" == b.wood && (a += "eucalypt<br/>");if ("filao" == b.wood || "casuarina" == b.wood) a += "casuarina<br/>";
    }if ("tree" == b.natural && (!b["genus:de"] && !b["species:de"] && b.leaf_type && (a = "broadleaved" == b.leaf_type || "deciduous" == b.leaf_type || "broadleafed" == b.leaf_type ? a + "broad-leaved<br/>" : a + "conifer<br/>"), b.genus && (a += b.genus + "<br/>"), b["genus:de"] && (a += b["genus:de"] + "<br/>"), b.species && (a += b.species + "<br/>"), b["species:de"] && (a += b["species:de"] + "<br/>"), "landmark" == b.denotation && (a += "landmark<br/>"), "natural_monument" == b.denotation || "yes" == b.monument)) a += "natural monument<br/>";"manger" == b["feeding:type"] && (a += "manger:rack for fodder<br/>");"automated" == b["feeding:type"] && (a += "automated<br/>");if (b["feeding:for"]) switch (b["feeding:for"]) {case "sheep":
            a += "animal: sheep<br/>";break;case "horse":
            a += "animal: horse<br/>";break;case "cow":
            a += "animal: cow<br/>";break;case "rabbit":
            a += "animal: rabbit<br/>";break;case "bunny":
            a += "animal: bunny<br/>";break;
        case "cat":
            a += "animal: cat </br>";break;case "swan":
            a += "animal: swan </br>";break;case "guinea pig":
            a += "animal: guinea pig </br>";break;case "donkey":
            a += "animal: donkey </br>";break;case "squirrel":
            a += "animal: squirrel </br>";break;case "pig":
            a += "animal: pig </br>";break;case "deer":
            a += "animal: deer </br>";break;case "guinea pig":
            a += "animal: guinea pig </br>";break;case "monkey":
            a += "animal: monkey </br>";break;case "camel":
            a += "animal: camel </br>";break;case "goat":
            a += "animal: goat </br>";break;case "hamster":
            a += "animal: hamster </br>";break;case "alpaca":
            a += "animal: alpaca </br>";break;default:
            a += "animal: unknown<br/>";}if (b["feeding:fodder"]) switch (b["feeding:fodder"]) {case "hay":
            a += "feed with: hay</br>";break;case "grain":
            a += "feed with: grain</br>";break;case "corn":
            a += "feed with: corn</*br>";break;default:
            a += "feed with: unknown</br>";}"volcano" == b.natural && "active" == b.status && (a += "active volcano<br/>");"volcano" == b.natural && "dormant" == b.status && (a += "dormant volcano<br/>");"volcano" == b.natural && "extinct" == b.status && (a += "extinct volcano<br/>");"volcano" == b.natural && "stratovolcano" == b.type && (a += "type of volcanism:stratovolcano<br/>");"volcano" == b.natural && "shield" == b.type && (a += "type of volcanism:shield<br/>");"volcano" == b.natural && "scoria" == b.type && (a += "type of volcanism:scoria<br/>");return a;
},
    fnContentProtectedArea = exports.fnContentProtectedArea = function fnContentProtectedArea(b) {
    var a = "",
        c = "";"protected_area" == b.boundary && (b.protect_class && (c = b.protect_class), b.protect_id && (c = b.protect_id), "1" == c && (a = "description: Strict Nature Reserve, Wilderness Area<br/>"), "2" == c && (a = "description: National Park<br/>"), "3" == c && (a = "description: Natural Monument or Feature<br/>"), "4" == c && (a = "description: Habitat/Species Management Area<br/>"), "5" == c && (a = "description: Protected Landscape/ Seascape<br/>"), "6" == c && (a = "description: Protected area with sustainable use of natural resources<br/>"), "7" == c && (a = "description: nature-feature area<br/>"), "97" == c && (a = "description: protected by continental agreements<br/>"), "98" == c && (a = "description: protected by interstate- or international conventions<br/>"), "99" == c && (a = "other continental or international national protected areas <br/>"), "21" == c && (a = "description: Community life: religious, sacred areas, associative locations, recreation<br/>"), "22" == c && (a = "description: Cultural assets (cultural assets and - efforts, districts historical heritage, monument conservation)<br/>"), "23" == c && (a = "description: Protection in favor of economics<br/>"), "24" == c && (a = "description: Political protection<br/>"), "25" == c && (a = "description: Military areas (military refuges, test area)<br/>"), "26" == c && (a = "description: Historic: for colonial-stuff and protectorates.<br/>"), "29" == c && (a = "description: other social protected areas<br/>"), "11" == c && (a = "description: soil: crop yield, erosion protection, ...<br/>"), "12" == c && (a = "description: water: water protection area, fresh water, drinking water, springs, ...<br/>"), "13" == c && (a = 'description: climate and -air: gasper supply/cold air, ...for emission-, immission control in OSM existent, see "Low Emission Zone" (LEZ)<br/>'), "14" == c && (a = "description: species: no fishing, protected for fishery, protected for hunting, plants, ...<br/>"), "15" == c && (a = "description: location condition: floodwater retention area, protection forest, grazing land, ...<br/>"), "16" == c && (a = 'description: longtime hazard area: contamination, earth-moving area, "problem sites" ...<br/>'), "19" == c && (a = "description: other national resources protected areas<br/>"));return a;
},
    fnContentLanduse = exports.fnContentLanduse = function fnContentLanduse(b) {
    var a = "";"quarry" == b.landuse && b.resource && (a += "Resource: " + b.resource + "<br/>");"open_stable" == b["animal_keeping:type"] && (a += "open stable<br/>");"field_shelter" == b["animal_keeping:type"] && (a += "field shelter<br/>");"paddock" == b["animal_keeping:type"] && (a += "paddock<br/>");b.animal_keeping && (a += "animals: horses<br/>");return a;
},
    fnMessstation = exports.fnMessstation = function fnMessstation(b) {
    var a = "";"yes" == b["monitoring:water_level"] && (a += "water level<br/>");"yes" == b["monitoring:seismic_activity"] && (a += "seismic activity<br/>");"yes" == b["monitoring:tide_gauge"] && (a += "tide gauge<br/>");"yes" == b["monitoring:weather"] && (a += "weather<br/>");"yes" == b["monitoring:air_quality"] && (a += "air quality<br/>");return a;
},
    fnContentRoute = exports.fnContentRoute = function fnContentRoute(b) {
    var a = "";b.route && ("yes" == b.roundtrip && (a += "roundtrip<br/>"), b.length && (a += "length: " + b.length + "<br/>"), b.distance && (a += "distance: " + b.distance + "<br/>"), b.symbol && (a += "symbol: " + b.symbol + "<br/>"));return a;
},
    fnContentPetrol = exports.fnContentPetrol = function fnContentPetrol(b) {
    var a = "";"fuel" == b.amenity && ("yes" == b["fuel:biodiesel"] && (a += "biodiesel<br/>"), "yes" == b["fuel:e85"] && (a += "e85<br/>"), "yes" == b["fuel:e10"] && (a += "e10<br/>"), "yes" == b["fuel:lpg"] && (a += "lpg<br/>"), "yes" == b["fuel:cng"] && (a += "cng<br/>"), "diesel" == b.fuel && (a += "diesel<br/>"), "lpg" == b.fuel && (a += "lpg<br/>"), "yes" == b["fuel:octane_95"] && (a += "octane 95<br/>"), "yes" == b["fuel:octane_98"] && (a += "octane 98<br/>"), "yes" == b["fuel:octane_100"] && (a += "octane 100<br/>"), "yes" == b["fuel:octane_102"] && (a += "octane 102<br/>"), "yes" == b["fuel:diesel"] && (a += "diesel<br/>"), "yes" == b["fuel:electricity"] && (a += "charging station / loading station<br/>"));return a;
},
    fnContentHistoric = exports.fnContentHistoric = function fnContentHistoric(b) {
    var a = "";if ("archaeological_site" == b.historic && b.site_type) switch (b.site_type) {case "megalith":
            a += "megalith<br/>";break;case "bigstone":
            a += "bigstone<br/>";break;case "tumulus":
            a += "tumulus<br/>";break;case "fortification":
            a += "fortification<br/>";break;default:
            a += "unknown<br/>";}return a;
},
    fnContentBarriers = exports.fnContentBarriers = function fnContentBarriers(b, a) {
    var c = "";if ("wall" == b.barrier || "bollard" == b.barrier) b.material && (c += "material: " + translate(b.material) + "<br/>");return c;
},
    fnContentTourism = exports.fnContentTourism = function fnContentTourism(b) {
    var a = "";if ("camp_site" == b.tourism) {
        "yes" == b.dog && (a += "dogs allowed<br/>");"no" == b.dog && (a += "dogs forbidden<br/>");b.stars && (a += b.stars + "stars<br/>");b.caravans && (a += "caravan sites<br/>");if ("yes" == b.openfire || "yes" == b.fireplace) a += "Thers is an openfire. <br/>";"yes" == b.washing_machine && (a += "washing machine<br/>");"yes" == b.dryer && (a += "dryer<br/>");"yes" == b.group_only && (a += "use for groups only<br/>");"reception" == b.camp_site && (a += "reception available<br/>");
    }"information" == b.tourism && "map" == b.information && ("topo" == b.map_type && (a += "topo</br>"), "street" == b.map_type && (a += "street</br>"), "scheme" == b.map_type && (a += "scheme</br>"), "toposcope" == b.map_type && (a += "toposcope</br>"));"information" == b.tourism && "map" == b.information && ("site" == b.map_size && (a += "map of site</br>"), "city" == b.map_size && (a += "city map</br>"), "region" == b.map_size && (a += "map of region</br>"));"geology" == b.board_type && (a += "geologic information<br/>");"history" == b.board_type && (a += "historic information<br/>");"nature" == b.board_type && (a += "information about nature<br/>");"notice" == b.board_type && (a += "general information<br/>");"plants" == b.board_type && (a += "information about plants<br/>");
    "wildlife" == b.board_type && (a += "information about wildlife<br/>");return a;
},
    fnContentAmenity = exports.fnContentAmenity = function fnContentAmenity(b) {
    var a = "";"boat_sharing" == b.amenity && (a += b.boattype + "<br/>");"embassy" == b.amenity && (a += b.country + "<br/>");if (b.vending) switch (b.vending) {case "admission_tickets":
            a += "tickets<br/>";break;case "animal_feed":
            a += "animal feed<br/>";break;case "books":
            a += "books<br/>";break;case "candles":
            a += "candles<br/>";break;case "cigarettes":
            a += "cigarettes<br/>";break;case "condoms":
            a += "condoms<br/>";break;case "drinks":
            a += "drinks<br/>";break;case "first_aid":
            a += "first aid articles<br/>";break;case "fishing_tackle":
            a += "fishing tackle<br/>";break;case "flowers":
            a += "flowers<br/>";break;case "ice_cream":
            a += "ice cream<br/>";break;case "laundry_detergent":
            a += "laundry detergent<br/>";break;case "newspapers":
            a += "newspapers<br/>";break;case "SIM_cards":
            a += "sIM-cards<br/>";break;case "sweets":
            a += "sweets<br/>";break;case "parcel_pickup":
            a += "parcel pickup<br/>";break;case "ice_cubes":
            a += "ice cubes<br/>";break;case "public_transport_tickets":
            a += "public transport tickets<br/>";break;case "parking_ticket":
            a += "parking tickets<br/>";break;case "sex_toys":
            a += "sex toys<br/>";break;case "stamps":
            a += "stamps<br/>";break;case "toll":
            a += "toll<br/>";break;case "umbrellas":
            a += "umbrellas<br/>";break;default:
            a += "content unknown<br/>";}"post_box" == b.amenity && (b.collection_times && (a += "collection times: " + b.collection_times + "<br/>"), "yes" == b.drive_through && (a += "accessible by car. <br/>"));return a;
},
    fnContentStorage = exports.fnContentStorage = function fnContentStorage(b) {
    var a = "";if ("storage_tank" == b.man_made) {
        if (b.content) {
            var c = b.content;switch (c) {case "fuel":
                    c = "fuel";break;case "oil":
                    c = "oil";break;case "gas":
                    c = "gas";break;case "slurry":
                    c = "slurry";break;case "cement":
                    c = "cement";break;case "water":
                    c = "water";break;case "manure":
                    c = "manure";break;case "silage":
                    c = "silage";}a += "content: " + c + "<br/>";
        }if (b.contents) {
            c = b.contents;switch (c) {case "fuel":
                    c = "fuel";break;case "oil":
                    c = "oil";break;case "gas":
                    c = "gas";break;case "slurry":
                    c = "slurry";break;case "cement":
                    c = "cement";break;case "water":
                    c = "water";
                    break;case "manure":
                    c = "manure";break;case "silage":
                    c = "silage";}a += "content: " + c + "<br/>";
        }
    }b.storage && ("gas" == b.storage && (a += "content: gas<br/>"), "oil" == b.storage && (a += "content: oil<br/>"));return a;
},
    fnContentInformationCity = exports.fnContentInformationCity = function fnContentInformationCity(b) {
    var a = "";b["name:de"] && (a += "german name: " + b["name:de"] + "<br/>");if (1E4 <= b.population) if (b.population = "" + b.population, 3 < b.population.length) {
        var c = b.population.length % 3,
            d = 0 < c ? b.population.substring(0, c) : "";for (var i = 0; i < Math.floor(b.population.length / 3); i++) {
            d = 0 == c && 0 == i ? d + b.population.substring(c + 3 * i, c + 3 * i + 3) : d + ("." + b.population.substring(c + 3 * i, c + 3 * i + 3));
        }a += "population: " + d + "<br/>";
    } else a += "population " + b.population + "<br/>";1E4 >= b.population && (a += "population: " + b.population + "<br/>");return a;
},
    fnContentEmergency = exports.fnContentEmergency = function fnContentEmergency(b) {
    var a = "";b.lifeboat && ("inshore" == b.lifeboat ? a += "application: inshore<br/>" : "offshore" == b.lifeboat && (a += "application: offshore<br/>"));b["lifeboat:class"] && (a += "type of boat: " + b["lifeboat:class"] + "<br/>");if (b["siren:type"]) {
        var c = b["siren:type"];
        switch (c) {case "mechanical":
                c = "mechanical";break;case "electronic":
                c = "electronic";break;case "pneumatic":
                c = "pneumatic";break;case "electromechanic":
                c = "electromechanic";}a += "Typ: " + c + "<br/>";
    }if (b["siren:purpose"]) {
        c = b["siren:purpose"];switch (c) {case "air_raid":
                c = "air raid";break;case "tornado":
                c = "tornado";break;case "storm":
                c = "storm";break;case "civil_defense":
                c = "civil defence";break;case "fire":
                c = "fire";}a += "use: " + c + "<br/>";
    }b["siren:model"] && (a += "model: " + b["siren:model"] + "<br/>");b["siren:range"] && (a += "range of siren: " + b["siren:range"] + "<br/>");return a;
},
    fnContentCuisine = exports.fnContentCuisine = function fnContentCuisine(b) {
    var a = "";if (b.cuisine) {
        var c = "",
            a = ("supermarket" == b.shop || "convenience" == b.shop || "deli" == b.shop || "organic" == b.shop) && "restaurant" != b.amenity ? a + "specialties: " : a + "cuisine: ";"arabic" == b.cuisine && (c += "arabic<br/>");"italian" == b.cuisine && (c += " italian<br/>");"international" == b.cuisine && (c += " international<br/>");"regional" == b.cuisine && (c += " regional<br/>");"chinese" == b.cuisine && (c += " chinese<br/>");"greek" == b.cuisine && (c += " greek<br/>");"african" == b.cuisine && (c += " african<br/>");"german" == b.cuisine && (c += " german<br/>");"mexican" == b.cuisine && (c += " mexican<br/>");"french" == b.cuisine && (c += " french<br/>");"indian" == b.cuisine && (c += " indian<br/>");"iranian" == b.cuisine && (c += " iranian<br/>");"lebanese" == b.cuisine && (c += " lebanese<br/>");"thai" == b.cuisine && (c += " thai<br/>");"balkan" == b.cuisine && (c += " balkan<br/>");"turkish" == b.cuisine && (c += " turkish<br/>");"bavarian" == b.cuisine && (c += " bavarian<br/>");"czech" == b.cuisine && (c += " czech<br/>");"portuguese" == b.cuisine && (c += " portuguese<br/>");"spanish" == b.cuisine && (c += " spanish<br/>");"japanese" == b.cuisine && (c += " japanese<br/>");"fish" == b.cuisine && (c += " fish<br/>");"brazilian" == b.cuisine && (c += " brazilian<br/>");"asian" == b.cuisine && (c += " asian<br/>");"mediterranean" == b.cuisine && (c += "mediterranean<br/>");"seafood" == b.cuisine && (c += " seafood<br/>");"ice_cream" == b.cuisine && (c += " ice cream<br/>");"burger" == b.cuisine && (c += " burger<br/>");"frozen_yogurt" == b.cuisine && (c += " frozen yogurt<br/>");
        "" == c && (c = b.cuisine + "<br/>");a += c;
    }return a;
},
    fnContentShipping = exports.fnContentShipping = function fnContentShipping(b) {
    var a = "";b.harbour = "yes";"yes" == b["access:tide"] && (a += "Access restricted by tide</br>");"yes" == b["access:swell"] && (a += "access restricted by swell</br>");"yes" == b["access:ice"] && (a += "access restricted by ice</br>");b.vhf_channel && (a += "UKW-Channel: " + b.vhf_channel + "</br>");b.mmsi && (a += "MMSI-Number: " + b.mmsi + "</br>");b["harbour:information"] && (a += "information :" + b["harbour:information"] + "</br>");"yes" == b.motorboat && (a += "motorboat allowed</br>");
    "no" == b.motorboat && (a += "motorboat prohibited </br>");b.CEMT && (a += "CEMT: " + b.CEMT + "</br>");"yes" == b.intermittent && (a += "river intermittent dried out</br>");"yes" == b.tidal && (a += "tidal influence the flow</br>");b.draft && (a += " driving depth of water: " + b.draft + " m</br>");if ("slipway" == b.leisure || "slipway" == b.harbour) "hand" == b.operating && (a += "operating: by hand<br/>"), "car" == b.operating && (a += "operating: by car, boat trailer<br/>"), "cable_winch" == b.operating && (a += "operating: with cable winch<br/>"), "travellift" == b.operating && (a += "operating: by travellift<br/>"), "crane" == b.man_made && (a += "by crane<br/>", b["crane:maxload"] && (a += "maxload: " + b["crane:maxload"] + "<br/>"), b["ship:maxdraft"] && (a += "maximum permissible draught: " + b["ship:maxdraft"] + "<br/>"), b["ship:maxlength"] && (a += "maximum permissible length of a ship: " + b["ship:maxlength"] + "<br/>")), "yes" == b.vehicle && (a += "accessible by vehicle<br/>");a += fnWreckInfo(b);if ("ferry" == b.route || "ferry_terminal" == b.amenity || "yes" == b.ferry) fahrzeit = b.duration, "" != fahrzeit && "undefined" != fahrzeit && null != fahrzeit && (a += "duration in hours : " + fahrzeit + "<br/>"), "yes" == b.motorcar && (a += "motorcars allowed<br/>"), "no" == b.motorcar && (a += "motorcars prohibited<br/>"), "no" == b.motor_vehicle && (a += "motor vehicles prohibited<br/>"), "yes" == b.motor_vehicle && (a += "motor vehicles allowed<br/>"), "yes" == b.vehicle && (a += "vehicles allowed<br/>"), "no" == b.vehicle && (a += "no vehicles<br/>"), "no" == b.bicycle && (a += "no bicycles<br/>"), "no" == b.bicycle && (a += "bicycles allowed<br/>"), "yes" == b.hgv && (a += "hgv allowed<br/>"), "no" == b.hgv && (a += "hgv prohibited<br/>"), "yes" == b.foot && (a += "pedestrian allowed<br/>"), "no" == b.foot && (a += "pedestrian prohibited <br/>"), "yes" == b.bicycle && (a += "cyclist allowed <br/>"), "no" == b.bicycle && (a += "cyclist prohibited <br/>"), "yes" == b["ferry:cable"] && (a += "cable ferry<br/>");if (b["seamark:light:1:colour"]) {
        var c = b["seamark:light:1:colour"];switch (c) {case "white":
                c = "white";break;case "red":
                c = "red";break;case "green":
                c = "green";break;case "blue":
                c = "blue";break;case "yellow":
                c = "yellow";break;case "amber":
                c = "amber";}a += "colour of light: " + c + "<br/>";
    }"lighthouse" == b.man_made && (b["seamark:light:1:character"] && (a += "light character: " + b["seamark:light:1:character"] + "<br/>"), b["seamark:light:1:period"] && (a += "period: " + b["seamark:light:1:period"] + "<br/>"), b["seamark:light:1:height"] && (a += "height: " + b["seamark:light:1:height"] + " m<br/>"), b["seamark:light:1:range"] && (a += "range: " + b["seamark:light:1:range"] + " sm<br/>"));if (b["seamark:light:colour"]) {
        c = b["seamark:light:colour"];switch (c) {case "white":
                c = "white";
                break;case "red":
                c = "red";break;case "green":
                c = "green";break;case "blue":
                c = "blue";break;case "yellow":
                c = "yellow";break;case "amber":
                c = "amber";}a += "colour of light: " + c + "<br/>";
    }"lighthouse" == b.man_made && (b["seamark:light:character"] && (a += "light character: " + b["seamark:light:character"] + "<br/>"), b["seamark:light:height"] && (a += "height: " + b["seamark:light:height"] + " m<br/>"), b["seamark:light:range"] && (a += "range: " + b["seamark:light:range"] + " sm<br/>"), b["seamark:light:period"] && (a += "period: " + b["seamark:light:period"] + "<br/>"));return a;
},
    fnContentHydrants = exports.fnContentHydrants = function fnContentHydrants(b) {
    var a = "";if ("fire_hydrant" == b.emergency) {
        var c = b["fire_hydrant:count"];"undefined" != c && null != c && "" != c && (a += "Number: " + c + "<br/>");c = b["fire_hydrant:diameter"];"undefined" != c && null != c && "" != c && (a += "Pipe diameter: " + c + " mm<br/>");c = b["fire_hydrant:pressure"];"undefined" != c && null != c && "" != c && (a = "suction" == c ? a + "Pressure in bar / Suction: Suction<br/>" : a + ("Pressure in bar / Suction: " + c + "<br/>"));c = b["fire_hydrant:position"];"undefined" != c && null != c && "" != c && ("lane" == c ? a += "Position: Lane<br/>" : "parking_lot" == c ? a += "Position: Parking Lot<br/>" : "sidewalk" == c ? a += "Position: Sidewalk<br/>" : "green" == c && (a += "Position: Green<br/>"));c = b.water_volume;"undefined" != c && null != c && "" != c && (a += "Volume: " + c + "<br/>");c = b["fire_hydrant:awwa_class"];"undefined" != c && null != c && "" != c ? a += "AWWA Class: " + c + "<br/>" : (c = b.flow_rate, "undefined" != c && null != c && "" != c && (a += "Flow rate: " + c + "<br/>"));c = b.water_source;"undefined" != c && null != c && "" != c && "main" != c && (a += "Water source: " + c + "<br/>");c = b["couplings:type"];"undefined" != c && null != c && "" != c && (a += "Couplings type: " + c + "<br/>");c = b["couplings:diameter"];"undefined" != c && null != c && "" != c && (a += "Couplings diameter: " + c + "<br/>");c = b["pillar:type"];"dry_barrel" === c && (a += "Pillar type: " + c + "<br/>");"fire_hydrant" === b["disused:emergency"] && (a += "Currently disused");"" == a && (a = "No details available.");
    }return a;
},
    fnContentStreetsTraffic = exports.fnContentStreetsTraffic = function fnContentStreetsTraffic(b) {
    var a = "";"yes" == b["red_turn:right"] && (a += "red turn: allowed to turn to the right<br/>");
    "no" == b["red_turn:right"] && (a += "red turn: prohibited to turn to the right<br/>");b.bridge && (b.height && (a += "height: " + b.height + " m<br/>"), b.length && (a += "length: " + b.length + " m<br/>"), b.bridge_ref && (a += "bridge ref: " + b.bridge_ref + "<br/>"), b.start_date && (a += "start date: " + b.start_date + "</br>;"), b.maxweight && (a += "maxweight: " + b.maxweight + " t</br>"));b.highway && "yes" == b.toll && (a += "toll highway<br/>");"yes" == b["toll:hgv"] && (a += "HGV toll<br/>");if (b.surface) {
        var c = b.surface,
            a = a + "surface: ";switch (c) {case "grass":
                a += "grass<br/>";break;case "paved":
                a += "paved<br/>";break;case "asphalt":
                a += "asphalt<br/>";break;case "cobblestone":
                a += "cobblestone<br/>";break;case "sett":
                a += "sett<br/>";break;case "concrete":
                a += "concrete<br/>";break;case "unpaved":
                a += "unpaved<br/>";break;case "paving_stones":
                a += "paving stones<br/>";break;case "compacted":
                a += "compacted<br/>";break;case "dirt":
                a += "dirt<br/>";break;case "fine_gravel":
                a += "fine gravel<br/>";break;case "grass_paver":
                a += "grass paver<br/>";break;case "gravel":
                a += "gravel<br/>";
                break;case "earth":
                a += "earth<br/>";break;case "ground":
                a += "ground<br/>";break;case "metal":
                a += "metal<br/>";break;case "mud":
                a += "mud<br/>";break;case "sand":
                a += "sand<br/>";break;case "wood":
                a += "wood<br/>";break;case "tartan":
                a += "tartan<br/>";break;case "artificial_turf":
                a += "artificial turf<br/>";break;case "clay":
                a += "clay<br/>";break;default:
                a += "unknown<br/>";}
    }"grade1" == b.tracktype && (a += "path surface: Solid. Usually a paved or heavily compacted hardcore surface.<br/>");"grade2" == b.tracktype && (a += "path surface: Mostly solid. Usually an unpaved track with surface of gravel mixed with a varying amount of sand, silt, and clay.<br/>");
    "grade3" == b.tracktype && (a += "path surface: Even mixture of hard and soft materials. Almost always an unpaved track.<br/>");"grade4" == b.tracktype && (a += "path surface: Mostly soft. Almost always an unpaved track prominently with soil/sand/grass, but with some hard materials, or compressed materials mixed in.<br/>");"grade5" == b.tracktype && (a += "path surface: Soft. Almost always an unpaved track lacking hard materials, uncompacted, with surface of soil/sand/grass.<br/>");"yes" == b.motorcycle && (a += "<br/>motorcyle allowed.<br/>");
    "no" == b.motorcycle && (a += "<br/>motorcycles prohibited.<br/>");"excellent" == b.trail_visibility && (a += "trail visibility: Unambiguous path or markers everywhere<br/>");"good" == b.trail_visibility && (a += "trail visibility: Next marker always visible, but sometimes has to be searched for.<br/>");"intermediate" == b.trail_visibility && (a += "trail visibility: Track mostly visible<br/>");"bad" == b.trail_visibility && (a += "trail visibility: Path sometimes invisible, route partly pathless<br/>");"horrible" == b.trail_visibility && (a += "trail visibility: Often pathless<br/>");"no" == b.trail_visibility && (a += "trail visibility: Mostly pathless<br/>");"hiking" == b.sac_scale && (a += "trail: Trail well cleared. (SAC Scale: T1 (yellow))</br>");"mountain_hiking" == b.sac_scale && (a += "trail: Trail with continuous line and balanced ascent (SAC Scale: T2 (red))</br>");"demanding_mountain_hiking" == b.sac_scale && (a += "trail: exposed sites may be secured with ropes or chains, possible need to use hands for balance (SAC Scale: T3 (red))</br>");"alphine_hiking" == b.sac_scale && (a += "trail: sometimes need for hand use to get ahead (SAC Scale: T4 (blue))</br>");"demanding_alphine_hiking" == b.sac_scale && (a += "trail: single plainly climbing up to second grade (SAC Scale: T5 (blue))</br>");"difficult_alpine_hiking" == b.sac_scale && (a += "trail: climbing up to second grade (SAC Scale: T6 (blue))</br>");b["mtb:name"] && (a += "cycleway :" + b["mtb:name"] + "</br>");"0" == b["mtb:scale"] && (a += "Mountainbikeroute: Very easy way - Gravel or packed earth. No particular difficulties. Mostly forest and meadow paths (highway=path). Sections with steps, rocks, or roots are not expected. Wide curves, easy to moderate slope. No special skills are needed to ride this. Easy to ride uphill.</br>Surface: solid and handy</br>Obstacles: no obstacles</br>Gradient: mild to moderate</br>Bends: wide</br>Driving skills: no special driving skills required</br>");
    "1" == b["mtb:scale"] && (a += "Mountainbikeroute: Smaller obstacles like roots and small stones. Erosion damage may increase difficulty. Soil may be loose in places. Tight turns, but no hairpin turns. Riding requires care and attention, but no special skill. Obstacles can be ridden over. Difficult to ride uphill.</br>Surface: loose surface possible, small roots and stones</br>Obstacles: small obstacles, water gutter, erosion damage</br>Gradient: < 40%</br>Bends: wide</br>Driving skills: basic driving skills required, obstacles can be passed over</br>");
    "2" == b["mtb:scale"] && (a += "Mountainbikeroute: Obstacles such as large rocks and stones. Soil is often loose.  Steps are expected. Wider hairpin turns, steepness of up to 70%. Requires some advanced riding skills. Only very skilled riders can go uphill on this.</br>Surface: surface usually not compacted, larger roots and stones.</br>Obstacles: plain steps and stairs</br>Gradient: < 70%</br>Bends: easy hairpins</br>Driving skills: advanced driving skills required</br>");"3" == b["mtb:scale"] && (a += "Mountainbikeroute: Many sections with large obstacles such as boulders and large roots. Many hairpin and off-balance turns. Slippery surface and talus sections may be found. The surface may be very slippery. Constant concentration and very good skills needed. Nearly impossible to ride uphill.</br>Surface: many large roots / rocks or slippery ground, loose scree</br>Obstacles: drags, hardly driveable steps</br>Gradient: >70%</br>Bends: bail like hairpins</br>Driving skills: perfect bike control with trial skills required, like moving the rear wheel only in hairpins</br>");
    "4" == b["mtb:scale"] && (a += "Mountainbikeroute: Very steep and difficult, with sections having large boulders and roots. Frequent loose debris. Very steep sections with very tight hairpin turns and high steps that will cause the chainring to hit the ground. Some trials techniques will be necessary. Nearly impossible to ride uphill.</br>Surface: many large roots / rocks or slippery ground, loose scree</br>Obstacles: drags, hardly driveable steps</br>Gradient: >70%</br>Bends: bail like hairpins</br>Driving skills: perfect bike control with trial skills required, like moving the rear wheel only in hairpins</br>");
    "5" == b["mtb:scale"] && (a += "Mountainbikeroute: Very steep and difficult with big boulder fields and debris, and landslides. Speed must be carried for counter-ascents. If at all only short passages are available for accelerating and braking. Fallen trees may make very steep passages even more difficult. Very few Mountainbikers can actually ride at this level. Most will have to push.</br>Surface: counter-ascents / rocks or slippery ground, loose scree / path is rather a Alpine hiking (>T4) path</br>Obstacles: drags, combinations of hardly driveable steps</br>Gradient: >70%</br>Bends: bail like hairpins with obstacles</br>Driving skills: excellent bike control with special trial skills required, moving the front and rear wheel is limited</br>");
    "6" == b["mtb:scale"] && (a += "Mountainbikeroute: Classify ways with 6 that are not rideable at all for a mtbiker. E.g. Chains or stemples (metal rungs) on a via ferrata or simply unsecured alpine pathes that are not even partly rideable for the very best mtbikers (using trial techniques). Steepness is often >45\xB0. If used for single points, then this highlights exceptionally difficult spots. Often spotting is impossible and falling may be lethal.</br>Surface: Path is rather a Alpine hiking (T5 or T6) path or bare rock without visible path.</br>Obstacles: Steps over 2m, rock faces,...</br>Gradient: >100%</br>Bends: no bends can be distinguished as such.</br>Driving skills: only the very best trial specialists or vertriders will try to ride these spots. Walking the place first to find a way to clear is needed.</br>");
    "10" == b.maxspeed && (a += 'traffic-calmed sector: maxspeed 10 Km/h and "right over left"</br>');"30" == b.maxspeed && (a += 'traffic-calmed sector: "right over left" and maxspeed 30 Km/h</br>');"50" == b.maxspeed && (a += "maxspeed 50 Km/h</br>");"70" == b.maxspeed && (a += "maxspeed 50 Km/h</br>");"80" == b.maxspeed && (a += "maxspeed 80 Km/h</br>");"100" == b.maxspeed && (a += "maxspeed  100 Km/h</br>");"no" == b.overtaking && (a += "No overtaking!</br>");"yes" == b.noexit && (a += "noexit</br>");"yes" == b.oneway && (a += "oneway</br>");"designated" == b.priority_road && (a += "priority road designated</br>");"end" == b.priority_road && (a += "priority road ends</br>");"emergency_bay" == b.highway && (a += "emergency bay</br>");"yes" == b.traffic_calming && (a += "traffic calming</br>");"bump" == b.traffic_calming && (a += "bump</br>");"chicane" == b.traffic_calming && (a += "chicane</br>");"choker" == b.traffic_calming && (a += "choker</br>");"cushion" == b.traffic_calming && (a += "cushion</br>");"hump" == b.traffic_calming && (a += "hump</br>");"island" == b.traffic_calming && (a += "island</br>");
    "rumble_strip" == b.traffic_calming && (a += "rumble strip</br>");"table" == b.traffic_calming && (a += "table</br>");if ("parking" == b.amenity && ("yes" == b.fee && (a += "fee required<br/>"), c = b["capacity:women"], "" != c && "no" != c && null != c)) {
        var d = "unkown";"yes" != c && (d = c);a += "ladies parking spaces (numbers: " + d + ") <br/>";
    }b.park_ride && ("bus" == b.park_ride && (a += "bus connection<br/>"), "tram" == b.park_ride && (a += "tram connection<br/>"), "unknown" == b.park_ride && (a += "park ride unkown<br/>"));b["railway:position"] && (a += "railway<br/>position: " + b["railway:position"] + "<br/>");b.uic_ref && (a += "UIC: " + b.uic_ref + "<br/>");return a;
},
    fnContentSports = exports.fnContentSports = function fnContentSports(b) {
    var a = "";"9pin" == b.sport && (a += "possible sport : 9pin<br/>");"10pin" == b.sport && (a += "possible sport : 10pin<br/>");"american_football" == b.sport && (a += "possible sport : american football<br/>");"aikido" == b.sport && (a += "possible sport : aikido<br/>");"archery" == b.sport && (a += "possible sport : archery<br/>");"athletics" == b.sport && (a += "possible sport : athletics<br/>");"australian_football" == b.sport && (a += "possible sport : australian football<br/>");"base" == b.sport && (a += "possible sport : base<br/>");"badminton" == b.sport && (a += "possible sport : badminton<br/>");"baseball" == b.sport && (a += "possible sport : baseball<br/>");"basketball" == b.sport && (a += "possible sport : basketball<br/>");"beachvolleyball" == b.sport && (a += "possible sport : beachvolleyball<br/>");"bmx" == b.sport && (a += "possible sport : bmx<br/>");"boules" == b.sport && (a += "possible sport : boules<br/>");"boule" == b.sport && (a += "possible sport : boule<br/>");
    "bowls" == b.sport && (a += "possible sport : bowls<br/>");"boxing" == b.sport && (a += "possible sport : boxing<br/>");"canadian_football" == b.sport && (a += "possible sport : canadian football<br/>");"canoe" == b.sport && (a += "possible sport : canoe<br/>");"chess" == b.sport && (a += "possible sport : chess<br/>");"cliff_diving" == b.sport && (a += "possible sport : cliff diving<br/>");"climbing" == b.sport && (a += "possible sport : climbing<br/>");"climbing_adventure" == b.sport && (a += "possible sport : adventure climbing<br/>");"cricket" == b.sport && (a += "possible sport : cricket<br/>");"cricket_nets" == b.sport && (a += "possible sport : cricket nets<br/>");"croquet" == b.sport && (a += "possible sport : croquet<br/>");"curling" == b.sport && (a += "possible sport : curling<br/>");"cycling" == b.sport && (a += "possible sport : cycling<br/>");if ("darts" == b.sport || "dart" == b.sport) a += "Darts<br/>";"dog_racing" == b.sport && (a += "possible sport : dog racing<br/>");"fencing" == b.sport && (a += "possible sport : fencing<br/>");"equestrian" == b.sport && (a += "possible sport : equestrian<br/>");
    "football" == b.sport && (a += "possible sport: american football<br/>");"free_flying" == b.sport && (a += "possible sport: free flying<br/>");"gaelic_games" == b.sport && (a += "possible sport: gaelic games<br/>");"golf" == b.sport && (a += "possible sport: golf<br/>");"gymnastics" == b.sport && (a += "possible sport: gymnastik<br/>");"hockey" == b.sport && (a += "possible sport: hockey<br/>");"horseshoes" == b.sport && (a += "possible sport: horseshoes<br/>");"horse_racing" == b.sport && (a += "possible sport: horse racing<br/>");"ice_stock" == b.sport && (a += "possible sport: ice stock<br/>");"judo" == b.sport && (a += "possible sport: judo<br/>");"karting" == b.sport && (a += "possible sport: karting<br/>");"kitesurfing" == b.sport && (a += "possible sport: kitesurfing<br/>");"korfball" == b.sport && (a += "possible sport: korfball<br/>");"motor" == b.sport && (a += "possible sport: motor<br/>");"multi" == b.sport && (a += "possible sport: multi<br/>");"obstacle_course" == b.sport && (a += "possible sport: obstacle course<br/>");"orienteering" == b.sport && (a += "possible sport: orienteering<br/>");
    "paddle_tennis" == b.sport && (a += "possible sport: paddle-tennis<br/>");"paragliding" == b.sport && (a += "possible sport: paragliding<br/>");"Pelota" == b.sport && (a += "possible sport: Pelota<br/>");"rasquet" == b.sport && (a += "possible sport: racquet<br/>");"rowing" == b.sport && (a += "possible sport: rowing<br/>");"rugby_league" == b.sport && (a += "possible sport: rugby league<br/>");"rugby_union" == b.sport && (a += "possible sport: rugby union<br/>");"running" == b.sport && (a += "possible sport: running<br/>");"scuba_diving" == b.sport && (a += "possible sport: scuba diving<br/>");"shooting" == b.sport && (a += "possible sport: shooting<br/>");"skating" == b.sport && (a += "possible sport: skating<br/>");"skateboard" == b.sport && (a += "possible sport: skateboard<br/>");"skiing" == b.sport && (a += "possible sport: skiing<br/>");"soccer" == b.sport && (a += "possible sport: soccer<br/>");"surfing" == b.sport && (a += "possible sport: surfing<br/>");"swimming" == b.sport && (a += "possible sport: swimming<br/>");"table_tennis" == b.sport && (a += "possible sport: table tennis<br/>");
    "taekwondo" == b.sport && (a += "possible sport: taekwondo<br/>");"team_handball" == b.sport && (a += "possible sport: team handball<br/>");"tennis" == b.sport && (a += "possible sport: tennis<br/>");"toboggan" == b.sport && (a += "possible sport: toboggan<br/>");"volleyball" == b.sport && (a += "possible sport: volleyball<br/>");"water_ski" == b.sport && (a += "possible sport: water ski<br/>");"weightlifting" == b.sport && (a += "possible sport: weightlifting<br/>");"wrestling" == b.sport && (a += "possible sport: wrestling<br/>");return a;
};
function fnArztInfo(b) {
    var a = "",
        c = "",
        d = b["healthcare:speciality"];"" != d && ("general" == d && (c += "general<br/>"), "allergology" == d && (c += "allergology<br/>"), "anaesthetics" == d && (c += "anaesthetics<br/>"), "biochemistry" == d && (c += "biochemistry<br/>"), "biological_haematology" == d && (c += "biological haematology<br/>"), "biology" == d && (c += "biology<br/>"), "cardiology" == d && (c += "cardiology<br/>"), "cardiac_surgery" == d && (c += "cardiac surgery<br/>"), "child_psychiatry" == d && (c += "child psychiatry<br/>"), "dental_oral_maxillo_facial_surgery" == d && (c += "dental-, oral-, maxillo- and facial-surgery<br/>"), "dermatology" == d && (c += "dermatology<br/>"), "dermatovenereology" == d && (c += "dermatovenereology<br/>"), "diagnostic_radiology" == d && (c += "diagnostic radiology<br/>"), "emergency" == d && (c += "emergency<br/>"), "endocrinology" == d && (c += "endocrinology<br/>"), "gastroenterological_surgery" == d && (c += "gastroenterological surgery<br/>"), "gastroenterology" == d && (c += "gastroenterology<br/>"), "geriatrics" == d && (c += "geriatrics<br/>"), "gynaecology" == d && (c += "gynaecology<br/>"), "haematology" == d && (c += "haematology<br/>"), "hepatology" == d && (c += "hepatology<br/>"), "immunology" == d && (c += "immunology<br/>"), "infectious_diseases" == d && (c += "infectious diseases<br/>"), "intensive" == d && (c += "intensive<br/>"), "internal" == d && (c += "internal<br/>"), "maxillofacial_surgery" == d && (c += "maxillofacial surgery<br/>"), "nephrology" == d && (c += "nephrology<br/>"), "neurology" == d && (c += "neurology<br/>"), "neurophysiology" == d && (c += "neurophysiology<br/>"), "neuropsychiatry" == d && (c += "neuropsychiatry<br/>"), "neurosurgery" == d && (c += "neurosurgery<br/>"), "nuclear" == d && (c += "nuclear<br/>"), "occupational" == d && (c += "occupational <br/>"), "oncology" == d && (c += "oncology<br/>"), "ophthalmology" == d && (c += "ophthalmology<br/>"), "orthopaedics" == d && (c += "orthopaedics<br/>"), "otolaryngology" == d && (c += "otolaryngology<br/>"), "paediatric_surgery" == d && (c += "paediatric surgery<br/>"), "paediatrics" == d && (c += "paediatrics<br/>"), "palliative" == d && (c += "palliative<br/>"), "physiatry" == d && (c += "physiatry<br/>"), "plastic_surgery" == d && (c += "plastic surgery<br/>"), "proctology" == d && (c += "proctology<br/>"), "psychiatry" == d && (c += "psychiatry<br/>"), "pulmonology" == d && (c += "pulmonology<br/>"), "radiology" == d && (c += "radiology<br/>"), "radiotherapy" == d && (c += "radiotherapy<br/>"), "rheumatology" == d && (c += "rheumatology<br/>"), "stomatology" == d && (c += "stomatology<br/>"), "surgery" == d && (c += "surgery<br/>"), "surgical_oncology" == d && (c += "surgical oncology<br/>"), "thoracic_surgery" == d && (c += "thoracic surgery<br/>"), "transplant" == d && (c += "transplant<br/>"), "trauma" == d && (c += "trauma<br/>"), "tropical" == d && (c += "tropical<br/>"), "urology" == d && (c += "urology<br/>"), "vascular_surgery" == d && (c += "vascular surgery<br/>"), "venereology" == d && (c += "venereology<br/>"), "acupuncture" == d && (c += "acupuncture<br/>"), "naturopathy" == d && (c += "naturopathy<br/>"), "chiropractic" == d && (c += "chiropractic <br/>"), "homeopathy" == d && (c += "homeopathy<br/>"), "osteopathy" == d && (c += "osteopathy<br/>"));"" != b.health_specialty && ("yes" == b["health_specialty:family_medicine"] && (c += "family medicine<br/>"), "yes" == b["health_specialty:emergency_medicine"] && (c += "emergency medicine<br/>"), "yes" == b["health_specialty:anaesthesiology"] && (c += "anaesthesiology<br/>"), "yes" == b["health_specialty:dermatology"] && (c += "dermatology<br/>"), "yes" == b["health_specialty:ear_nose_throat"] && (c += "ear, nose, throat (ENT specialist)<br/>"), "yes" == b["health_specialty:occupational_medicine"] && (c += "occupational medicine<br/>"), "yes" == b["health_specialty:internal_medicine"] && (c += "internal medicine<br/>"), "yes" == b["health_specialty:neurology"] && (c += "neurology<br/>"), "yes" == b["health_specialty:ophthalmology"] && (c += "ophthalmology<br/>"), "yes" == b["health_specialty:palliative_medicine"] && (c += "palliative medicine<br/>"), "yes" == b["health_specialty:psychiatry"] && (c += "psychiatry<br/>"), "yes" == b["health_specialty:gynaecology"] && (c += "gynaecology<br/>"), "yes" == b["health_specialty:urology"] && (c += "urology<br/>"), "yes" == b["health_specialty:pain_medicine"] && (c += "pain medicine<br/>"), "yes" == b["health_specialty:environmental_medicine"] && (c += "environmental medicine<br/>"), "yes" == b["health_specialty:intensive_care_medicin"] && (c += "intensive care medicin<br/>"), "yes" == b["health_specialty:paediatrics"] && (c += "paediatrics<br/>"), "yes" == b["health_specialty:physiatry"] && (c += "physiatry<br/>"), "yes" == b["health_specialty:radiology"] && (c += "radiology<br/>"), "yes" == b["health_specialty:general"] && (c += "general<br/>"), "yes" == b["health_specialty:occupational_therapy"] && (c += "occupational therapy<br/>"), "yes" == b["health_specialty:pulmonology"] && (c += "pulmonology<br/>"), "yes" == b["health_specialty:acupuncture"] && (c += "acupuncture<br/>"), "yes" == b["health_specialty:orthopaedics"] && (c += "orthopaedics<br/>"), "yes" == b["health_specialty:chiropractic"] && (c += "chiropractic<br/>"), "yes" == b["health_specialty:sports_medicine"] && (c += "sports medicine<br/>"));"" != c && (a = a + "subjects: " + ('<div class="c4g_open_text">' + c + "</div>"));return a;
}
function fnKraftwerkInfo(b) {
    var a = "";if (b["generator:method"]) {
        a += "method of generation: ";switch (b["generator:method"]) {case "combustion":
                a += "combustion";break;case "thermal":
                a += "thermal";break;case "pumping":
                a += "pumping";break;case "photovoltaic":
                a += "photovoltaic";break;case "gasification":
                a += "gasification";break;case "anaerobic_digestion":
                a += "anaerobic digestion";break;case "pyrolysis":
                a += "pyrolysis";break;case "fission":
                a += "fission";break;case "fusion":
                a += "fusion";break;default:
                a += "unknown<br/>";}a += "<br/>";
    }if (b.power_source) {
        a += "power source: ";switch (b.power_source) {case "photovoltaic":
                a += "photovoltaic";break;default:
                a += "unknown<br/>";}a += "<br/>";
    }b["generator:output:electricity"] && (a += "electricity generation: " + b["generator:output:electricity"] + "<br/>");b["generator:output:heat"] && (a += "heat generation: " + b["generator:output:heat"] + "<br/>");b["generator:output:cold"] && (a += "cold generation: " + b["generator:output:cold"] + "<br/>");b["generator:output"] && (a += "output: " + b["generator:output"] + "<br/>");
    b["generator:output:hot_air"] && (a += "hot-air generation: " + b["generator:output:hot_air"] + "<br/>");b["generator:output:cold_water"] && (a += "cold water generation: " + b["generator:output:cold_water"] + "<br/>");b["generator:output:cold_air"] && (a += "cold air generation: " + b["generator:output:cold_air"] + "<br/>");b["generator:output:compressed_air"] && (a += "compressed air generation: " + b["generator:output:compressed_air"] + "<br/>");b["generator:output:steam"] && (a += "steam generation: " + b["generator:output:steam"] + "<br/>");b["generator:output:vacuum"] && (a += "vacuum generation: " + b["generator:output:vacuum"] + "<br/>");b["generator:output:battery_charging"] && (a += "battery charging: " + b["generator:output:battery_charging"] + "<br/>");"PWR" == b["generator:type"] && (a += "generator type: " + b["generator:type"] + "<br/>");"BWR-1" == b["generator:type"] && (a += "generator type: " + b["generator:type"] + "<br/>");"BWR-2" == b["generator:type"] && (a += "generator type: " + b["generator:type"] + "<br/>");"BWR-3" == b["generator:type"] && (a += "generator type: " + b["generator:type"] + "<br/>");"BWR-4" == b["generator:type"] && (a += "generator type: " + b["generator:type"] + "<br/>");"BWR-5" == b["generator:type"] && (a += "generator type: " + b["generator:type"] + "<br/>");"BWR-6" == b["generator:type"] && (a += "generator type: " + b["generator:type"] + "<br/>");"PHWR" == b["generator:type"] && (a += "generator type: " + b["generator:type"] + "<br/>");"GCR" == b["generator:type"] && (a += "generator type: " + b["generator:type"] + "<br/>");"FBR" == b["generator:type"] && (a += "generator type: " + b["generator:type"] + "<br/>");"RBMK-1000" == b["generator:type"] && (a += "generator type: " + b["generator:type"] + "<br/>");"RBMK-1500" == b["generator:type"] && (a += "generator type: " + b["generator:type"] + "<br/>");"VVER" == b["generator:type"] && (a += "generator type: " + b["generator:type"] + "<br/>");"CANDU" == b["generator:type"] && (a += "generator type: " + b["generator:type"] + "<br/>");"CPR-1000" == b["generator:type"] && (a += "generator type: " + b["generator:type"] + "<br/>");"EPR" == b["generator:type"] && (a += "generator type: " + b["generator:type"] + "<br/>");
    "tokamak" == b["generator:type"] && (a += "generator type: " + b["generator:type"] + "<br/>");"stellarator" == b["generator:type"] && (a += "generator type: " + b["generator:type"] + "<br/>");"ICF" == b["generator:type"] && (a += "generator type: " + b["generator:type"] + "<br/>");"cold-fusion" == b["generator:type"] && (a += "generator type: " + b["generator:type"] + "<br/>");"wind_turbine" == b["generator:method"] && "horizontal_axis" == b["generator:type"] && (a += "generator method: horizontal axis wind turbine<br/>");"wind_turbine" == b["generator:method"] && "vertical_axis" == b["generator:type"] && (a += "generator method: vertical axis wind turbine<br/>");"francis_turbine" == b["generator:type"] && (a += "generator type: francis-turbine<br/>");"kaplan_turbine" == b["generator:type"] && (a += "generator type: kaplan-turbine<br/>");"pelton_turbine" == b["generator:type"] && (a += "generator type: pelton-turbine<br/>");"stream" == b["generator:method"] && "horizontal_axis" == b["generator:type"] && (a += "generator method: horizontal axis sea current power station<br/>");"stream" == b["generator:method"] && "vertical_axis" == b["generator:type"] && (a += "generator type: vertical axis sea current power station<br/>");"steam_turbine" == b["generator:type"] && (a += "generator type: steam turbine<br/>");"heat_pump" == b["generator:type"] && (a += "generator type: heat pump<br/>");"solar_thermal_collector" == b["generator:type"] && (a += "generator type: solar thermal collector<br/>");"solar_photovoltaic_panel" == b["generator:type"] && (a += "generator type: solar photovoltaic panel<br/>");"steam_generator" == b["generator:type"] && (a += "generator type: steam generator<br/>");"gas_turbine" == b["generator:type"] && (a += "generator type: gas turbine<br/>");"combined_cycle" == b["generator:type"] && (a += "generator type: combined cycle<br/>");"reciprocating_engine" == b["generator:type"] && (a += "generator type: reciprocating engine<br/>");return a;
}
function fnWertstoffinfo(b) {
    var a = "";if ("container" == b.recycling_type || "centre" == b.recycling_type || "recycling" == b.amenity) "yes" == b["recycling:glass"] && (a += "glass container</br>"), "yes" == b["recycling:shoes"] && (a += "shoe container</br>"), "yes" == b["recycling:cooking_oil"] && (a += "recycling of cooking oil</br>"), "yes" == b["recycling:paper"] && (a += "recycling of paper</br>"), "yes" == b["recycling:engine_oil"] && (a += "recycling of engine oil</br>"), "yes" == b["recycling:clothes"] && (a += "recycling of clothes</br>"), "yes" == b["recycling:car_batteries"] && (a += "recycling of car batteries</br>"), "yes" == b["recycling:cans"] && (a += "recycling of cans</br>"), "yes" == b["recycling:scrap_metal"] && (a += "recycling of scrap metal</br>"), "yes" == b["recycling:plastic"] && (a += "recycling of plastic</br>"), "yes" == b["recycling:batterries"] && (a += "recycling of batterries</br>"), "yes" == b["recycling:plastic_bottles"] && (a += "recycling of plastic bottles</br>"), "yes" == b["recycling:green_waste"] && (a += "recycling of green waste</br>"), "yes" == b["recycling:hardcore"] && (a += "recycling of hardcore</br>");return a;
}
var fnContentGeneralInformations = function fnContentGeneralInformations(b) {
    var a = "";b.width && (a += "width: " + b.width + " m<br/>");b.height && (a += "height: " + b.height + " m<br/>");b.maxwidth && (a += "maxwidth: " + b.maxwidth + " m<br/>");b.maxheight && (a += "maxheight: " + b.maxheight + " m<br/>");b.maxweight && (a += "maxweight: " + b.maxweight + " t<br/>");b.maxspeed && (a += "maxspeed: " + b.maxspeed + " km/h<br/>");b.min_age && (a += "minimum age: " + b.min_age + "<br/>");b.max_age && (a += "maximum age: " + b.max_age + "<br/>");"yes" == b.nudism && (a += "nudism<br/>");"yes" == b.ruins && (a += "ruins<br/>");b.ele && (a += "height above sea level: " + b.ele + " m<br/>");b["xmas:day_date"] && (a += "period from - till: " + b["xmas:day_date"] + "<br/>");b["rotor:diameter"] && (a += "diameter of rotor: " + b["rotor:diameter"] + " m<br/>");b["xmas:note"] && (a += "information: " + b["xmas:note"] + "<br/>");"port" == b["seamark:beacon_lateral:category"] && (a += "port<br/>");"starboard" == b["seamark:beacon_lateral:category"] && (a += "starboard<br/>");"yes" == b["service:bicycle:retail"] && (a += "retail bicycles<br/>");"yes" == b["service:bicycle:repair"] && (a += "repair bicycles<br/>");"yes" == b["service:bicycle:rental"] && (a += "rental bicycles<br/>");"yes" == b["service:bicycle:pump"] && (a += "use of a pump is possible<br/>");"yes" == b["service:bicycle:diy"] && (a += "diy is possible<br/>");"yes" == b["service:bicycle:cleaning"] && (a += "cleaning bicycles<br/>");"yes" == b["service:bicycle:second_hand"] && (a += "sale of second hand bicycles<br/>");"yes" == b["service:bicycle:charging"] && (a += "charging electric bikes is possible<br/>");"yes" == b.cafe && (a += "cafe<br/>");"yes" == b.breakfast && (a += "breakfast<br/>");"yes" == b.snack && (a += "snack<br/>");"yes" == b.indoor_seating && (a += "indoor seating<br/>");"yes" == b.outdoor_seating && (a += "outdoor seating<br/>");"yes" == b.self_service && (a += "self service<br/>");"yes" == b.bakehouse && (a += "bakehouse<br/>");"yes" == b.pastry_shop && (a += "pastry shop<br/>");"yes" == b.fair_trade && (a += "fair trade<br/>");"only" == b.fair_trade && (a += "only fair trade<br/>");"no" == b.fair_trade && (a += "no fair trade<br/>");return a;
},
    fnContentHealthcare = function fnContentHealthcare(b) {
    var a = "";if ("doctors" == b.amenity || "physician" == b.office || "doctor" == b.healthcare) a += fnArztInfo(b), b.medical_area && (a += b.medical_area + "<br/>"), b.type && (a += b.type + "<br/>"), b["doctors:de"] && (a += b["doctors:de"] + "<br/>"), b["note:de"] && (a += b["note:de"] + "<br/>");"yes" == b.dispensing && (a += "pharmacy with dispensing<br/>");"abused" == b["social_facility:for"] && (a += "social facility for: abused people<br/>");"child" == b["social_facility:for"] && (a += "social facility for: children<br/>");"disabled" == b["social_facility:for"] && (a += "social facility for: disabled people<br/>");
    "diseased" == b["social_facility:for"] && (a += "social facility for: diseased people<br/>");"drug_addicted" == b["social_facility:for"] && (a += "social facility for: drug addicted people<br/>");"homeless" == b["social_facility:for"] && (a += "social facility for: homeless<br/>");"juvenile" == b["social_facility:for"] && (a += "social facility for: juvenile and teenager<br/>");"mental_health" == b["social_facility:for"] && (a += "social facility for: people with mental health problems<br/>");"migrant" == b["social_facility:for"] && (a += "social facility for: migrants<br/>");"orphan" == b["social_facility:for"] && (a += "social facility for: orphans<br/>");"senior" == b["social_facility:for"] && (a += "social facility for: seniors<br/>");"underprivileged" == b["social_facility:for"] && (a += "social facility for: underprivileged people<br/>");"unemployed" == b["social_facility:for"] && (a += "social facility for: unemployed<br/>");"victim" == b["social_facility:for"] && (a += "social facility for: victims<br/>");return a;
};
function fnAdditionalBuildingInfos(b) {
    var a = "";b["building:color"] && (a += "building color: " + b["building:color"] + "</br>");b["building:height"] && (a += "building height: " + b["building:height"] + " m</br>");b["building:level"] && (a += "level: " + b["building:level"] + "</br>");b["building:part"] && (a += "building part: " + b["building:part"] + "</br>");b["roof:color"] && (a += "roof color: " + b["roof:colour"] + "</br>");b["roof:shape"] && (a += "roof shape: " + b["roof:shape"] + "</br>");b["roof:height"] && (a += "roof height: " + b["roof:height"] + " m</br>");b["roof:material"] && (a += "roof material: " + b["roof:material"] + " </br>");b["roof:orientation"] && (a += "roof orientation: " + b["roof:orientation"] + " </br>");b["roof:direction"] && (a += "roof direction: " + b["roof:direction"] + " </br>");b["building:type"] && (a += "building type: " + b["building:type"] + "</br>");return a;
}
function fnSicherheitAdditional(b) {
    var a = "";"surveillance" == b.man_made && ("indoor" == b.surveillance && (a += "indoor surveillance"), "outdoor" == b.surveillance && (a += "outdoor surveillance"), "public" == b.surveillance && (a += "public surveillance"), "camera" == b["surveillance:type"] && (a += "type of surveillance: camera"), "guard" == b["surveillance:type"] && (a += "type of surveillance: guard"), "ALPR" == b["surveillance:type"] && (a += "type of surveillance: ALPR"), "town" == b["surveillance:zone"] && (a += "zone of surveillance: town"), "parking" == b["surveillance:zone"] && (a += "zone of surveillance: parking"), "traffic" == b["surveillance:zone"] && (a += "zone of surveillance: traffic"), "shop" == b["surveillance:zone"] && (a += "zone of surveillance: shop"), "bank" == b["surveillance:zone"] && (a += "zone of surveillance: bank"), "building" == b["surveillance:zone"] && (a += "zone of surveillance: building"));return a;
}
function fnWreckInfo(b) {
    var a = "";"wreck" == b.historic && (b["wreck:date_sunk"] && (a += "sunk: " + b["wreck:date_sunk"] + "<br/>"), b["wreck:depth"] && (a += "depth: " + b["wreck:depth"] + "<br/>"), b["wreck:clearance"] && (a += "clearance: " + b["wreck:clearance"] + "<br/>"), b["wreck:date_commissioned"] && (a += "commissioned: " + b["wreck:date_commissioned"] + "<br/>"), b["wreck:gross_tonnage"] && (a += "gross tonnage: " + b["wreck:gross_tonnage"] + "<br/>"), b["wreck:length"] && (a += "length: " + b["wreck:length"] + "<br/>"), b["wreck:width"] && (a += "width: " + b["wreck:width"] + "<br/>"), b["wreck:cargo"] && (a = "timber" == b["wreck:cargo"] ? a + "cargo: timber<br/>" : "coal" == b["wreck:cargo"] ? a + "cargo: coal<br/>" : a + ("cargo: " + b["wreck:cargo"] + "<br/>")), "yes" == b["wreck:visible_at_low_tide"] && (a += "visible at low tide: yes<br/>"), "no" == b["wreck:visible_at_low_tide"] && (a += "visible at low tide: no<br/>"), "yes" == b["wreck:visible_at_high_tide"] && (a += "visible at high tide: yes<br/>"), "no" == b["wreck:visible_at_high_tide"] && (a += "visible at high tide: no<br/>"), "yes" == b.access && (a += "accessible<br/>"), "no" == b.access && (a += "no access possible<br/>"), "permit_required" == b.access && (a += "permit required for acces<br/>"));return a;
}
function fnKlosterAdditional(b) {
    var a = "";if (b["monastery:type"]) switch (b["monastery:type"]) {case "monastery":
            a += "type: monastery<br/>";break;case "convent":
            a += "type: convent<br/>";break;case "canonry":
            a += "type: canonry<br/>";break;case "commandry":
            a += "type: commandry<br/>";break;case "hermitage":
            a += "type: hermitage<br/>";break;default:
            a += "type: unknown<br/>";}b["community:gender"] && ("male" == b["community:gender"] && (a += "gender: male<br/>"), "female" == b["community:gender"] && (a += "gender: female<br/>"));
    b.religious_rank && ("abbey" == b.religious_rank ? a += "religious rank: abbey<br/>" : "abbey" == b.religious_rank && (a += "religious rank: abbey<br/>"));"yes" == b.shrine && (a += "feature: shrine<br/>");"yes" == b.sanctuary && (a += "feature: sanctuary<br/>");if (b.religion) switch (b.religion) {case "animist":
            a += "religion: animist<br/><br/>";break;case "bahai":
            a += "religion: bahai<br/>";break;case "buddhist":
            a += "religion: buddhist<br/>";break;case "christian":
            a += "religion: christian<br/>";break;case "hindu":
            a += "religion: hindu<br/>";
            break;case "IglesiaNiCristo":
            a += "religion: IglesiaNiCristo<br/>";break;case "jain":
            a += "religion: jain<br/>";break;case "jewish":
            a += "religion: jewish<br/>";break;case "multifaith":
            a += "religion: multifaith<br/>";break;case "muslim":
            a += "religion: muslim<br/>";type += "Mosque<br/>";break;case "pagan":
            a += "religion: pagan<br/>";break;case "pastafarian":
            a += "religion: pastafarian<br/>";break;case "scientologist":
            a += "religion: scientologist<br/>";break;case "shinto":
            a += "religion: shinto<br/>";break;case "sikh":
            a += "religion: sikh<br/>";break;case "spiritualist":
            a += "religion: spiritualist<br/>";break;case "taoist":
            a += "religion: taoist<br/>";break;case "unitarian":
            a += "religion: unitarian<br/>";break;case "yazidi":
            a += "religion: yazidi<br/>";break;case "zoroastrian":
            a += "eligion: zoroastrian<br/>";break;default:
            a += "religion: unknown<br/>";}if (b.denomination) switch (b.denomination) {case "anglican":
            a += "denomination: Anglican<br/><br/>";break;case "baptist":
            a += "denomination: Baptist<br/>";break;case "catholic":
            a += "denomination: Catholic<br/>";
            break;case "roman_catholic":
            a += "denomination: Roman Catholic<br/>";break;case "old_catholic":
            a += "denomination: Old Catholic<br/>";break;case "greek_catholic":
            a += "denomination: Greek Catholic<br/>";break;case "evangelical":
            a += "denomination: Evangelical";case "jehovahs_witness":
            a += "denomination: Jehovahs Witness<br/>";break;case "lutheran":
            a += "denomination: Lutheran<br/>";break;case "mennonite":
            a += "denomination: Mennonite<br/>";break;case "messianic_jewish":
            a += "denomination: Messianic Jewish<br/>";
            break;case "methodist":
            a += "denomination: Methodist<br/>";break;case "mormon":
            a += "denomination: Mormon<br/>";break;case "new_apostolic":
            a += "denomination: New Apostolic<br/>";break;case "orthodox":
            a += "denomination: Orthodox<br/>";break;case "greek_orthodox":
            a += "denomination: Greek Orthodox<br/>";break;case "coptic_orthodox":
            a += "denomination: coptic orthodox<br/>";break;case "pentecostal":
            a += "denomination: pentecostal<br/>";break;case "presbyterian":
            a += "denomination: Presbyterian<br/>";break;case "protestant":
            a += "denomination: Protestant<br/>";break;case "quaker":
            a += "denomination: Quaker<br/>";break;case "reformed":
            a += "denomination: Reformed<br/>";break;case "russian_orthodox":
            a += "denomination: Russian-Orthodox<br/>";break;case "seventh_day_adventist":
            a += "denomination: Seventh Day Adventist<br/>";break;case "christian_community":
            a += "denomination: Christian Community<br/>";break;case "adventist":
            a += "denomination: Adventist<br/>";break;case "alliance":
            a += "denomination: Alliance<br/>";break;case "assemblies_of_god":
            a += "denomination: Assemblies of God<br/>";break;case "apostolic":
            a += "denomination: Apostolic<br/>";break;case "armenian_apostolic":
            a += "denomination: Armenian Apostolic<br/>";break;case "assyrian":
            a += "denomination: Assyrian<br/>";break;case "christ_scientist":
            a += "denomination: Christ Scientist<br/>";break;case "church_of_scotland":
            a += "denomination: Church of Scotland<br/>";break;case "czechoslovak_hussite":
            a += "denomination: Czechoslovak Hussite<br/>";break;case "dutch_reformed":
            a += "denomination: Dutch Reformed<br/>";
            break;case "exclusive_brethren":
            a += "denomination: Exclusive Brethren<br/>";break;case "foursquare":
            a += "denomination: Foursquare<br/>";break;case "kimbanguist":
            a += "denomination: Kimbanguist<br/>";break;case "living_waters_church":
            a += "denomination: Living Waters Church<br/>";break;case "mariavite":
            a += "denomination: Mariavite<br/>";break;case "maronite":
            a += "denomination: Maronite<br/>";break;case "moravian":
            a += "denomination: Moravian<br/>";break;case "nazarene":
            a += "denomination: Nazarene<br/>";break;
        case "nondenominational":
            a += "denomination: Nondenominational<br/>";break;case "old_believers":
            a += "denomination: Old Believers<br/>";break;case "polish_catholic":
            a += "denomination: Polish-Catholic<br/>";break;case "salvation_army":
            a += "denomination: Salvation Army<br/>";break;case "santo_daime":
            a += "denomination: Santo Daime<br/>";break;case "serbian_orthodox":
            a += "denomination: Serbisch-Orthodox<br/>";break;case "spiritism":
            a += "denomination: Spiritism<br/>";break;case "united":
            a += "denomination: United<br/>";
            break;case "united_church_of_christ":
            a += "denomination: United Church of Christ<br/>";break;case "united_free_church_of_scotland":
            a += "denomination: United Free Church of Scotland<br/>";break;case "united_methodist":
            a += "denomination: United Methodist<br/>";break;case "united_reformed":
            a += "denomination: United Reformed<br/>";break;case "uniting":
            a += "denomination: Uniting<br/>";break;case "church_of_sweden":
            a += "denomination: Church of Sweden<br/>";break;case "mission_covenant_church_of_sweden":
            a += "denomination: Mission Covenant Church Of Sweden<br/>";
            break;case "alternative":
            a += "denomination: alternative<br/>";break;case "ashkenazi":
            a += "denomination: ashkenazi<br/>";break;case "buchari":
            a += "denomination: buchari<br/>";break;case "conservative":
            a += "denomination: conservative<br/>";break;case "egalitarian":
            a += "denomination: egalitarian<br/>";break;case "hasidic":
            a += "denomination: hasidic<br/>";break;case "humanistic":
            a += "denomination: humanistic<br/>";break;case "kabbalah":
            a += "denomination: kabbalah<br/>";break;case "kabbalistic":
            a += "denomination: kabbalistic<br/>";
            break;case "karaite":
            a += "denomination: karaite<br/>";break;case "liberal":
            a += "denomination: liberal<br/>";break;case "lubavitch":
            a += "denomination: lubavitch<br/>";break;case "lubavitch_messianic":
            a += "denomination: lubavitch messianic<br/>";break;case "mizrachi_baghdadi":
            a += "denomination: mizrachi baghdadi<br/>";break;case "mizrachi_chida":
            a += "denomination: mizrachi chida<br/>";break;case "mizrachi_jerusalemite":
            a += "denomination: mizrachi jerusalemite<br/>";break;case "mizrachi_livorno":
            a += "denomination: mizrachi livorno<br/>";
            break;case "mizrachi_moroccan":
            a += "denomination: mizrachi moroccan<br/>";break;case "modern_orthodox":
            a += "denomination: modern orthodox<br/>";break;case "neo_orthodox":
            a += "denomination: neo orthodox<br/>";break;case "nondenominational":
            a += "denomination: nondenominational<br/>";break;case "orthodox":
            a += "denomination: orthodox<br/>";break;case "orthodox_ashkenaz":
            a += "denomination: orthodox ashkenaz<br/>";break;case "orthodox_sefard":
            a += "denomination: orthodox sefard<br/>";break;case "progressive":
            a += "denomination: progressive<br/>";break;case "reconstructionist":
            a += "denomination: reconstructionist<br/>";break;case "reform":
            a += "denomination: reform<br/>";break;case "renewal":
            a += "denomination: renewal<br/>";break;case "samaritan":
            a += "denomination: samaritan<br/>";break;case "sefardi":
            a += "denomination: sefardi<br/>";break;case "sefardi_amsterdam":
            a += "denomination: sefardi amsterdam<br/>";break;case "sefardi_london":
            a += "denomination: sefardi london<br/>";break;case "traditional":
            a += "denomination: traditional<br/>";
            break;case "ultra_orthodox":
            a += "denomination: ultra orthodox<br/>";break;case "unaffiliated":
            a += "denomination: unaffiliated<br/>";break;case "yemenite":
            a += "denomination: yemenite<br/>";break;case "yemenite_baladi":
            a += "denomination: yemenite baladi<br/>";break;case "yemenite_shami":
            a += "denomination: yemenite shami<br/>";break;case "ahmadiya":
            a += "denomination: ahmadiya<br/>";break;case "alaouite":
            a += "denomination: alaouite<br/>";break;case "druze":
            a += "denomination: druze<br/>";break;case "ibadi":
            a += "denomination: ibadi<br/>";break;case "ismaili":
            a += "denomination: ismaili<br/>";break;case "shia":
            a += "denomination: shia<br/>";break;case "sunni":
            a += "denomination: sunni<br/>";break;case "nichiren":
            a += "denomination: nichiren<br/>";break;case "jodo_shinshu":
            a += "denomination: jodo shinshu<br/>";break;case "jodo_shu":
            a += "denomination: jodo shu<br/>";break;case "vajrayana":
            a += "denomination: vajrayana<br/>";break;case "shingon_shu":
            a += "denomination: shingon shu<br/>";break;case "zen":
            a += "denomination: zen<br/>";
            break;case "thai_mahanikaya":
            a += "denomination: thai mahanikaya<br/>";break;case "thai_thammayut":
            a += "denomination: thai thammayut<br/>";break;case "asatru":
            a += "denomination: asatru<br/>";break;case "celtic":
            a += "denomination: celtic<br/>";break;case "greco_roman":
            a += "denomination: greco roman<br/>";break;case "wicca":
            a += "denomination: wicca<br/>";break;case "irani":
            a += "denomination: irani<br/>";break;case "parsi":
            a += "denomination: parsi<br/>";break;default:
            a += "unknown<br/>";}if (b.community) switch (b.community) {case "AA":
            a += "community (AA): Augustinians of the Assumption <br/>";break;case "BSCM":
            a += "community (BSCM): Adorers of the Sacred Heart of Jesus of Montmartre <br/>";break;case "CBMV":
            a += "community (CBMV): Augustiner-Chorfrauen B.M.V.<br/>";break;case "CO":
            a += "community (CO): Oratorians<br/>";break;case "CMC":
            a += "community (CMC): Congregation of the Mother Co-Redemptrix<br/>";break;case "CRSP":
            a += "community (CRSP): Kongregation der Regularkleriker vom hl. Paulus (Barnabiten)<br/>";break;case "CSJ":
            a += "community (CSJ): Carmel Saint-Joseph<br/>";
            break;case "CSSP":
            a += "community (CSSP): Congr\xE9gation du Saint-Esprit<br/>";break;case "CSSR":
            a += "community (CSSR): Congr\xE9gation du Tr\xE8s Saint R\xE9dempteur<br/>";break;case "FCJM":
            a += "community (FCJM): Franciscan Sisters, Daughters of the Sacred Heart of Jesus and Mary<br/>";break;case "FMGB":
            a += "community (FMGB): Suore Francescane Missionarie di Ges\xF9 Bambino<br/>";break;case "FMH":
            a += "community(FMH): Congregatio Filiarum Mariae Sanctissimae ab Horto<br/>";break;case "FMM":
            a += "community (FMM): Franciscaines missionnaires de Marie<br/>";break;case "FSC":
            a += "community (FSC): Fr\xE8res des \xC9coles chr\xE9tiennes<br/>";break;case "MCCI":
            a += "community (MCCI): Missionnaires comboniens du Sacr\xE9-C\u0153ur<br/>";break;case "MSFS":
            a += "community (MSFS): Missionnaires de Saint Fran\xE7ois de Sales<br/>";break;case "OCart":
            a += "community (OCart): Order of the Carthusians<br/>";break;case "OCC":
            a += "community (OCC): Ordre de Notre Dame du Mont-Carmel<br/>";break;case "OCD":
            a += "community (OCD): Ordre des Carmes d\xE9chaux<br/>";break;case "OCSO":
            a += "community (OCSO): Trappists (lat. Ordo Cisterciensis Strictioris Observantiae)<br/>";break;case "OFM":
            a += "community (OFM): Ordre des Fr\xE8res Mineurs (Franziskaner)<br/>";break;case "OFMCap":
            a += "community (OFMCap): Ordre des Fr\xE8res Mineurs Capucins<br/>";break;case "OFMConv":
            a += "community (OFMConv): Ordre des Fr\xE8res Mineurs Conventuels<br/>";break;case "OFS":
            a += "community (OFS): Franciscans secular Third Order<br/>";
            break;case "OMI":
            a += "community (OMI): Oblats de Marie<br/>";break;case "OP":
            a += "community (OP): Ordre des Fr\xE8res Pr\xEAcheurs<br/>";break;case "OPraem":
            a += "community (OPraem): Ordre des chanoines r\xE9guliers de Pr\xE9montr\xE9<br/>";break;case "OSB":
            a += "community (OSB): Order of Saint Benedict<br/>";break;case "OSC":
            a += "community (OSC): Ordre de Sainte-Claire ou Ordre des Pauvres Dames<br/>";break;case "OSSS":
            a += "community (OSSS): Ordre de Sainte-Brigitte<br/>";break;case "OVM":
            a += "community (OVM): Order of the Visitation of Holy Mary (Salesianerinnen)<br/>";
            break;case "PSDP":
            a += "community (PSDP): Petites s\u0153urs des pauvres (Kleinen Schwestern der Armen)<br/>";break;case "PFJ":
            a += "community (PFJ): Petits Fr\xE8res de J\xE9sus<br/>";break;case "SDB":
            a += "community (SDB): Soci\xE9t\xE9 de Saint Fran\xE7ois de Sales<br/>";break;case "SJ":
            a += "community (SJ): Compagnie de J\xE9sus<br/>";break;case "SOC":
            a += "community (SOC): Order of Cistercians<br/>";break;case "SSCC":
            a += "community (SSCC): Congregation of the Sacred Hearts of Jesus and Mary<br/>";
            break;case "SSF":
            a += "community (SSF): Society of St Francis<br/>";break;case "SSJE":
            a += "community (SSJE): Society of St John the Evangelist<br/>";break;case "SSpS":
            a += "community (SSpS): Steyler Missionsschwestern<br/>";break;case "TOR":
            a += "community (TOR): Terzo Ordine Regolare di San Francesco<br/>";break;default:
            a += "unknown<br/>";}return a;
}var fnTestInfoPopup = function fnTestInfoPopup(b) {
    b = b.getProperties();var a = "",
        c;for (c in b) {
        a = a + c + "=" + b[c] + "<br/>";
    }return '<div class="c4g_popup_text" style="width:300px;">' + a + "</div>";
};

/***/ }),

/***/ "./Resources/public/js/c4g-maps-proxy.js":
/*!***********************************************!*\
  !*** ./Resources/public/js/c4g-maps-proxy.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * This file is part of con4gis,
 * the gis-kit for Contao CMS.
 *
 * @package    con4gis
 * @version    6
 * @author     con4gis contributors (see "authors.txt")
 * @license    LGPL-3.0-or-later
 * @copyright  Küstenschmiede GmbH Software & Design
 * @link       https://www.con4gis.org
 */
// 'namespace'


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MapProxy = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _c4gBaselayerController = __webpack_require__(/*! ./c4g-baselayer-controller */ "./Resources/public/js/c4g-baselayer-controller.js");

var _c4gLayerController = __webpack_require__(/*! ./c4g-layer-controller */ "./Resources/public/js/c4g-layer-controller.js");

var _c4gLocationstyleController = __webpack_require__(/*! ./c4g-locationstyle-controller */ "./Resources/public/js/c4g-locationstyle-controller.js");

var _c4gMapsMiscSpinner = __webpack_require__(/*! ./c4g-maps-misc-spinner */ "./Resources/public/js/c4g-maps-misc-spinner.js");

var _c4gMapsUtils = __webpack_require__(/*! ./c4g-maps-utils */ "./Resources/public/js/c4g-maps-utils.js");

var _c4gMapsConstant = __webpack_require__(/*! ./c4g-maps-constant */ "./Resources/public/js/c4g-maps-constant.js");

var _c4gMapsI18n = __webpack_require__(/*! ./c4g-maps-i18n */ "./Resources/public/js/c4g-maps-i18n.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var langConstants = {};

var MapProxy = exports.MapProxy = function () {
  function MapProxy(options) {
    _classCallCheck(this, MapProxy);

    var mapData;

    this.options = jQuery.extend({
      mapController: false
    }, options);
    if (!this.options.mapController) {
      return false;
    }

    // c4g.maps.editorStyles = c4g.maps.editorStyles || {};

    //window.c4gMapsHooks.proxy_fillPopup = [];

    this.hook_baselayer_loaded = [];
    this.hook_baselayer_visibility = [];
    this.hook_layer_loaded = [];
    this.hook_layer_visibility = [];
    this.hook_map_click = [];
    this.hook_map_zoom = [];

    // add global hook for accessibility when there is no proxy reference
    window.c4gMapsHooks = window.c4gMapsHooks || {};
    window.c4gMapsHooks.proxy_layer_loaded = window.c4gMapsHooks.proxy_layer_loaded || [];
    window.c4gMapsHooks.proxy_layer_drawn = window.c4gMapsHooks.proxy_layer_drawn || [];
    window.c4gMapsHooks.proxy_baselayer_loaded = window.c4gMapsHooks.proxy_baselayer_loaded || [];

    this.baselayerIds = [];
    this.activeBaselayerId = undefined;
    this.layerIds = [];
    this.activeLayerIds = {};

    this.requestFunctions = {};
    this.request = {};

    this.baselayers_loaded = false;
    this.layers_loaded = false;

    mapData = this.options.mapController.data;
    langConstants = (0, _c4gMapsI18n.getLanguage)(mapData);
    this.mapData = mapData;
    this.mapId = mapData.id;

    this.api_baselayer_url = this.options.mapController.data.api.baselayer + '/' + mapData.profile;
    this.api_layer_url = this.options.mapController.data.api.layer + '/' + this.mapId;
    this.api_layercontent_url = this.options.mapController.data.api.layercontent;
    //this.api_layercontentdata_url = this.options.mapController.data.api.layercontentdata;
    this.api_layercontentdata_url = "con4gis/layerContentDataService";
    this.api_locstyle_url = this.options.mapController.data.api.locstyle;
    this.api_infowindow_url = this.options.mapController.data.api.infowindow;
    this.options = options;
    this.clickObserverActive = true;

    // this.initialize();
  }

  _createClass(MapProxy, [{
    key: "initialize",
    value: function initialize() {
      var self, map;

      self = this;
      map = this.options.mapController.map;

      this.baselayerController = new _c4gBaselayerController.C4gBaselayerController(this);
      this.baselayerController.loadBaseLayers();
      this.layerController = new _c4gLayerController.C4gLayerController(this);
      this.layerController.loadLayers();
      this.locationStyleController = new _c4gLocationstyleController.C4gLocationStyleController(this);
      this.addPopUp();

      //TODO check this, nearly the same as below
      map.on('change:view', function () {
        // zoom-observer
        //
        map.getView().on('change:resolution', function () {
          var layerId, layer;

          // check layer zoom-bounds
          // @TODO: Use "self.activeLayerIds = false" ?
          for (layerId in self.activeLayerIds) {
            if (self.activeLayerIds.hasOwnProperty(layerId)) {
              layer = self.layerController.arrLayers[layerId];
              if (self.checkLayerIsActiveForZoom(layerId)) {
                if (layer.isInactive) {
                  self.layerController.showLayer(layerId);
                }
              } else {
                self.layerController.hideLayer(layerId, true);
              }
            }
          }

          // hooks
          _c4gMapsUtils.utils.callHookFunctions(self.hook_map_zoom);

          if (self.options.mapController.data.caching && map.getView().getZoom()) {
            _c4gMapsUtils.utils.storeValue('zoom', map.getView().getZoom());
          }
        }); // end of "zoom-observer"
      }); // end of "zoom-observer"

      // zoom-observer
      //
      map.getView().on('change:resolution', function () {
        var layerId, layer;

        // check layer zoom-bounds
        // @TODO: Use "self.activeLayerIds = false" ?
        for (layerId in self.activeLayerIds) {
          if (self.activeLayerIds.hasOwnProperty(layerId)) {
            layer = self.layerController.arrLayers[layerId];
            if (self.checkLayerIsActiveForZoom(layerId)) {
              if (layer.isInactive) {
                self.layerController.showLayer(layerId);
              }
            } else {
              self.layerController.hideLayer(layerId, true);
            }
          }
        }

        // hooks
        _c4gMapsUtils.utils.callHookFunctions(window.c4gMapsHooks.hook_map_zoom, self);

        if (self.options.mapController.data.caching && map.getView().getZoom()) {
          _c4gMapsUtils.utils.storeValue('zoom', map.getView().getZoom());
        }
      }); // end of "zoom-observer"

      map.getView().on('change:center', function (evt) {
        if (self.options.mapController.data.caching) {
          var coordinate = ol.proj.toLonLat(map.getView().getCenter());
          if (coordinate) {
            _c4gMapsUtils.utils.storeValue('lon', coordinate[0]);
            _c4gMapsUtils.utils.storeValue('lat', coordinate[1]);
          }
        }
        window.c4gMapsHooks.map_center_changed = window.c4gMapsHooks.map_center_changed || [];
        _c4gMapsUtils.utils.callHookFunctions(window.c4gMapsHooks.map_center_changed, map.getView().getCenter());
      }); // end of "center-observer"

      // click-observer
      //
      map.on('click', function (clickEvent) {

        var feature, fFeatures, layer, popupInfos, currentZoom, minZoom, newCenter, geometry, coord, setPopup, styleFunc, styleCluster, objPopup;

        if (!self.clickObserverActive) {
          return false;
        }

        //ToDo check new function call with ol 4.3
        feature = map.forEachFeatureAtPixel(clickEvent.pixel, function (feature, layer) {
          return feature;
        });

        layer = map.forEachFeatureAtPixel(clickEvent.pixel, function (feature, layer) {
          return layer;
        });

        if (layer && layer.getStyle()) {
          styleFunc = layer.getStyle();
          if (typeof styleFunc === "function" && styleFunc(feature, currentZoom) && styleFunc(feature, currentZoom)['0']) {
            styleCluster = styleFunc(feature, currentZoom)['0'].clone();
            if (styleCluster && styleCluster.getImage()) {
              styleCluster.getImage().setScale(styleCluster.getImage().getScale() * 0.7);
            }
          }
        }

        fFeatures = feature ? feature.get('features') : false;
        if (!(fFeatures && fFeatures.length === 1)) {
          // cluster multiple POI
          if (fFeatures) {
            if (fFeatures[0].get('cluster_popup') == 1) {
              map.getView().setCenter(clickEvent.coordinate);
              currentZoom = map.getView().getZoom();
              minZoom = self.options.mapController.data.cluster_all ? self.options.mapController.data.cluster_zoom : fFeatures['0'].get('cluster_zoom');
              if (currentZoom >= minZoom) {
                setPopup = [];
                setPopup.content = '';
                setPopup.async = false;
                for (var i = 0; i < fFeatures.length; i++) {
                  setPopup.content = setPopup.content.concat(fFeatures[i].get('popup').content);
                }
                feature = fFeatures[0].clone();
                feature.set('popup', setPopup);
              } else {
                map.getView().setZoom(currentZoom + 1);
              }
            } else {

              feature.setStyle(new ol.style.Style({
                image: new ol.style.Circle({
                  fill: new ol.style.Fill({
                    opacity: 0
                  }),
                  radius: 0
                })
              }));
              feature = false;

              // animation
              map.getView().animate({
                start: +new Date(),
                duration: 1000,
                resolution: map.getView().getResolution(),
                center: [0, 0]
                //rotation: Math.PI
              });

              currentZoom = map.getView().getZoom();
              newCenter = map.getCoordinateFromPixel(clickEvent.pixel);
              minZoom = self.options.mapController.data.cluster_all ? self.options.mapController.data.cluster_zoom : fFeatures['0'].get('cluster_zoom');

              //ToDo remove with structure element param
              if (currentZoom >= minZoom) {

                //if (currentZoom >= map.getView().getMaxZoom()) {
                //open the cluster after zooming
                var pix = map.getView().getResolution();
                var max = fFeatures.length;
                var r = pix * 12 * (0.5 + max / 4);
                for (var i = 0; i < max; i++) {
                  var a = 2 * Math.PI * i / max;
                  if (max == 2 || max == 4) a += Math.PI / 4;
                  var p = [newCenter[0] + r * Math.sin(a), newCenter[1] + r * Math.cos(a)];
                  var coordinate = ol.proj.toLonLat(p);
                  var f = [];
                  f.push(fFeatures[i]);
                  var cf = new ol.Feature({
                    geometry: new ol.geom.Point(p),
                    features: f,
                    style: fFeatures[i].get('style')
                  });
                  layer.getSource().addFeature(cf);
                  map.getView().setCenter(newCenter);
                }
              } else {
                currentZoom += 1;
              }

              map.getView().setCenter(newCenter);
              map.getView().setZoom(currentZoom);
            }
          }
        } else if (fFeatures && fFeatures.length === 1) {
          feature = fFeatures[0];
        }

        if (self.options.mapController.controls.editor && self.options.mapController.controls.editor.isOpen()) {
          // do not show popup when editor is open
          if (feature && feature.get('projectId')) {
            // but call click hooks
            var result = _c4gMapsUtils.utils.callHookFunctions(self.hook_map_click, clickEvent);
            return false;
          }
        }
        popupInfos = {};
        if (feature && feature.get('popup')) {
          // single POI
          popupInfos = feature.get('popup');
        } else if (layer && layer.popup) {
          popupInfos = layer.popup;
        } else {
          feature = false;
        }
        if (feature && feature.get('loc_linkurl')) {
          if (self.options.mapController.data.link_newwindow === '1') {
            window.open(feature.get('loc_linkurl'));
          } else {
            window.open(feature.get('loc_linkurl'), "_self");
          }
        } else {
          if (feature && feature.get('zoom_onclick') && feature.get('zoom_onclick') != 0) {
            map.getView().setZoom(feature.get('zoom_onclick'));
            map.getView().setCenter(feature.getGeometry().getCoordinates());
          } else if (layer && layer.zoom_onclick && layer.zoom_onclick != 0) {
            map.getView().setZoom(layer.zoom_onclick);
            map.getView().setCenter(clickEvent.coordinate);
          }

          if (feature) {
            geometry = feature.getGeometry();
            if (geometry instanceof ol.geom.Point) {
              coord = geometry.getCoordinates();
            } else {
              coord = clickEvent.coordinate;
            }
            if (self.mapData.popupHandling < 2) {
              window.c4gMapsPopup.popup.setPosition(coord);
            } else {
              window.c4gMapsPopup.popup.setPosition(self.options.mapController.map.getView().getCenter());
            }

            if (popupInfos.content) {
              window.c4gMapsPopup.$content.html('');
              window.c4gMapsPopup.$popup.addClass(_c4gMapsConstant.cssConstants.ACTIVE).addClass(_c4gMapsConstant.cssConstants.LOADING);
              window.c4gMapsPopup.spinner.show();

              if (popupInfos.async === false || popupInfos.async == '0') {
                objPopup = {};
                objPopup.popup = popupInfos;
                objPopup.feature = feature;
                objPopup.layer = layer;
                // Call the popup hook for plugin specific popup content
                if (window.c4gMapsHooks !== undefined && _typeof(window.c4gMapsHooks.proxy_fillPopup) === 'object') {
                  _c4gMapsUtils.utils.callHookFunctions(window.c4gMapsHooks.proxy_fillPopup, { popup: objPopup, mapController: self.options.mapController });
                }
                self.setPopup(objPopup);
              } else {
                jQuery.ajax({
                  dataType: "json",
                  url: self.api_infowindow_url + '/' + popupInfos.content
                }).done(function (data) {
                  var popupInfo = {
                    async: popupInfos.async,
                    content: data.content,
                    popup: popupInfos.popup,
                    routing_link: popupInfos.routing_link
                  };

                  objPopup = {};
                  objPopup.popup = popupInfo;
                  objPopup.feature = feature;
                  objPopup.layer = layer;

                  // Call the popup hook for plugin specific popup content
                  if (window.c4gMapsHooks !== undefined && _typeof(window.c4gMapsHooks.proxy_fillPopup) === 'object') {
                    _c4gMapsUtils.utils.callHookFunctions(window.c4gMapsHooks.proxy_fillPopup, { popup: objPopup, mapController: self.options.mapController });
                  }
                  self.setPopup(objPopup);
                });
              }
            } else {
              window.c4gMapsPopup.$popup.removeClass(_c4gMapsConstant.cssConstants.ACTIVE);
            }
          } else {
            window.c4gMapsPopup.$popup.removeClass(_c4gMapsConstant.cssConstants.ACTIVE);
          }

          // hooks
          _c4gMapsUtils.utils.callHookFunctions(window.c4gMapsHooks.hook_map_click, clickEvent);
        }
      }); // end of "click-observer"
    } // end of "initial"*

  }, {
    key: "activateClickObserver",
    value: function activateClickObserver() {
      this.clickObserverActive = true;
    }
  }, {
    key: "deactivateClickObserver",
    value: function deactivateClickObserver() {
      this.clickObserverActive = false;
    }
  }, {
    key: "combine",
    value: function combine(proxy) {
      var func = function func(event) {
        proxy.combineLayers(proxy);
        proxy.options.mapController.map.un('postrender', func);
      };
      proxy.options.mapController.map.on('postrender', func);
    }
  }, {
    key: "setPopup",
    value: function setPopup(popupConfig) {
      var feature,
          layer,
          popupContent,
          router,
          routeButtonWrapper,
          routeFromButton,
          routeFromButtonSpan,
          routeToButton,
          routeToButtonSpan,
          routingHandler,
          self = this;

      feature = popupConfig.feature;
      layer = popupConfig.layer;

      popupContent = _c4gMapsUtils.utils.replaceAllPlaceholders(popupConfig.popup.content, feature, layer, this.options.mapController.data.lang);
      if (popupContent.trim()) {
        window.c4gMapsPopup.$content.html(popupContent);
        if (window.c4gMapsHooks !== undefined && _typeof(window.c4gMapsHooks.proxy_appendPopup) === 'object') {
          _c4gMapsUtils.utils.callHookFunctions(window.c4gMapsHooks.proxy_appendPopup, { popup: popupConfig, mapController: this.options.mapController });
        }
        if (feature.getGeometry() && feature.getGeometry() instanceof ol.geom.Point) {
          if (self.mapData.popupHandling < 2) {
            window.c4gMapsPopup.popup.setPosition(feature.getGeometry().getCoordinates());
          } else {

            window.c4gMapsPopup.popup.setPosition(self.options.mapController.map.getView().getCenter());
          }
        }
      } else {
        // hide popup if there is no valid content left
        window.c4gMapsPopup.$popup.removeClass(_c4gMapsConstant.cssConstants.ACTIVE);
      }

      window.c4gMapsPopup.$popup.removeClass(_c4gMapsConstant.cssConstants.LOADING);
      window.c4gMapsPopup.spinner.hide();
    } // end of "setPopup()"


  }, {
    key: "addPopUp",
    value: function addPopUp() {

      var popUpElement = void 0,
          popUpCloseElement = void 0,
          popUpContent = void 0,
          popup = void 0;

      popUpElement = document.createElement('div');
      popUpElement.setAttribute('id', 'c4g_popup_' + this.options.mapController.data.mapId);
      popUpElement.className = 'c4g-popup-wrapper';

      popUpCloseElement = document.createElement('button');
      popUpCloseElement.className = "c4g-popup-close c4g-icon";

      popUpContent = document.createElement('div');
      popUpContent.className = "c4g-popup-content";

      popUpElement.appendChild(popUpCloseElement);
      popUpElement.appendChild(popUpContent);

      jQuery(popUpCloseElement).click(function (event) {
        event.preventDefault();
        window.c4gMapsPopup.$popup.removeClass(_c4gMapsConstant.cssConstants.ACTIVE);
      });
      if (this.mapData.popupHandling < 2) {
        var autoPan = this.mapData.popupHandling == 1 ? true : false;
        popup = new ol.Overlay({
          element: popUpElement,
          positioning: 'bottom-left',
          offset: [-50, 0],
          autoPan: autoPan,
          autoPanAnimation: {
            duration: 0
          },
          autoPanMargin: 100
        });
      } else {
        $(popUpElement).addClass('c4g-popup-wrapper-nonose');
        popup = new ol.Overlay({
          element: popUpElement,
          positioning: 'center-center',
          offset: [-50, 0],
          autoPan: false
        });
      }

      window.c4gMapsPopup = {};
      window.c4gMapsPopup.popup = popup;
      // attach a spinner to the popup
      window.c4gMapsPopup.spinner = new _c4gMapsMiscSpinner.Spinner({ target: popUpElement });

      this.options.mapController.map.addOverlay(popup);

      window.c4gMapsPopup.$popup = jQuery(window.c4gMapsPopup.popup.getElement());
      window.c4gMapsPopup.$content = jQuery('.c4g-popup-content', window.c4gMapsPopup.$popup);
      this.currentPopup = window.c4gMapsPopup;
    } // end of "addPopUp()"


    /**
     * @TODO: [checkLocationStyles description]
     *
     * @param   {[type]}  opt_options  [description]
     *
     * @return  {[type]}               [description]
     */

  }, {
    key: "checkLocationStyles",
    value: function checkLocationStyles(opt_options) {

      var options,
          neededLayerStyles,
          getLayerStyles,
          self = this;

      if (opt_options && (typeof opt_options === "undefined" ? "undefined" : _typeof(opt_options)) === "object") {
        options = opt_options;
      } else {
        options = {};
      }

      this.locationStyleController.arrLocStyles = this.locationStyleController.arrLocStyles || {};

      neededLayerStyles = [];
      getLayerStyles = function getLayerStyles(layers) {
        var i, element, index;

        // ToDo: Rekursion integrieren (test mit forum)
        for (index in layers) {
          if (layers.hasOwnProperty(index)) {
            element = layers[index];

            if (element.content) {
              for (i = 0; i < element.content.length; i += 1) {

                if (element.content[i]) {
                  if (element.content[i].locationStyle && element.content[i].locationStyle !== "0" && neededLayerStyles.indexOf(element.content[i].locationStyle) === -1 && (!self.locationStyleController.arrLocStyles[element.content[i].locationStyle] || self.locationStyleController.arrLocStyles[element.content[i].locationStyle].style === undefined)) {
                    neededLayerStyles.push(element.content[i].locationStyle);
                  }
                }
              }
            }
          }
        }
      };

      getLayerStyles(this.layerController.arrLayers);

      if (neededLayerStyles.length > 0) {
        this.locationStyleController.loadLocationStyles(neededLayerStyles, options);
      } else {
        if (options.done && typeof options.done === "function") {
          options.done();
        }
      }
    } // end of "checkLocationStyles()"

  }, {
    key: "combineLayers",
    value: function combineLayers(proxy) {

      var i,
          j,
          k,
          layerId,
          layers,
          contentDataLayer,
          contentData,
          layer,
          layerGroups = [],
          source,
          style,
          features = [],
          styles = [],
          oneFeature,
          feature,
          vectorSource,
          clusterSource,
          vectorLayer;

      if (proxy.options.mapController.data.cluster_all === '1') {
        contentData = proxy.options.mapController.data;
        for (i in proxy.activeLayerIds) {
          //loop to get all layers
          layers = c4g.maps.layers[i];

          if (layers.type === "gpx") {
            continue;
          }

          if (layers && layers.vectorLayer) {
            if (layers.vectorLayer.getLayers() && layers.vectorLayer.getLayers().getArray()[0] && layers.vectorLayer.getLayers().getArray()[0].getSource() && layers.vectorLayer.getLayers().getArray()[0].getSource().getFeatures().length > 0) {
              proxy.options.mapController.map.removeLayer(layers.vectorLayer);
            }

            contentDataLayer = layers.content;
            layers.vectorLayer.getLayers().content = contentDataLayer;
            layerGroups.push(layers.vectorLayer.getLayers());
          }
        }
        for (k = 0; k < layerGroups.length; k++) {
          //loop to extract features from layers
          if (layerGroups[k].getArray().length > 0) {
            layer = layerGroups[k].getArray();
            source = layer["0"].getSource();
            style = layer["0"].getStyle();

            oneFeature = true;
            feature = source.getFeatures();
            for (j = 0; j < feature.length; j++) {
              //loop over all features from a source
              if (feature[j].get("features")) {
                for (i = 0; i < feature[j].get("features").length; i++) {
                  //loop for clustered features
                  if (layerGroups[k].content[j]) {
                    style = this.locationStyleController.arrLocStyles[layerGroups[k].content[j].locationStyle];
                  } else if (layerGroups[k].content[0]) {
                    style = this.locationStyleController.arrLocStyles[layerGroups[k].content[0].locationStyle];
                  }

                  feature[j].get("features")[i].setStyle(style.style);
                  if (!feature[j].get("features")[i].get('popup')) {
                    feature[j].get("features")[i].set('popup', layer['0'].popup);
                  }
                }
                features.push(feature[j].get("features"));

                oneFeature = false;
              }
            }
            if (oneFeature) {
              //single not clustered feature
              if (feature.length >= 1) {
                if (!feature['0'].get('popup')) {
                  feature['0'].set('popup', layer.popup);
                }
                features.push(feature);
              }
            }
          }
        }

        vectorSource = new ol.source.Vector({
          projection: 'EPSG:3857'

        });

        for (i = 0; i < features.length; i++) {
          vectorSource.addFeatures(features[i]);
        }

        clusterSource = new ol.source.Cluster({
          distance: 40,
          //threshold: 2, //minimum element count
          source: vectorSource
        });
        var styleForCluster = function styleForCluster(feature, resolution) {
          if (feature && feature.get('features') && feature.get('features')['0'].getStyle()) {
            style = feature.get('features')['0'].getStyle()(feature);
            if (feature !== undefined && feature !== null && feature.self !== window) {
              var fFeatures = feature.get('features');
              var size = fFeatures.length;
              if (size > 1) {
                if (!style) {
                  style = [];
                }

                // calculate bubble-offset
                var iconOffset = [0, 0];
                if (style[0]) {
                  if (typeof style[0].getImage().getRadius === "function") {
                    var radius = parseInt(style[0].getImage().getRadius(), 10);
                    if (radius) {
                      iconOffset = [0, radius];
                    }
                  } else if (typeof style[0].getImage().getAnchor === "function") {
                    iconOffset = style[0].getImage().getAnchor() || [0, 0];
                  }
                }

                var fillcolor = _c4gMapsUtils.utils.getRgbaFromHexAndOpacity('4975A8', {
                  unit: '%',
                  value: 70
                });

                if (contentData.cluster_fillcolor) {
                  fillcolor = _c4gMapsUtils.utils.getRgbaFromHexAndOpacity(contentData.cluster_fillcolor, {
                    unit: '%',
                    value: 70
                  });
                }
                var fontcolor = contentData.cluster_fontcolor ? '#' + contentData.cluster_fontcolor : '#FFFFFF';

                style.push(new ol.style.Style({
                  text: new ol.style.Text({
                    text: "●",
                    font: "60px sans-serif",
                    offsetX: -1 * iconOffset[0],
                    offsetY: -1 * iconOffset[1],
                    fill: new ol.style.Fill({
                      color: fillcolor
                    })
                  })
                }));
                style.push(new ol.style.Style({
                  text: new ol.style.Text({
                    text: size.toString(),
                    offsetX: -1 * iconOffset[0],
                    offsetY: -1 * iconOffset[1] + 3,
                    fill: new ol.style.Fill({
                      color: fontcolor
                    })
                  })
                }));
              }
            }
          } else {
            if (feature && feature.get('features') && feature.get('features')['0'].getStyle()) {
              return feature.get('features')['0'].getStyle()(feature);
            } else {
              return null;
            }
          }
          return style;
        };

        //vectorLayer = self.getVectorLayer(clusterSource, styleForCluster);

        vectorLayer = new ol.layer.Vector({
          name: 'Cluster',
          source: clusterSource,
          style: styleForCluster

        });

        var allLayers = proxy.options.mapController.map.getLayers().getArray();
        var missingLayer = true;
        for (i = 0; i < allLayers.length; i++) {

          if (allLayers[i].clusters) {
            allLayers[i] = vectorLayer;
            missingLayer = false;
          }
        }
        if (missingLayer) {
          proxy.options.mapController.map.addLayer(vectorLayer);
        }
      }
    } //end of combineLayers


  }, {
    key: "checkLayerIsActiveForZoom",
    value: function checkLayerIsActiveForZoom(layerId, opt_zoom) {
      var layer, zoom, layerContent, locstyle;

      if (!this.layerController.arrLayers[layerId]) {
        return false;
      }

      layer = this.layerController.arrLayers[layerId];

      if (opt_zoom) {
        zoom = opt_zoom;
      } else if (this.options.mapController.map.getView().getZoom() > -1) {
        zoom = this.options.mapController.map.getView().getZoom();
      } else {
        zoom = false;
      }
      if (layer.zoom === undefined) {
        if (layer.content && layer.content.length > 0) {
          for (var i = 0; i < layer.content.length; i++) {
            layerContent = layer.content[i];
            if (layerContent.locationStyle) {
              locstyle = this.locationStyleController.arrLocStyles[layerContent.locationStyle];
              // TODO check all locstyles and take the most constraining zoom value
              if (locstyle) {
                layer.zoom = {};
                if (locstyle.maxzoom) {
                  layer.zoom.max = locstyle.maxzoom;
                }
                if (locstyle.minzoom) {
                  layer.zoom.min = locstyle.minzoom;
                }
                if (layer.zoom.max || layer.zoom.min) {
                  break;
                }
              }
            }
          }
        }
      }
      if (typeof zoom === "number" && layer.zoom && (layer.zoom.min > zoom || layer.zoom.max > 0 && layer.zoom.max < zoom)) {
        return false;
      }

      return true;
    } // end of "checkLayerIsActive()"

  }]);

  return MapProxy;
}();

/***/ }),

/***/ "./Resources/public/js/c4g-maps-utils.js":
/*!***********************************************!*\
  !*** ./Resources/public/js/c4g-maps-utils.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.utils = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /*
                                                                                                                                                                                                                                                                               * This file is part of con4gis,
                                                                                                                                                                                                                                                                               * the gis-kit for Contao CMS.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * @package    con4gis
                                                                                                                                                                                                                                                                               * @version    6
                                                                                                                                                                                                                                                                               * @author     con4gis contributors (see "authors.txt")
                                                                                                                                                                                                                                                                               * @license    LGPL-3.0-or-later
                                                                                                                                                                                                                                                                               * @copyright  Küstenschmiede GmbH Software & Design
                                                                                                                                                                                                                                                                               * @link       https://www.con4gis.org
                                                                                                                                                                                                                                                                               */


var _c4gMapsConstant = __webpack_require__(/*! ./c4g-maps-constant */ "./Resources/public/js/c4g-maps-constant.js");

var _c4gMapsControlZoomlevel = __webpack_require__(/*! ./c4g-maps-control-zoomlevel */ "./Resources/public/js/c4g-maps-control-zoomlevel.js");

var _c4gMapsPopupInfoDe = __webpack_require__(/*! ./c4g-maps-popup-info-de */ "./Resources/public/js/c4g-maps-popup-info-de.js");

var popupFunctionsDE = _interopRequireWildcard(_c4gMapsPopupInfoDe);

var _c4gMapsPopupInfoEn = __webpack_require__(/*! ./c4g-maps-popup-info-en */ "./Resources/public/js/c4g-maps-popup-info-en.js");

var popupFunctionsEN = _interopRequireWildcard(_c4gMapsPopupInfoEn);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var popupFunctions = popupFunctionsDE;

if (typeof mapData !== "undefined") {
  if (mapData.lang === "de") {
    popupFunctions = popupFunctionsDE;
  } else if (mapData.lang === "en") {
    popupFunctions = popupFunctionsEN;
  } else {
    // fallback
    popupFunctions = popupFunctionsEN;
  }
} else {
  popupFunctions = popupFunctionsEN;
}

var utils = exports.utils = {
  /**
   *  Converts the first letter of a given string to uppercase, leaving the remaining string untouched.
   *
   *  @param    {string}    the string to capitalize
   *
   *  @return   {string}    the capitalized string
   */
  capitalizeFirstLetter: function capitalizeFirstLetter(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
  },

  /**
   * Generate an unique id.
   *
   * The id is 9 characters long and prefixed with an underscore.
   *
   * @return  {string}  The generated id.
   */
  getUniqueId: function getUniqueId() {
    // Math.random should be unique because of its seeding algorithm.
    // Convert it to base 36 (numbers + letters), and grab the first 9 characters
    // after the decimal.
    return '_' + Math.random().toString(36).substr(2, 9);
  },

  /**
   * Encode input strings for GeoJSON-Objects properly,
   * so they will not break the Code.
   * Transforms:
   *   \ -> \\;
   *   " -> '';
   *   Ä -> &Auml;
   *   ä -> &auml;
   *   Ö -> &Ouml;
   *   ö -> &ouml;
   *   Ü -> &Uuml;
   *   ü -> &uuml;
   *
   * @param   {string}  input  [description]
   *
   * @return  {string}         [description]
   */
  encodeGeoJsonProperty: function encodeGeoJsonProperty(input) {
    var output;

    if (!input) {
      return '';
    }

    output = input.replace(/\\/g, '\\\\').replace(/\"/g, '\'\'').replace(/Ä/g, '&Auml;').replace(/ä/g, '&auml;').replace(/Ö/g, '&Ouml;').replace(/ö/g, '&ouml;').replace(/Ü/g, '&Uuml;').replace(/ü/g, '&uuml;');

    return output;
  }, // end of encodeGeoJsonProperty()

  /**
   * Decode input strings for GeoJSON-Objects properly,
   * so they will be displayed correctly.
   * Transforms:
   *   \\     -> \;
   *   ''     -> ";
   *   &Auml; -> Ä
   *   &auml; -> ä
   *   &Ouml; -> Ö
   *   &ouml; -> ö
   *   &Uuml; -> Ü
   *   &uuml; -> ü
   *
   * @param   {string}  input  [description]
   *
   * @return  {string}         [description]
   */
  decodeGeoJsonProperty: function decodeGeoJsonProperty(input) {
    var output;

    if (!input) {
      return '';
    }
    if (typeof input !== "string") {
      input = input + "";
    }

    output = input.replace(/\\\\/g, '\\').replace(/\'\'/g, '\"').replace(/&Auml;/g, 'Ä').replace(/&auml;/g, 'ä').replace(/&Ouml;/g, 'Ö').replace(/&ouml;/g, 'ö').replace(/&Uuml;/g, 'Ü;').replace(/&uuml;/g, 'ü');

    return output;
  }, // end of decodeGeoJsonProperty()

  /**
   * Create or replace an URL-parameter.
   *
   * If `opt_getKey` is `false` or `undefined` the given parameter, `param`,
   * will be applied as "hash-parameter".
   * e.g.:
   *   https://myurl.de:port/path/to/maps#param
   * Note, that already existing "hash-parameters" will be overriden,
   * whereas existing "GET-parameters" stay untouched.
   *
   * If `opt_getKey` is set, it will be applied as "GET-parameter".
   * e.g.:
   *   https://myurl.de:port/path/to/maps?opt_getKey=param
   * If the key described by `opt_getKey` is already existing, its value will be overriden,
   * otherwise the key-value-pair will be appended appropriatly.
   * Already existing "hash-parameters" will stay untouched.
   *
   * If `opt_execute` is `false` or `undefined`, the function will return the new link as `string`,
   * otherwise the "href/location" will be changed directly in the browser, which can cause a pagereload.
   *
   * @param  {string}                    param        [description]
   * @param  {undefined|boolean|string}  opt_getKey   Default: `undefined`
   * @param  {undefined|boolean}         opt_execute  Default: `undefined`
   */
  setUrlParam: function setUrlParam(param, opt_getKey, opt_execute) {
    var link, searchParam, paramReplaced, i;

    if ((typeof param === "undefined" ? "undefined" : _typeof(param)) === undefined) {
      return false;
    }

    link = location.origin + location.pathname;

    if (!opt_getKey) {
      // use hash-parameter
      if (opt_execute) {
        location.hash = param;
        return true;
      }
      link += location.search + '#' + param;
    } else {
      // use GET-parameter
      if (location.search) {
        // there are already search-parameters
        paramReplaced = false;
        opt_getKey = opt_getKey.toLowerCase();
        // replace parameter if already existent
        searchParam = location.search.replace(/([^=\?\&]+)=([^&]+)/gi, function (match, key, value, offset, originString) {
          if (key === opt_getKey) {
            paramReplaced = true;
            return key + '=' + param;
          }
          return match;
        });
        // otherwise append as new parameter
        if (!paramReplaced) {
          searchParam += '&' + opt_getKey + '=' + param;
        }
      } else {
        // this will be the only search-parameter in the URL
        searchParam = '?' + opt_getKey + '=' + param;
      }
      if (opt_execute) {
        location.search = searchParam;
        return true;
      }
      link += searchParam + location.hash;
    }

    return link;
  }, // end of setUrlParam()

  /**
   * Get search or hash URL-parameter as string.
   *
   * If `opt_getKey` is `false` or `undefined`, the hash-parameter of the URL is returned,
   * otherwise it will search for a GET-parameter and return its value.
   *
   * If a parameter is not existent, or empty, an empty string will be returned.
   *
   * @param   {undefined|string}  opt_getKey  Default: `undefined`
   *
   * @return  {string}                        The found parameter.
   */
  getUrlParam: function getUrlParam(opt_getKey) {
    var param, regEx;

    if (!opt_getKey) {
      param = location.hash.substring(1);
    } else {
      if (!location.search) {
        param = '';
      } else {
        regEx = new RegExp('[\?\&]' + opt_getKey + '=([^&]+)', 'i');
        param = regEx.exec(location.search);
        param = param ? param[1] : '';
      }
    }

    return param;
  }, // end of getUrlParam()

  /**
   * Delta-encode an array of numbers.
   * Note that the array will be sorted (lowest to highest)
   * before encoding.
   *
   * So after the encoding the first value of the output contains
   * the smallest number of the set and each following number just
   * represents the offset to its previous neighbor.
   *
   * This is mostly efficient for high numbers, that are "close to each other".
   *
   * Example:
   *   [1337, 11, 101, 123, 96, 69, 42, 42]
   *   will be sorted
   *   [11, 42, 42, 69, 96, 101, 123, 1337]
   *   and encoded to
   *   [11, 31, 0, 27, 27, 5, 22, 1214]
   *
   * @param   {array<numbers>}  arrInput  [description]
   *
   * @return  {array<numbers>}            [description]
   */
  deltaEncode: function deltaEncode(arrInput) {
    var arrOutput, i;

    if (!arrInput) {
      return [];
    }
    if (arrInput.length === 1) {
      return arrInput;
    }

    arrInput.sort(function (a, b) {
      return a - b;
    });

    arrOutput = [];
    arrOutput[0] = arrInput[0];
    for (i = 1; i < arrInput.length; i += 1) {
      arrOutput[i] = arrInput[i] - arrInput[i - 1];
    }

    return arrOutput;
  }, // end of deltaEncode()

  /**
   * Decode a delta-encoded array.
   * See `deltaEncode` function for more detailed information.
   *
   * @param   {array<numbers>}  arrInput  [description]
   *
   * @return  {array<numbers>}            [description]
   */
  deltaDecode: function deltaDecode(arrInput) {
    var arrOutput, i;

    if (!arrInput) {
      return [];
    }

    arrOutput = [];
    arrOutput[0] = parseInt(arrInput[0], 10);
    if (isNaN(arrInput[0])) {
      return [];
    }
    for (i = 1; i < arrInput.length; i += 1) {
      arrOutput[i] = parseInt(arrInput[i], 10) + arrOutput[i - 1];
      if (isNaN(arrOutput[i])) {
        return [];
      }
    }

    return arrOutput;
  }, // end of deltaDecode()

  /**
   * Check and call functions in `arrHookFunctions` with given `parameters`.
   *
   * @param   {array<function>}   arrHookFunctions  [description]
   * @param   {mixed}             parameters        [description]
   */
  callHookFunctions: function callHookFunctions(arrHookFunctions, parameters) {
    var j;

    if (arrHookFunctions && arrHookFunctions.length > 0) {
      for (j = 0; j < arrHookFunctions.length; j += 1) {
        if (typeof arrHookFunctions[j] === 'function') {
          arrHookFunctions[j](parameters);
        }
      }
    }
  }, // end of "callHookFunctions()"

  /**
   * Convert a hex-formated color value into rgba()-format.
   *
   * @param   {string|number}  hex          [description]
   * @param   {string|number}  opt_opacity  [description]
   *
   * @return  {string}                      [description]
   */
  getRgbaFromHexAndOpacity: function getRgbaFromHexAndOpacity(hex, opt_opacity, opt_array) {

    var bigint, r, g, b, a;

    bigint = parseInt(hex, 16);
    if (opt_opacity && opt_opacity.value) {
      opt_opacity.value = parseInt(opt_opacity.value);
    }

    if (opt_opacity && typeof opt_opacity !== 'number') {
      if ((typeof opt_opacity === "undefined" ? "undefined" : _typeof(opt_opacity)) === 'object' && opt_opacity.value) {
        opt_opacity = opt_opacity.value;
      } else {
        opt_opacity = 100;
      }
    }

    r = bigint >> 16 & 255;
    g = bigint >> 8 & 255;
    b = bigint & 255;
    a = opt_opacity ? opt_opacity / 100 : 1;
    if (opt_array) {
      return [r, g, b, a];
    }

    return "rgba(" + r + "," + g + "," + b + "," + a + ")";
  },

  /**
   * Measure the dimensions of the given geometry.
   *
   * If the geometry is a `LineString` the function will measure its length,
   * is it a `Polygon` it will measure the acreage,
   * otherwise it will return `0`.
   *
   * If the optional `opt_forceLineMeasure` parameter is `true`
   * and the geometry is a `Polygon` it will measure its perimeter instead
   * of its acreage.
   *
   * @param   {ol.geom.LineString|ol.geom.Polygon}   geometry              [description]
   * @param   {undefined|boolean}                    opt_forceLineMeasure  [description]
   *
   * @return  {array<string>|number}                                       [description]
   */
  measureGeometry: function measureGeometry(geometry, opt_forceLineMeasure, opt_forceSurfaceMeasure) {
    var value, sphere, coordinates, coord1, coord2, result, i;

    if (!geometry) {
      return false;
    }

    //sphere = new ol.Sphere(6378137);
    result = {};

    if (geometry instanceof ol.geom.LineString || geometry instanceof ol.geom.Polygon && opt_forceLineMeasure) {

      coordinates = geometry.getCoordinates();
      if (geometry instanceof ol.geom.Polygon) {
        coordinates = coordinates[0];
      }
      value = 0;
      for (i = 0; i < coordinates.length - 1; i += 1) {
        coord1 = ol.proj.transform(coordinates[i], 'EPSG:3857', 'EPSG:4326');
        coord2 = ol.proj.transform(coordinates[i + 1], 'EPSG:3857', 'EPSG:4326');
        value += ol.sphere.getDistance(coord1, coord2, 6378137);
      }
      result.rawValue = (Math.round(value * 100) / 100).toFixed(2);
      if (value > 1000) {
        result.htmlValue = (Math.round(value / 1000 * 100) / 100).toFixed(2) + ' ' + 'km';
      } else {
        result.htmlValue = result.rawValue + ' ' + 'm';
      }
    } else if (geometry instanceof ol.geom.Polygon) {
      //geometry = /** @type {ol.geom.Polygon} */(geometry.clone().transform('EPSG:3857', 'EPSG:4326'));
      //coordinates = geometry.getLinearRing(0).getCoordinates();
      value = Math.abs(ol.sphere.getArea(geometry));
      result.rawValue = (Math.round(value * 100) / 100).toFixed(2);
      if (value > 10000) {
        result.htmlValue = (Math.round(value / 1000000 * 100) / 100).toFixed(2) + ' ' + 'km<sup>2</sup>';
      } else {
        result.htmlValue = result.rawValue + ' ' + 'm<sup>2</sup>';
      }
    } else if (geometry instanceof ol.geom.Circle && opt_forceSurfaceMeasure) {
      var center = geometry.getCenter();
      var radius = geometry.getRadius();
      var edgeCoordinate = [center[0] + radius, center[1]];
      //var wgs84Sphere = new ol.Sphere(6378137);
      var value = ol.sphere.getDistance(ol.proj.transform(center, 'EPSG:3857', 'EPSG:4326'), ol.proj.transform(edgeCoordinate, 'EPSG:3857', 'EPSG:4326'), 6378137);

      value = Math.PI * Math.sqrt(value);

      result.rawValue = (Math.round(value * 100) / 100).toFixed(2);
      if (value > 10000) {
        result.htmlValue = (Math.round(value / 1000000 * 100) / 100).toFixed(2) + ' ' + 'km<sup>2</sup>';
      } else {
        result.htmlValue = result.rawValue + ' ' + 'm<sup>2</sup>';
      }
    } else if (geometry instanceof ol.geom.Circle) {
      var center = geometry.getCenter();
      var radius = geometry.getRadius();
      var edgeCoordinate = [center[0] + radius, center[1]];
      //var wgs84Sphere = new ol.Sphere(6378137);
      var value = ol.sphere.getDistance(ol.proj.transform(center, 'EPSG:3857', 'EPSG:4326'), ol.proj.transform(edgeCoordinate, 'EPSG:3857', 'EPSG:4326'), 6378137);

      result.rawValue = (Math.round(value * 100) / 100).toFixed(2);
      if (result.rawValue > 10000) {
        result.htmlValue = (Math.round(value * 100 / 100) / 1000).toFixed(2) + ' ' + 'km';
      } else {
        result.htmlValue = result.rawValue + ' ' + 'm';
      }
    } else {
      result = 0;
    }

    return result;
  },

  /**
   * Calculate extent for an array of geometries.
   *
   * @param   {Array.<ol.geom.simpleGeometry>}  arrGeometries  [description]
   *
   * @return  {ol.Extent}                                      [description]
   */
  getExtentForGeometries: function getExtentForGeometries(arrGeometries) {
    var extentSource;

    if (!arrGeometries) {
      console.warn('Geometries missing for extent calculation');
      return false;
    }

    extentSource = new ol.source.Vector();
    extentSource.addFeatures(arrGeometries);

    return extentSource.getExtent() || ol.Extent([0, 0, 0, 0]);
  }, // end of getExtentForGeometries()

  /**
   * Fit view of `map` to a given array of `extents`.
   * Animated if `opt_animationDuration` is an integer > 0.
   *
   * @param   {object}     extents                 [description]
   * @param   {ol.Map}     map                    [description]
   * @param   {integer}    opt_animationDuration  [description]
   *
   * @return  {boolean}                           [description]
   */
  fitToExtents: function fitToExtents(extents, map, opt_padding, opt_animationDuration) {
    var view, padding, extent, key;

    if (!extents || !map) {
      console.warn('Missing extent or map for fitExtent');
      return false;
    }
    //extent = ol.extent.createEmpty();

    for (key in extents) {
      if (extents.hasOwnProperty(key)) {
        if (typeof extent === "undefined") {
          extent = extents[key];
        } else {
          ol.extent.extend(extent, extents[key]);
        }
      }
    }

    this.fitToExtent(extent, map, opt_padding, 5, 0, 0, 2);
  }, // end of fitToExtents

  /**
   * Fit view of `map` to a given `extent`.
   * Animated if `opt_animationDuration` is an integer > 0.
   *
   * @param   {ol.Extent}  extent                 [description]
   * @param   {ol.Map}     map                    [description]
   * @param   {array}      opt_padding            [description]
   * @param   {integer}    opt_animationDuration  [description]
   * @param   {integer}    opt_minZoom            [description]
   * @param   {integer}    opt_maxZoom            [description]
   * @param   {integer}    opt_minResolution      [description]
   *
   * @return  {boolean}                           [description]
   */
  fitToExtent: function fitToExtent(extent, map, opt_padding, opt_animationDuration, opt_minZoom, opt_maxZoom, opt_minResolution) {
    var view, padding, fitOptions;

    if (!extent || !map) {
      console.warn('Missing extent or map for fitExtent');
      return false;
    }

    view = map.getView();

    fitOptions = {
      'padding': opt_padding || [25, 25, 25, 25]
    };

    if (opt_minResolution && opt_minResolution > 0) {
      fitOptions.minResolution = opt_minResolution;
    }

    if (opt_minZoom && opt_minZoom >= 0) {
      fitOptions.minZoom = opt_minZoom;
    }

    if (opt_maxZoom && opt_maxZoom >= 0) {
      fitOptions.maxZoom = opt_maxZoom;
    }

    // animate the "fitting" when a duration is given and its greater than 0
    if (opt_animationDuration && opt_animationDuration > 0) {
      view.animate({
        start: +new Date(),
        duration: opt_animationDuration,
        resolution: view.getResolution(),
        center: [0, 0]
      });
    }

    try {
      view.fit(extent, map.getSize(), { padding: [25, 25, 25, 25] });
      //view.fit(extent, map.getSize());
      //view.setZoom(view.getZoom()-1);
      return true;
    } catch (e) {
      return false;
    }
  }, // end of fitToExtent()

  /**
   * Convenience function to run all placeholder functions at once.
   *
   * @param   {string}                      strInput   [description]
   * @param   {ol.Feature}                  feature    [description]
   * @param   {ol.layer.Layer | undefined}  opt_layer  [description]
   * @param   {string}                      language   [description]
   *
   * @return  {string}                                 [description]
   */
  replaceAllPlaceholders: function replaceAllPlaceholders(strInput, feature, opt_layer, language) {
    var strOutput;

    // only check the first two parameters as they will be used by all placeholder-functions
    // -> for performance
    if (!strInput || !feature) {
      return strInput;
    }

    strOutput = this.replaceFunctionPlaceholders(strInput, feature, opt_layer, language);
    strOutput = this.replaceEditorVarsPlaceholders(strOutput, feature);
    strOutput = this.replaceAttributePlaceholders(strOutput, feature);

    return strOutput;
  }, // end of replaceAllPlaceholders()

  /**
   * Replace every occurance of `${FNfunctionName}`, in `strInput`,
   * with the result of `window.functionName(feature, style)`, if it exist.
   * Otherwise the placeholder will be simply removed (/replaced with '').
   * Style will be taken either from the feature, or the layer.
   *
   * @param   {string}          strInput  [description]
   * @param   {ol.Feature}      feature   [description]
   * @param   {ol.layer.Layer}  layer     [description]
   * @param   {string}          language  [description]
   *
   * @return  {string}                    [description]
   */
  replaceFunctionPlaceholders: function replaceFunctionPlaceholders(strInput, feature, layer, language) {
    var strOutput;

    if (!strInput || !feature || !layer) {
      return strInput;
    }
    popupFunctions = language === 'de' || language === 'de-DE' ? popupFunctionsDE : popupFunctionsEN;

    strOutput = strInput.replace(/\$\{FN([^\}]*)\}/g, function (match, functionName, offset, originString) {
      var style;

      // check if function exists
      if (typeof popupFunctions[functionName] === 'function') {
        // search style
        if (typeof feature.getStyle === 'function' && feature.getStyle() && typeof feature.getStyle() === 'function') {
          style = feature.getStyle();
        } else if (typeof layer.getStyle === 'function' && layer.getStyle()) {
          style = layer.getStyle();
        } else {
          return '';
        }
        return popupFunctions[functionName](feature, style);
      }
      return '';
    }); // end of replace()

    return strOutput;
  }, // end of replaceFunctionPlaceholders()

  /**
   * Replace placeholders, in `strInput`, for variables set by the geoEditor.
   * Valid placeholders are: ([key] represents the stringname of the variables key)
   *   `${EL[key]}`   =>  Label for the variable
   *   `${EVL[key]}`  =>  Label for the variable, if a value is set too
   *   `${EV[key]}`   =>  Value of the variable
   *   `${EVV[key]}`  =>  Same as `${EV[key]}`
   *
   * If no appropriate value can be found for a placeholder
   * it will simply be removed (/replaced with '').
   *
   * @param   {string}      strInput  [description]
   * @param   {ol.Feature}  feature   [description]
   *
   * @return  {string}                [description]
   */
  replaceEditorVarsPlaceholders: function replaceEditorVarsPlaceholders(strInput, feature) {
    var strOutput;

    if (!strInput || !feature || typeof feature.get !== 'function') {
      return strInput;
    }

    strOutput = strInput.replace(/\$\{(EV?[LV])([^\}]*)\}/g, function (match, type, evKey, offset, originString) {
      var editorVars, i;

      // check if feature has editorVars
      if (feature.get('editorVars')) {
        editorVars = feature.get('editorVars');
        // search for editorVar with key == evKey
        for (i = 0; i < editorVars.length; i += 1) {
          if (editorVars[i].key === evKey) {
            // if type is 'EVL' display label only if a value is set too
            if (type === 'EL' || type === 'EVL' && editorVars[i].value) {
              return editorVars[i].label;
            } else {
              return editorVars[i].value;
            }
          }
        }
      }
      return '';
    }); // end of replace()

    return strOutput;
  }, // end of replaceEditorVarsPlaceholders()

  /**
   * Replace every occurance of `${attr}`, in `strInput`,
   * with the result of `feature.get(attr)`, if it exist.
   * Otherwise the placeholder will be simply removed (/replaced with '').
   *
   * @param   {string}      strInput  [description]
   * @param   {ol.Feature}  feature   [description]
   *
   * @return  {string}                [description]
   */
  replaceAttributePlaceholders: function replaceAttributePlaceholders(strInput, feature) {
    var strOutput;

    if (!strInput || !feature || typeof feature.get !== 'function') {
      return strInput;
    }

    strOutput = strInput.replace(/\$\{([^\}]*)\}/g, function (match, attr, offset, originString) {
      return feature.get(attr) || '';
    }); // end of replace()

    return strOutput;
  }, // end of replaceAttributePlaceholders()

  objectToArray: function objectToArray(object) {
    if (object && (typeof object === "undefined" ? "undefined" : _typeof(object)) === 'object') {
      object = Object.keys(object).map(function (key) {
        return object[key];
      });
    }
    return object;
  }, // end of objectToArray()

  getVectorLayer: function getVectorLayer(source, style) {
    var fnStyle;

    // make sure that the style is a function
    if (typeof style === 'function') {
      fnStyle = style;
    } else if (style !== undefined) {
      fnStyle = function fnStyle() {
        return style;
      };
    }

    return new ol.layer.Vector({
      source: source,
      style: fnStyle
    });
  },
  // end of "getVectorLayer()"

  /**
   * Extracts the subdomain from the current request host and returns it.
   * @returns {string | *}
   */
  getCurrentSubdomain: function getCurrentSubdomain() {
    return window.location.href;
  },


  /**
   * Returns the current domain (without the subdomain)
   */
  getCurrentDomain: function getCurrentDomain() {
    var domain = window.location.hostname;
    var arrDomain = domain.split('.');
    if (arrDomain.length > 2) {
      // there is a subdomain
      return arrDomain[arrDomain.length - 2];
    } else {
      return arrDomain[0];
    }
  },


  getValue: function getValue(key) {
    return localStorage[key] || '';
  },
  storeValue: function storeValue(key, value) {
    localStorage[key] = value; // only strings
  }
};

/***/ }),

/***/ "./Resources/public/js/c4g-maps.js":
/*!*****************************************!*\
  !*** ./Resources/public/js/c4g-maps.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MapController = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * This file is part of con4gis,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * the gis-kit for Contao CMS.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @package    con4gis
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @version    6
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @author     con4gis contributors (see "authors.txt")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @license    LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @copyright  Küstenschmiede GmbH Software & Design
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @link       https://www.con4gis.org
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _c4gMapsProxy = __webpack_require__(/*! ./c4g-maps-proxy */ "./Resources/public/js/c4g-maps-proxy.js");

var _c4gMapsConstant = __webpack_require__(/*! ./c4g-maps-constant */ "./Resources/public/js/c4g-maps-constant.js");

var _c4gMapsMiscSpinner = __webpack_require__(/*! ./c4g-maps-misc-spinner */ "./Resources/public/js/c4g-maps-misc-spinner.js");

var _c4gMapsMiscMaphover = __webpack_require__(/*! ./c4g-maps-misc-maphover */ "./Resources/public/js/c4g-maps-misc-maphover.js");

var _c4gMapsUtils = __webpack_require__(/*! ./c4g-maps-utils */ "./Resources/public/js/c4g-maps-utils.js");

var _c4gMapsControlPortsideMeasuretools = __webpack_require__(/*! ./c4g-maps-control-portside-measuretools */ "./Resources/public/js/c4g-maps-control-portside-measuretools.js");

var _c4gMapsControlPrint = __webpack_require__(/*! ./c4g-maps-control-print */ "./Resources/public/js/c4g-maps-control-print.js");

var _c4gMapsControlGrid = __webpack_require__(/*! ./c4g-maps-control-grid */ "./Resources/public/js/c4g-maps-control-grid.js");

var _c4gMapsControlZoomlevel = __webpack_require__(/*! ./c4g-maps-control-zoomlevel */ "./Resources/public/js/c4g-maps-control-zoomlevel.js");

var _c4gMapsControlOverviewmap = __webpack_require__(/*! ./c4g-maps-control-overviewmap */ "./Resources/public/js/c4g-maps-control-overviewmap.js");

var _c4gMapsControlGeosearch = __webpack_require__(/*! ./c4g-maps-control-geosearch */ "./Resources/public/js/c4g-maps-control-geosearch.js");

var _c4gMapsControlPermalink = __webpack_require__(/*! ./c4g-maps-control-permalink */ "./Resources/public/js/c4g-maps-control-permalink.js");

var _c4gMapsControlStarboard = __webpack_require__(/*! ./c4g-maps-control-starboard */ "./Resources/public/js/c4g-maps-control-starboard.js");

var _c4gMapsControlPortsideAccount = __webpack_require__(/*! ./c4g-maps-control-portside-account */ "./Resources/public/js/c4g-maps-control-portside-account.js");

var _c4gMapsInteractionGeopicker = __webpack_require__(/*! ./c4g-maps-interaction-geopicker */ "./Resources/public/js/c4g-maps-interaction-geopicker.js");

var _c4gMapsControlHome = __webpack_require__(/*! ./c4g-maps-control-home */ "./Resources/public/js/c4g-maps-control-home.js");

var _c4gMapsControlPosition = __webpack_require__(/*! ./c4g-maps-control-position */ "./Resources/public/js/c4g-maps-control-position.js");

var _c4gMapsControlPortsideInfopage = __webpack_require__(/*! ./c4g-maps-control-portside-infopage */ "./Resources/public/js/c4g-maps-control-portside-infopage.js");

var _c4gMapsI18n = __webpack_require__(/*! ./c4g-maps-i18n */ "./Resources/public/js/c4g-maps-i18n.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var langConstants = {};

'use strict';

var MapController = exports.MapController = function () {

  /**
   * [MapController description]
   * @param {json-object}  mapData  Object to configure con4gis-maps.
   *                                See "docs/mapData-values.md"
   *                                to get a list of valid values for this object.
   */
  function MapController(mapData) {
    _classCallCheck(this, MapController);

    //---
    this.map = null;
    // this.controls = null;
    this.leftSlideElements = [];
    this.rightSlideElements = [];
    langConstants = (0, _c4gMapsI18n.getLanguage)(mapData);

    var self = this,
        permalink = false,
        minZoom,
        maxZoom,
        view,
        geoLocation,
        controls = [],
        interactions = [],
        _displayAllLocations,
        domMapDiv,
        kinetic,
        controlContainerTopLeft,
        controlContainerBottomLeft,
        controlContainerTopRight,
        controlContainerBottomRight,
        controlContainerBottomLeftSub,
        starboard_label,
        logoLink,
        logoGraphic,
        removeElement,
        enableStarboard = true;

    //--
    mapData = jQuery.extend({
      api: {},
      addIdToDiv: false,
      mapId: 1,
      mapDiv: 'c4g_map',
      center: {},
      calc_extent: 'CENTERZOOM',
      attribution: {},
      editor: {},
      measuretools: {},
      infopage: {},
      account: '',
      starboard: {},
      layerswitcher: {},
      baselayerswitcher: {},
      geosearch: {}
    }, mapData);
    if (mapData.calc_extent === 'LOCATIONS') {
      mapData = jQuery.extend({
        min_gap: 25
      }, mapData);
    }

    // center
    mapData.center = jQuery.extend({
      lat: 52.22,
      lon: 9.43,
      rotation: 0,
      zoom: 6
    }, mapData.center);
    // attribution
    mapData.attribution = jQuery.extend({
      enable: true,
      collapsed: false,
      collapsible: true
    }, mapData.attribution);
    // geosearch
    mapData.geosearch = jQuery.extend({
      enable: false,
      div: false
    }, mapData.geosearch);
    // permalink
    mapData.permalink = jQuery.extend({
      enable: false,
      get_parameter: false
    }, mapData.permalink);
    this.data = mapData;
    if (mapData.addIdToDiv) {
      mapData.mapDiv += '_' + mapData.mapId;
    }
    // PHPStorm marks this as error, but it is none
    // This is needed for preventing an error with the OSM-Overpass API
    // which occurs when MooTools is loaded
    if (window.MooTools && Browser.Document) {
      Document = Browser.Document;
    }
    this.proxy = new _c4gMapsProxy.MapProxy({ mapController: this });

    // check permalink
    if (mapData.permalink.enable) {
      permalink = _c4gMapsUtils.utils.getUrlParam(mapData.permalink.get_parameter);

      if (permalink) {
        permalink = permalink.split('/');
        switch (permalink.length) {
          case 6:
            permalink[0] = parseFloat(permalink[0]);
            mapData.center.lon = !isNaN(permalink[0]) ? permalink[0] : mapData.center.lon;
            permalink[1] = parseFloat(permalink[1]);
            mapData.center.lat = !isNaN(permalink[1]) ? permalink[1] : mapData.center.lat;
            permalink[2] = parseInt(permalink[2], 10);
            mapData.center.zoom = !isNaN(permalink[2]) ? permalink[2] : mapData.center.zoom;
            permalink[3] = parseFloat(permalink[3]);
            mapData.center.rotation = !isNaN(permalink[3]) ? permalink[3] : mapData.center.rotation;
            permalink[4] = parseInt(permalink[4], 10);
            mapData.baselayer = !isNaN(permalink[4]) ? permalink[4] : mapData.baselayer;
            mapData.layers = permalink[5].split(':');
            // decode deltaEncoding
            mapData.layers = _c4gMapsUtils.utils.deltaDecode(mapData.layers);
            break;
          case 2:
            // baselayer and layers only
            permalink[0] = parseInt(permalink[0], 10);
            mapData.baselayer = !isNaN(permalink[0]) ? permalink[0] : mapData.baselayer;
            mapData.layers = permalink[1].split(':');
            // decode deltaEncoding
            mapData.layers = _c4gMapsUtils.utils.deltaDecode(mapData.layers);
            break;
          case 1:
            // layers only
            mapData.layers = permalink[0].split(':');
            // decode deltaEncoding
            mapData.layers = _c4gMapsUtils.utils.deltaDecode(mapData.layers);
            break;
          default:
            // invalid count of permalink parameters
            permalink = false;
        }
        if (mapData.layers.length < 1) {
          mapData.layers = false;
          permalink = false;
        }
      } else {
        // just to make sure this var is really "false"
        permalink = false;
      }
    }

    if (mapData.minZoom && mapData.minZoom > 0) {
      minZoom = mapData.minZoom;
    } else {
      minZoom = 0;
    }

    if (mapData.maxZoom && mapData.maxZoom > 0) {
      maxZoom = mapData.maxZoom;
    } else {
      maxZoom = 19;
    }

    if (mapData.caching) {
      if (_c4gMapsUtils.utils.getValue('lon') && _c4gMapsUtils.utils.getValue('lat')) {
        mapData.center.lon = _c4gMapsUtils.utils.getValue('lon');
        mapData.center.lat = _c4gMapsUtils.utils.getValue('lat');
      }

      if (_c4gMapsUtils.utils.getValue('zoom')) {
        mapData.center.zoom = _c4gMapsUtils.utils.getValue('zoom');
      }
    }

    view = new ol.View({
      // projection: ol.proj.get('EPSG:4326'),
      // center: [parseFloat(mapData.center_lon), parseFloat(mapData.center_lat)],
      // minResolution: undefined,
      // maxResolution: undefined,
      center: ol.proj.transform([parseFloat(mapData.center.lon), parseFloat(mapData.center.lat)], 'EPSG:4326', 'EPSG:3857'),
      zoom: parseInt(mapData.center.zoom, 10),
      minZoom: parseInt(minZoom, 10),
      maxZoom: parseInt(maxZoom, 10),
      rotation: parseFloat(mapData.center.rotation)
    });

    // check userposition
    if (mapData.geolocation && !permalink) {
      geoLocation = new ol.Geolocation({
        //tracking: !mapData.geopicker,
        tracking: true,
        projection: view.getProjection()
      });
      geoLocation.on('change', function (evt) {
        if (geoLocation) {
          view.setCenter(geoLocation.getPosition());
          if (mapData.geolocation_zoom) {
            view.setZoom(parseInt(mapData.geolocation_zoom, 10));
          }
          geoLocation.setTracking(false);
          if (self.map) {
            self.map.setView(view);
            if (self.$overlaycontainer_stopevent) {
              // utils.redrawMapView(self);
            }
          }
        }
      });
    }

    // enable default Controls/Interactions if there is no profile
    // [note]: maybe change this in the future? -> "no default"-option?
    if (!mapData.profile) {
      controls = ol.control.defaults();
      interactions = ol.interaction.defaults();
    }

    // set default base layer when backend geopicker is enabled
    if (mapData.geopicker && mapData.geopicker.type === "backend") {
      if (mapData.default_baselayer) {
        this.proxy.hook_baselayer_loaded.push(function (baselayerIds) {
          self.proxy.baselayerController.showBaseLayer(mapData.default_baselayer);
        });
      } // end inner if
      this.map = new ol.Map({
        controls: controls,
        interactions: interactions,
        layers: [new ol.layer.Group({
          title: 'Base maps',
          layers: [],
          checkSum: 'baseMapsLayer'
        })],
        loadTilesWhileAnimating: true,
        target: mapData.mapDiv,
        view: view
      });
    } else {
      // initialize Map
      //

      if (mapData.default_baselayer) {
        this.proxy.hook_baselayer_loaded.push(function (baselayerIds) {
          if (mapData.baselayer && baselayerIds.indexOf(mapData.baselayer.toString()) > -1) {
            mapData.default_baselayer = mapData.baselayer;
          }

          if (mapData.caching) {
            if (_c4gMapsUtils.utils.getValue('baselayer')) {
              mapData.default_baselayer = _c4gMapsUtils.utils.getValue('baselayer');
            }
          }

          self.proxy.baselayerController.showBaseLayer(mapData.default_baselayer);
        });
      }
      this.map = new ol.Map({
        controls: controls,
        interactions: interactions,
        layers: [new ol.layer.Group({
          title: 'Base maps',
          layers: [],
          checkSum: 'baseMapsLayer'
        })],
        loadTilesWhileAnimating: true,
        target: mapData.mapDiv,
        view: view
      });
    }

    mapData.map = this.map;

    // set extent to make all locations visible if wanted
    if (mapData.calc_extent === "LOCATIONS") {
      _displayAllLocations = function displayAllLocations(layerIds) {
        var layers = self.proxy.layerController.arrLayers,
            layer,
            geometry,
            coords,
            padding,
            coordinates,
            extent,
            featureList,
            featureArray,
            key,
            vectorArray,
            layerGroup,
            center;
        // delete function from hook array
        delete this[this.indexOf(_displayAllLocations)];
        coordinates = [];
        // calculate resulting extent of all geometries
        for (key in layers) {
          if (layers.hasOwnProperty(key)) {
            layer = layers[key];
            if (layer.type == "overpass") {
              continue;
            }
            vectorArray = layer.content;
            if (vectorArray === undefined) {
              // catch case of linked layers
              continue;
            }
            if ((typeof vectorArray === "undefined" ? "undefined" : _typeof(vectorArray)) === "object") {
              vectorArray = _c4gMapsUtils.utils.objectToArray(vectorArray);
            }
            layerGroup = layer.vectorLayer;
            if (vectorArray && vectorArray.forEach && typeof vectorArray.forEach === 'function') {
              vectorArray.forEach(function (vectorLayer) {
                if (vectorLayer && vectorLayer.data && vectorLayer.data.geometry && vectorLayer.data.geometry.coordinates) {
                  if (vectorLayer.data.geometry.type === "Point") {
                    coords = ol.proj.transform([parseFloat(vectorLayer.data.geometry.coordinates[0]), parseFloat(vectorLayer.data.geometry.coordinates[1])], 'EPSG:4326', 'EPSG:3857');
                    if (coords[0] == "Infinity" || coords[0] == "-Infinity") {
                      return;
                    }
                    geometry = new ol.geom.Point(coords);
                    coordinates.push(geometry.getCoordinates());
                  }
                }
              });
            }
            if (layerGroup) {
              // handle more complex geometries
              featureList = layerGroup.getLayers();
              featureArray = featureList.getArray();
              featureArray.forEach(function (feature) {
                if (layer.type === "kml") {
                  var source = feature.getSource();
                  //var sourceFeatures = source.getFeatures();
                  source.getExtent().forEach(function (coordinate) {
                    coordinates.push(coordinate);
                  });
                } else {
                  coordinates.push(ol.extent.getTopRight(feature.getSource().getExtent()));
                  coordinates.push(ol.extent.getTopLeft(feature.getSource().getExtent()));
                  coordinates.push(ol.extent.getBottomRight(feature.getSource().getExtent()));
                  coordinates.push(ol.extent.getBottomLeft(feature.getSource().getExtent()));
                }
              });
            }
          }
        }
        extent = ol.extent.boundingExtent(coordinates);
        if (extent[0] == "Infinity" || extent[0] == "-Infinity") {
          return;
        }
        //TODO: catch case min_gap is already an array
        padding = [mapData.min_gap, mapData.min_gap, mapData.min_gap, mapData.min_gap];
        self.map.getView().fit(extent, self.map.getSize(), { padding: padding });
        center = self.map.getView().getCenter();
        if (isNaN(center[0])) {
          self.map.getView().setCenter([50, 10]);
          self.map.getView().setZoom(mapData.minZoom || 10);
        }
      };
      this.proxy.hook_layer_visibility.push(_displayAllLocations);
    }

    // set map-size and -margin
    domMapDiv = document.getElementById(mapData.mapDiv);

    if (domMapDiv && domMapDiv.style) {
      if (mapData.width) {
        domMapDiv.style.width = mapData.width;
      }
      if (mapData.height) {
        domMapDiv.style.height = mapData.height;
      }
      if (mapData.margin) {
        domMapDiv.style.margin = mapData.margin;
      }
    } else {
      console.warn('can not get element by id mapData.mapDiv');
      return;
    }

    this.map.updateSize();
    this.proxy.initialize();
    // this.proxy.loadBaseLayers();
    // this.proxy.loadLayers();
    // ---

    // save overlaycontainer
    this.$overlaycontainer_stopevent = jQuery('#' + mapData.mapDiv + ' .' + _c4gMapsConstant.cssConstants.OL_OVERLAYCONTAINER_SE);
    // add Spinner
    this.spinner = new _c4gMapsMiscSpinner.Spinner({ className: _c4gMapsConstant.cssConstants.LARGE });
    // add mapHover
    this.mapHover = new _c4gMapsMiscMaphover.MapHover({ mapController: this });

    // add interactions ===
    //

    // mouse navigation
    if (mapData.mouse_nav) {
      // drag pan and kinetic scrolling
      if (mapData.mouse_nav.drag_pan) {
        kinetic = mapData.mouse_nav.kinetic ? new ol.Kinetic(-0.005, 0.05, 100) : null;
        this.map.addInteraction(new ol.interaction.DragPan({ kinetic: kinetic }));
      }
      // mousewheel zoom
      if (mapData.mouse_nav.wheel_zoom) {
        this.map.addInteraction(new ol.interaction.MouseWheelZoom());
      }
      // doubleclick zoom
      if (mapData.mouse_nav.doubleclick_zoom) {
        this.map.addInteraction(new ol.interaction.DoubleClickZoom());
      }
      // box zoom
      if (mapData.mouse_nav.drag_zoom) {
        this.map.addInteraction(new ol.interaction.DragZoom({ condition: ol.events.condition.shiftKeyOnly }));
      }
      // drag rotate (& zoom)
      ol.events.condition.custom = function (mapBrowserEvent) {
        var browserEvent = mapBrowserEvent.originalEvent;
        return browserEvent.ctrlKey && browserEvent.shiftKey;
      };

      if (mapData.mouse_nav.drag_rotate_zoom) {
        this.map.addInteraction(new ol.interaction.DragRotateAndZoom({ condition: ol.events.condition.custom }));
      } else if (mapData.mouse_nav.drag_rotate) {
        this.map.addInteraction(new ol.interaction.DragRotate({ condition: ol.events.condition.custom }));
      }
    }
    // touch navigation
    if (mapData.touch_nav) {
      // rotate (pinch)
      if (mapData.touch_nav.rotate) {
        this.map.addInteraction(new ol.interaction.PinchRotate());
      }
      // zoom (pinch)
      if (mapData.touch_nav.zoom) {
        this.map.addInteraction(new ol.interaction.PinchZoom({ constrainResolution: true }));
      }
    }
    // keyboard navigation
    if (mapData.keyboard_nav) {
      // pan (arrow keys)
      if (mapData.keyboard_nav.pan) {
        this.map.addInteraction(new ol.interaction.KeyboardPan());
      }
      // zoom ("+" and "-" key)
      if (mapData.keyboard_nav.zoom) {
        this.map.addInteraction(new ol.interaction.KeyboardZoom());
      }
    }
    // ===

    // add control-containers ===
    //
    // top-left
    controlContainerTopLeft = document.createElement('div');
    controlContainerTopLeft.className = _c4gMapsConstant.cssConstants.CONTROL_CONTAINER_TL + ' ' + _c4gMapsConstant.cssConstants.OL_UNSELECTABLE;
    this.$overlaycontainer_stopevent.prepend(controlContainerTopLeft);
    // bottom-left
    controlContainerBottomLeft = document.createElement('div');
    controlContainerBottomLeft.className = _c4gMapsConstant.cssConstants.CONTROL_CONTAINER_BL + ' ' + _c4gMapsConstant.cssConstants.OL_UNSELECTABLE;
    jQuery(controlContainerTopLeft).after(controlContainerBottomLeft);
    // element needs to be moved when Portside will be opened
    this.leftSlideElements.push(controlContainerBottomLeft);
    // top-right
    controlContainerTopRight = document.createElement('div');
    controlContainerTopRight.className = _c4gMapsConstant.cssConstants.CONTROL_CONTAINER_TR + ' ' + _c4gMapsConstant.cssConstants.OL_UNSELECTABLE;
    jQuery(controlContainerBottomLeft).after(controlContainerTopRight);
    // element needs to be moved when Starboard will be opened
    this.rightSlideElements.push(controlContainerTopRight);
    // bottom-right
    controlContainerBottomRight = document.createElement('div');
    controlContainerBottomRight.className = _c4gMapsConstant.cssConstants.CONTROL_CONTAINER_BR + ' ' + _c4gMapsConstant.cssConstants.OL_UNSELECTABLE;
    jQuery(controlContainerTopRight).after(controlContainerBottomRight);
    // element needs to be moved when Starboard will be opened
    this.rightSlideElements.push(controlContainerBottomRight);
    // ===
    // add controls ===
    this.controls = {};
    //


    // account
    if (mapData.account && typeof _c4gMapsControlPortsideAccount.Account === 'function') {
      this.controls.account = new _c4gMapsControlPortsideAccount.Account({
        tipLabel: langConstants.CTRL_ACCOUNT,
        target: controlContainerTopLeft,
        caching: mapData.caching,
        mapController: this
      });
      this.map.addControl(this.controls.account);
      // open if opened before
      if (mapData.caching && _c4gMapsUtils.utils.getValue(this.controls.account.options.name) === '1') {
        this.controls.account.open();
      }
    }

    // zoom-controls
    if (mapData.zoom_panel || mapData.zoom_slider) {
      this.controls.zoom = new ol.control.Zoom({
        zoomInLabel: ' ',
        zoomOutLabel: ' ',
        zoomInTipLabel: langConstants.CTRL_ZOOM_IN,
        zoomOutTipLabel: langConstants.CTRL_ZOOM_OUT,
        target: controlContainerTopLeft
      });
      this.map.addControl(this.controls.zoom);

      if (mapData.zoom_slider) {
        this.controls.zoomslider = new ol.control.ZoomSlider({
          label: ' ',
          tipLabel: langConstants.CTRL_ZOOM_SLIDER,
          target: controlContainerTopLeft
        });
        this.map.addControl(this.controls.zoomslider);
      }
    }
    if (mapData.zoom_extent & !mapData.zoom_slider) {
      this.controls.zoom_extent = new ol.control.ZoomToExtent({
        label: ' ',
        tipLabel: langConstants.CTRL_ZOOM_EXT,
        target: controlContainerTopLeft
      });
      this.map.addControl(this.controls.zoom_extent);
    }
    if (mapData.zoom_home & !mapData.zoom_slider) {
      this.controls.zoom_home = new _c4gMapsControlHome.Home({
        label: ' ',
        disableLabel: ' ',
        tipLabel: langConstants.CTRL_ZOOM_HOME,
        target: controlContainerTopLeft,
        mapController: this
      });
      this.map.addControl(this.controls.zoom_home);
    }

    if (mapData.zoom_position & !mapData.zoom_slider) {
      this.controls.zoom_position = new _c4gMapsControlPosition.Position({
        label: ' ',
        disableLabel: ' ',
        tipLabel: langConstants.CTRL_ZOOM_POS,
        target: controlContainerTopLeft,
        mapController: this
      });
      this.map.addControl(this.controls.zoom_position);
    }

    // combined zoom-controls
    if (mapData.zoom_slider) {
      jQuery('#' + mapData.mapDiv + ' .' + _c4gMapsConstant.cssConstants.OL_ZOOM).addClass(_c4gMapsConstant.cssConstants.OL_ZOOM_WITH_SLIDER).removeClass(_c4gMapsConstant.cssConstants.OL_ZOOM);
      jQuery('#' + mapData.mapDiv + ' .' + _c4gMapsConstant.cssConstants.OL_ZOOM_IN).after(jQuery('#' + mapData.mapDiv + ' .' + _c4gMapsConstant.cssConstants.OL_ZOOM_SLIDER + ' button').addClass(_c4gMapsConstant.cssConstants.OL_ZOOM_SLIDER));
      jQuery('#' + mapData.mapDiv + ' .' + _c4gMapsConstant.cssConstants.OL_ZOOM_SLIDER + '.' + _c4gMapsConstant.cssConstants.OL_CONTROL).remove();
    }

    if (mapData.zoom_panel && mapData.zoom_extent) {
      jQuery('#' + mapData.mapDiv + ' .' + _c4gMapsConstant.cssConstants.OL_ZOOM).addClass(_c4gMapsConstant.cssConstants.OL_ZOOM_WITH_EXT).removeClass(_c4gMapsConstant.cssConstants.OL_ZOOM);
      jQuery('#' + mapData.mapDiv + ' .' + _c4gMapsConstant.cssConstants.OL_ZOOM_IN).after(jQuery('#' + mapData.mapDiv + ' .' + _c4gMapsConstant.cssConstants.OL_ZOOM_EXT + ' button').addClass(_c4gMapsConstant.cssConstants.OL_ZOOM_EXT));
      jQuery('#' + mapData.mapDiv + ' .' + _c4gMapsConstant.cssConstants.OL_ZOOM_EXT + '.' + _c4gMapsConstant.cssConstants.OL_CONTROL).remove();
    }

    if (mapData.zoom_panel && mapData.zoom_home) {
      jQuery('#' + mapData.mapDiv + ' .' + _c4gMapsConstant.cssConstants.OL_ZOOM).addClass(_c4gMapsConstant.cssConstants.OL_ZOOM_WITH_HOME).removeClass(_c4gMapsConstant.cssConstants.OL_ZOOM);
      jQuery('#' + mapData.mapDiv + ' .' + _c4gMapsConstant.cssConstants.OL_ZOOM_IN).after(jQuery('#' + mapData.mapDiv + ' .' + _c4gMapsConstant.cssConstants.OL_ZOOM_HOME + ' button').addClass(_c4gMapsConstant.cssConstants.OL_ZOOM_HOME));
      removeElement = controlContainerTopLeft.querySelector('.' + _c4gMapsConstant.cssConstants.OL_ZOOM_HOME + '.' + _c4gMapsConstant.cssConstants.OL_UNSELECTABLE + '.button');
      if (removeElement) {
        try {
          removeElement.remove();
        } catch (err) {
          //ie 11 error
        }
      }
    }

    if (mapData.zoom_panel && mapData.zoom_position) {
      jQuery('#' + mapData.mapDiv + ' .' + _c4gMapsConstant.cssConstants.OL_ZOOM).addClass(_c4gMapsConstant.cssConstants.OL_ZOOM_WITH_POS).removeClass(_c4gMapsConstant.cssConstants.OL_ZOOM);
      jQuery('#' + mapData.mapDiv + ' .' + _c4gMapsConstant.cssConstants.OL_ZOOM_IN).after(jQuery('#' + mapData.mapDiv + ' .' + _c4gMapsConstant.cssConstants.OL_ZOOM_POS + ' button').addClass(_c4gMapsConstant.cssConstants.OL_ZOOM_POS));
      jQuery('#' + mapData.mapDiv + ' .' + _c4gMapsConstant.cssConstants.OL_ZOOM_POS + '.' + _c4gMapsConstant.cssConstants.OL_CONTROL).remove();
      removeElement = controlContainerTopLeft.querySelector('.' + _c4gMapsConstant.cssConstants.OL_ZOOM_POS + '.' + _c4gMapsConstant.cssConstants.OL_UNSELECTABLE + '.button');
      if (removeElement) {
        try {
          removeElement.remove();
        } catch (err) {
          //ie 11 error
        }
      }
    }

    // fullscreen
    if (mapData.fullscreen) {
      this.controls.fullscreen = new ol.control.FullScreen({
        label: ' ',
        labelActive: ' ',
        tipLabel: langConstants.CTRL_FULLSCREEN,
        target: controlContainerTopLeft
      });
      this.map.addControl(this.controls.fullscreen);
    }

    // measuretools
    if (mapData.measuretools.enable && typeof _c4gMapsControlPortsideMeasuretools.Measuretools === 'function') {
      this.controls.measuretools = new _c4gMapsControlPortsideMeasuretools.Measuretools({
        tipLabel: langConstants.CTRL_MEASURETOOLS,
        target: controlContainerTopLeft,
        caching: mapData.caching,
        mapController: this
      });
      this.map.addControl(this.controls.measuretools);
      // open if opened before
      if (mapData.caching && _c4gMapsUtils.utils.getValue(this.controls.measuretools.options.name) === '1') {
        this.controls.measuretools.open();
      }
    }
    //
    if (mapData.print) {
      this.controls.print = new _c4gMapsControlPrint.Print({
        label: "",
        tipLabel: langConstants.CTRL_PRINT,
        target: controlContainerTopLeft,
        mapController: this
      });
      this.map.addControl(this.controls.print);
    }

    // show graticule (grid)
    if (mapData.graticule) {
      this.controls.graticule = new _c4gMapsControlGrid.Grid({
        label: ' ',
        disableLabel: ' ',
        tipLabel: langConstants.CTRL_GRID,
        caching: mapData.caching,
        target: controlContainerTopLeft,
        mapController: this
      });
      this.map.addControl(this.controls.graticule);
    }
    // rotate-control
    //TODO: use something like "mapData.rotate"
    //   Check: mapData.mouse_nav (defined?)
    if (mapData.mouse_nav && (mapData.mouse_nav.drag_rotate || mapData.mouse_nav.drag_rotate && mapData.mouse_nav.drag_rotate_zoom)) {
      this.controls.rotate = new ol.control.Rotate({
        label: ' ',
        tipLabel: langConstants.CTRL_RESET_ROTATION,
        target: controlContainerTopLeft
      });
      this.map.addControl(this.controls.rotate);
    }
    // infopage
    if (mapData.infopage && typeof _c4gMapsControlPortsideInfopage.Infopage === 'function') {
      this.controls.infopage = new _c4gMapsControlPortsideInfopage.Infopage({
        tipLabel: langConstants.CTRL_INFOPAGE,
        target: controlContainerTopLeft,
        caching: mapData.caching,
        mapController: this
      });
      this.map.addControl(this.controls.infopage);
      // open if opened before
      if (mapData.caching && _c4gMapsUtils.utils.getValue(this.controls.infopage.options.name) === '1') {
        this.controls.infopage.open();
      }
    }
    // @ToDo mapData.additionalPanel is always true, because it is set as an new object in the beginning. Therefore the second parameter of the boolean is requested, which throws an error
    // additionalPanel is furthermore not found anywhere in Maps and should be loaded over a hook

    // if (mapData.additionalPanel && typeof c4g.maps.control.additionalPanel === 'function') {
    //   this.controls.additionalPanel = new c4g.maps.control.additionalPanel({
    //     tipLabel: langConstants.CTRL_ADDITIONALPANEL,
    //     target: controlContainerTopLeft,
    //     caching: mapData.caching,
    //     mapController: this
    //   });
    //   this.map.addControl(this.controls.additionalPanel);
    // }


    // scaleline
    if (mapData.scaleline) {
      this.controls.scaleline = new ol.control.ScaleLine({
        target: controlContainerBottomLeft
      });
      this.map.addControl(this.controls.scaleline);
    }

    // zoom-level & mouse-position
    if (mapData.zoomlevel || mapData.mouseposition) {
      // wrapper for zoom-level and mouse-position
      controlContainerBottomLeftSub = document.createElement('div');
      controlContainerBottomLeftSub.className = _c4gMapsConstant.cssConstants.CONTROL_CONTAINER_BL_SUB + ' ' + _c4gMapsConstant.cssConstants.OL_UNSELECTABLE;
      jQuery(controlContainerBottomLeft).append(controlContainerBottomLeftSub);
      // display zoom-level
      if (mapData.zoomlevel) {
        this.controls.zoomlevel = new _c4gMapsControlZoomlevel.Zoomlevel({
          mapController: this,
          target: controlContainerBottomLeftSub,
          undefinedHTML: 'N/A'
        });
        this.map.addControl(this.controls.zoomlevel);
      }
      // display mouse-position
      if (mapData.mouseposition) {
        this.controls.mouseposition = new ol.control.MousePosition({
          projection: 'EPSG:4326',
          coordinateFormat: ol.coordinate.toStringHDMS,
          target: controlContainerBottomLeftSub,
          undefinedHTML: 'N/A'
        });
        this.map.addControl(this.controls.mouseposition);
      }
    }

    // geosearch
    if (mapData.geosearch.enable) {
      this.controls.geosearch = new _c4gMapsControlGeosearch.GeoSearch({
        mapController: this,
        target: controlContainerTopRight,
        extDiv: mapData.geosearch.div || false,
        collapsible: true,
        collapsed: mapData.geosearch.collapsed,
        label: ' ',
        collapsedLabel: '',
        // engineUrl: mapData.geosearch.engine,
        searchZoom: mapData.geosearch.searchzoom,
        zoomBounds: mapData.geosearch.zoombounds,
        quicksearch: true,
        animate: mapData.geosearch.animate,
        markResult: mapData.geosearch.markresult,
        popup: mapData.geosearch.popup,
        autopick: mapData.geopicker,
        caching: mapData.caching,
        results: mapData.geosearch.results
      });
      this.map.addControl(this.controls.geosearch);
      // open if opened before
      // if ((mapData.caching && (utils.getValue(this.controls.geosearch.options.name) === '1'))) {
      //   this.controls.geosearch.open();
      // }
    }

    // geobookmarks - not ready
    if (mapData.geobookmarks) {
      this.controls.geobookmarks = new ol.control.GeoBookmark({
        //target: controlContainerTopRight
        label: ' ',
        tipLabel: langConstants.CTRL_GEOBOOKMARKS,
        placeholder: langConstants.GEOBOOKMARKS_PLACEHOLDER,
        namespace: 'c4g_geobookmarks' /*,
                                      className: cssConstants.GEOBOOKMARKS*/ //ToDo implement for own styling
      });
      this.map.addControl(this.controls.geobookmarks);
      this.rightSlideElements.push('.ol-bookmark');
    }

    // overview-map
    if (mapData.overviewmap) {
      var overviewMapOptions = { target: controlContainerTopRight, mapController: this, collapsed: true };
      var scope = this;
      var addOverviewMap = function addOverviewMap() {
        var activeBaselayer = scope.proxy.activeBaselayerId;
        scope.proxy.baselayerController.showBaseLayer(activeBaselayer);
        overviewMapOptions.layers = [scope.proxy.baselayerController.arrBaselayers[activeBaselayer].layer];
        if (scope.overviewMap) {
          // we are reloading the overview map, so keep the collapsed-property
          overviewMapOptions.collapsed = !scope.overviewMap.isOpen();
        }
        scope.overviewMap = new _c4gMapsControlOverviewmap.OverviewMap(overviewMapOptions);
        scope.controls.overviewmap = scope.overviewMap.getOverviewMap();
        scope.map.addControl(scope.controls.overviewmap);
      };
      if (this.proxy.baselayers_loaded) {
        addOverviewMap();
      } else {
        window.c4gMapsHooks.proxy_baselayer_loaded.push(addOverviewMap);
      }
      // add hook to synchronize overviewmap with baselayer
      window.c4gMapsHooks.baselayer_changed = window.c4gMapsHooks.baselayer_changed || [];
      window.c4gMapsHooks.baselayer_changed.push(function (baselayerId) {
        scope.map.removeControl(scope.controls.overviewmap);
        scope.overviewMap.removeFromMap();
        addOverviewMap();
      });
    }

    // starboard
    if (mapData.geopicker && mapData.geopicker.type === "backend") {
      enableStarboard = false;
    }

    // popup margin
    //this.leftSlideElements.push('.ol-overlay-container');
    //this.rightSlideElements.push('.ol-overlay-container');

    if (typeof _c4gMapsControlStarboard.Starboard === 'function' && enableStarboard && !this.controls.starboard) {
      this.initializeStarboard();
    }

    // backend-geopicker
    if (mapData.geopicker && (mapData.geopicker.type === "backend" || mapData.geopicker.type === "frontend")) {
      this.controls.geopicker = new _c4gMapsInteractionGeopicker.GeoPicker({
        mapContainer: this
      });
      this.map.addInteraction(this.controls.geopicker);
      if (mapData.geopicker.type === "frontend") {
        // substring is needed here for taking out the #
        if (mapData.geopicker.input_geo_x && mapData.geopicker.input_geo_x) {
          var geoxField = document.getElementById(mapData.geopicker.input_geo_x.substring(1));
          var geoyField = document.getElementById(mapData.geopicker.input_geo_y.substring(1));
          if (geoxField && geoyField) {
            var locGeox = geoxField.value;
            var locGeoy = geoyField.value;
            if (locGeox && locGeoy) {
              var numerized = [parseFloat(locGeox, 10), parseFloat(locGeoy, 10)];
              var transformed = ol.proj.transform(numerized, ol.proj.get('EPSG:4326'), ol.proj.get('EPSG:3857'));
              geoLocation = null;
              this.map.getView().setCenter(transformed);
            }
          }
        }
      }
    }

    // show attribution
    if (mapData.attribution.enable) {
      // @TODO: create own attribution-control
      if (mapData.attribution.cfg_logo) {
        logoLink = document.createElement('a');
        logoLink.href = 'https://con4gis.org';
        logoLink.title = 'built with con4gis';
        logoLink.target = '_blank';
        logoLink.className = _c4gMapsConstant.cssConstants.ATTRIBUTION_LOGO;
        logoGraphic = document.createElement('img');
        logoGraphic.src = 'bundles/con4gismaps/images/logo_con4gis.svg';
        logoLink.appendChild(logoGraphic);
        controlContainerBottomRight.appendChild(logoLink);
      }
      this.controls.attribution = new ol.control.Attribution({
        label: ' ',
        tipLabel: langConstants.CTRL_ATTRIBUTION,
        collapseLabel: ' ',
        target: controlContainerBottomRight,
        collapsible: true
      });
      this.controls.attribution.setCollapsed(mapData.attribution.collapsed === '1');
      this.map.addControl(this.controls.attribution);
    }

    // show permalink
    if (mapData.permalink.enable) {
      this.controls.permalink = new _c4gMapsControlPermalink.Permalink({
        label: ' ',
        tipLabel: langConstants.CTRL_PERMALINK,
        mapController: this,
        getParameter: mapData.permalink.get_parameter,
        target: controlContainerBottomRight
      });
      this.map.addControl(this.controls.permalink);
    }

    //themeData
    if (mapData.themeData) {
      domMapDiv = document.getElementById(mapData.mapDiv);
      if (mapData.themeData['useglobal']) {
        domMapDiv = document.getElementById('wrapper');
      }
      ;

      if (mapData.themeData['maincolor']) {
        var mainColor = _c4gMapsUtils.utils.getRgbaFromHexAndOpacity(mapData.themeData['maincolor'], mapData.themeData['mainopacity']);
        var fontColor = _c4gMapsUtils.utils.getRgbaFromHexAndOpacity(mapData.themeData['fontcolor'], mapData.themeData['fontopacity']);
        var shadowColor = _c4gMapsUtils.utils.getRgbaFromHexAndOpacity(mapData.themeData['shadowcolor'], mapData.themeData['shadowopacity']);

        if (domMapDiv && domMapDiv.style) {
          domMapDiv.style.setProperty('--main-color', mainColor);
          domMapDiv.style.setProperty('--font-color', fontColor);
          domMapDiv.style.setProperty('--shadow-color', shadowColor);
        }
      }

      if (domMapDiv && mapData.themeData['buttonradius']) {
        domMapDiv.style.setProperty('--button-radius-percent', mapData.themeData['buttonradius'] + '%');
        domMapDiv.style.setProperty('--button-radius-pixel', mapData.themeData['buttonradius'] + 'px');
      }
    }
    if (window.c4gMapsHooks !== undefined && Array.isArray(window.c4gMapsHooks.mapController_addControls)) {
      _c4gMapsUtils.utils.callHookFunctions(window.c4gMapsHooks.mapController_addControls, {
        mapController: this,
        Container: controlContainerTopLeft
      });
    }
  }

  _createClass(MapController, [{
    key: "initializeStarboard",
    value: function initializeStarboard() {
      var mapData = this.data;
      var starboard_label = void 0;
      if (mapData.starboard.label) {
        starboard_label = langConstants.CTRL_STARBOARD.replace('Starboard', mapData.starboard.label).replace('starboard', mapData.starboard.label);
      }

      this.controls.starboard = new _c4gMapsControlStarboard.Starboard({
        create: mapData.starboard.enable || false,
        headline: mapData.starboard.label,
        tipLabel: starboard_label || false,
        caching: mapData.caching,
        mapController: this,
        extDiv: mapData.starboard.div,
        // defaultOpen: mapData.starboard.open,
        filter: mapData.starboard.filter,
        button: mapData.starboard.button,
        baselayerSwitcherCreate: mapData.baselayerswitcher.enable,
        baselayerSwitcherTitle: mapData.baselayerswitcher.label,
        layerSwitcherCreate: mapData.layerswitcher.enable,
        layerSwitcherTitle: mapData.layerswitcher.label
      });
      this.map.addControl(this.controls.starboard);

      // open if opened before
      if (mapData.starboard.open || mapData.caching && _c4gMapsUtils.utils.getValue(this.controls.starboard.options.name) === '1') {
        this.controls.starboard.open();
      }
    }
  }]);

  return MapController;
}();

/***/ }),

/***/ "./Resources/public/js/c4g-overlay-controller.js":
/*!*******************************************************!*\
  !*** ./Resources/public/js/c4g-overlay-controller.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.C4gOverlayController = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * This file is part of con4gis,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * the gis-kit for Contao CMS.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @package    con4gis
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @version    6
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @author     con4gis contributors (see "authors.txt")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @license    LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @copyright  Küstenschmiede GmbH Software & Design
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @link       https://www.con4gis.org
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _c4gOverlay = __webpack_require__(/*! ./c4g-overlay */ "./Resources/public/js/c4g-overlay.js");

var _c4gMapsConfig = __webpack_require__(/*! ./c4g-maps-config */ "./Resources/public/js/c4g-maps-config.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var C4gOverlayController = exports.C4gOverlayController = function () {
  function C4gOverlayController(baselayer) {
    _classCallCheck(this, C4gOverlayController);

    this.baselayer = baselayer;
    this.arrOverlays = [];
  }

  _createClass(C4gOverlayController, [{
    key: "showOverlayLayer",
    value: function showOverlayLayer(overlayId) {
      var self = this,
          overlayLayerConfig,
          osmSourceConfigs = _c4gMapsConfig.config.osm,
          stamenSourceConfigs = _c4gMapsConfig.config.stamen,
          layerOptions,
          overlayLayer,
          noUrl;

      layerOptions = {};
      overlayLayer = new ol.layer.Tile({
        source: new ol.source.OSM()
      });

      overlayLayerConfig = this.arrOverlays[overlayId];

      switch (overlayLayerConfig.provider) {
        case 'osm':
          if (osmSourceConfigs[overlayLayerConfig.style]) {
            overlayLayer = new ol.layer.Tile({
              source: new ol.source.OSM(jQuery.extend(osmSourceConfigs[overlayLayerConfig.style], layerOptions))
            });
          } else if (stamenSourceConfigs[overlayLayerConfig.style]) {
            // Stamen
            overlayLayer = new ol.layer.Tile({
              source: new ol.source.Stamen(jQuery.extend(stamenSourceConfigs[overlayLayerConfig.style], layerOptions))
            });
            // } else if (mapQuestSourceConfigs[overlayLayerConfig.style]) {
            //   // mapQuest
            //   overlayLayer = new ol.layer.Tile({
            //     source: new ol.source.MapQuest(mapQuestSourceConfigs[overlayLayerConfig.style])
            //   });
          } else if (overlayLayerConfig.style === 'osm_custom') {
            // custom
            noUrl = true;
            if (overlayLayerConfig.attribution) {
              layerOptions.attributions = overlayLayerConfig.attribution + ' ' + ol.source.OSM.ATTRIBUTION;
            }

            if (overlayLayerConfig.url) {
              layerOptions.url = overlayLayerConfig.url;
              noUrl = false;
            } else if (overlayLayerConfig.urls) {
              layerOptions.urls = overlayLayerConfig.urls;
              noUrl = false;
            }
            if (!noUrl) {
              overlayLayer = new ol.layer.Tile({
                source: new ol.source.XYZ(layerOptions)
              });
            } else {
              console.warn('custom url(s) missing -> switch to default');
            }
          } else {
            console.warn('unsupported osm-style -> switch to default');
          }
          break;
        case 'google':
          //@todo
          console.warn('google-maps are currently unsupported');
          break;
        case 'bing':
          if (baseLayerConfig.apiKey && overlayLayerConfig.style) {
            overlayLayer = new ol.layer.Tile({
              source: new ol.source.BingMaps({
                culture: navigator.languages ? navigator.languages[0] : navigator.language || navigator.userLanguage,
                key: overlayLayerConfig.apiKey,
                imagerySet: overlayLayerConfig.style
              })
            });
          } else {
            console.warn('wrong bing-key or invalid imagery-set!');
          }
          break;
        case 'wms':
          overlayLayer = new ol.layer.Tile({
            source: new ol.source.TileWMS({
              url: overlayLayerConfig.url,
              params: {
                LAYERS: overlayLayerConfig.params.layers,
                VERSION: overlayLayerConfig.params.version,
                //FORMAT: overlayLayerConfig.params.format,
                TRANSPARENT: overlayLayerConfig.params.transparent
              },
              gutter: overlayLayerConfig.gutter,
              attributions: overlayLayerConfig.attribution + ' ' + ol.source.OSM.ATTRIBUTION
            })
            //extent: ol.proj.transformExtent([5.59334, 50.0578, 9.74158, 52.7998], 'EPSG:4326', 'EPSG:3857')
          });
          break;
        case 'owm':
          overlayLayer = new ol.layer.Tile({
            source: new ol.source.XYZ({
              url: overlayLayerConfig.url + overlayLayerConfig.app_id + '/{z}/{x}/{y}?hash=' + overlayLayerConfig.api_key,
              attributions: overlayLayerConfig.attribution + ' ' + ol.source.OSM.ATTRIBUTION
            })
            //extent: ol.proj.transformExtent([5.59334, 50.0578, 9.74158, 52.7998], 'EPSG:4326', 'EPSG:3857')
          });
          break;
        default:
          console.warn('unsupported provider');
          break;
      }
      this.arrOverlays[overlayId].layer = overlayLayer;
      this.arrOverlays[overlayId].changeOpacity(parseInt(overlayLayerConfig.opacity) / 100);
      return this.arrOverlays[overlayId].layer;
    }
  }]);

  return C4gOverlayController;
}();

/***/ }),

/***/ "./Resources/public/js/c4g-overlay.js":
/*!********************************************!*\
  !*** ./Resources/public/js/c4g-overlay.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * This file is part of con4gis,
 * the gis-kit for Contao CMS.
 *
 * @package    con4gis
 * @version    6
 * @author     con4gis contributors (see "authors.txt")
 * @license    LGPL-3.0-or-later
 * @copyright  Küstenschmiede GmbH Software & Design
 * @link       https://www.con4gis.org
 */
var C4gOverlay = exports.C4gOverlay = function () {
  function C4gOverlay(overlayArr, mapController) {
    _classCallCheck(this, C4gOverlay);

    this.id = overlayArr['id'];
    this.pid = overlayArr['pid'];
    this.name = overlayArr['name'];
    this.provider = overlayArr['provider'];
    this.style = overlayArr['style'];
    this.url = overlayArr['url'];
    this.urls = overlayArr['urls'];
    this.opacity = overlayArr['opacity'];
    this.attribution = overlayArr['attribution'];
    this.gutter = overlayArr['gutter'];
    this.params = overlayArr['params'];
    this.layer = false;
    this.overlayArr = overlayArr;
    this.mapController = mapController;
  }

  _createClass(C4gOverlay, [{
    key: 'changeOpacity',
    value: function changeOpacity(value) {
      var layer;

      layer = this.layer;
      if (layer) {
        this.mapController.map.removeLayer(layer);
        layer.setOpacity(value / 100);
        this.mapController.map.addLayer(layer);
      }
    }
  }]);

  return C4gOverlay;
}();

/***/ }),

/***/ "./node_modules/ol/AssertionError.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/AssertionError.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ "./node_modules/ol/util.js");
/**
 * @module ol/AssertionError
 */


/**
 * Error object thrown when an assertion failed. This is an ECMA-262 Error,
 * extended with a `code` property.
 * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error.
 */
var AssertionError = /*@__PURE__*/(function (Error) {
  function AssertionError(code) {
    var path = _util_js__WEBPACK_IMPORTED_MODULE_0__["VERSION"] === 'latest' ? _util_js__WEBPACK_IMPORTED_MODULE_0__["VERSION"] : 'v' + _util_js__WEBPACK_IMPORTED_MODULE_0__["VERSION"].split('-')[0];
    var message = 'Assertion failed. See https://openlayers.org/en/' + path +
    '/doc/errors/#' + code + ' for details.';

    Error.call(this, message);

    /**
     * Error code. The meaning of the code can be found on
     * https://openlayers.org/en/latest/doc/errors/ (replace `latest` with
     * the version found in the OpenLayers script's header comment if a version
     * other than the latest is used).
     * @type {number}
     * @api
     */
    this.code = code;

    /**
     * @type {string}
     */
    this.name = 'AssertionError';

    // Re-assign message, see https://github.com/Rich-Harris/buble/issues/40
    this.message = message;
  }

  if ( Error ) AssertionError.__proto__ = Error;
  AssertionError.prototype = Object.create( Error && Error.prototype );
  AssertionError.prototype.constructor = AssertionError;

  return AssertionError;
}(Error));

/* harmony default export */ __webpack_exports__["default"] = (AssertionError);

//# sourceMappingURL=AssertionError.js.map

/***/ }),

/***/ "./node_modules/ol/Collection.js":
/*!***************************************!*\
  !*** ./node_modules/ol/Collection.js ***!
  \***************************************/
/*! exports provided: CollectionEvent, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CollectionEvent", function() { return CollectionEvent; });
/* harmony import */ var _AssertionError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AssertionError.js */ "./node_modules/ol/AssertionError.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CollectionEventType.js */ "./node_modules/ol/CollectionEventType.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events/Event.js */ "./node_modules/ol/events/Event.js");
/**
 * @module ol/Collection
 */






/**
 * @enum {string}
 * @private
 */
var Property = {
  LENGTH: 'length'
};


/**
 * @classdesc
 * Events emitted by {@link module:ol/Collection~Collection} instances are instances of this
 * type.
 */
var CollectionEvent = /*@__PURE__*/(function (Event) {
  function CollectionEvent(type, opt_element) {
    Event.call(this, type);

    /**
     * The element that is added to or removed from the collection.
     * @type {*}
     * @api
     */
    this.element = opt_element;

  }

  if ( Event ) CollectionEvent.__proto__ = Event;
  CollectionEvent.prototype = Object.create( Event && Event.prototype );
  CollectionEvent.prototype.constructor = CollectionEvent;

  return CollectionEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_3__["default"]));


/**
 * @typedef {Object} Options
 * @property {boolean} [unique=false] Disallow the same item from being added to
 * the collection twice.
 */

/**
 * @classdesc
 * An expanded version of standard JS Array, adding convenience methods for
 * manipulation. Add and remove changes to the Collection trigger a Collection
 * event. Note that this does not cover changes to the objects _within_ the
 * Collection; they trigger events on the appropriate object, not on the
 * Collection as a whole.
 *
 * @fires CollectionEvent
 *
 * @template T
 * @api
 */
var Collection = /*@__PURE__*/(function (BaseObject) {
  function Collection(opt_array, opt_options) {

    BaseObject.call(this);

    var options = opt_options || {};

    /**
     * @private
     * @type {boolean}
     */
    this.unique_ = !!options.unique;

    /**
     * @private
     * @type {!Array<T>}
     */
    this.array_ = opt_array ? opt_array : [];

    if (this.unique_) {
      for (var i = 0, ii = this.array_.length; i < ii; ++i) {
        this.assertUnique_(this.array_[i], i);
      }
    }

    this.updateLength_();

  }

  if ( BaseObject ) Collection.__proto__ = BaseObject;
  Collection.prototype = Object.create( BaseObject && BaseObject.prototype );
  Collection.prototype.constructor = Collection;

  /**
   * Remove all elements from the collection.
   * @api
   */
  Collection.prototype.clear = function clear () {
    while (this.getLength() > 0) {
      this.pop();
    }
  };

  /**
   * Add elements to the collection.  This pushes each item in the provided array
   * to the end of the collection.
   * @param {!Array<T>} arr Array.
   * @return {Collection<T>} This collection.
   * @api
   */
  Collection.prototype.extend = function extend (arr) {
    for (var i = 0, ii = arr.length; i < ii; ++i) {
      this.push(arr[i]);
    }
    return this;
  };

  /**
   * Iterate over each element, calling the provided callback.
   * @param {function(T, number, Array<T>): *} f The function to call
   *     for every element. This function takes 3 arguments (the element, the
   *     index and the array). The return value is ignored.
   * @api
   */
  Collection.prototype.forEach = function forEach (f) {
    var array = this.array_;
    for (var i = 0, ii = array.length; i < ii; ++i) {
      f(array[i], i, array);
    }
  };

  /**
   * Get a reference to the underlying Array object. Warning: if the array
   * is mutated, no events will be dispatched by the collection, and the
   * collection's "length" property won't be in sync with the actual length
   * of the array.
   * @return {!Array<T>} Array.
   * @api
   */
  Collection.prototype.getArray = function getArray () {
    return this.array_;
  };

  /**
   * Get the element at the provided index.
   * @param {number} index Index.
   * @return {T} Element.
   * @api
   */
  Collection.prototype.item = function item (index) {
    return this.array_[index];
  };

  /**
   * Get the length of this collection.
   * @return {number} The length of the array.
   * @observable
   * @api
   */
  Collection.prototype.getLength = function getLength () {
    return this.get(Property.LENGTH);
  };

  /**
   * Insert an element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  Collection.prototype.insertAt = function insertAt (index, elem) {
    if (this.unique_) {
      this.assertUnique_(elem);
    }
    this.array_.splice(index, 0, elem);
    this.updateLength_();
    this.dispatchEvent(
      new CollectionEvent(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].ADD, elem));
  };

  /**
   * Remove the last element of the collection and return it.
   * Return `undefined` if the collection is empty.
   * @return {T|undefined} Element.
   * @api
   */
  Collection.prototype.pop = function pop () {
    return this.removeAt(this.getLength() - 1);
  };

  /**
   * Insert the provided element at the end of the collection.
   * @param {T} elem Element.
   * @return {number} New length of the collection.
   * @api
   */
  Collection.prototype.push = function push (elem) {
    if (this.unique_) {
      this.assertUnique_(elem);
    }
    var n = this.getLength();
    this.insertAt(n, elem);
    return this.getLength();
  };

  /**
   * Remove the first occurrence of an element from the collection.
   * @param {T} elem Element.
   * @return {T|undefined} The removed element or undefined if none found.
   * @api
   */
  Collection.prototype.remove = function remove (elem) {
    var arr = this.array_;
    for (var i = 0, ii = arr.length; i < ii; ++i) {
      if (arr[i] === elem) {
        return this.removeAt(i);
      }
    }
    return undefined;
  };

  /**
   * Remove the element at the provided index and return it.
   * Return `undefined` if the collection does not contain this index.
   * @param {number} index Index.
   * @return {T|undefined} Value.
   * @api
   */
  Collection.prototype.removeAt = function removeAt (index) {
    var prev = this.array_[index];
    this.array_.splice(index, 1);
    this.updateLength_();
    this.dispatchEvent(new CollectionEvent(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].REMOVE, prev));
    return prev;
  };

  /**
   * Set the element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  Collection.prototype.setAt = function setAt (index, elem) {
    var n = this.getLength();
    if (index < n) {
      if (this.unique_) {
        this.assertUnique_(elem, index);
      }
      var prev = this.array_[index];
      this.array_[index] = elem;
      this.dispatchEvent(
        new CollectionEvent(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].REMOVE, prev));
      this.dispatchEvent(
        new CollectionEvent(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].ADD, elem));
    } else {
      for (var j = n; j < index; ++j) {
        this.insertAt(j, undefined);
      }
      this.insertAt(index, elem);
    }
  };

  /**
   * @private
   */
  Collection.prototype.updateLength_ = function updateLength_ () {
    this.set(Property.LENGTH, this.array_.length);
  };

  /**
   * @private
   * @param {T} elem Element.
   * @param {number=} opt_except Optional index to ignore.
   */
  Collection.prototype.assertUnique_ = function assertUnique_ (elem, opt_except) {
    for (var i = 0, ii = this.array_.length; i < ii; ++i) {
      if (this.array_[i] === elem && i !== opt_except) {
        throw new _AssertionError_js__WEBPACK_IMPORTED_MODULE_0__["default"](58);
      }
    }
  };

  return Collection;
}(_Object_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (Collection);

//# sourceMappingURL=Collection.js.map

/***/ }),

/***/ "./node_modules/ol/CollectionEventType.js":
/*!************************************************!*\
  !*** ./node_modules/ol/CollectionEventType.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/CollectionEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  /**
   * Triggered when an item is added to the collection.
   * @event module:ol/Collection.CollectionEvent#add
   * @api
   */
  ADD: 'add',
  /**
   * Triggered when an item is removed from the collection.
   * @event module:ol/Collection.CollectionEvent#remove
   * @api
   */
  REMOVE: 'remove'
});

//# sourceMappingURL=CollectionEventType.js.map

/***/ }),

/***/ "./node_modules/ol/Disposable.js":
/*!***************************************!*\
  !*** ./node_modules/ol/Disposable.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/Disposable
 */

/**
 * @classdesc
 * Objects that need to clean up after themselves.
 */
var Disposable = function Disposable() {
  /**
   * The object has already been disposed.
   * @type {boolean}
   * @private
   */
  this.disposed_ = false;
};

/**
 * Clean up.
 */
Disposable.prototype.dispose = function dispose () {
  if (!this.disposed_) {
    this.disposed_ = true;
    this.disposeInternal();
  }
};

/**
 * Extension point for disposable objects.
 * @protected
 */
Disposable.prototype.disposeInternal = function disposeInternal () {};

/* harmony default export */ __webpack_exports__["default"] = (Disposable);

//# sourceMappingURL=Disposable.js.map

/***/ }),

/***/ "./node_modules/ol/Feature.js":
/*!************************************!*\
  !*** ./node_modules/ol/Feature.js ***!
  \************************************/
/*! exports provided: createStyleFunction, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createStyleFunction", function() { return createStyleFunction; });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Object.js */ "./node_modules/ol/Object.js");
/**
 * @module ol/Feature
 */





/**
 * @typedef {typeof Feature|typeof import("./render/Feature.js").default} FeatureClass
 */

/**
 * @typedef {Feature|import("./render/Feature.js").default} FeatureLike
 */

/**
 * @classdesc
 * A vector object for geographic features with a geometry and other
 * attribute properties, similar to the features in vector file formats like
 * GeoJSON.
 *
 * Features can be styled individually with `setStyle`; otherwise they use the
 * style of their vector layer.
 *
 * Note that attribute properties are set as {@link module:ol/Object} properties on
 * the feature object, so they are observable, and have get/set accessors.
 *
 * Typically, a feature has a single geometry property. You can set the
 * geometry using the `setGeometry` method and get it with `getGeometry`.
 * It is possible to store more than one geometry on a feature using attribute
 * properties. By default, the geometry used for rendering is identified by
 * the property name `geometry`. If you want to use another geometry property
 * for rendering, use the `setGeometryName` method to change the attribute
 * property associated with the geometry for the feature.  For example:
 *
 * ```js
 *
 * import Feature from 'ol/Feature';
 * import Polygon from 'ol/geom/Polygon';
 * import Point from 'ol/geom/Point';
 *
 * var feature = new Feature({
 *   geometry: new Polygon(polyCoords),
 *   labelPoint: new Point(labelCoords),
 *   name: 'My Polygon'
 * });
 *
 * // get the polygon geometry
 * var poly = feature.getGeometry();
 *
 * // Render the feature as a point using the coordinates from labelPoint
 * feature.setGeometryName('labelPoint');
 *
 * // get the point geometry
 * var point = feature.getGeometry();
 * ```
 *
 * @api
 */
var Feature = /*@__PURE__*/(function (BaseObject) {
  function Feature(opt_geometryOrProperties) {

    BaseObject.call(this);

    /**
     * @private
     * @type {number|string|undefined}
     */
    this.id_ = undefined;

    /**
     * @type {string}
     * @private
     */
    this.geometryName_ = 'geometry';

    /**
     * User provided style.
     * @private
     * @type {import("./style/Style.js").StyleLike}
     */
    this.style_ = null;

    /**
     * @private
     * @type {import("./style/Style.js").StyleFunction|undefined}
     */
    this.styleFunction_ = undefined;

    /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */
    this.geometryChangeKey_ = null;

    Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["listen"])(
      this, Object(_Object_js__WEBPACK_IMPORTED_MODULE_3__["getChangeEventType"])(this.geometryName_),
      this.handleGeometryChanged_, this);

    if (opt_geometryOrProperties) {
      if (typeof /** @type {?} */ (opt_geometryOrProperties).getSimplifiedGeometry === 'function') {
        var geometry = /** @type {import("./geom/Geometry.js").default} */ (opt_geometryOrProperties);
        this.setGeometry(geometry);
      } else {
        /** @type {Object<string, *>} */
        var properties = opt_geometryOrProperties;
        this.setProperties(properties);
      }
    }
  }

  if ( BaseObject ) Feature.__proto__ = BaseObject;
  Feature.prototype = Object.create( BaseObject && BaseObject.prototype );
  Feature.prototype.constructor = Feature;

  /**
   * Clone this feature. If the original feature has a geometry it
   * is also cloned. The feature id is not set in the clone.
   * @return {Feature} The clone.
   * @api
   */
  Feature.prototype.clone = function clone () {
    var clone = new Feature(this.getProperties());
    clone.setGeometryName(this.getGeometryName());
    var geometry = this.getGeometry();
    if (geometry) {
      clone.setGeometry(geometry.clone());
    }
    var style = this.getStyle();
    if (style) {
      clone.setStyle(style);
    }
    return clone;
  };

  /**
   * Get the feature's default geometry.  A feature may have any number of named
   * geometries.  The "default" geometry (the one that is rendered by default) is
   * set when calling {@link module:ol/Feature~Feature#setGeometry}.
   * @return {import("./geom/Geometry.js").default|undefined} The default geometry for the feature.
   * @api
   * @observable
   */
  Feature.prototype.getGeometry = function getGeometry () {
    return (
      /** @type {import("./geom/Geometry.js").default|undefined} */ (this.get(this.geometryName_))
    );
  };

  /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is either set when reading data from a remote source or set explicitly by
   * calling {@link module:ol/Feature~Feature#setId}.
   * @return {number|string|undefined} Id.
   * @api
   */
  Feature.prototype.getId = function getId () {
    return this.id_;
  };

  /**
   * Get the name of the feature's default geometry.  By default, the default
   * geometry is named `geometry`.
   * @return {string} Get the property name associated with the default geometry
   *     for this feature.
   * @api
   */
  Feature.prototype.getGeometryName = function getGeometryName () {
    return this.geometryName_;
  };

  /**
   * Get the feature's style. Will return what was provided to the
   * {@link module:ol/Feature~Feature#setStyle} method.
   * @return {import("./style/Style.js").StyleLike} The feature style.
   * @api
   */
  Feature.prototype.getStyle = function getStyle () {
    return this.style_;
  };

  /**
   * Get the feature's style function.
   * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
   * representing the current style of this feature.
   * @api
   */
  Feature.prototype.getStyleFunction = function getStyleFunction () {
    return this.styleFunction_;
  };

  /**
   * @private
   */
  Feature.prototype.handleGeometryChange_ = function handleGeometryChange_ () {
    this.changed();
  };

  /**
   * @private
   */
  Feature.prototype.handleGeometryChanged_ = function handleGeometryChanged_ () {
    if (this.geometryChangeKey_) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["unlistenByKey"])(this.geometryChangeKey_);
      this.geometryChangeKey_ = null;
    }
    var geometry = this.getGeometry();
    if (geometry) {
      this.geometryChangeKey_ = Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["listen"])(geometry,
        _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CHANGE, this.handleGeometryChange_, this);
    }
    this.changed();
  };

  /**
   * Set the default geometry for the feature.  This will update the property
   * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
   * @param {import("./geom/Geometry.js").default|undefined} geometry The new geometry.
   * @api
   * @observable
   */
  Feature.prototype.setGeometry = function setGeometry (geometry) {
    this.set(this.geometryName_, geometry);
  };

  /**
   * Set the style for the feature.  This can be a single style object, an array
   * of styles, or a function that takes a resolution and returns an array of
   * styles. If it is `null` the feature has no style (a `null` style).
   * @param {import("./style/Style.js").StyleLike} style Style for this feature.
   * @api
   * @fires module:ol/events/Event~Event#event:change
   */
  Feature.prototype.setStyle = function setStyle (style) {
    this.style_ = style;
    this.styleFunction_ = !style ? undefined : createStyleFunction(style);
    this.changed();
  };

  /**
   * Set the feature id.  The feature id is considered stable and may be used when
   * requesting features or comparing identifiers returned from a remote source.
   * The feature id can be used with the
   * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
   * @param {number|string|undefined} id The feature id.
   * @api
   * @fires module:ol/events/Event~Event#event:change
   */
  Feature.prototype.setId = function setId (id) {
    this.id_ = id;
    this.changed();
  };

  /**
   * Set the property name to be used when getting the feature's default geometry.
   * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
   * this name will be returned.
   * @param {string} name The property name of the default geometry.
   * @api
   */
  Feature.prototype.setGeometryName = function setGeometryName (name) {
    Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["unlisten"])(
      this, Object(_Object_js__WEBPACK_IMPORTED_MODULE_3__["getChangeEventType"])(this.geometryName_),
      this.handleGeometryChanged_, this);
    this.geometryName_ = name;
    Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["listen"])(
      this, Object(_Object_js__WEBPACK_IMPORTED_MODULE_3__["getChangeEventType"])(this.geometryName_),
      this.handleGeometryChanged_, this);
    this.handleGeometryChanged_();
  };

  return Feature;
}(_Object_js__WEBPACK_IMPORTED_MODULE_3__["default"]));


/**
 * Convert the provided object into a feature style function.  Functions passed
 * through unchanged.  Arrays of Style or single style objects wrapped
 * in a new feature style function.
 * @param {!import("./style/Style.js").StyleFunction|!Array<import("./style/Style.js").default>|!import("./style/Style.js").default} obj
 *     A feature style function, a single style, or an array of styles.
 * @return {import("./style/Style.js").StyleFunction} A style function.
 */
function createStyleFunction(obj) {
  if (typeof obj === 'function') {
    return obj;
  } else {
    /**
     * @type {Array<import("./style/Style.js").default>}
     */
    var styles;
    if (Array.isArray(obj)) {
      styles = obj;
    } else {
      Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(typeof /** @type {?} */ (obj).getZIndex === 'function',
        41); // Expected an `import("./style/Style.js").Style` or an array of `import("./style/Style.js").Style`
      var style = /** @type {import("./style/Style.js").default} */ (obj);
      styles = [style];
    }
    return function() {
      return styles;
    };
  }
}
/* harmony default export */ __webpack_exports__["default"] = (Feature);

//# sourceMappingURL=Feature.js.map

/***/ }),

/***/ "./node_modules/ol/Image.js":
/*!**********************************!*\
  !*** ./node_modules/ol/Image.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ImageBase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ImageBase.js */ "./node_modules/ol/ImageBase.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ImageState.js */ "./node_modules/ol/ImageState.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/**
 * @module ol/Image
 */







/**
 * A function that takes an {@link module:ol/Image~Image} for the image and a
 * `{string}` for the src as arguments. It is supposed to make it so the
 * underlying image {@link module:ol/Image~Image#getImage} is assigned the
 * content specified by the src. If not specified, the default is
 *
 *     function(image, src) {
 *       image.getImage().src = src;
 *     }
 *
 * Providing a custom `imageLoadFunction` can be useful to load images with
 * post requests or - in general - through XHR requests, where the src of the
 * image element would be set to a data URI when the content is loaded.
 *
 * @typedef {function(ImageWrapper, string)} LoadFunction
 * @api
 */


var ImageWrapper = /*@__PURE__*/(function (ImageBase) {
  function ImageWrapper(extent, resolution, pixelRatio, src, crossOrigin, imageLoadFunction) {

    ImageBase.call(this, extent, resolution, pixelRatio, _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE);

    /**
     * @private
     * @type {string}
     */
    this.src_ = src;

    /**
     * @private
     * @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement}
     */
    this.image_ = new Image();
    if (crossOrigin !== null) {
      this.image_.crossOrigin = crossOrigin;
    }

    /**
     * @private
     * @type {Array<import("./events.js").EventsKey>}
     */
    this.imageListenerKeys_ = null;

    /**
     * @protected
     * @type {ImageState}
     */
    this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE;

    /**
     * @private
     * @type {LoadFunction}
     */
    this.imageLoadFunction_ = imageLoadFunction;

  }

  if ( ImageBase ) ImageWrapper.__proto__ = ImageBase;
  ImageWrapper.prototype = Object.create( ImageBase && ImageBase.prototype );
  ImageWrapper.prototype.constructor = ImageWrapper;

  /**
   * @inheritDoc
   * @api
   */
  ImageWrapper.prototype.getImage = function getImage () {
    return this.image_;
  };

  /**
   * Tracks loading or read errors.
   *
   * @private
   */
  ImageWrapper.prototype.handleImageError_ = function handleImageError_ () {
    this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR;
    this.unlistenImage_();
    this.changed();
  };

  /**
   * Tracks successful image load.
   *
   * @private
   */
  ImageWrapper.prototype.handleImageLoad_ = function handleImageLoad_ () {
    if (this.resolution === undefined) {
      this.resolution = Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["getHeight"])(this.extent) / this.image_.height;
    }
    this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;
    this.unlistenImage_();
    this.changed();
  };

  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   * @override
   * @api
   */
  ImageWrapper.prototype.load = function load () {
    if (this.state == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE || this.state == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR) {
      this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING;
      this.changed();
      this.imageListenerKeys_ = [
        Object(_events_js__WEBPACK_IMPORTED_MODULE_2__["listenOnce"])(this.image_, _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].ERROR,
          this.handleImageError_, this),
        Object(_events_js__WEBPACK_IMPORTED_MODULE_2__["listenOnce"])(this.image_, _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOAD,
          this.handleImageLoad_, this)
      ];
      this.imageLoadFunction_(this, this.src_);
    }
  };

  /**
   * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.
   */
  ImageWrapper.prototype.setImage = function setImage (image) {
    this.image_ = image;
  };

  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */
  ImageWrapper.prototype.unlistenImage_ = function unlistenImage_ () {
    this.imageListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_2__["unlistenByKey"]);
    this.imageListenerKeys_ = null;
  };

  return ImageWrapper;
}(_ImageBase_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (ImageWrapper);

//# sourceMappingURL=Image.js.map

/***/ }),

/***/ "./node_modules/ol/ImageBase.js":
/*!**************************************!*\
  !*** ./node_modules/ol/ImageBase.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events/Target.js */ "./node_modules/ol/events/Target.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/**
 * @module ol/ImageBase
 */




/**
 * @abstract
 */
var ImageBase = /*@__PURE__*/(function (EventTarget) {
  function ImageBase(extent, resolution, pixelRatio, state) {

    EventTarget.call(this);

    /**
     * @protected
     * @type {import("./extent.js").Extent}
     */
    this.extent = extent;

    /**
     * @private
     * @type {number}
     */
    this.pixelRatio_ = pixelRatio;

    /**
     * @protected
     * @type {number|undefined}
     */
    this.resolution = resolution;

    /**
     * @protected
     * @type {import("./ImageState.js").default}
     */
    this.state = state;

  }

  if ( EventTarget ) ImageBase.__proto__ = EventTarget;
  ImageBase.prototype = Object.create( EventTarget && EventTarget.prototype );
  ImageBase.prototype.constructor = ImageBase;

  /**
   * @protected
   */
  ImageBase.prototype.changed = function changed () {
    this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CHANGE);
  };

  /**
   * @return {import("./extent.js").Extent} Extent.
   */
  ImageBase.prototype.getExtent = function getExtent () {
    return this.extent;
  };

  /**
   * @abstract
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   */
  ImageBase.prototype.getImage = function getImage () {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * @return {number} PixelRatio.
   */
  ImageBase.prototype.getPixelRatio = function getPixelRatio () {
    return this.pixelRatio_;
  };

  /**
   * @return {number} Resolution.
   */
  ImageBase.prototype.getResolution = function getResolution () {
    return /** @type {number} */ (this.resolution);
  };

  /**
   * @return {import("./ImageState.js").default} State.
   */
  ImageBase.prototype.getState = function getState () {
    return this.state;
  };

  /**
   * Load not yet loaded URI.
   * @abstract
   */
  ImageBase.prototype.load = function load () {
    Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  return ImageBase;
}(_events_Target_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (ImageBase);

//# sourceMappingURL=ImageBase.js.map

/***/ }),

/***/ "./node_modules/ol/ImageCanvas.js":
/*!****************************************!*\
  !*** ./node_modules/ol/ImageCanvas.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ImageBase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ImageBase.js */ "./node_modules/ol/ImageBase.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ImageState.js */ "./node_modules/ol/ImageState.js");
/**
 * @module ol/ImageCanvas
 */




/**
 * A function that is called to trigger asynchronous canvas drawing.  It is
 * called with a "done" callback that should be called when drawing is done.
 * If any error occurs during drawing, the "done" callback should be called with
 * that error.
 *
 * @typedef {function(function(Error=))} Loader
 */


var ImageCanvas = /*@__PURE__*/(function (ImageBase) {
  function ImageCanvas(extent, resolution, pixelRatio, canvas, opt_loader) {

    var state = opt_loader !== undefined ? _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE : _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;

    ImageBase.call(this, extent, resolution, pixelRatio, state);

    /**
     * Optional canvas loader function.
     * @type {?Loader}
     * @private
     */
    this.loader_ = opt_loader !== undefined ? opt_loader : null;

    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    this.canvas_ = canvas;

    /**
     * @private
     * @type {Error}
     */
    this.error_ = null;

  }

  if ( ImageBase ) ImageCanvas.__proto__ = ImageBase;
  ImageCanvas.prototype = Object.create( ImageBase && ImageBase.prototype );
  ImageCanvas.prototype.constructor = ImageCanvas;

  /**
   * Get any error associated with asynchronous rendering.
   * @return {Error} Any error that occurred during rendering.
   */
  ImageCanvas.prototype.getError = function getError () {
    return this.error_;
  };

  /**
   * Handle async drawing complete.
   * @param {Error=} err Any error during drawing.
   * @private
   */
  ImageCanvas.prototype.handleLoad_ = function handleLoad_ (err) {
    if (err) {
      this.error_ = err;
      this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR;
    } else {
      this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;
    }
    this.changed();
  };

  /**
   * @inheritDoc
   */
  ImageCanvas.prototype.load = function load () {
    if (this.state == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE) {
      this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING;
      this.changed();
      this.loader_(this.handleLoad_.bind(this));
    }
  };

  /**
   * @return {HTMLCanvasElement} Canvas element.
   */
  ImageCanvas.prototype.getImage = function getImage () {
    return this.canvas_;
  };

  return ImageCanvas;
}(_ImageBase_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (ImageCanvas);

//# sourceMappingURL=ImageCanvas.js.map

/***/ }),

/***/ "./node_modules/ol/ImageState.js":
/*!***************************************!*\
  !*** ./node_modules/ol/ImageState.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/ImageState
 */

/**
 * @enum {number}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3
});

//# sourceMappingURL=ImageState.js.map

/***/ }),

/***/ "./node_modules/ol/ImageTile.js":
/*!**************************************!*\
  !*** ./node_modules/ol/ImageTile.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Tile.js */ "./node_modules/ol/Tile.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/**
 * @module ol/ImageTile
 */







var ImageTile = /*@__PURE__*/(function (Tile) {
  function ImageTile(tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options) {

    Tile.call(this, tileCoord, state, opt_options);

    /**
     * @private
     * @type {?string}
     */
    this.crossOrigin_ = crossOrigin;

    /**
     * Image URI
     *
     * @private
     * @type {string}
     */
    this.src_ = src;

    /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement}
     */
    this.image_ = new Image();
    if (crossOrigin !== null) {
      this.image_.crossOrigin = crossOrigin;
    }

    /**
     * @private
     * @type {Array<import("./events.js").EventsKey>}
     */
    this.imageListenerKeys_ = null;

    /**
     * @private
     * @type {import("./Tile.js").LoadFunction}
     */
    this.tileLoadFunction_ = tileLoadFunction;

  }

  if ( Tile ) ImageTile.__proto__ = Tile;
  ImageTile.prototype = Object.create( Tile && Tile.prototype );
  ImageTile.prototype.constructor = ImageTile;

  /**
   * @inheritDoc
   */
  ImageTile.prototype.disposeInternal = function disposeInternal () {
    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING) {
      this.unlistenImage_();
      this.image_ = getBlankImage();
    }
    if (this.interimTile) {
      this.interimTile.dispose();
    }
    this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ABORT;
    this.changed();
    Tile.prototype.disposeInternal.call(this);
  };

  /**
   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @api
   */
  ImageTile.prototype.getImage = function getImage () {
    return this.image_;
  };

  /**
   * @inheritDoc
   */
  ImageTile.prototype.getKey = function getKey () {
    return this.src_;
  };

  /**
   * Tracks loading or read errors.
   *
   * @private
   */
  ImageTile.prototype.handleImageError_ = function handleImageError_ () {
    this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR;
    this.unlistenImage_();
    this.image_ = getBlankImage();
    this.changed();
  };

  /**
   * Tracks successful image load.
   *
   * @private
   */
  ImageTile.prototype.handleImageLoad_ = function handleImageLoad_ () {
    var image = /** @type {HTMLImageElement} */ (this.image_);
    if (image.naturalWidth && image.naturalHeight) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;
    } else {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].EMPTY;
    }
    this.unlistenImage_();
    this.changed();
  };

  /**
   * @inheritDoc
   * @api
   */
  ImageTile.prototype.load = function load () {
    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE;
      this.image_ = new Image();
      if (this.crossOrigin_ !== null) {
        this.image_.crossOrigin = this.crossOrigin_;
      }
    }
    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING;
      this.changed();
      this.imageListenerKeys_ = [
        Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listenOnce"])(this.image_, _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].ERROR,
          this.handleImageError_, this),
        Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listenOnce"])(this.image_, _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOAD,
          this.handleImageLoad_, this)
      ];
      this.tileLoadFunction_(this, this.src_);
    }
  };

  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */
  ImageTile.prototype.unlistenImage_ = function unlistenImage_ () {
    this.imageListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_3__["unlistenByKey"]);
    this.imageListenerKeys_ = null;
  };

  return ImageTile;
}(_Tile_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/**
 * Get a 1-pixel blank image.
 * @return {HTMLCanvasElement} Blank image.
 */
function getBlankImage() {
  var ctx = Object(_dom_js__WEBPACK_IMPORTED_MODULE_2__["createCanvasContext2D"])(1, 1);
  ctx.fillStyle = 'rgba(0,0,0,0)';
  ctx.fillRect(0, 0, 1, 1);
  return ctx.canvas;
}

/* harmony default export */ __webpack_exports__["default"] = (ImageTile);

//# sourceMappingURL=ImageTile.js.map

/***/ }),

/***/ "./node_modules/ol/LayerType.js":
/*!**************************************!*\
  !*** ./node_modules/ol/LayerType.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/LayerType
 */

/**
 * A layer type used when creating layer renderers.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  IMAGE: 'IMAGE',
  TILE: 'TILE',
  VECTOR_TILE: 'VECTOR_TILE',
  VECTOR: 'VECTOR'
});

//# sourceMappingURL=LayerType.js.map

/***/ }),

/***/ "./node_modules/ol/Object.js":
/*!***********************************!*\
  !*** ./node_modules/ol/Object.js ***!
  \***********************************/
/*! exports provided: ObjectEvent, getChangeEventType, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjectEvent", function() { return ObjectEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getChangeEventType", function() { return getChangeEventType; });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ObjectEventType.js */ "./node_modules/ol/ObjectEventType.js");
/* harmony import */ var _Observable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Observable.js */ "./node_modules/ol/Observable.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/Object
 */







/**
 * @classdesc
 * Events emitted by {@link module:ol/Object~BaseObject} instances are instances of this type.
 */
var ObjectEvent = /*@__PURE__*/(function (Event) {
  function ObjectEvent(type, key, oldValue) {
    Event.call(this, type);

    /**
     * The name of the property whose value is changing.
     * @type {string}
     * @api
     */
    this.key = key;

    /**
     * The old value. To get the new value use `e.target.get(e.key)` where
     * `e` is the event object.
     * @type {*}
     * @api
     */
    this.oldValue = oldValue;

  }

  if ( Event ) ObjectEvent.__proto__ = Event;
  ObjectEvent.prototype = Object.create( Event && Event.prototype );
  ObjectEvent.prototype.constructor = ObjectEvent;

  return ObjectEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_3__["default"]));


/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Most non-trivial classes inherit from this.
 *
 * This extends {@link module:ol/Observable} with observable
 * properties, where each property is observable as well as the object as a
 * whole.
 *
 * Classes that inherit from this have pre-defined properties, to which you can
 * add your owns. The pre-defined properties are listed in this documentation as
 * 'Observable Properties', and have their own accessors; for example,
 * {@link module:ol/Map~Map} has a `target` property, accessed with
 * `getTarget()` and changed with `setTarget()`. Not all properties are however
 * settable. There are also general-purpose accessors `get()` and `set()`. For
 * example, `get('target')` is equivalent to `getTarget()`.
 *
 * The `set` accessors trigger a change event, and you can monitor this by
 * registering a listener. For example, {@link module:ol/View~View} has a
 * `center` property, so `view.on('change:center', function(evt) {...});` would
 * call the function whenever the value of the center property changes. Within
 * the function, `evt.target` would be the view, so `evt.target.getCenter()`
 * would return the new center.
 *
 * You can add your own observable properties with
 * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.
 * You can listen for changes on that property value with
 * `object.on('change:prop', listener)`. You can get a list of all
 * properties with {@link module:ol/Object~BaseObject#getProperties}.
 *
 * Note that the observable properties are separate from standard JS properties.
 * You can, for example, give your map object a title with
 * `map.title='New title'` and with `map.set('title', 'Another title')`. The
 * first will be a `hasOwnProperty`; the second will appear in
 * `getProperties()`. Only the second is observable.
 *
 * Properties can be deleted by using the unset method. E.g.
 * object.unset('foo').
 *
 * @fires ObjectEvent
 * @api
 */
var BaseObject = /*@__PURE__*/(function (Observable) {
  function BaseObject(opt_values) {
    Observable.call(this);

    // Call {@link module:ol/util~getUid} to ensure that the order of objects' ids is
    // the same as the order in which they were created.  This also helps to
    // ensure that object properties are always added in the same order, which
    // helps many JavaScript engines generate faster code.
    Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(this);

    /**
     * @private
     * @type {!Object<string, *>}
     */
    this.values_ = {};

    if (opt_values !== undefined) {
      this.setProperties(opt_values);
    }
  }

  if ( Observable ) BaseObject.__proto__ = Observable;
  BaseObject.prototype = Object.create( Observable && Observable.prototype );
  BaseObject.prototype.constructor = BaseObject;

  /**
   * Gets a value.
   * @param {string} key Key name.
   * @return {*} Value.
   * @api
   */
  BaseObject.prototype.get = function get (key) {
    var value;
    if (this.values_.hasOwnProperty(key)) {
      value = this.values_[key];
    }
    return value;
  };

  /**
   * Get a list of object property names.
   * @return {Array<string>} List of property names.
   * @api
   */
  BaseObject.prototype.getKeys = function getKeys () {
    return Object.keys(this.values_);
  };

  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>} Object.
   * @api
   */
  BaseObject.prototype.getProperties = function getProperties () {
    return Object(_obj_js__WEBPACK_IMPORTED_MODULE_4__["assign"])({}, this.values_);
  };

  /**
   * @param {string} key Key name.
   * @param {*} oldValue Old value.
   */
  BaseObject.prototype.notify = function notify (key, oldValue) {
    var eventType;
    eventType = getChangeEventType(key);
    this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
    eventType = _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].PROPERTYCHANGE;
    this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
  };

  /**
   * Sets a value.
   * @param {string} key Key name.
   * @param {*} value Value.
   * @param {boolean=} opt_silent Update without triggering an event.
   * @api
   */
  BaseObject.prototype.set = function set (key, value, opt_silent) {
    if (opt_silent) {
      this.values_[key] = value;
    } else {
      var oldValue = this.values_[key];
      this.values_[key] = value;
      if (oldValue !== value) {
        this.notify(key, oldValue);
      }
    }
  };

  /**
   * Sets a collection of key-value pairs.  Note that this changes any existing
   * properties and adds new ones (it does not remove any existing properties).
   * @param {Object<string, *>} values Values.
   * @param {boolean=} opt_silent Update without triggering an event.
   * @api
   */
  BaseObject.prototype.setProperties = function setProperties (values, opt_silent) {
    for (var key in values) {
      this.set(key, values[key], opt_silent);
    }
  };

  /**
   * Unsets a property.
   * @param {string} key Key name.
   * @param {boolean=} opt_silent Unset without triggering an event.
   * @api
   */
  BaseObject.prototype.unset = function unset (key, opt_silent) {
    if (key in this.values_) {
      var oldValue = this.values_[key];
      delete this.values_[key];
      if (!opt_silent) {
        this.notify(key, oldValue);
      }
    }
  };

  return BaseObject;
}(_Observable_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/**
 * @type {Object<string, string>}
 */
var changeEventTypeCache = {};


/**
 * @param {string} key Key name.
 * @return {string} Change name.
 */
function getChangeEventType(key) {
  return changeEventTypeCache.hasOwnProperty(key) ?
    changeEventTypeCache[key] :
    (changeEventTypeCache[key] = 'change:' + key);
}


/* harmony default export */ __webpack_exports__["default"] = (BaseObject);

//# sourceMappingURL=Object.js.map

/***/ }),

/***/ "./node_modules/ol/ObjectEventType.js":
/*!********************************************!*\
  !*** ./node_modules/ol/ObjectEventType.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/ObjectEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  /**
   * Triggered when a property is changed.
   * @event module:ol/Object.ObjectEvent#propertychange
   * @api
   */
  PROPERTYCHANGE: 'propertychange'
});

//# sourceMappingURL=ObjectEventType.js.map

/***/ }),

/***/ "./node_modules/ol/Observable.js":
/*!***************************************!*\
  !*** ./node_modules/ol/Observable.js ***!
  \***************************************/
/*! exports provided: unByKey, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unByKey", function() { return unByKey; });
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events/Target.js */ "./node_modules/ol/events/Target.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/**
 * @module ol/Observable
 */




/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * An event target providing convenient methods for listener registration
 * and unregistration. A generic `change` event is always available through
 * {@link module:ol/Observable~Observable#changed}.
 *
 * @fires import("./events/Event.js").Event
 * @api
 */
var Observable = /*@__PURE__*/(function (EventTarget) {
  function Observable() {

    EventTarget.call(this);

    /**
     * @private
     * @type {number}
     */
    this.revision_ = 0;

  }

  if ( EventTarget ) Observable.__proto__ = EventTarget;
  Observable.prototype = Object.create( EventTarget && EventTarget.prototype );
  Observable.prototype.constructor = Observable;

  /**
   * Increases the revision counter and dispatches a 'change' event.
   * @api
   */
  Observable.prototype.changed = function changed () {
    ++this.revision_;
    this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CHANGE);
  };

  /**
   * Get the version number for this object.  Each time the object is modified,
   * its version number will be incremented.
   * @return {number} Revision.
   * @api
   */
  Observable.prototype.getRevision = function getRevision () {
    return this.revision_;
  };

  /**
   * Listen for a certain type of event.
   * @param {string|Array<string>} type The event type or array of event types.
   * @param {function(?): ?} listener The listener function.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
   *     called with an array of event types as the first argument, the return
   *     will be an array of keys.
   * @api
   */
  Observable.prototype.on = function on (type, listener) {
    if (Array.isArray(type)) {
      var len = type.length;
      var keys = new Array(len);
      for (var i = 0; i < len; ++i) {
        keys[i] = Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listen"])(this, type[i], listener);
      }
      return keys;
    } else {
      return Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listen"])(this, /** @type {string} */ (type), listener);
    }
  };

  /**
   * Listen once for a certain type of event.
   * @param {string|Array<string>} type The event type or array of event types.
   * @param {function(?): ?} listener The listener function.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
   *     called with an array of event types as the first argument, the return
   *     will be an array of keys.
   * @api
   */
  Observable.prototype.once = function once (type, listener) {
    if (Array.isArray(type)) {
      var len = type.length;
      var keys = new Array(len);
      for (var i = 0; i < len; ++i) {
        keys[i] = Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listenOnce"])(this, type[i], listener);
      }
      return keys;
    } else {
      return Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listenOnce"])(this, /** @type {string} */ (type), listener);
    }
  };

  /**
   * Unlisten for a certain type of event.
   * @param {string|Array<string>} type The event type or array of event types.
   * @param {function(?): ?} listener The listener function.
   * @api
   */
  Observable.prototype.un = function un (type, listener) {
    if (Array.isArray(type)) {
      for (var i = 0, ii = type.length; i < ii; ++i) {
        Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["unlisten"])(this, type[i], listener);
      }
      return;
    } else {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["unlisten"])(this, /** @type {string} */ (type), listener);
    }
  };

  return Observable;
}(_events_Target_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/**
 * Removes an event listener using the key returned by `on()` or `once()`.
 * @param {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} key The key returned by `on()`
 *     or `once()` (or an array of keys).
 * @api
 */
function unByKey(key) {
  if (Array.isArray(key)) {
    for (var i = 0, ii = key.length; i < ii; ++i) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["unlistenByKey"])(key[i]);
    }
  } else {
    Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["unlistenByKey"])(/** @type {import("./events.js").EventsKey} */ (key));
  }
}


/* harmony default export */ __webpack_exports__["default"] = (Observable);

//# sourceMappingURL=Observable.js.map

/***/ }),

/***/ "./node_modules/ol/Tile.js":
/*!*********************************!*\
  !*** ./node_modules/ol/Tile.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./easing.js */ "./node_modules/ol/easing.js");
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events/Target.js */ "./node_modules/ol/events/Target.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/**
 * @module ol/Tile
 */






/**
 * A function that takes an {@link module:ol/Tile} for the tile and a
 * `{string}` for the url as arguments. The default is
 * ```js
 * source.setTileLoadFunction(function(tile, src) {
 *   tile.getImage().src = src;
 * });
 * ```
 * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve
 * error handling:
 *
 * ```js
 * import TileState from 'ol/TileState';
 *
 * source.setTileLoadFunction(function(tile, src) {
 *   var xhr = new XMLHttpRequest();
 *   xhr.responseType = 'blob';
 *   xhr.addEventListener('loadend', function (evt) {
 *     var data = this.response;
 *     if (data !== undefined) {
 *       tile.getImage().src = URL.createObjectURL(data);
 *     } else {
 *       tile.setState(TileState.ERROR);
 *     }
 *   });
 *   xhr.addEventListener('error', function () {
 *     tile.setState(TileState.ERROR);
 *   });
 *   xhr.open('GET', src);
 *   xhr.send();
 * });
 * ```
 *
 * @typedef {function(Tile, string)} LoadFunction
 * @api
 */

/**
 * {@link module:ol/source/Tile~Tile} sources use a function of this type to get
 * the url that provides a tile for a given tile coordinate.
 *
 * This function takes an {@link module:ol/tilecoord~TileCoord} for the tile
 * coordinate, a `{number}` representing the pixel ratio and a
 * {@link module:ol/proj/Projection} for the projection  as arguments
 * and returns a `{string}` representing the tile URL, or undefined if no tile
 * should be requested for the passed tile coordinate.
 *
 * @typedef {function(import("./tilecoord.js").TileCoord, number,
 *           import("./proj/Projection.js").default): (string|undefined)} UrlFunction
 * @api
 */


/**
 * @typedef {Object} Options
 * @property {number} [transition=250] A duration for tile opacity
 * transitions in milliseconds. A duration of 0 disables the opacity transition.
 * @api
 */


/**
 * @classdesc
 * Base class for tiles.
 *
 * @abstract
 */
var Tile = /*@__PURE__*/(function (EventTarget) {
  function Tile(tileCoord, state, opt_options) {
    EventTarget.call(this);

    var options = opt_options ? opt_options : {};

    /**
     * @type {import("./tilecoord.js").TileCoord}
     */
    this.tileCoord = tileCoord;

    /**
     * @protected
     * @type {TileState}
     */
    this.state = state;

    /**
     * An "interim" tile for this tile. The interim tile may be used while this
     * one is loading, for "smooth" transitions when changing params/dimensions
     * on the source.
     * @type {Tile}
     */
    this.interimTile = null;

    /**
     * A key assigned to the tile. This is used by the tile source to determine
     * if this tile can effectively be used, or if a new tile should be created
     * and this one be used as an interim tile for this new tile.
     * @type {string}
     */
    this.key = '';

    /**
     * The duration for the opacity transition.
     * @type {number}
     */
    this.transition_ = options.transition === undefined ? 250 : options.transition;

    /**
     * Lookup of start times for rendering transitions.  If the start time is
     * equal to -1, the transition is complete.
     * @type {Object<string, number>}
     */
    this.transitionStarts_ = {};

  }

  if ( EventTarget ) Tile.__proto__ = EventTarget;
  Tile.prototype = Object.create( EventTarget && EventTarget.prototype );
  Tile.prototype.constructor = Tile;

  /**
   * @protected
   */
  Tile.prototype.changed = function changed () {
    this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].CHANGE);
  };

  /**
   * @return {string} Key.
   */
  Tile.prototype.getKey = function getKey () {
    return this.key + '/' + this.tileCoord;
  };

  /**
   * Get the interim tile most suitable for rendering using the chain of interim
   * tiles. This corresponds to the  most recent tile that has been loaded, if no
   * such tile exists, the original tile is returned.
   * @return {!Tile} Best tile for rendering.
   */
  Tile.prototype.getInterimTile = function getInterimTile () {
    if (!this.interimTile) {
      //empty chain
      return this;
    }
    var tile = this.interimTile;

    // find the first loaded tile and return it. Since the chain is sorted in
    // decreasing order of creation time, there is no need to search the remainder
    // of the list (all those tiles correspond to older requests and will be
    // cleaned up by refreshInterimChain)
    do {
      if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADED) {
        return tile;
      }
      tile = tile.interimTile;
    } while (tile);

    // we can not find a better tile
    return this;
  };

  /**
   * Goes through the chain of interim tiles and discards sections of the chain
   * that are no longer relevant.
   */
  Tile.prototype.refreshInterimChain = function refreshInterimChain () {
    if (!this.interimTile) {
      return;
    }

    var tile = this.interimTile;
    var prev = /** @type {Tile} */ (this);

    do {
      if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADED) {
        //we have a loaded tile, we can discard the rest of the list
        //we would could abort any LOADING tile request
        //older than this tile (i.e. any LOADING tile following this entry in the chain)
        tile.interimTile = null;
        break;
      } else if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADING) {
        //keep this LOADING tile any loaded tiles later in the chain are
        //older than this tile, so we're still interested in the request
        prev = tile;
      } else if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].IDLE) {
        //the head of the list is the most current tile, we don't need
        //to start any other requests for this chain
        prev.interimTile = tile.interimTile;
      } else {
        prev = tile;
      }
      tile = prev.interimTile;
    } while (tile);
  };

  /**
   * Get the tile coordinate for this tile.
   * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
   * @api
   */
  Tile.prototype.getTileCoord = function getTileCoord () {
    return this.tileCoord;
  };

  /**
   * @return {TileState} State.
   */
  Tile.prototype.getState = function getState () {
    return this.state;
  };

  /**
   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
   * when the tile cannot be loaded. Otherwise the tile cannot be removed from
   * the tile queue and will block other requests.
   * @param {TileState} state State.
   * @api
   */
  Tile.prototype.setState = function setState (state) {
    this.state = state;
    this.changed();
  };

  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   * @abstract
   * @api
   */
  Tile.prototype.load = function load () {};

  /**
   * Get the alpha value for rendering.
   * @param {string} id An id for the renderer.
   * @param {number} time The render frame time.
   * @return {number} A number between 0 and 1.
   */
  Tile.prototype.getAlpha = function getAlpha (id, time) {
    if (!this.transition_) {
      return 1;
    }

    var start = this.transitionStarts_[id];
    if (!start) {
      start = time;
      this.transitionStarts_[id] = start;
    } else if (start === -1) {
      return 1;
    }

    var delta = time - start + (1000 / 60); // avoid rendering at 0
    if (delta >= this.transition_) {
      return 1;
    }
    return Object(_easing_js__WEBPACK_IMPORTED_MODULE_1__["easeIn"])(delta / this.transition_);
  };

  /**
   * Determine if a tile is in an alpha transition.  A tile is considered in
   * transition if tile.getAlpha() has not yet been called or has been called
   * and returned 1.
   * @param {string} id An id for the renderer.
   * @return {boolean} The tile is in transition.
   */
  Tile.prototype.inTransition = function inTransition (id) {
    if (!this.transition_) {
      return false;
    }
    return this.transitionStarts_[id] !== -1;
  };

  /**
   * Mark a transition as complete.
   * @param {string} id An id for the renderer.
   */
  Tile.prototype.endTransition = function endTransition (id) {
    if (this.transition_) {
      this.transitionStarts_[id] = -1;
    }
  };

  return Tile;
}(_events_Target_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (Tile);

//# sourceMappingURL=Tile.js.map

/***/ }),

/***/ "./node_modules/ol/TileCache.js":
/*!**************************************!*\
  !*** ./node_modules/ol/TileCache.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _structs_LRUCache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./structs/LRUCache.js */ "./node_modules/ol/structs/LRUCache.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tilecoord.js */ "./node_modules/ol/tilecoord.js");
/**
 * @module ol/TileCache
 */



var TileCache = /*@__PURE__*/(function (LRUCache) {
  function TileCache(opt_highWaterMark) {

    LRUCache.call(this, opt_highWaterMark);

  }

  if ( LRUCache ) TileCache.__proto__ = LRUCache;
  TileCache.prototype = Object.create( LRUCache && LRUCache.prototype );
  TileCache.prototype.constructor = TileCache;

  /**
   * @param {!Object<string, import("./TileRange.js").default>} usedTiles Used tiles.
   */
  TileCache.prototype.expireCache = function expireCache (usedTiles) {
    while (this.canExpireCache()) {
      var tile = this.peekLast();
      var zKey = tile.tileCoord[0].toString();
      if (zKey in usedTiles && usedTiles[zKey].contains(tile.tileCoord)) {
        break;
      } else {
        this.pop().dispose();
      }
    }
  };

  /**
   * Prune all tiles from the cache that don't have the same z as the newest tile.
   */
  TileCache.prototype.pruneExceptNewestZ = function pruneExceptNewestZ () {
    if (this.getCount() === 0) {
      return;
    }
    var key = this.peekFirstKey();
    var tileCoord = Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_1__["fromKey"])(key);
    var z = tileCoord[0];
    this.forEach(function(tile) {
      if (tile.tileCoord[0] !== z) {
        this.remove(Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_1__["getKey"])(tile.tileCoord));
        tile.dispose();
      }
    }, this);
  };

  return TileCache;
}(_structs_LRUCache_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (TileCache);

//# sourceMappingURL=TileCache.js.map

/***/ }),

/***/ "./node_modules/ol/TileQueue.js":
/*!**************************************!*\
  !*** ./node_modules/ol/TileQueue.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _structs_PriorityQueue_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./structs/PriorityQueue.js */ "./node_modules/ol/structs/PriorityQueue.js");
/**
 * @module ol/TileQueue
 */






/**
 * @typedef {function(import("./Tile.js").default, string, import("./coordinate.js").Coordinate, number): number} PriorityFunction
 */


var TileQueue = /*@__PURE__*/(function (PriorityQueue) {
  function TileQueue(tilePriorityFunction, tileChangeCallback) {

    PriorityQueue.call(
      /**
       * @param {Array} element Element.
       * @return {number} Priority.
       */
      this, function(element) {
        return tilePriorityFunction.apply(null, element);
      },
      /**
       * @param {Array} element Element.
       * @return {string} Key.
       */
      function(element) {
        return (/** @type {import("./Tile.js").default} */ (element[0]).getKey());
      });

    /**
     * @private
     * @type {function(): ?}
     */
    this.tileChangeCallback_ = tileChangeCallback;

    /**
     * @private
     * @type {number}
     */
    this.tilesLoading_ = 0;

    /**
     * @private
     * @type {!Object<string,boolean>}
     */
    this.tilesLoadingKeys_ = {};

  }

  if ( PriorityQueue ) TileQueue.__proto__ = PriorityQueue;
  TileQueue.prototype = Object.create( PriorityQueue && PriorityQueue.prototype );
  TileQueue.prototype.constructor = TileQueue;

  /**
   * @inheritDoc
   */
  TileQueue.prototype.enqueue = function enqueue (element) {
    var added = PriorityQueue.prototype.enqueue.call(this, element);
    if (added) {
      var tile = element[0];
      Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["listen"])(tile, _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CHANGE, this.handleTileChange, this);
    }
    return added;
  };

  /**
   * @return {number} Number of tiles loading.
   */
  TileQueue.prototype.getTilesLoading = function getTilesLoading () {
    return this.tilesLoading_;
  };

  /**
   * @param {import("./events/Event.js").default} event Event.
   * @protected
   */
  TileQueue.prototype.handleTileChange = function handleTileChange (event) {
    var tile = /** @type {import("./Tile.js").default} */ (event.target);
    var state = tile.getState();
    if (state === _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADED || state === _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].ERROR ||
        state === _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].EMPTY || state === _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].ABORT) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["unlisten"])(tile, _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CHANGE, this.handleTileChange, this);
      var tileKey = tile.getKey();
      if (tileKey in this.tilesLoadingKeys_) {
        delete this.tilesLoadingKeys_[tileKey];
        --this.tilesLoading_;
      }
      this.tileChangeCallback_();
    }
  };

  /**
   * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
   * @param {number} maxNewLoads Maximum number of new tiles to load.
   */
  TileQueue.prototype.loadMoreTiles = function loadMoreTiles (maxTotalLoading, maxNewLoads) {
    var newLoads = 0;
    var abortedTiles = false;
    var state, tile, tileKey;
    while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads &&
           this.getCount() > 0) {
      tile = /** @type {import("./Tile.js").default} */ (this.dequeue()[0]);
      tileKey = tile.getKey();
      state = tile.getState();
      if (state === _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].ABORT) {
        abortedTiles = true;
      } else if (state === _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].IDLE && !(tileKey in this.tilesLoadingKeys_)) {
        this.tilesLoadingKeys_[tileKey] = true;
        ++this.tilesLoading_;
        ++newLoads;
        tile.load();
      }
    }
    if (newLoads === 0 && abortedTiles) {
      // Do not stop the render loop when all wanted tiles were aborted due to
      // a small, saturated tile cache.
      this.tileChangeCallback_();
    }
  };

  return TileQueue;
}(_structs_PriorityQueue_js__WEBPACK_IMPORTED_MODULE_3__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (TileQueue);

//# sourceMappingURL=TileQueue.js.map

/***/ }),

/***/ "./node_modules/ol/TileRange.js":
/*!**************************************!*\
  !*** ./node_modules/ol/TileRange.js ***!
  \**************************************/
/*! exports provided: createOrUpdate, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdate", function() { return createOrUpdate; });
/**
 * @module ol/TileRange
 */

/**
 * A representation of a contiguous block of tiles.  A tile range is specified
 * by its min/max tile coordinates and is inclusive of coordinates.
 */
var TileRange = function TileRange(minX, maxX, minY, maxY) {

  /**
   * @type {number}
   */
  this.minX = minX;

  /**
   * @type {number}
   */
  this.maxX = maxX;

  /**
   * @type {number}
   */
  this.minY = minY;

  /**
   * @type {number}
   */
  this.maxY = maxY;

};

/**
 * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @return {boolean} Contains tile coordinate.
 */
TileRange.prototype.contains = function contains (tileCoord) {
  return this.containsXY(tileCoord[1], tileCoord[2]);
};

/**
 * @param {TileRange} tileRange Tile range.
 * @return {boolean} Contains.
 */
TileRange.prototype.containsTileRange = function containsTileRange (tileRange) {
  return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX &&
     this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;
};

/**
 * @param {number} x Tile coordinate x.
 * @param {number} y Tile coordinate y.
 * @return {boolean} Contains coordinate.
 */
TileRange.prototype.containsXY = function containsXY (x, y) {
  return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
};

/**
 * @param {TileRange} tileRange Tile range.
 * @return {boolean} Equals.
 */
TileRange.prototype.equals = function equals (tileRange) {
  return this.minX == tileRange.minX && this.minY == tileRange.minY &&
     this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;
};

/**
 * @param {TileRange} tileRange Tile range.
 */
TileRange.prototype.extend = function extend (tileRange) {
  if (tileRange.minX < this.minX) {
    this.minX = tileRange.minX;
  }
  if (tileRange.maxX > this.maxX) {
    this.maxX = tileRange.maxX;
  }
  if (tileRange.minY < this.minY) {
    this.minY = tileRange.minY;
  }
  if (tileRange.maxY > this.maxY) {
    this.maxY = tileRange.maxY;
  }
};

/**
 * @return {number} Height.
 */
TileRange.prototype.getHeight = function getHeight () {
  return this.maxY - this.minY + 1;
};

/**
 * @return {import("./size.js").Size} Size.
 */
TileRange.prototype.getSize = function getSize () {
  return [this.getWidth(), this.getHeight()];
};

/**
 * @return {number} Width.
 */
TileRange.prototype.getWidth = function getWidth () {
  return this.maxX - this.minX + 1;
};

/**
 * @param {TileRange} tileRange Tile range.
 * @return {boolean} Intersects.
 */
TileRange.prototype.intersects = function intersects (tileRange) {
  return this.minX <= tileRange.maxX &&
     this.maxX >= tileRange.minX &&
     this.minY <= tileRange.maxY &&
     this.maxY >= tileRange.minY;
};


/**
 * @param {number} minX Minimum X.
 * @param {number} maxX Maximum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxY Maximum Y.
 * @param {TileRange=} tileRange TileRange.
 * @return {TileRange} Tile range.
 */
function createOrUpdate(minX, maxX, minY, maxY, tileRange) {
  if (tileRange !== undefined) {
    tileRange.minX = minX;
    tileRange.maxX = maxX;
    tileRange.minY = minY;
    tileRange.maxY = maxY;
    return tileRange;
  } else {
    return new TileRange(minX, maxX, minY, maxY);
  }
}


/* harmony default export */ __webpack_exports__["default"] = (TileRange);

//# sourceMappingURL=TileRange.js.map

/***/ }),

/***/ "./node_modules/ol/TileState.js":
/*!**************************************!*\
  !*** ./node_modules/ol/TileState.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/TileState
 */

/**
 * @enum {number}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  /**
   * Indicates that tile loading failed
   * @type {number}
   */
  ERROR: 3,
  EMPTY: 4,
  ABORT: 5
});

//# sourceMappingURL=TileState.js.map

/***/ }),

/***/ "./node_modules/ol/VectorImageTile.js":
/*!********************************************!*\
  !*** ./node_modules/ol/VectorImageTile.js ***!
  \********************************************/
/*! exports provided: default, defaultLoadFunction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultLoadFunction", function() { return defaultLoadFunction; });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Tile.js */ "./node_modules/ol/Tile.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _featureloader_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./featureloader.js */ "./node_modules/ol/featureloader.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./functions.js */ "./node_modules/ol/functions.js");
/**
 * @module ol/VectorImageTile
 */











/**
 * @typedef {Object} ReplayState
 * @property {boolean} dirty
 * @property {null|import("./render.js").OrderFunction} renderedRenderOrder
 * @property {number} renderedTileRevision
 * @property {number} renderedRevision
 */


var VectorImageTile = /*@__PURE__*/(function (Tile) {
  function VectorImageTile(tileCoord, state, sourceRevision, format, tileLoadFunction,
    urlTileCoord, tileUrlFunction, sourceTileGrid, tileGrid, sourceTiles,
    pixelRatio, projection, tileClass, handleTileChange, zoom) {

    Tile.call(this, tileCoord, state, {transition: 0});

    /**
     * @private
     * @type {!Object<string, CanvasRenderingContext2D>}
     */
    this.context_ = {};

    /**
     * @private
     * @type {import("./featureloader.js").FeatureLoader}
     */
    this.loader_;

    /**
     * @private
     * @type {!Object<string, ReplayState>}
     */
    this.replayState_ = {};

    /**
     * @private
     * @type {Object<string, import("./VectorTile.js").default>}
     */
    this.sourceTiles_ = sourceTiles;

    /**
     * Keys of source tiles used by this tile. Use with {@link #getTile}.
     * @type {Array<string>}
     */
    this.tileKeys = [];

    /**
     * @type {import("./extent.js").Extent}
     */
    this.extent = null;

    /**
     * @type {number}
     */
    this.sourceRevision_ = sourceRevision;

    /**
     * @type {import("./tilecoord.js").TileCoord}
     */
    this.wrappedTileCoord = urlTileCoord;

    /**
     * @type {Array<import("./events.js").EventsKey>}
     */
    this.loadListenerKeys_ = [];

    /**
     * @type {Array<import("./events.js").EventsKey>}
     */
    this.sourceTileListenerKeys_ = [];

    if (urlTileCoord) {
      var extent = this.extent = tileGrid.getTileCoordExtent(urlTileCoord);
      var resolution = tileGrid.getResolution(zoom);
      var sourceZ = sourceTileGrid.getZForResolution(resolution);
      var useLoadedOnly = zoom != tileCoord[0];
      var loadCount = 0;
      sourceTileGrid.forEachTileCoord(extent, sourceZ, function(sourceTileCoord) {
        var sharedExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getIntersection"])(extent,
          sourceTileGrid.getTileCoordExtent(sourceTileCoord));
        var sourceExtent = sourceTileGrid.getExtent();
        if (sourceExtent) {
          sharedExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getIntersection"])(sharedExtent, sourceExtent, sharedExtent);
        }
        if (Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getWidth"])(sharedExtent) / resolution >= 0.5 &&
            Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getHeight"])(sharedExtent) / resolution >= 0.5) {
          // only include source tile if overlap is at least 1 pixel
          ++loadCount;
          var sourceTileKey = sourceTileCoord.toString();
          var sourceTile = sourceTiles[sourceTileKey];
          if (!sourceTile && !useLoadedOnly) {
            var tileUrl = tileUrlFunction(sourceTileCoord, pixelRatio, projection);
            sourceTile = sourceTiles[sourceTileKey] = new tileClass(sourceTileCoord,
              tileUrl == undefined ? _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY : _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE,
              tileUrl == undefined ? '' : tileUrl,
              format, tileLoadFunction);
            this.sourceTileListenerKeys_.push(
              Object(_events_js__WEBPACK_IMPORTED_MODULE_4__["listen"])(sourceTile, _events_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].CHANGE, handleTileChange));
          }
          if (sourceTile && (!useLoadedOnly || sourceTile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED)) {
            sourceTile.consumers++;
            this.tileKeys.push(sourceTileKey);
          }
        }
      }.bind(this));

      if (useLoadedOnly && loadCount == this.tileKeys.length) {
        this.finishLoading_();
      }

      if (zoom <= tileCoord[0] && this.state != _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
        while (zoom > tileGrid.getMinZoom()) {
          var tile = new VectorImageTile(tileCoord, state, sourceRevision,
            format, tileLoadFunction, urlTileCoord, tileUrlFunction,
            sourceTileGrid, tileGrid, sourceTiles, pixelRatio, projection,
            tileClass, _functions_js__WEBPACK_IMPORTED_MODULE_8__["VOID"], --zoom);
          if (tile.state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
            this.interimTile = tile;
            break;
          }
        }
      }
    }

  }

  if ( Tile ) VectorImageTile.__proto__ = Tile;
  VectorImageTile.prototype = Object.create( Tile && Tile.prototype );
  VectorImageTile.prototype.constructor = VectorImageTile;

  /**
   * @inheritDoc
   */
  VectorImageTile.prototype.disposeInternal = function disposeInternal () {
    this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ABORT;
    this.changed();
    if (this.interimTile) {
      this.interimTile.dispose();
    }

    for (var i = 0, ii = this.tileKeys.length; i < ii; ++i) {
      var sourceTileKey = this.tileKeys[i];
      var sourceTile = this.getTile(sourceTileKey);
      sourceTile.consumers--;
      if (sourceTile.consumers == 0) {
        delete this.sourceTiles_[sourceTileKey];
        sourceTile.dispose();
      }
    }
    this.tileKeys.length = 0;
    this.sourceTiles_ = null;
    this.loadListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_4__["unlistenByKey"]);
    this.loadListenerKeys_.length = 0;
    this.sourceTileListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_4__["unlistenByKey"]);
    this.sourceTileListenerKeys_.length = 0;
    Tile.prototype.disposeInternal.call(this);
  };

  /**
   * @param {import("./layer/Layer.js").default} layer Layer.
   * @return {CanvasRenderingContext2D} The rendering context.
   */
  VectorImageTile.prototype.getContext = function getContext (layer) {
    var key = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(layer);
    if (!(key in this.context_)) {
      this.context_[key] = Object(_dom_js__WEBPACK_IMPORTED_MODULE_3__["createCanvasContext2D"])();
    }
    return this.context_[key];
  };

  /**
   * Get the Canvas for this tile.
   * @param {import("./layer/Layer.js").default} layer Layer.
   * @return {HTMLCanvasElement} Canvas.
   */
  VectorImageTile.prototype.getImage = function getImage (layer) {
    return this.getReplayState(layer).renderedTileRevision == -1 ?
      null : this.getContext(layer).canvas;
  };

  /**
   * @param {import("./layer/Layer.js").default} layer Layer.
   * @return {ReplayState} The replay state.
   */
  VectorImageTile.prototype.getReplayState = function getReplayState (layer) {
    var key = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(layer);
    if (!(key in this.replayState_)) {
      this.replayState_[key] = {
        dirty: false,
        renderedRenderOrder: null,
        renderedRevision: -1,
        renderedTileRevision: -1
      };
    }
    return this.replayState_[key];
  };

  /**
   * @inheritDoc
   */
  VectorImageTile.prototype.getKey = function getKey () {
    return this.tileKeys.join('/') + '-' + this.sourceRevision_;
  };

  /**
   * @param {string} tileKey Key (tileCoord) of the source tile.
   * @return {import("./VectorTile.js").default} Source tile.
   */
  VectorImageTile.prototype.getTile = function getTile (tileKey) {
    return this.sourceTiles_[tileKey];
  };

  /**
   * @inheritDoc
   */
  VectorImageTile.prototype.load = function load () {
    // Source tiles with LOADED state - we just count them because once they are
    // loaded, we're no longer listening to state changes.
    var leftToLoad = 0;
    // Source tiles with ERROR state - we track them because they can still have
    // an ERROR state after another load attempt.
    var errorSourceTiles = {};

    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE) {
      this.setState(_TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING);
    }
    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING) {
      this.tileKeys.forEach(function(sourceTileKey) {
        var sourceTile = this.getTile(sourceTileKey);
        if (sourceTile.state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE) {
          sourceTile.setLoader(this.loader_);
          sourceTile.load();
        }
        if (sourceTile.state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING) {
          var key = Object(_events_js__WEBPACK_IMPORTED_MODULE_4__["listen"])(sourceTile, _events_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].CHANGE, function(e) {
            var state = sourceTile.getState();
            if (state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED ||
                state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR) {
              var uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(sourceTile);
              if (state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR) {
                errorSourceTiles[uid] = true;
              } else {
                --leftToLoad;
                delete errorSourceTiles[uid];
              }
              if (leftToLoad - Object.keys(errorSourceTiles).length == 0) {
                this.finishLoading_();
              }
            }
          }.bind(this));
          this.loadListenerKeys_.push(key);
          ++leftToLoad;
        }
      }.bind(this));
    }
    if (leftToLoad - Object.keys(errorSourceTiles).length == 0) {
      setTimeout(this.finishLoading_.bind(this), 0);
    }
  };

  /**
   * @private
   */
  VectorImageTile.prototype.finishLoading_ = function finishLoading_ () {
    var loaded = this.tileKeys.length;
    var empty = 0;
    for (var i = loaded - 1; i >= 0; --i) {
      var state = this.getTile(this.tileKeys[i]).getState();
      if (state != _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
        --loaded;
      }
      if (state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY) {
        ++empty;
      }
    }
    if (loaded == this.tileKeys.length) {
      this.loadListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_4__["unlistenByKey"]);
      this.loadListenerKeys_.length = 0;
      this.setState(_TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED);
    } else {
      this.setState(empty == this.tileKeys.length ? _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY : _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR);
    }
  };

  return VectorImageTile;
}(_Tile_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (VectorImageTile);

/**
 * Sets the loader for a tile.
 * @param {import("./VectorTile.js").default} tile Vector tile.
 * @param {string} url URL.
 */
function defaultLoadFunction(tile, url) {
  var loader = Object(_featureloader_js__WEBPACK_IMPORTED_MODULE_7__["loadFeaturesXhr"])(url, tile.getFormat(), tile.onLoad.bind(tile), tile.onError.bind(tile));
  tile.setLoader(loader);
}

//# sourceMappingURL=VectorImageTile.js.map

/***/ }),

/***/ "./node_modules/ol/VectorTile.js":
/*!***************************************!*\
  !*** ./node_modules/ol/VectorTile.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Tile.js */ "./node_modules/ol/Tile.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TileState.js */ "./node_modules/ol/TileState.js");
/**
 * @module ol/VectorTile
 */




/**
 * @const
 * @type {import("./extent.js").Extent}
 */
var DEFAULT_EXTENT = [0, 0, 4096, 4096];


var VectorTile = /*@__PURE__*/(function (Tile) {
  function VectorTile(tileCoord, state, src, format, tileLoadFunction, opt_options) {

    Tile.call(this, tileCoord, state, opt_options);

    /**
     * @type {number}
     */
    this.consumers = 0;

    /**
     * @private
     * @type {import("./extent.js").Extent}
     */
    this.extent_ = null;

    /**
     * @private
     * @type {import("./format/Feature.js").default}
     */
    this.format_ = format;

    /**
     * @private
     * @type {Array<import("./Feature.js").default>}
     */
    this.features_ = null;

    /**
     * @private
     * @type {import("./featureloader.js").FeatureLoader}
     */
    this.loader_;

    /**
     * Data projection
     * @private
     * @type {import("./proj/Projection.js").default}
     */
    this.projection_ = null;

    /**
     * @private
     * @type {Object<string, import("./render/ReplayGroup.js").default>}
     */
    this.replayGroups_ = {};

    /**
     * @private
     * @type {import("./Tile.js").LoadFunction}
     */
    this.tileLoadFunction_ = tileLoadFunction;

    /**
     * @private
     * @type {string}
     */
    this.url_ = src;

  }

  if ( Tile ) VectorTile.__proto__ = Tile;
  VectorTile.prototype = Object.create( Tile && Tile.prototype );
  VectorTile.prototype.constructor = VectorTile;

  /**
   * @inheritDoc
   */
  VectorTile.prototype.disposeInternal = function disposeInternal () {
    this.features_ = null;
    this.replayGroups_ = {};
    this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ABORT;
    this.changed();
    Tile.prototype.disposeInternal.call(this);
  };

  /**
   * Gets the extent of the vector tile.
   * @return {import("./extent.js").Extent} The extent.
   * @api
   */
  VectorTile.prototype.getExtent = function getExtent () {
    return this.extent_ || DEFAULT_EXTENT;
  };

  /**
   * Get the feature format assigned for reading this tile's features.
   * @return {import("./format/Feature.js").default} Feature format.
   * @api
   */
  VectorTile.prototype.getFormat = function getFormat () {
    return this.format_;
  };

  /**
   * Get the features for this tile. Geometries will be in the projection returned
   * by {@link module:ol/VectorTile~VectorTile#getProjection}.
   * @return {Array<import("./Feature.js").FeatureLike>} Features.
   * @api
   */
  VectorTile.prototype.getFeatures = function getFeatures () {
    return this.features_;
  };

  /**
   * @inheritDoc
   */
  VectorTile.prototype.getKey = function getKey () {
    return this.url_;
  };

  /**
   * Get the feature projection of features returned by
   * {@link module:ol/VectorTile~VectorTile#getFeatures}.
   * @return {import("./proj/Projection.js").default} Feature projection.
   * @api
   */
  VectorTile.prototype.getProjection = function getProjection () {
    return this.projection_;
  };

  /**
   * @param {import("./layer/Layer.js").default} layer Layer.
   * @param {string} key Key.
   * @return {import("./render/ReplayGroup.js").default} Replay group.
   */
  VectorTile.prototype.getReplayGroup = function getReplayGroup (layer, key) {
    return this.replayGroups_[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(layer) + ',' + key];
  };

  /**
   * @inheritDoc
   */
  VectorTile.prototype.load = function load () {
    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE) {
      this.setState(_TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING);
      this.tileLoadFunction_(this, this.url_);
      this.loader_(null, NaN, null);
    }
  };

  /**
   * Handler for successful tile load.
   * @param {Array<import("./Feature.js").default>} features The loaded features.
   * @param {import("./proj/Projection.js").default} dataProjection Data projection.
   * @param {import("./extent.js").Extent} extent Extent.
   */
  VectorTile.prototype.onLoad = function onLoad (features, dataProjection, extent) {
    this.setProjection(dataProjection);
    this.setFeatures(features);
    this.setExtent(extent);
  };

  /**
   * Handler for tile load errors.
   */
  VectorTile.prototype.onError = function onError () {
    this.setState(_TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR);
  };

  /**
   * Function for use in an {@link module:ol/source/VectorTile~VectorTile}'s
   * `tileLoadFunction`. Sets the extent of the vector tile. This is only required
   * for tiles in projections with `tile-pixels` as units. The extent should be
   * set to `[0, 0, tilePixelSize, tilePixelSize]`, where `tilePixelSize` is
   * calculated by multiplying the tile size with the tile pixel ratio. For
   * sources using {@link module:ol/format/MVT~MVT} as feature format, the
   * {@link module:ol/format/MVT~MVT#getLastExtent} method will return the correct
   * extent. The default is `[0, 0, 4096, 4096]`.
   * @param {import("./extent.js").Extent} extent The extent.
   * @api
   */
  VectorTile.prototype.setExtent = function setExtent (extent) {
    this.extent_ = extent;
  };

  /**
   * Function for use in an {@link module:ol/source/VectorTile~VectorTile}'s `tileLoadFunction`.
   * Sets the features for the tile.
   * @param {Array<import("./Feature.js").default>} features Features.
   * @api
   */
  VectorTile.prototype.setFeatures = function setFeatures (features) {
    this.features_ = features;
    this.setState(_TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED);
  };

  /**
   * Function for use in an {@link module:ol/source/VectorTile~VectorTile}'s `tileLoadFunction`.
   * Sets the projection of the features that were added with
   * {@link module:ol/VectorTile~VectorTile#setFeatures}.
   * @param {import("./proj/Projection.js").default} projection Feature projection.
   * @api
   */
  VectorTile.prototype.setProjection = function setProjection (projection) {
    this.projection_ = projection;
  };

  /**
   * @param {import("./layer/Layer.js").default} layer Layer.
   * @param {string} key Key.
   * @param {import("./render/ReplayGroup.js").default} replayGroup Replay group.
   */
  VectorTile.prototype.setReplayGroup = function setReplayGroup (layer, key, replayGroup) {
    this.replayGroups_[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(layer) + ',' + key] = replayGroup;
  };

  /**
   * Set the feature loader for reading this tile's features.
   * @param {import("./featureloader.js").FeatureLoader} loader Feature loader.
   * @api
   */
  VectorTile.prototype.setLoader = function setLoader (loader) {
    this.loader_ = loader;
  };

  return VectorTile;
}(_Tile_js__WEBPACK_IMPORTED_MODULE_1__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (VectorTile);

//# sourceMappingURL=VectorTile.js.map

/***/ }),

/***/ "./node_modules/ol/ViewHint.js":
/*!*************************************!*\
  !*** ./node_modules/ol/ViewHint.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/ViewHint
 */

/**
 * @enum {number}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  ANIMATING: 0,
  INTERACTING: 1
});

//# sourceMappingURL=ViewHint.js.map

/***/ }),

/***/ "./node_modules/ol/array.js":
/*!**********************************!*\
  !*** ./node_modules/ol/array.js ***!
  \**********************************/
/*! exports provided: binarySearch, numberSafeCompareFunction, includes, linearFindNearest, reverseSubArray, extend, remove, find, equals, stableSort, findIndex, isSorted */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "binarySearch", function() { return binarySearch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "numberSafeCompareFunction", function() { return numberSafeCompareFunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "includes", function() { return includes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearFindNearest", function() { return linearFindNearest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverseSubArray", function() { return reverseSubArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "remove", function() { return remove; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "find", function() { return find; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stableSort", function() { return stableSort; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findIndex", function() { return findIndex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSorted", function() { return isSorted; });
/**
 * @module ol/array
 */


/**
 * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.
 * https://github.com/darkskyapp/binary-search
 *
 * @param {Array<*>} haystack Items to search through.
 * @param {*} needle The item to look for.
 * @param {Function=} opt_comparator Comparator function.
 * @return {number} The index of the item if found, -1 if not.
 */
function binarySearch(haystack, needle, opt_comparator) {
  var mid, cmp;
  var comparator = opt_comparator || numberSafeCompareFunction;
  var low = 0;
  var high = haystack.length;
  var found = false;

  while (low < high) {
    /* Note that "(low + high) >>> 1" may overflow, and results in a typecast
     * to double (which gives the wrong results). */
    mid = low + (high - low >> 1);
    cmp = +comparator(haystack[mid], needle);

    if (cmp < 0.0) { /* Too low. */
      low = mid + 1;

    } else { /* Key found or too high */
      high = mid;
      found = !cmp;
    }
  }

  /* Key not found. */
  return found ? low : ~low;
}


/**
 * Compare function for array sort that is safe for numbers.
 * @param {*} a The first object to be compared.
 * @param {*} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is less than, equal to, or greater than the second.
 */
function numberSafeCompareFunction(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
}


/**
 * Whether the array contains the given object.
 * @param {Array<*>} arr The array to test for the presence of the element.
 * @param {*} obj The object for which to test.
 * @return {boolean} The object is in the array.
 */
function includes(arr, obj) {
  return arr.indexOf(obj) >= 0;
}


/**
 * @param {Array<number>} arr Array.
 * @param {number} target Target.
 * @param {number} direction 0 means return the nearest, > 0
 *    means return the largest nearest, < 0 means return the
 *    smallest nearest.
 * @return {number} Index.
 */
function linearFindNearest(arr, target, direction) {
  var n = arr.length;
  if (arr[0] <= target) {
    return 0;
  } else if (target <= arr[n - 1]) {
    return n - 1;
  } else {
    var i;
    if (direction > 0) {
      for (i = 1; i < n; ++i) {
        if (arr[i] < target) {
          return i - 1;
        }
      }
    } else if (direction < 0) {
      for (i = 1; i < n; ++i) {
        if (arr[i] <= target) {
          return i;
        }
      }
    } else {
      for (i = 1; i < n; ++i) {
        if (arr[i] == target) {
          return i;
        } else if (arr[i] < target) {
          if (arr[i - 1] - target < target - arr[i]) {
            return i - 1;
          } else {
            return i;
          }
        }
      }
    }
    return n - 1;
  }
}


/**
 * @param {Array<*>} arr Array.
 * @param {number} begin Begin index.
 * @param {number} end End index.
 */
function reverseSubArray(arr, begin, end) {
  while (begin < end) {
    var tmp = arr[begin];
    arr[begin] = arr[end];
    arr[end] = tmp;
    ++begin;
    --end;
  }
}


/**
 * @param {Array<VALUE>} arr The array to modify.
 * @param {!Array<VALUE>|VALUE} data The elements or arrays of elements to add to arr.
 * @template VALUE
 */
function extend(arr, data) {
  var extension = Array.isArray(data) ? data : [data];
  var length = extension.length;
  for (var i = 0; i < length; i++) {
    arr[arr.length] = extension[i];
  }
}


/**
 * @param {Array<VALUE>} arr The array to modify.
 * @param {VALUE} obj The element to remove.
 * @template VALUE
 * @return {boolean} If the element was removed.
 */
function remove(arr, obj) {
  var i = arr.indexOf(obj);
  var found = i > -1;
  if (found) {
    arr.splice(i, 1);
  }
  return found;
}


/**
 * @param {Array<VALUE>} arr The array to search in.
 * @param {function(VALUE, number, ?) : boolean} func The function to compare.
 * @template VALUE
 * @return {VALUE|null} The element found or null.
 */
function find(arr, func) {
  var length = arr.length >>> 0;
  var value;

  for (var i = 0; i < length; i++) {
    value = arr[i];
    if (func(value, i, arr)) {
      return value;
    }
  }
  return null;
}


/**
 * @param {Array|Uint8ClampedArray} arr1 The first array to compare.
 * @param {Array|Uint8ClampedArray} arr2 The second array to compare.
 * @return {boolean} Whether the two arrays are equal.
 */
function equals(arr1, arr2) {
  var len1 = arr1.length;
  if (len1 !== arr2.length) {
    return false;
  }
  for (var i = 0; i < len1; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
}


/**
 * Sort the passed array such that the relative order of equal elements is preverved.
 * See https://en.wikipedia.org/wiki/Sorting_algorithm#Stability for details.
 * @param {Array<*>} arr The array to sort (modifies original).
 * @param {!function(*, *): number} compareFnc Comparison function.
 * @api
 */
function stableSort(arr, compareFnc) {
  var length = arr.length;
  var tmp = Array(arr.length);
  var i;
  for (i = 0; i < length; i++) {
    tmp[i] = {index: i, value: arr[i]};
  }
  tmp.sort(function(a, b) {
    return compareFnc(a.value, b.value) || a.index - b.index;
  });
  for (i = 0; i < arr.length; i++) {
    arr[i] = tmp[i].value;
  }
}


/**
 * @param {Array<*>} arr The array to search in.
 * @param {Function} func Comparison function.
 * @return {number} Return index.
 */
function findIndex(arr, func) {
  var index;
  var found = !arr.every(function(el, idx) {
    index = idx;
    return !func(el, idx, arr);
  });
  return found ? index : -1;
}


/**
 * @param {Array<*>} arr The array to test.
 * @param {Function=} opt_func Comparison function.
 * @param {boolean=} opt_strict Strictly sorted (default false).
 * @return {boolean} Return index.
 */
function isSorted(arr, opt_func, opt_strict) {
  var compare = opt_func || numberSafeCompareFunction;
  return arr.every(function(currentVal, index) {
    if (index === 0) {
      return true;
    }
    var res = compare(arr[index - 1], currentVal);
    return !(res > 0 || opt_strict && res === 0);
  });
}

//# sourceMappingURL=array.js.map

/***/ }),

/***/ "./node_modules/ol/asserts.js":
/*!************************************!*\
  !*** ./node_modules/ol/asserts.js ***!
  \************************************/
/*! exports provided: assert */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return assert; });
/* harmony import */ var _AssertionError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AssertionError.js */ "./node_modules/ol/AssertionError.js");
/**
 * @module ol/asserts
 */


/**
 * @param {*} assertion Assertion we expected to be truthy.
 * @param {number} errorCode Error code.
 */
function assert(assertion, errorCode) {
  if (!assertion) {
    throw new _AssertionError_js__WEBPACK_IMPORTED_MODULE_0__["default"](errorCode);
  }
}

//# sourceMappingURL=asserts.js.map

/***/ }),

/***/ "./node_modules/ol/color.js":
/*!**********************************!*\
  !*** ./node_modules/ol/color.js ***!
  \**********************************/
/*! exports provided: asString, fromString, asArray, normalize, toString */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asString", function() { return asString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromString", function() { return fromString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asArray", function() { return asArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toString", function() { return toString; });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/color
 */




/**
 * A color represented as a short array [red, green, blue, alpha].
 * red, green, and blue should be integers in the range 0..255 inclusive.
 * alpha should be a float in the range 0..1 inclusive. If no alpha value is
 * given then `1` will be used.
 * @typedef {Array<number>} Color
 * @api
 */


/**
 * This RegExp matches # followed by 3, 4, 6, or 8 hex digits.
 * @const
 * @type {RegExp}
 * @private
 */
var HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i;


/**
 * Regular expression for matching potential named color style strings.
 * @const
 * @type {RegExp}
 * @private
 */
var NAMED_COLOR_RE_ = /^([a-z]*)$/i;


/**
 * Return the color as an rgba string.
 * @param {Color|string} color Color.
 * @return {string} Rgba string.
 * @api
 */
function asString(color) {
  if (typeof color === 'string') {
    return color;
  } else {
    return toString(color);
  }
}

/**
 * Return named color as an rgba string.
 * @param {string} color Named color.
 * @return {string} Rgb string.
 */
function fromNamed(color) {
  var el = document.createElement('div');
  el.style.color = color;
  if (el.style.color !== '') {
    document.body.appendChild(el);
    var rgb = getComputedStyle(el).color;
    document.body.removeChild(el);
    return rgb;
  } else {
    return '';
  }
}


/**
 * @param {string} s String.
 * @return {Color} Color.
 */
var fromString = (
  function() {

    // We maintain a small cache of parsed strings.  To provide cheap LRU-like
    // semantics, whenever the cache grows too large we simply delete an
    // arbitrary 25% of the entries.

    /**
     * @const
     * @type {number}
     */
    var MAX_CACHE_SIZE = 1024;

    /**
     * @type {Object<string, Color>}
     */
    var cache = {};

    /**
     * @type {number}
     */
    var cacheSize = 0;

    return (
      /**
       * @param {string} s String.
       * @return {Color} Color.
       */
      function(s) {
        var color;
        if (cache.hasOwnProperty(s)) {
          color = cache[s];
        } else {
          if (cacheSize >= MAX_CACHE_SIZE) {
            var i = 0;
            for (var key in cache) {
              if ((i++ & 3) === 0) {
                delete cache[key];
                --cacheSize;
              }
            }
          }
          color = fromStringInternal_(s);
          cache[s] = color;
          ++cacheSize;
        }
        return color;
      }
    );

  })();

/**
 * Return the color as an array. This function maintains a cache of calculated
 * arrays which means the result should not be modified.
 * @param {Color|string} color Color.
 * @return {Color} Color.
 * @api
 */
function asArray(color) {
  if (Array.isArray(color)) {
    return color;
  } else {
    return fromString(color);
  }
}

/**
 * @param {string} s String.
 * @private
 * @return {Color} Color.
 */
function fromStringInternal_(s) {
  var r, g, b, a, color;

  if (NAMED_COLOR_RE_.exec(s)) {
    s = fromNamed(s);
  }

  if (HEX_COLOR_RE_.exec(s)) { // hex
    var n = s.length - 1; // number of hex digits
    var d; // number of digits per channel
    if (n <= 4) {
      d = 1;
    } else {
      d = 2;
    }
    var hasAlpha = n === 4 || n === 8;
    r = parseInt(s.substr(1 + 0 * d, d), 16);
    g = parseInt(s.substr(1 + 1 * d, d), 16);
    b = parseInt(s.substr(1 + 2 * d, d), 16);
    if (hasAlpha) {
      a = parseInt(s.substr(1 + 3 * d, d), 16);
    } else {
      a = 255;
    }
    if (d == 1) {
      r = (r << 4) + r;
      g = (g << 4) + g;
      b = (b << 4) + b;
      if (hasAlpha) {
        a = (a << 4) + a;
      }
    }
    color = [r, g, b, a / 255];
  } else if (s.indexOf('rgba(') == 0) { // rgba()
    color = s.slice(5, -1).split(',').map(Number);
    normalize(color);
  } else if (s.indexOf('rgb(') == 0) { // rgb()
    color = s.slice(4, -1).split(',').map(Number);
    color.push(1);
    normalize(color);
  } else {
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(false, 14); // Invalid color
  }
  return color;
}


/**
 * TODO this function is only used in the test, we probably shouldn't export it
 * @param {Color} color Color.
 * @return {Color} Clamped color.
 */
function normalize(color) {
  color[0] = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["clamp"])((color[0] + 0.5) | 0, 0, 255);
  color[1] = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["clamp"])((color[1] + 0.5) | 0, 0, 255);
  color[2] = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["clamp"])((color[2] + 0.5) | 0, 0, 255);
  color[3] = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["clamp"])(color[3], 0, 1);
  return color;
}


/**
 * @param {Color} color Color.
 * @return {string} String.
 */
function toString(color) {
  var r = color[0];
  if (r != (r | 0)) {
    r = (r + 0.5) | 0;
  }
  var g = color[1];
  if (g != (g | 0)) {
    g = (g + 0.5) | 0;
  }
  var b = color[2];
  if (b != (b | 0)) {
    b = (b + 0.5) | 0;
  }
  var a = color[3] === undefined ? 1 : color[3];
  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
}

//# sourceMappingURL=color.js.map

/***/ }),

/***/ "./node_modules/ol/colorlike.js":
/*!**************************************!*\
  !*** ./node_modules/ol/colorlike.js ***!
  \**************************************/
/*! exports provided: asColorLike */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asColorLike", function() { return asColorLike; });
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/ol/color.js");
/**
 * @module ol/colorlike
 */



/**
 * A type accepted by CanvasRenderingContext2D.fillStyle
 * or CanvasRenderingContext2D.strokeStyle.
 * Represents a color, pattern, or gradient. The origin for patterns and
 * gradients as fill style is an increment of 512 css pixels from map coordinate
 * `[0, 0]`. For seamless repeat patterns, width and height of the pattern image
 * must be a factor of two (2, 4, 8, ..., 512).
 *
 * @typedef {string|CanvasPattern|CanvasGradient} ColorLike
 * @api
 */


/**
 * @param {import("./color.js").Color|ColorLike} color Color.
 * @return {ColorLike} The color as an {@link ol/colorlike~ColorLike}.
 * @api
 */
function asColorLike(color) {
  if (Array.isArray(color)) {
    return Object(_color_js__WEBPACK_IMPORTED_MODULE_0__["toString"])(color);
  } else {
    return color;
  }
}

//# sourceMappingURL=colorlike.js.map

/***/ }),

/***/ "./node_modules/ol/coordinate.js":
/*!***************************************!*\
  !*** ./node_modules/ol/coordinate.js ***!
  \***************************************/
/*! exports provided: add, closestOnCircle, closestOnSegment, createStringXY, degreesToStringHDMS, format, equals, rotate, scale, squaredDistance, distance, squaredDistanceToSegment, toStringHDMS, toStringXY */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "closestOnCircle", function() { return closestOnCircle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "closestOnSegment", function() { return closestOnSegment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createStringXY", function() { return createStringXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "degreesToStringHDMS", function() { return degreesToStringHDMS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "format", function() { return format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistanceToSegment", function() { return squaredDistanceToSegment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toStringHDMS", function() { return toStringHDMS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toStringXY", function() { return toStringXY; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./string.js */ "./node_modules/ol/string.js");
/**
 * @module ol/coordinate
 */




/**
 * An array of numbers representing an xy coordinate. Example: `[16, 48]`.
 * @typedef {Array<number>} Coordinate
 * @api
 */


/**
 * A function that takes a {@link module:ol/coordinate~Coordinate} and
 * transforms it into a `{string}`.
 *
 * @typedef {function((Coordinate|undefined)): string} CoordinateFormat
 * @api
 */


/**
 * Add `delta` to `coordinate`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     import {add} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     add(coord, [-2, 4]);
 *     // coord is now [5.85, 51.983333]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {Coordinate} delta Delta.
 * @return {Coordinate} The input coordinate adjusted by
 * the given delta.
 * @api
 */
function add(coordinate, delta) {
  coordinate[0] += delta[0];
  coordinate[1] += delta[1];
  return coordinate;
}


/**
 * Calculates the point closest to the passed coordinate on the passed circle.
 *
 * @param {Coordinate} coordinate The coordinate.
 * @param {import("./geom/Circle.js").default} circle The circle.
 * @return {Coordinate} Closest point on the circumference.
 */
function closestOnCircle(coordinate, circle) {
  var r = circle.getRadius();
  var center = circle.getCenter();
  var x0 = center[0];
  var y0 = center[1];
  var x1 = coordinate[0];
  var y1 = coordinate[1];

  var dx = x1 - x0;
  var dy = y1 - y0;
  if (dx === 0 && dy === 0) {
    dx = 1;
  }
  var d = Math.sqrt(dx * dx + dy * dy);

  var x = x0 + r * dx / d;
  var y = y0 + r * dy / d;

  return [x, y];
}


/**
 * Calculates the point closest to the passed coordinate on the passed segment.
 * This is the foot of the perpendicular of the coordinate to the segment when
 * the foot is on the segment, or the closest segment coordinate when the foot
 * is outside the segment.
 *
 * @param {Coordinate} coordinate The coordinate.
 * @param {Array<Coordinate>} segment The two coordinates
 * of the segment.
 * @return {Coordinate} The foot of the perpendicular of
 * the coordinate to the segment.
 */
function closestOnSegment(coordinate, segment) {
  var x0 = coordinate[0];
  var y0 = coordinate[1];
  var start = segment[0];
  var end = segment[1];
  var x1 = start[0];
  var y1 = start[1];
  var x2 = end[0];
  var y2 = end[1];
  var dx = x2 - x1;
  var dy = y2 - y1;
  var along = (dx === 0 && dy === 0) ? 0 :
    ((dx * (x0 - x1)) + (dy * (y0 - y1))) / ((dx * dx + dy * dy) || 0);
  var x, y;
  if (along <= 0) {
    x = x1;
    y = y1;
  } else if (along >= 1) {
    x = x2;
    y = y2;
  } else {
    x = x1 + along * dx;
    y = y1 + along * dy;
  }
  return [x, y];
}


/**
 * Returns a {@link module:ol/coordinate~CoordinateFormat} function that can be
 * used to format
 * a {Coordinate} to a string.
 *
 * Example without specifying the fractional digits:
 *
 *     import {createStringXY} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var stringifyFunc = createStringXY();
 *     var out = stringifyFunc(coord);
 *     // out is now '8, 48'
 *
 * Example with explicitly specifying 2 fractional digits:
 *
 *     import {createStringXY} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var stringifyFunc = createStringXY(2);
 *     var out = stringifyFunc(coord);
 *     // out is now '7.85, 47.98'
 *
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {CoordinateFormat} Coordinate format.
 * @api
 */
function createStringXY(opt_fractionDigits) {
  return (
    /**
     * @param {Coordinate} coordinate Coordinate.
     * @return {string} String XY.
     */
    function(coordinate) {
      return toStringXY(coordinate, opt_fractionDigits);
    }
  );
}


/**
 * @param {string} hemispheres Hemispheres.
 * @param {number} degrees Degrees.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} String.
 */
function degreesToStringHDMS(hemispheres, degrees, opt_fractionDigits) {
  var normalizedDegrees = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["modulo"])(degrees + 180, 360) - 180;
  var x = Math.abs(3600 * normalizedDegrees);
  var dflPrecision = opt_fractionDigits || 0;
  var precision = Math.pow(10, dflPrecision);

  var deg = Math.floor(x / 3600);
  var min = Math.floor((x - deg * 3600) / 60);
  var sec = x - (deg * 3600) - (min * 60);
  sec = Math.ceil(sec * precision) / precision;

  if (sec >= 60) {
    sec = 0;
    min += 1;
  }

  if (min >= 60) {
    min = 0;
    deg += 1;
  }

  return deg + '\u00b0 ' + Object(_string_js__WEBPACK_IMPORTED_MODULE_1__["padNumber"])(min, 2) + '\u2032 ' +
    Object(_string_js__WEBPACK_IMPORTED_MODULE_1__["padNumber"])(sec, 2, dflPrecision) + '\u2033' +
    (normalizedDegrees == 0 ? '' : ' ' + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0));
}


/**
 * Transforms the given {@link module:ol/coordinate~Coordinate} to a string
 * using the given string template. The strings `{x}` and `{y}` in the template
 * will be replaced with the first and second coordinate values respectively.
 *
 * Example without specifying the fractional digits:
 *
 *     import {format} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var template = 'Coordinate is ({x}|{y}).';
 *     var out = format(coord, template);
 *     // out is now 'Coordinate is (8|48).'
 *
 * Example explicitly specifying the fractional digits:
 *
 *     import {format} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var template = 'Coordinate is ({x}|{y}).';
 *     var out = format(coord, template, 2);
 *     // out is now 'Coordinate is (7.85|47.98).'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {string} template A template string with `{x}` and `{y}` placeholders
 *     that will be replaced by first and second coordinate values.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Formatted coordinate.
 * @api
 */
function format(coordinate, template, opt_fractionDigits) {
  if (coordinate) {
    return template
      .replace('{x}', coordinate[0].toFixed(opt_fractionDigits))
      .replace('{y}', coordinate[1].toFixed(opt_fractionDigits));
  } else {
    return '';
  }
}


/**
 * @param {Coordinate} coordinate1 First coordinate.
 * @param {Coordinate} coordinate2 Second coordinate.
 * @return {boolean} The two coordinates are equal.
 */
function equals(coordinate1, coordinate2) {
  var equals = true;
  for (var i = coordinate1.length - 1; i >= 0; --i) {
    if (coordinate1[i] != coordinate2[i]) {
      equals = false;
      break;
    }
  }
  return equals;
}


/**
 * Rotate `coordinate` by `angle`. `coordinate` is modified in place and
 * returned by the function.
 *
 * Example:
 *
 *     import {rotate} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var rotateRadians = Math.PI / 2; // 90 degrees
 *     rotate(coord, rotateRadians);
 *     // coord is now [-47.983333, 7.85]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} angle Angle in radian.
 * @return {Coordinate} Coordinate.
 * @api
 */
function rotate(coordinate, angle) {
  var cosAngle = Math.cos(angle);
  var sinAngle = Math.sin(angle);
  var x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  var y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  coordinate[0] = x;
  coordinate[1] = y;
  return coordinate;
}


/**
 * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     import {scale as scaleCoordinate} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var scale = 1.2;
 *     scaleCoordinate(coord, scale);
 *     // coord is now [9.42, 57.5799996]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} scale Scale factor.
 * @return {Coordinate} Coordinate.
 */
function scale(coordinate, scale) {
  coordinate[0] *= scale;
  coordinate[1] *= scale;
  return coordinate;
}


/**
 * @param {Coordinate} coord1 First coordinate.
 * @param {Coordinate} coord2 Second coordinate.
 * @return {number} Squared distance between coord1 and coord2.
 */
function squaredDistance(coord1, coord2) {
  var dx = coord1[0] - coord2[0];
  var dy = coord1[1] - coord2[1];
  return dx * dx + dy * dy;
}


/**
 * @param {Coordinate} coord1 First coordinate.
 * @param {Coordinate} coord2 Second coordinate.
 * @return {number} Distance between coord1 and coord2.
 */
function distance(coord1, coord2) {
  return Math.sqrt(squaredDistance(coord1, coord2));
}


/**
 * Calculate the squared distance from a coordinate to a line segment.
 *
 * @param {Coordinate} coordinate Coordinate of the point.
 * @param {Array<Coordinate>} segment Line segment (2
 * coordinates).
 * @return {number} Squared distance from the point to the line segment.
 */
function squaredDistanceToSegment(coordinate, segment) {
  return squaredDistance(coordinate,
    closestOnSegment(coordinate, segment));
}


/**
 * Format a geographic coordinate with the hemisphere, degrees, minutes, and
 * seconds.
 *
 * Example without specifying fractional digits:
 *
 *     import {toStringHDMS} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var out = toStringHDMS(coord);
 *     // out is now '47° 58′ 60″ N 7° 50′ 60″ E'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     import {toStringHDMS} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var out = toStringHDMS(coord, 1);
 *     // out is now '47° 58′ 60.0″ N 7° 50′ 60.0″ E'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Hemisphere, degrees, minutes and seconds.
 * @api
 */
function toStringHDMS(coordinate, opt_fractionDigits) {
  if (coordinate) {
    return degreesToStringHDMS('NS', coordinate[1], opt_fractionDigits) + ' ' +
        degreesToStringHDMS('EW', coordinate[0], opt_fractionDigits);
  } else {
    return '';
  }
}


/**
 * Format a coordinate as a comma delimited string.
 *
 * Example without specifying fractional digits:
 *
 *     import {toStringXY} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var out = toStringXY(coord);
 *     // out is now '8, 48'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     import {toStringXY} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var out = toStringXY(coord, 1);
 *     // out is now '7.8, 48.0'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} XY.
 * @api
 */
function toStringXY(coordinate, opt_fractionDigits) {
  return format(coordinate, '{x}, {y}', opt_fractionDigits);
}

//# sourceMappingURL=coordinate.js.map

/***/ }),

/***/ "./node_modules/ol/css.js":
/*!********************************!*\
  !*** ./node_modules/ol/css.js ***!
  \********************************/
/*! exports provided: CLASS_HIDDEN, CLASS_SELECTABLE, CLASS_UNSELECTABLE, CLASS_UNSUPPORTED, CLASS_CONTROL, CLASS_COLLAPSED, getFontFamilies */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLASS_HIDDEN", function() { return CLASS_HIDDEN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLASS_SELECTABLE", function() { return CLASS_SELECTABLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLASS_UNSELECTABLE", function() { return CLASS_UNSELECTABLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLASS_UNSUPPORTED", function() { return CLASS_UNSUPPORTED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLASS_CONTROL", function() { return CLASS_CONTROL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLASS_COLLAPSED", function() { return CLASS_COLLAPSED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFontFamilies", function() { return getFontFamilies; });
/**
 * @module ol/css
 */


/**
 * The CSS class for hidden feature.
 *
 * @const
 * @type {string}
 */
var CLASS_HIDDEN = 'ol-hidden';


/**
 * The CSS class that we'll give the DOM elements to have them selectable.
 *
 * @const
 * @type {string}
 */
var CLASS_SELECTABLE = 'ol-selectable';


/**
 * The CSS class that we'll give the DOM elements to have them unselectable.
 *
 * @const
 * @type {string}
 */
var CLASS_UNSELECTABLE = 'ol-unselectable';


/**
 * The CSS class for unsupported feature.
 *
 * @const
 * @type {string}
 */
var CLASS_UNSUPPORTED = 'ol-unsupported';


/**
 * The CSS class for controls.
 *
 * @const
 * @type {string}
 */
var CLASS_CONTROL = 'ol-control';


/**
 * The CSS class that we'll give the DOM elements that are collapsed, i.e.
 * to those elements which usually can be expanded.
 *
 * @const
 * @type {string}
 */
var CLASS_COLLAPSED = 'ol-collapsed';


/**
 * Get the list of font families from a font spec.  Note that this doesn't work
 * for font families that have commas in them.
 * @param {string} The CSS font property.
 * @return {Object<string>} The font families (or null if the input spec is invalid).
 */
var getFontFamilies = (function() {
  var style;
  var cache = {};
  return function(font) {
    if (!style) {
      style = document.createElement('div').style;
    }
    if (!(font in cache)) {
      style.font = font;
      var family = style.fontFamily;
      style.font = '';
      if (!family) {
        return null;
      }
      cache[font] = family.split(/,\s?/);
    }
    return cache[font];
  };
})();

//# sourceMappingURL=css.js.map

/***/ }),

/***/ "./node_modules/ol/dom.js":
/*!********************************!*\
  !*** ./node_modules/ol/dom.js ***!
  \********************************/
/*! exports provided: createCanvasContext2D, outerWidth, outerHeight, replaceNode, removeNode, removeChildren */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createCanvasContext2D", function() { return createCanvasContext2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "outerWidth", function() { return outerWidth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "outerHeight", function() { return outerHeight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "replaceNode", function() { return replaceNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeNode", function() { return removeNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeChildren", function() { return removeChildren; });
/**
 * @module ol/dom
 */


/**
 * Create an html canvas element and returns its 2d context.
 * @param {number=} opt_width Canvas width.
 * @param {number=} opt_height Canvas height.
 * @return {CanvasRenderingContext2D} The context.
 */
function createCanvasContext2D(opt_width, opt_height) {
  var canvas = /** @type {HTMLCanvasElement} */ (document.createElement('canvas'));
  if (opt_width) {
    canvas.width = opt_width;
  }
  if (opt_height) {
    canvas.height = opt_height;
  }
  return /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));
}


/**
 * Get the current computed width for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerWidth(true)`.
 * @param {!HTMLElement} element Element.
 * @return {number} The width.
 */
function outerWidth(element) {
  var width = element.offsetWidth;
  var style = getComputedStyle(element);
  width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);

  return width;
}


/**
 * Get the current computed height for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerHeight(true)`.
 * @param {!HTMLElement} element Element.
 * @return {number} The height.
 */
function outerHeight(element) {
  var height = element.offsetHeight;
  var style = getComputedStyle(element);
  height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);

  return height;
}

/**
 * @param {Node} newNode Node to replace old node
 * @param {Node} oldNode The node to be replaced
 */
function replaceNode(newNode, oldNode) {
  var parent = oldNode.parentNode;
  if (parent) {
    parent.replaceChild(newNode, oldNode);
  }
}

/**
 * @param {Node} node The node to remove.
 * @returns {Node} The node that was removed or null.
 */
function removeNode(node) {
  return node && node.parentNode ? node.parentNode.removeChild(node) : null;
}

/**
 * @param {Node} node The node to remove the children from.
 */
function removeChildren(node) {
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
}

//# sourceMappingURL=dom.js.map

/***/ }),

/***/ "./node_modules/ol/easing.js":
/*!***********************************!*\
  !*** ./node_modules/ol/easing.js ***!
  \***********************************/
/*! exports provided: easeIn, easeOut, inAndOut, linear, upAndDown */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "easeIn", function() { return easeIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "easeOut", function() { return easeOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inAndOut", function() { return inAndOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linear", function() { return linear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "upAndDown", function() { return upAndDown; });
/**
 * @module ol/easing
 */


/**
 * Start slow and speed up.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function easeIn(t) {
  return Math.pow(t, 3);
}


/**
 * Start fast and slow down.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function easeOut(t) {
  return 1 - easeIn(1 - t);
}


/**
 * Start slow, speed up, and then slow down again.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function inAndOut(t) {
  return 3 * t * t - 2 * t * t * t;
}


/**
 * Maintain a constant speed over time.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function linear(t) {
  return t;
}


/**
 * Start slow, speed up, and at the very end slow down again.  This has the
 * same general behavior as {@link module:ol/easing~inAndOut}, but the final
 * slowdown is delayed.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function upAndDown(t) {
  if (t < 0.5) {
    return inAndOut(2 * t);
  } else {
    return 1 - inAndOut(2 * (t - 0.5));
  }
}

//# sourceMappingURL=easing.js.map

/***/ }),

/***/ "./node_modules/ol/events.js":
/*!***********************************!*\
  !*** ./node_modules/ol/events.js ***!
  \***********************************/
/*! exports provided: bindListener, findListener, getListeners, listen, listenOnce, unlisten, unlistenByKey, unlistenAll */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bindListener", function() { return bindListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findListener", function() { return findListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getListeners", function() { return getListeners; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "listen", function() { return listen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "listenOnce", function() { return listenOnce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unlisten", function() { return unlisten; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unlistenByKey", function() { return unlistenByKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unlistenAll", function() { return unlistenAll; });
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/events
 */



/**
 * Key to use with {@link module:ol/Observable~Observable#unByKey}.
 * @typedef {Object} EventsKey
 * @property {Object} [bindTo]
 * @property {ListenerFunction} [boundListener]
 * @property {boolean} callOnce
 * @property {number} [deleteIndex]
 * @property {ListenerFunction} listener
 * @property {import("./events/Target.js").EventTargetLike} target
 * @property {string} type
 * @api
 */


/**
 * Listener function. This function is called with an event object as argument.
 * When the function returns `false`, event propagation will stop.
 *
 * @typedef {function((Event|import("./events/Event.js").default)): (void|boolean)} ListenerFunction
 * @api
 */


/**
 * @param {EventsKey} listenerObj Listener object.
 * @return {ListenerFunction} Bound listener.
 */
function bindListener(listenerObj) {
  var boundListener = function(evt) {
    var listener = listenerObj.listener;
    var bindTo = listenerObj.bindTo || listenerObj.target;
    if (listenerObj.callOnce) {
      unlistenByKey(listenerObj);
    }
    return listener.call(bindTo, evt);
  };
  listenerObj.boundListener = boundListener;
  return boundListener;
}


/**
 * Finds the matching {@link module:ol/events~EventsKey} in the given listener
 * array.
 *
 * @param {!Array<!EventsKey>} listeners Array of listeners.
 * @param {!Function} listener The listener function.
 * @param {Object=} opt_this The `this` value inside the listener.
 * @param {boolean=} opt_setDeleteIndex Set the deleteIndex on the matching
 *     listener, for {@link module:ol/events~unlistenByKey}.
 * @return {EventsKey|undefined} The matching listener object.
 */
function findListener(listeners, listener, opt_this, opt_setDeleteIndex) {
  var listenerObj;
  for (var i = 0, ii = listeners.length; i < ii; ++i) {
    listenerObj = listeners[i];
    if (listenerObj.listener === listener &&
        listenerObj.bindTo === opt_this) {
      if (opt_setDeleteIndex) {
        listenerObj.deleteIndex = i;
      }
      return listenerObj;
    }
  }
  return undefined;
}


/**
 * @param {import("./events/Target.js").EventTargetLike} target Target.
 * @param {string} type Type.
 * @return {Array<EventsKey>|undefined} Listeners.
 */
function getListeners(target, type) {
  var listenerMap = getListenerMap(target);
  return listenerMap ? listenerMap[type] : undefined;
}


/**
 * Get the lookup of listeners.
 * @param {Object} target Target.
 * @param {boolean=} opt_create If a map should be created if it doesn't exist.
 * @return {!Object<string, Array<EventsKey>>} Map of
 *     listeners by event type.
 */
function getListenerMap(target, opt_create) {
  var listenerMap = target.ol_lm;
  if (!listenerMap && opt_create) {
    listenerMap = target.ol_lm = {};
  }
  return listenerMap;
}


/**
 * Remove the listener map from a target.
 * @param {Object} target Target.
 */
function removeListenerMap(target) {
  delete target.ol_lm;
}


/**
 * Clean up all listener objects of the given type.  All properties on the
 * listener objects will be removed, and if no listeners remain in the listener
 * map, it will be removed from the target.
 * @param {import("./events/Target.js").EventTargetLike} target Target.
 * @param {string} type Type.
 */
function removeListeners(target, type) {
  var listeners = getListeners(target, type);
  if (listeners) {
    for (var i = 0, ii = listeners.length; i < ii; ++i) {
      /** @type {import("./events/Target.js").default} */ (target).
        removeEventListener(type, listeners[i].boundListener);
      Object(_obj_js__WEBPACK_IMPORTED_MODULE_0__["clear"])(listeners[i]);
    }
    listeners.length = 0;
    var listenerMap = getListenerMap(target);
    if (listenerMap) {
      delete listenerMap[type];
      if (Object.keys(listenerMap).length === 0) {
        removeListenerMap(target);
      }
    }
  }
}


/**
 * Registers an event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * This function efficiently binds a `listener` to a `this` object, and returns
 * a key for use with {@link module:ol/events~unlistenByKey}.
 *
 * @param {import("./events/Target.js").EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ListenerFunction} listener Listener.
 * @param {Object=} opt_this Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @param {boolean=} opt_once If true, add the listener as one-off listener.
 * @return {EventsKey} Unique key for the listener.
 */
function listen(target, type, listener, opt_this, opt_once) {
  var listenerMap = getListenerMap(target, true);
  var listeners = listenerMap[type];
  if (!listeners) {
    listeners = listenerMap[type] = [];
  }
  var listenerObj = findListener(listeners, listener, opt_this, false);
  if (listenerObj) {
    if (!opt_once) {
      // Turn one-off listener into a permanent one.
      listenerObj.callOnce = false;
    }
  } else {
    listenerObj = /** @type {EventsKey} */ ({
      bindTo: opt_this,
      callOnce: !!opt_once,
      listener: listener,
      target: target,
      type: type
    });
    /** @type {import("./events/Target.js").default} */ (target).
      addEventListener(type, bindListener(listenerObj));
    listeners.push(listenerObj);
  }

  return listenerObj;
}


/**
 * Registers a one-off event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * This function efficiently binds a `listener` as self-unregistering listener
 * to a `this` object, and returns a key for use with
 * {@link module:ol/events~unlistenByKey} in case the listener needs to be
 * unregistered before it is called.
 *
 * When {@link module:ol/events~listen} is called with the same arguments after this
 * function, the self-unregistering listener will be turned into a permanent
 * listener.
 *
 * @param {import("./events/Target.js").EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ListenerFunction} listener Listener.
 * @param {Object=} opt_this Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @return {EventsKey} Key for unlistenByKey.
 */
function listenOnce(target, type, listener, opt_this) {
  return listen(target, type, listener, opt_this, true);
}


/**
 * Unregisters an event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * To return a listener, this function needs to be called with the exact same
 * arguments that were used for a previous {@link module:ol/events~listen} call.
 *
 * @param {import("./events/Target.js").EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ListenerFunction} listener Listener.
 * @param {Object=} opt_this Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 */
function unlisten(target, type, listener, opt_this) {
  var listeners = getListeners(target, type);
  if (listeners) {
    var listenerObj = findListener(listeners, listener, opt_this, true);
    if (listenerObj) {
      unlistenByKey(listenerObj);
    }
  }
}


/**
 * Unregisters event listeners on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * The argument passed to this function is the key returned from
 * {@link module:ol/events~listen} or {@link module:ol/events~listenOnce}.
 *
 * @param {EventsKey} key The key.
 */
function unlistenByKey(key) {
  if (key && key.target) {
    /** @type {import("./events/Target.js").default} */ (key.target).
      removeEventListener(key.type, key.boundListener);
    var listeners = getListeners(key.target, key.type);
    if (listeners) {
      var i = 'deleteIndex' in key ? key.deleteIndex : listeners.indexOf(key);
      if (i !== -1) {
        listeners.splice(i, 1);
      }
      if (listeners.length === 0) {
        removeListeners(key.target, key.type);
      }
    }
    Object(_obj_js__WEBPACK_IMPORTED_MODULE_0__["clear"])(key);
  }
}


/**
 * Unregisters all event listeners on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * @param {import("./events/Target.js").EventTargetLike} target Target.
 */
function unlistenAll(target) {
  var listenerMap = getListenerMap(target);
  if (listenerMap) {
    for (var type in listenerMap) {
      removeListeners(target, type);
    }
  }
}

//# sourceMappingURL=events.js.map

/***/ }),

/***/ "./node_modules/ol/events/Event.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/events/Event.js ***!
  \*****************************************/
/*! exports provided: stopPropagation, preventDefault, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stopPropagation", function() { return stopPropagation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "preventDefault", function() { return preventDefault; });
/**
 * @module ol/events/Event
 */

/**
 * @classdesc
 * Stripped down implementation of the W3C DOM Level 2 Event interface.
 * See https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface.
 *
 * This implementation only provides `type` and `target` properties, and
 * `stopPropagation` and `preventDefault` methods. It is meant as base class
 * for higher level events defined in the library, and works with
 * {@link module:ol/events/Target~Target}.
 */
var Event = function Event(type) {

  /**
   * @type {boolean}
   */
  this.propagationStopped;

  /**
   * The event type.
   * @type {string}
   * @api
   */
  this.type = type;

  /**
   * The event target.
   * @type {Object}
   * @api
   */
  this.target = null;
};

/**
 * Stop event propagation.
 * @api
 */
Event.prototype.preventDefault = function preventDefault () {
  this.propagationStopped = true;
};

/**
 * Stop event propagation.
 * @api
 */
Event.prototype.stopPropagation = function stopPropagation () {
  this.propagationStopped = true;
};


/**
 * @param {Event|import("./Event.js").default} evt Event
 */
function stopPropagation(evt) {
  evt.stopPropagation();
}


/**
 * @param {Event|import("./Event.js").default} evt Event
 */
function preventDefault(evt) {
  evt.preventDefault();
}

/* harmony default export */ __webpack_exports__["default"] = (Event);

//# sourceMappingURL=Event.js.map

/***/ }),

/***/ "./node_modules/ol/events/EventType.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/events/EventType.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/events/EventType
 */

/**
 * @enum {string}
 * @const
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event module:ol/events/Event~Event#change
   * @api
   */
  CHANGE: 'change',

  CLEAR: 'clear',
  CONTEXTMENU: 'contextmenu',
  CLICK: 'click',
  DBLCLICK: 'dblclick',
  DRAGENTER: 'dragenter',
  DRAGOVER: 'dragover',
  DROP: 'drop',
  ERROR: 'error',
  KEYDOWN: 'keydown',
  KEYPRESS: 'keypress',
  LOAD: 'load',
  MOUSEDOWN: 'mousedown',
  MOUSEMOVE: 'mousemove',
  MOUSEOUT: 'mouseout',
  MOUSEUP: 'mouseup',
  MOUSEWHEEL: 'mousewheel',
  MSPOINTERDOWN: 'MSPointerDown',
  RESIZE: 'resize',
  TOUCHSTART: 'touchstart',
  TOUCHMOVE: 'touchmove',
  TOUCHEND: 'touchend',
  WHEEL: 'wheel'
});

//# sourceMappingURL=EventType.js.map

/***/ }),

/***/ "./node_modules/ol/events/Target.js":
/*!******************************************!*\
  !*** ./node_modules/ol/events/Target.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Disposable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Disposable.js */ "./node_modules/ol/Disposable.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _Event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Event.js */ "./node_modules/ol/events/Event.js");
/**
 * @module ol/events/Target
 */






/**
 * @typedef {EventTarget|Target} EventTargetLike
 */


/**
 * @classdesc
 * A simplified implementation of the W3C DOM Level 2 EventTarget interface.
 * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.
 *
 * There are two important simplifications compared to the specification:
 *
 * 1. The handling of `useCapture` in `addEventListener` and
 *    `removeEventListener`. There is no real capture model.
 * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.
 *    There is no event target hierarchy. When a listener calls
 *    `stopPropagation` or `preventDefault` on an event object, it means that no
 *    more listeners after this one will be called. Same as when the listener
 *    returns false.
 */
var Target = /*@__PURE__*/(function (Disposable) {
  function Target() {

    Disposable.call(this);

    /**
     * @private
     * @type {!Object<string, number>}
     */
    this.pendingRemovals_ = {};

    /**
     * @private
     * @type {!Object<string, number>}
     */
    this.dispatching_ = {};

    /**
     * @private
     * @type {!Object<string, Array<import("../events.js").ListenerFunction>>}
     */
    this.listeners_ = {};

  }

  if ( Disposable ) Target.__proto__ = Disposable;
  Target.prototype = Object.create( Disposable && Disposable.prototype );
  Target.prototype.constructor = Target;

  /**
   * @param {string} type Type.
   * @param {import("../events.js").ListenerFunction} listener Listener.
   */
  Target.prototype.addEventListener = function addEventListener (type, listener) {
    var listeners = this.listeners_[type];
    if (!listeners) {
      listeners = this.listeners_[type] = [];
    }
    if (listeners.indexOf(listener) === -1) {
      listeners.push(listener);
    }
  };

  /**
   * Dispatches an event and calls all listeners listening for events
   * of this type. The event parameter can either be a string or an
   * Object with a `type` property.
   *
   * @param {{type: string,
   *     target: (EventTargetLike|undefined),
   *     propagationStopped: (boolean|undefined)}|
   *     import("./Event.js").default|string} event Event object.
   * @return {boolean|undefined} `false` if anyone called preventDefault on the
   *     event object or if any of the listeners returned false.
   * @api
   */
  Target.prototype.dispatchEvent = function dispatchEvent (event) {
    var evt = typeof event === 'string' ? new _Event_js__WEBPACK_IMPORTED_MODULE_3__["default"](event) : event;
    var type = evt.type;
    evt.target = this;
    var listeners = this.listeners_[type];
    var propagate;
    if (listeners) {
      if (!(type in this.dispatching_)) {
        this.dispatching_[type] = 0;
        this.pendingRemovals_[type] = 0;
      }
      ++this.dispatching_[type];
      for (var i = 0, ii = listeners.length; i < ii; ++i) {
        if (listeners[i].call(this, evt) === false || evt.propagationStopped) {
          propagate = false;
          break;
        }
      }
      --this.dispatching_[type];
      if (this.dispatching_[type] === 0) {
        var pendingRemovals = this.pendingRemovals_[type];
        delete this.pendingRemovals_[type];
        while (pendingRemovals--) {
          this.removeEventListener(type, _functions_js__WEBPACK_IMPORTED_MODULE_2__["VOID"]);
        }
        delete this.dispatching_[type];
      }
      return propagate;
    }
  };

  /**
   * @inheritDoc
   */
  Target.prototype.disposeInternal = function disposeInternal () {
    Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["unlistenAll"])(this);
  };

  /**
   * Get the listeners for a specified event type. Listeners are returned in the
   * order that they will be called in.
   *
   * @param {string} type Type.
   * @return {Array<import("../events.js").ListenerFunction>} Listeners.
   */
  Target.prototype.getListeners = function getListeners (type) {
    return this.listeners_[type];
  };

  /**
   * @param {string=} opt_type Type. If not provided,
   *     `true` will be returned if this event target has any listeners.
   * @return {boolean} Has listeners.
   */
  Target.prototype.hasListener = function hasListener (opt_type) {
    return opt_type ?
      opt_type in this.listeners_ :
      Object.keys(this.listeners_).length > 0;
  };

  /**
   * @param {string} type Type.
   * @param {import("../events.js").ListenerFunction} listener Listener.
   */
  Target.prototype.removeEventListener = function removeEventListener (type, listener) {
    var listeners = this.listeners_[type];
    if (listeners) {
      var index = listeners.indexOf(listener);
      if (type in this.pendingRemovals_) {
        // make listener a no-op, and remove later in #dispatchEvent()
        listeners[index] = _functions_js__WEBPACK_IMPORTED_MODULE_2__["VOID"];
        ++this.pendingRemovals_[type];
      } else {
        listeners.splice(index, 1);
        if (listeners.length === 0) {
          delete this.listeners_[type];
        }
      }
    }
  };

  return Target;
}(_Disposable_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (Target);

//# sourceMappingURL=Target.js.map

/***/ }),

/***/ "./node_modules/ol/extent.js":
/*!***********************************!*\
  !*** ./node_modules/ol/extent.js ***!
  \***********************************/
/*! exports provided: boundingExtent, buffer, clone, closestSquaredDistanceXY, containsCoordinate, containsExtent, containsXY, coordinateRelationship, createEmpty, createOrUpdate, createOrUpdateEmpty, createOrUpdateFromCoordinate, createOrUpdateFromCoordinates, createOrUpdateFromFlatCoordinates, createOrUpdateFromRings, equals, extend, extendCoordinate, extendCoordinates, extendFlatCoordinates, extendRings, extendXY, forEachCorner, getArea, getBottomLeft, getBottomRight, getCenter, getCorner, getEnlargedArea, getForViewAndSize, getHeight, getIntersectionArea, getIntersection, getMargin, getSize, getTopLeft, getTopRight, getWidth, intersects, isEmpty, returnOrUpdate, scaleFromCenter, intersectsSegment, applyTransform */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "boundingExtent", function() { return boundingExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buffer", function() { return buffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "closestSquaredDistanceXY", function() { return closestSquaredDistanceXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "containsCoordinate", function() { return containsCoordinate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "containsExtent", function() { return containsExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "containsXY", function() { return containsXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "coordinateRelationship", function() { return coordinateRelationship; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createEmpty", function() { return createEmpty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdate", function() { return createOrUpdate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdateEmpty", function() { return createOrUpdateEmpty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdateFromCoordinate", function() { return createOrUpdateFromCoordinate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdateFromCoordinates", function() { return createOrUpdateFromCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdateFromFlatCoordinates", function() { return createOrUpdateFromFlatCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdateFromRings", function() { return createOrUpdateFromRings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendCoordinate", function() { return extendCoordinate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendCoordinates", function() { return extendCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendFlatCoordinates", function() { return extendFlatCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendRings", function() { return extendRings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendXY", function() { return extendXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEachCorner", function() { return forEachCorner; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getArea", function() { return getArea; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBottomLeft", function() { return getBottomLeft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBottomRight", function() { return getBottomRight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCenter", function() { return getCenter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCorner", function() { return getCorner; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getEnlargedArea", function() { return getEnlargedArea; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getForViewAndSize", function() { return getForViewAndSize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getHeight", function() { return getHeight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getIntersectionArea", function() { return getIntersectionArea; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getIntersection", function() { return getIntersection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMargin", function() { return getMargin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSize", function() { return getSize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTopLeft", function() { return getTopLeft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTopRight", function() { return getTopRight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getWidth", function() { return getWidth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersects", function() { return intersects; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEmpty", function() { return isEmpty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "returnOrUpdate", function() { return returnOrUpdate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleFromCenter", function() { return scaleFromCenter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersectsSegment", function() { return intersectsSegment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyTransform", function() { return applyTransform; });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _extent_Corner_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extent/Corner.js */ "./node_modules/ol/extent/Corner.js");
/* harmony import */ var _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./extent/Relationship.js */ "./node_modules/ol/extent/Relationship.js");
/**
 * @module ol/extent
 */





/**
 * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.
 * @typedef {Array<number>} Extent
 * @api
 */

/**
 * Build an extent that includes all given coordinates.
 *
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @return {Extent} Bounding extent.
 * @api
 */
function boundingExtent(coordinates) {
  var extent = createEmpty();
  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    extendCoordinate(extent, coordinates[i]);
  }
  return extent;
}


/**
 * @param {Array<number>} xs Xs.
 * @param {Array<number>} ys Ys.
 * @param {Extent=} opt_extent Destination extent.
 * @private
 * @return {Extent} Extent.
 */
function _boundingExtentXYs(xs, ys, opt_extent) {
  var minX = Math.min.apply(null, xs);
  var minY = Math.min.apply(null, ys);
  var maxX = Math.max.apply(null, xs);
  var maxY = Math.max.apply(null, ys);
  return createOrUpdate(minX, minY, maxX, maxY, opt_extent);
}


/**
 * Return extent increased by the provided value.
 * @param {Extent} extent Extent.
 * @param {number} value The amount by which the extent should be buffered.
 * @param {Extent=} opt_extent Extent.
 * @return {Extent} Extent.
 * @api
 */
function buffer(extent, value, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0] - value;
    opt_extent[1] = extent[1] - value;
    opt_extent[2] = extent[2] + value;
    opt_extent[3] = extent[3] + value;
    return opt_extent;
  } else {
    return [
      extent[0] - value,
      extent[1] - value,
      extent[2] + value,
      extent[3] + value
    ];
  }
}


/**
 * Creates a clone of an extent.
 *
 * @param {Extent} extent Extent to clone.
 * @param {Extent=} opt_extent Extent.
 * @return {Extent} The clone.
 */
function clone(extent, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0];
    opt_extent[1] = extent[1];
    opt_extent[2] = extent[2];
    opt_extent[3] = extent[3];
    return opt_extent;
  } else {
    return extent.slice();
  }
}


/**
 * @param {Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {number} Closest squared distance.
 */
function closestSquaredDistanceXY(extent, x, y) {
  var dx, dy;
  if (x < extent[0]) {
    dx = extent[0] - x;
  } else if (extent[2] < x) {
    dx = x - extent[2];
  } else {
    dx = 0;
  }
  if (y < extent[1]) {
    dy = extent[1] - y;
  } else if (extent[3] < y) {
    dy = y - extent[3];
  } else {
    dy = 0;
  }
  return dx * dx + dy * dy;
}


/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {Extent} extent Extent.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @return {boolean} The coordinate is contained in the extent.
 * @api
 */
function containsCoordinate(extent, coordinate) {
  return containsXY(extent, coordinate[0], coordinate[1]);
}


/**
 * Check if one extent contains another.
 *
 * An extent is deemed contained if it lies completely within the other extent,
 * including if they share one or more edges.
 *
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {boolean} The second extent is contained by or on the edge of the
 *     first.
 * @api
 */
function containsExtent(extent1, extent2) {
  return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] &&
      extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
}


/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {Extent} extent Extent.
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @return {boolean} The x, y values are contained in the extent.
 * @api
 */
function containsXY(extent, x, y) {
  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
}


/**
 * Get the relationship between a coordinate and extent.
 * @param {Extent} extent The extent.
 * @param {import("./coordinate.js").Coordinate} coordinate The coordinate.
 * @return {Relationship} The relationship (bitwise compare with
 *     import("./extent/Relationship.js").Relationship).
 */
function coordinateRelationship(extent, coordinate) {
  var minX = extent[0];
  var minY = extent[1];
  var maxX = extent[2];
  var maxY = extent[3];
  var x = coordinate[0];
  var y = coordinate[1];
  var relationship = _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].UNKNOWN;
  if (x < minX) {
    relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].LEFT;
  } else if (x > maxX) {
    relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].RIGHT;
  }
  if (y < minY) {
    relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].BELOW;
  } else if (y > maxY) {
    relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].ABOVE;
  }
  if (relationship === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].UNKNOWN) {
    relationship = _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].INTERSECTING;
  }
  return relationship;
}


/**
 * Create an empty extent.
 * @return {Extent} Empty extent.
 * @api
 */
function createEmpty() {
  return [Infinity, Infinity, -Infinity, -Infinity];
}


/**
 * Create a new extent or update the provided extent.
 * @param {number} minX Minimum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxX Maximum X.
 * @param {number} maxY Maximum Y.
 * @param {Extent=} opt_extent Destination extent.
 * @return {Extent} Extent.
 */
function createOrUpdate(minX, minY, maxX, maxY, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = minX;
    opt_extent[1] = minY;
    opt_extent[2] = maxX;
    opt_extent[3] = maxY;
    return opt_extent;
  } else {
    return [minX, minY, maxX, maxY];
  }
}


/**
 * Create a new empty extent or make the provided one empty.
 * @param {Extent=} opt_extent Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateEmpty(opt_extent) {
  return createOrUpdate(
    Infinity, Infinity, -Infinity, -Infinity, opt_extent);
}


/**
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {Extent=} opt_extent Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateFromCoordinate(coordinate, opt_extent) {
  var x = coordinate[0];
  var y = coordinate[1];
  return createOrUpdate(x, y, x, y, opt_extent);
}


/**
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @param {Extent=} opt_extent Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateFromCoordinates(coordinates, opt_extent) {
  var extent = createOrUpdateEmpty(opt_extent);
  return extendCoordinates(extent, coordinates);
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Extent=} opt_extent Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, opt_extent) {
  var extent = createOrUpdateEmpty(opt_extent);
  return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
}

/**
 * @param {Array<Array<import("./coordinate.js").Coordinate>>} rings Rings.
 * @param {Extent=} opt_extent Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateFromRings(rings, opt_extent) {
  var extent = createOrUpdateEmpty(opt_extent);
  return extendRings(extent, rings);
}


/**
 * Determine if two extents are equivalent.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {boolean} The two extents are equivalent.
 * @api
 */
function equals(extent1, extent2) {
  return extent1[0] == extent2[0] && extent1[2] == extent2[2] &&
      extent1[1] == extent2[1] && extent1[3] == extent2[3];
}


/**
 * Modify an extent to include another extent.
 * @param {Extent} extent1 The extent to be modified.
 * @param {Extent} extent2 The extent that will be included in the first.
 * @return {Extent} A reference to the first (extended) extent.
 * @api
 */
function extend(extent1, extent2) {
  if (extent2[0] < extent1[0]) {
    extent1[0] = extent2[0];
  }
  if (extent2[2] > extent1[2]) {
    extent1[2] = extent2[2];
  }
  if (extent2[1] < extent1[1]) {
    extent1[1] = extent2[1];
  }
  if (extent2[3] > extent1[3]) {
    extent1[3] = extent2[3];
  }
  return extent1;
}


/**
 * @param {Extent} extent Extent.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 */
function extendCoordinate(extent, coordinate) {
  if (coordinate[0] < extent[0]) {
    extent[0] = coordinate[0];
  }
  if (coordinate[0] > extent[2]) {
    extent[2] = coordinate[0];
  }
  if (coordinate[1] < extent[1]) {
    extent[1] = coordinate[1];
  }
  if (coordinate[1] > extent[3]) {
    extent[3] = coordinate[1];
  }
}


/**
 * @param {Extent} extent Extent.
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @return {Extent} Extent.
 */
function extendCoordinates(extent, coordinates) {
  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    extendCoordinate(extent, coordinates[i]);
  }
  return extent;
}


/**
 * @param {Extent} extent Extent.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {Extent} Extent.
 */
function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {
  for (; offset < end; offset += stride) {
    extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
  }
  return extent;
}


/**
 * @param {Extent} extent Extent.
 * @param {Array<Array<import("./coordinate.js").Coordinate>>} rings Rings.
 * @return {Extent} Extent.
 */
function extendRings(extent, rings) {
  for (var i = 0, ii = rings.length; i < ii; ++i) {
    extendCoordinates(extent, rings[i]);
  }
  return extent;
}


/**
 * @param {Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 */
function extendXY(extent, x, y) {
  extent[0] = Math.min(extent[0], x);
  extent[1] = Math.min(extent[1], y);
  extent[2] = Math.max(extent[2], x);
  extent[3] = Math.max(extent[3], y);
}


/**
 * This function calls `callback` for each corner of the extent. If the
 * callback returns a truthy value the function returns that value
 * immediately. Otherwise the function returns `false`.
 * @param {Extent} extent Extent.
 * @param {function(this:T, import("./coordinate.js").Coordinate): S} callback Callback.
 * @param {T=} opt_this Value to use as `this` when executing `callback`.
 * @return {S|boolean} Value.
 * @template S, T
 */
function forEachCorner(extent, callback, opt_this) {
  var val;
  val = callback.call(opt_this, getBottomLeft(extent));
  if (val) {
    return val;
  }
  val = callback.call(opt_this, getBottomRight(extent));
  if (val) {
    return val;
  }
  val = callback.call(opt_this, getTopRight(extent));
  if (val) {
    return val;
  }
  val = callback.call(opt_this, getTopLeft(extent));
  if (val) {
    return val;
  }
  return false;
}


/**
 * Get the size of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Area.
 * @api
 */
function getArea(extent) {
  var area = 0;
  if (!isEmpty(extent)) {
    area = getWidth(extent) * getHeight(extent);
  }
  return area;
}


/**
 * Get the bottom left coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Bottom left coordinate.
 * @api
 */
function getBottomLeft(extent) {
  return [extent[0], extent[1]];
}


/**
 * Get the bottom right coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Bottom right coordinate.
 * @api
 */
function getBottomRight(extent) {
  return [extent[2], extent[1]];
}


/**
 * Get the center coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Center.
 * @api
 */
function getCenter(extent) {
  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
}


/**
 * Get a corner coordinate of an extent.
 * @param {Extent} extent Extent.
 * @param {Corner} corner Corner.
 * @return {import("./coordinate.js").Coordinate} Corner coordinate.
 */
function getCorner(extent, corner) {
  var coordinate;
  if (corner === _extent_Corner_js__WEBPACK_IMPORTED_MODULE_1__["default"].BOTTOM_LEFT) {
    coordinate = getBottomLeft(extent);
  } else if (corner === _extent_Corner_js__WEBPACK_IMPORTED_MODULE_1__["default"].BOTTOM_RIGHT) {
    coordinate = getBottomRight(extent);
  } else if (corner === _extent_Corner_js__WEBPACK_IMPORTED_MODULE_1__["default"].TOP_LEFT) {
    coordinate = getTopLeft(extent);
  } else if (corner === _extent_Corner_js__WEBPACK_IMPORTED_MODULE_1__["default"].TOP_RIGHT) {
    coordinate = getTopRight(extent);
  } else {
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(false, 13); // Invalid corner
  }
  return coordinate;
}


/**
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {number} Enlarged area.
 */
function getEnlargedArea(extent1, extent2) {
  var minX = Math.min(extent1[0], extent2[0]);
  var minY = Math.min(extent1[1], extent2[1]);
  var maxX = Math.max(extent1[2], extent2[2]);
  var maxY = Math.max(extent1[3], extent2[3]);
  return (maxX - minX) * (maxY - minY);
}


/**
 * @param {import("./coordinate.js").Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {import("./size.js").Size} size Size.
 * @param {Extent=} opt_extent Destination extent.
 * @return {Extent} Extent.
 */
function getForViewAndSize(center, resolution, rotation, size, opt_extent) {
  var dx = resolution * size[0] / 2;
  var dy = resolution * size[1] / 2;
  var cosRotation = Math.cos(rotation);
  var sinRotation = Math.sin(rotation);
  var xCos = dx * cosRotation;
  var xSin = dx * sinRotation;
  var yCos = dy * cosRotation;
  var ySin = dy * sinRotation;
  var x = center[0];
  var y = center[1];
  var x0 = x - xCos + ySin;
  var x1 = x - xCos - ySin;
  var x2 = x + xCos - ySin;
  var x3 = x + xCos + ySin;
  var y0 = y - xSin - yCos;
  var y1 = y - xSin + yCos;
  var y2 = y + xSin + yCos;
  var y3 = y + xSin - yCos;
  return createOrUpdate(
    Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3),
    Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3),
    opt_extent);
}


/**
 * Get the height of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Height.
 * @api
 */
function getHeight(extent) {
  return extent[3] - extent[1];
}


/**
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {number} Intersection area.
 */
function getIntersectionArea(extent1, extent2) {
  var intersection = getIntersection(extent1, extent2);
  return getArea(intersection);
}


/**
 * Get the intersection of two extents.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @param {Extent=} opt_extent Optional extent to populate with intersection.
 * @return {Extent} Intersecting extent.
 * @api
 */
function getIntersection(extent1, extent2, opt_extent) {
  var intersection = opt_extent ? opt_extent : createEmpty();
  if (intersects(extent1, extent2)) {
    if (extent1[0] > extent2[0]) {
      intersection[0] = extent1[0];
    } else {
      intersection[0] = extent2[0];
    }
    if (extent1[1] > extent2[1]) {
      intersection[1] = extent1[1];
    } else {
      intersection[1] = extent2[1];
    }
    if (extent1[2] < extent2[2]) {
      intersection[2] = extent1[2];
    } else {
      intersection[2] = extent2[2];
    }
    if (extent1[3] < extent2[3]) {
      intersection[3] = extent1[3];
    } else {
      intersection[3] = extent2[3];
    }
  } else {
    createOrUpdateEmpty(intersection);
  }
  return intersection;
}


/**
 * @param {Extent} extent Extent.
 * @return {number} Margin.
 */
function getMargin(extent) {
  return getWidth(extent) + getHeight(extent);
}


/**
 * Get the size (width, height) of an extent.
 * @param {Extent} extent The extent.
 * @return {import("./size.js").Size} The extent size.
 * @api
 */
function getSize(extent) {
  return [extent[2] - extent[0], extent[3] - extent[1]];
}


/**
 * Get the top left coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Top left coordinate.
 * @api
 */
function getTopLeft(extent) {
  return [extent[0], extent[3]];
}


/**
 * Get the top right coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Top right coordinate.
 * @api
 */
function getTopRight(extent) {
  return [extent[2], extent[3]];
}


/**
 * Get the width of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Width.
 * @api
 */
function getWidth(extent) {
  return extent[2] - extent[0];
}


/**
 * Determine if one extent intersects another.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent.
 * @return {boolean} The two extents intersect.
 * @api
 */
function intersects(extent1, extent2) {
  return extent1[0] <= extent2[2] &&
      extent1[2] >= extent2[0] &&
      extent1[1] <= extent2[3] &&
      extent1[3] >= extent2[1];
}


/**
 * Determine if an extent is empty.
 * @param {Extent} extent Extent.
 * @return {boolean} Is empty.
 * @api
 */
function isEmpty(extent) {
  return extent[2] < extent[0] || extent[3] < extent[1];
}


/**
 * @param {Extent} extent Extent.
 * @param {Extent=} opt_extent Extent.
 * @return {Extent} Extent.
 */
function returnOrUpdate(extent, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0];
    opt_extent[1] = extent[1];
    opt_extent[2] = extent[2];
    opt_extent[3] = extent[3];
    return opt_extent;
  } else {
    return extent;
  }
}


/**
 * @param {Extent} extent Extent.
 * @param {number} value Value.
 */
function scaleFromCenter(extent, value) {
  var deltaX = ((extent[2] - extent[0]) / 2) * (value - 1);
  var deltaY = ((extent[3] - extent[1]) / 2) * (value - 1);
  extent[0] -= deltaX;
  extent[2] += deltaX;
  extent[1] -= deltaY;
  extent[3] += deltaY;
}


/**
 * Determine if the segment between two coordinates intersects (crosses,
 * touches, or is contained by) the provided extent.
 * @param {Extent} extent The extent.
 * @param {import("./coordinate.js").Coordinate} start Segment start coordinate.
 * @param {import("./coordinate.js").Coordinate} end Segment end coordinate.
 * @return {boolean} The segment intersects the extent.
 */
function intersectsSegment(extent, start, end) {
  var intersects = false;
  var startRel = coordinateRelationship(extent, start);
  var endRel = coordinateRelationship(extent, end);
  if (startRel === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].INTERSECTING ||
      endRel === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].INTERSECTING) {
    intersects = true;
  } else {
    var minX = extent[0];
    var minY = extent[1];
    var maxX = extent[2];
    var maxY = extent[3];
    var startX = start[0];
    var startY = start[1];
    var endX = end[0];
    var endY = end[1];
    var slope = (endY - startY) / (endX - startX);
    var x, y;
    if (!!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].ABOVE) &&
        !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].ABOVE)) {
      // potentially intersects top
      x = endX - ((endY - maxY) / slope);
      intersects = x >= minX && x <= maxX;
    }
    if (!intersects && !!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].RIGHT) &&
        !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].RIGHT)) {
      // potentially intersects right
      y = endY - ((endX - maxX) * slope);
      intersects = y >= minY && y <= maxY;
    }
    if (!intersects && !!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].BELOW) &&
        !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].BELOW)) {
      // potentially intersects bottom
      x = endX - ((endY - minY) / slope);
      intersects = x >= minX && x <= maxX;
    }
    if (!intersects && !!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].LEFT) &&
        !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].LEFT)) {
      // potentially intersects left
      y = endY - ((endX - minX) * slope);
      intersects = y >= minY && y <= maxY;
    }

  }
  return intersects;
}


/**
 * Apply a transform function to the extent.
 * @param {Extent} extent Extent.
 * @param {import("./proj.js").TransformFunction} transformFn Transform function.
 * Called with `[minX, minY, maxX, maxY]` extent coordinates.
 * @param {Extent=} opt_extent Destination extent.
 * @return {Extent} Extent.
 * @api
 */
function applyTransform(extent, transformFn, opt_extent) {
  var coordinates = [
    extent[0], extent[1],
    extent[0], extent[3],
    extent[2], extent[1],
    extent[2], extent[3]
  ];
  transformFn(coordinates, coordinates, 2);
  var xs = [coordinates[0], coordinates[2], coordinates[4], coordinates[6]];
  var ys = [coordinates[1], coordinates[3], coordinates[5], coordinates[7]];
  return _boundingExtentXYs(xs, ys, opt_extent);
}

//# sourceMappingURL=extent.js.map

/***/ }),

/***/ "./node_modules/ol/extent/Corner.js":
/*!******************************************!*\
  !*** ./node_modules/ol/extent/Corner.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/extent/Corner
 */

/**
 * Extent corner.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  BOTTOM_LEFT: 'bottom-left',
  BOTTOM_RIGHT: 'bottom-right',
  TOP_LEFT: 'top-left',
  TOP_RIGHT: 'top-right'
});

//# sourceMappingURL=Corner.js.map

/***/ }),

/***/ "./node_modules/ol/extent/Relationship.js":
/*!************************************************!*\
  !*** ./node_modules/ol/extent/Relationship.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/extent/Relationship
 */

/**
 * Relationship to an extent.
 * @enum {number}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16
});

//# sourceMappingURL=Relationship.js.map

/***/ }),

/***/ "./node_modules/ol/featureloader.js":
/*!******************************************!*\
  !*** ./node_modules/ol/featureloader.js ***!
  \******************************************/
/*! exports provided: loadFeaturesXhr, xhr */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadFeaturesXhr", function() { return loadFeaturesXhr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xhr", function() { return xhr; });
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _format_FormatType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./format/FormatType.js */ "./node_modules/ol/format/FormatType.js");
/**
 * @module ol/featureloader
 */



/**
 * {@link module:ol/source/Vector} sources use a function of this type to
 * load features.
 *
 * This function takes an {@link module:ol/extent~Extent} representing the area to be loaded,
 * a `{number}` representing the resolution (map units per pixel) and an
 * {@link module:ol/proj/Projection} for the projection  as
 * arguments. `this` within the function is bound to the
 * {@link module:ol/source/Vector} it's called from.
 *
 * The function is responsible for loading the features and adding them to the
 * source.
 * @typedef {function(this:(import("./source/Vector").default|import("./VectorTile.js").default), import("./extent.js").Extent, number,
 *                    import("./proj/Projection.js").default)} FeatureLoader
 * @api
 */


/**
 * {@link module:ol/source/Vector} sources use a function of this type to
 * get the url to load features from.
 *
 * This function takes an {@link module:ol/extent~Extent} representing the area
 * to be loaded, a `{number}` representing the resolution (map units per pixel)
 * and an {@link module:ol/proj/Projection} for the projection  as
 * arguments and returns a `{string}` representing the URL.
 * @typedef {function(import("./extent.js").Extent, number, import("./proj/Projection.js").default): string} FeatureUrlFunction
 * @api
 */


/**
 * @param {string|FeatureUrlFunction} url Feature URL service.
 * @param {import("./format/Feature.js").default} format Feature format.
 * @param {function(this:import("./VectorTile.js").default, Array<import("./Feature.js").default>, import("./proj/Projection.js").default, import("./extent.js").Extent)|function(this:import("./source/Vector").default, Array<import("./Feature.js").default>)} success
 *     Function called with the loaded features and optionally with the data
 *     projection. Called with the vector tile or source as `this`.
 * @param {function(this:import("./VectorTile.js").default)|function(this:import("./source/Vector").default)} failure
 *     Function called when loading failed. Called with the vector tile or
 *     source as `this`.
 * @return {FeatureLoader} The feature loader.
 */
function loadFeaturesXhr(url, format, success, failure) {
  return (
    /**
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @this {import("./source/Vector").default|import("./VectorTile.js").default}
     */
    function(extent, resolution, projection) {
      var xhr = new XMLHttpRequest();
      xhr.open('GET',
        typeof url === 'function' ? url(extent, resolution, projection) : url,
        true);
      if (format.getType() == _format_FormatType_js__WEBPACK_IMPORTED_MODULE_1__["default"].ARRAY_BUFFER) {
        xhr.responseType = 'arraybuffer';
      }
      /**
       * @param {Event} event Event.
       * @private
       */
      xhr.onload = function(event) {
        // status will be 0 for file:// urls
        if (!xhr.status || xhr.status >= 200 && xhr.status < 300) {
          var type = format.getType();
          /** @type {Document|Node|Object|string|undefined} */
          var source;
          if (type == _format_FormatType_js__WEBPACK_IMPORTED_MODULE_1__["default"].JSON || type == _format_FormatType_js__WEBPACK_IMPORTED_MODULE_1__["default"].TEXT) {
            source = xhr.responseText;
          } else if (type == _format_FormatType_js__WEBPACK_IMPORTED_MODULE_1__["default"].XML) {
            source = xhr.responseXML;
            if (!source) {
              source = new DOMParser().parseFromString(xhr.responseText, 'application/xml');
            }
          } else if (type == _format_FormatType_js__WEBPACK_IMPORTED_MODULE_1__["default"].ARRAY_BUFFER) {
            source = /** @type {ArrayBuffer} */ (xhr.response);
          }
          if (source) {
            success.call(this, format.readFeatures(source,
              {featureProjection: projection}),
            format.readProjection(source), format.getLastExtent());
          } else {
            failure.call(this);
          }
        } else {
          failure.call(this);
        }
      }.bind(this);
      /**
       * @private
       */
      xhr.onerror = function() {
        failure.call(this);
      }.bind(this);
      xhr.send();
    }
  );
}


/**
 * Create an XHR feature loader for a `url` and `format`. The feature loader
 * loads features (with XHR), parses the features, and adds them to the
 * vector source.
 * @param {string|FeatureUrlFunction} url Feature URL service.
 * @param {import("./format/Feature.js").default} format Feature format.
 * @return {FeatureLoader} The feature loader.
 * @api
 */
function xhr(url, format) {
  return loadFeaturesXhr(url, format,
    /**
     * @param {Array<import("./Feature.js").default>} features The loaded features.
     * @param {import("./proj/Projection.js").default} dataProjection Data
     * projection.
     * @this {import("./source/Vector").default|import("./VectorTile.js").default}
     */
    function(features, dataProjection) {
      var sourceOrTile = /** @type {?} */ (this);
      if (typeof sourceOrTile.addFeatures === 'function') {
        /** @type {import("./source/Vector").default} */ (sourceOrTile).addFeatures(features);
      }
    }, /* FIXME handle error */ _functions_js__WEBPACK_IMPORTED_MODULE_0__["VOID"]);
}

//# sourceMappingURL=featureloader.js.map

/***/ }),

/***/ "./node_modules/ol/format/FormatType.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/format/FormatType.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/format/FormatType
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  ARRAY_BUFFER: 'arraybuffer',
  JSON: 'json',
  TEXT: 'text',
  XML: 'xml'
});

//# sourceMappingURL=FormatType.js.map

/***/ }),

/***/ "./node_modules/ol/functions.js":
/*!**************************************!*\
  !*** ./node_modules/ol/functions.js ***!
  \**************************************/
/*! exports provided: TRUE, FALSE, VOID */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TRUE", function() { return TRUE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FALSE", function() { return FALSE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VOID", function() { return VOID; });
/**
 * @module ol/functions
 */

/**
 * Always returns true.
 * @returns {boolean} true.
 */
function TRUE() {
  return true;
}

/**
 * Always returns false.
 * @returns {boolean} false.
 */
function FALSE() {
  return false;
}

/**
 * A reusable function, used e.g. as a default for callbacks.
 *
 * @return {void} Nothing.
 */
function VOID() {}

//# sourceMappingURL=functions.js.map

/***/ }),

/***/ "./node_modules/ol/geom/Geometry.js":
/*!******************************************!*\
  !*** ./node_modules/ol/geom/Geometry.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _flat_transform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flat/transform.js */ "./node_modules/ol/geom/flat/transform.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _proj_Units_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../proj/Units.js */ "./node_modules/ol/proj/Units.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/geom/Geometry
 */









/**
 * @type {import("../transform.js").Transform}
 */
var tmpTransform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_6__["create"])();


/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for vector geometries.
 *
 * To get notified of changes to the geometry, register a listener for the
 * generic `change` event on your geometry instance.
 *
 * @abstract
 * @api
 */
var Geometry = /*@__PURE__*/(function (BaseObject) {
  function Geometry() {

    BaseObject.call(this);

    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    this.extent_ = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["createEmpty"])();

    /**
     * @private
     * @type {number}
     */
    this.extentRevision_ = -1;

    /**
     * @protected
     * @type {Object<string, Geometry>}
     */
    this.simplifiedGeometryCache = {};

    /**
     * @protected
     * @type {number}
     */
    this.simplifiedGeometryMaxMinSquaredTolerance = 0;

    /**
     * @protected
     * @type {number}
     */
    this.simplifiedGeometryRevision = 0;

  }

  if ( BaseObject ) Geometry.__proto__ = BaseObject;
  Geometry.prototype = Object.create( BaseObject && BaseObject.prototype );
  Geometry.prototype.constructor = Geometry;

  /**
   * Make a complete copy of the geometry.
   * @abstract
   * @return {!Geometry} Clone.
   */
  Geometry.prototype.clone = function clone () {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * @abstract
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  Geometry.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  Geometry.prototype.containsXY = function containsXY (x, y) {
    return false;
  };

  /**
   * Return the closest point of the geometry to the passed point as
   * {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} point Point.
   * @param {import("../coordinate.js").Coordinate=} opt_closestPoint Closest point.
   * @return {import("../coordinate.js").Coordinate} Closest point.
   * @api
   */
  Geometry.prototype.getClosestPoint = function getClosestPoint (point, opt_closestPoint) {
    var closestPoint = opt_closestPoint ? opt_closestPoint : [NaN, NaN];
    this.closestPointXY(point[0], point[1], closestPoint, Infinity);
    return closestPoint;
  };

  /**
   * Returns true if this geometry includes the specified coordinate. If the
   * coordinate is on the boundary of the geometry, returns false.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {boolean} Contains coordinate.
   * @api
   */
  Geometry.prototype.intersectsCoordinate = function intersectsCoordinate (coordinate) {
    return this.containsXY(coordinate[0], coordinate[1]);
  };

  /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  Geometry.prototype.computeExtent = function computeExtent (extent) {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Get the extent of the geometry.
   * @param {import("../extent.js").Extent=} opt_extent Extent.
   * @return {import("../extent.js").Extent} extent Extent.
   * @api
   */
  Geometry.prototype.getExtent = function getExtent (opt_extent) {
    if (this.extentRevision_ != this.getRevision()) {
      this.extent_ = this.computeExtent(this.extent_);
      this.extentRevision_ = this.getRevision();
    }
    return Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["returnOrUpdate"])(this.extent_, opt_extent);
  };

  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  Geometry.prototype.rotate = function rotate (angle, anchor) {
    Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number=} opt_sy The scaling factor in the y-direction (defaults to
   *     sx).
   * @param {import("../coordinate.js").Coordinate=} opt_anchor The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  Geometry.prototype.scale = function scale (sx, opt_sy, opt_anchor) {
    Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Create a simplified version of this geometry.  For linestrings, this uses
   * the the {@link
   * https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm
   * Douglas Peucker} algorithm.  For polygons, a quantization-based
   * simplification is used to preserve topology.
   * @param {number} tolerance The tolerance distance for simplification.
   * @return {Geometry} A new, simplified version of the original geometry.
   * @api
   */
  Geometry.prototype.simplify = function simplify (tolerance) {
    return this.getSimplifiedGeometry(tolerance * tolerance);
  };

  /**
   * Create a simplified version of this geometry using the Douglas Peucker
   * algorithm.
   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Geometry} Simplified geometry.
   */
  Geometry.prototype.getSimplifiedGeometry = function getSimplifiedGeometry (squaredTolerance) {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Get the type of this geometry.
   * @abstract
   * @return {import("./GeometryType.js").default} Geometry type.
   */
  Geometry.prototype.getType = function getType () {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Apply a transform function to each coordinate of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @abstract
   * @param {import("../proj.js").TransformFunction} transformFn Transform.
   */
  Geometry.prototype.applyTransform = function applyTransform (transformFn) {
    Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Test if the geometry and the passed extent intersect.
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   */
  Geometry.prototype.intersectsExtent = function intersectsExtent (extent) {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @abstract
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  Geometry.prototype.translate = function translate (deltaX, deltaY) {
    Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Transform each coordinate of the geometry from one coordinate reference
   * system to another. The geometry is modified in place.
   * For example, a line will be transformed to a line and a circle to a circle.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   *
   * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @return {Geometry} This geometry.  Note that original geometry is
   *     modified in place.
   * @api
   */
  Geometry.prototype.transform = function transform (source, destination) {
    /** @type {import("../proj/Projection.js").default} */
    var sourceProj = Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__["get"])(source);
    var transformFn = sourceProj.getUnits() == _proj_Units_js__WEBPACK_IMPORTED_MODULE_5__["default"].TILE_PIXELS ?
      function(inCoordinates, outCoordinates, stride) {
        var pixelExtent = sourceProj.getExtent();
        var projectedExtent = sourceProj.getWorldExtent();
        var scale = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["getHeight"])(projectedExtent) / Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["getHeight"])(pixelExtent);
        Object(_transform_js__WEBPACK_IMPORTED_MODULE_6__["compose"])(tmpTransform,
          projectedExtent[0], projectedExtent[3],
          scale, -scale, 0,
          0, 0);
        Object(_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__["transform2D"])(inCoordinates, 0, inCoordinates.length, stride,
          tmpTransform, outCoordinates);
        return Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__["getTransform"])(sourceProj, destination)(inCoordinates, outCoordinates, stride);
      } :
      Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__["getTransform"])(sourceProj, destination);
    this.applyTransform(transformFn);
    return this;
  };

  return Geometry;
}(_Object_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (Geometry);

//# sourceMappingURL=Geometry.js.map

/***/ }),

/***/ "./node_modules/ol/geom/GeometryLayout.js":
/*!************************************************!*\
  !*** ./node_modules/ol/geom/GeometryLayout.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/geom/GeometryLayout
 */

/**
 * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')
 * or measure ('M') coordinate is available. Supported values are `'XY'`,
 * `'XYZ'`, `'XYM'`, `'XYZM'`.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  XY: 'XY',
  XYZ: 'XYZ',
  XYM: 'XYM',
  XYZM: 'XYZM'
});

//# sourceMappingURL=GeometryLayout.js.map

/***/ }),

/***/ "./node_modules/ol/geom/GeometryType.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/GeometryType.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/geom/GeometryType
 */

/**
 * The geometry type. One of `'Point'`, `'LineString'`, `'LinearRing'`,
 * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,
 * `'GeometryCollection'`, `'Circle'`.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  POINT: 'Point',
  LINE_STRING: 'LineString',
  LINEAR_RING: 'LinearRing',
  POLYGON: 'Polygon',
  MULTI_POINT: 'MultiPoint',
  MULTI_LINE_STRING: 'MultiLineString',
  MULTI_POLYGON: 'MultiPolygon',
  GEOMETRY_COLLECTION: 'GeometryCollection',
  CIRCLE: 'Circle'
});

//# sourceMappingURL=GeometryType.js.map

/***/ }),

/***/ "./node_modules/ol/geom/Point.js":
/*!***************************************!*\
  !*** ./node_modules/ol/geom/Point.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _GeometryType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/geom/Point
 */






/**
 * @classdesc
 * Point geometry.
 *
 * @api
 */
var Point = /*@__PURE__*/(function (SimpleGeometry) {
  function Point(coordinates, opt_layout) {
    SimpleGeometry.call(this);
    this.setCoordinates(coordinates, opt_layout);
  }

  if ( SimpleGeometry ) Point.__proto__ = SimpleGeometry;
  Point.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );
  Point.prototype.constructor = Point;

  /**
   * Make a complete copy of the geometry.
   * @return {!Point} Clone.
   * @override
   * @api
   */
  Point.prototype.clone = function clone () {
    var point = new Point(this.flatCoordinates.slice(), this.layout);
    return point;
  };

  /**
   * @inheritDoc
   */
  Point.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {
    var flatCoordinates = this.flatCoordinates;
    var squaredDistance = Object(_math_js__WEBPACK_IMPORTED_MODULE_4__["squaredDistance"])(x, y, flatCoordinates[0], flatCoordinates[1]);
    if (squaredDistance < minSquaredDistance) {
      var stride = this.stride;
      for (var i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[i];
      }
      closestPoint.length = stride;
      return squaredDistance;
    } else {
      return minSquaredDistance;
    }
  };

  /**
   * Return the coordinate of the point.
   * @return {import("../coordinate.js").Coordinate} Coordinates.
   * @override
   * @api
   */
  Point.prototype.getCoordinates = function getCoordinates () {
    return !this.flatCoordinates ? [] : this.flatCoordinates.slice();
  };

  /**
   * @inheritDoc
   */
  Point.prototype.computeExtent = function computeExtent (extent) {
    return Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["createOrUpdateFromCoordinate"])(this.flatCoordinates, extent);
  };

  /**
   * @inheritDoc
   * @api
   */
  Point.prototype.getType = function getType () {
    return _GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINT;
  };

  /**
   * @inheritDoc
   * @api
   */
  Point.prototype.intersectsExtent = function intersectsExtent (extent) {
    return Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["containsXY"])(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
  };

  /**
   * @inheritDoc
   * @api
   */
  Point.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 0);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = Object(_flat_deflate_js__WEBPACK_IMPORTED_MODULE_3__["deflateCoordinate"])(
      this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  };

  return Point;
}(_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (Point);

//# sourceMappingURL=Point.js.map

/***/ }),

/***/ "./node_modules/ol/geom/SimpleGeometry.js":
/*!************************************************!*\
  !*** ./node_modules/ol/geom/SimpleGeometry.js ***!
  \************************************************/
/*! exports provided: getStrideForLayout, transformGeom2D, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getStrideForLayout", function() { return getStrideForLayout; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformGeom2D", function() { return transformGeom2D; });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _Geometry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Geometry.js */ "./node_modules/ol/geom/Geometry.js");
/* harmony import */ var _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GeometryLayout.js */ "./node_modules/ol/geom/GeometryLayout.js");
/* harmony import */ var _flat_transform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./flat/transform.js */ "./node_modules/ol/geom/flat/transform.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/geom/SimpleGeometry
 */







/**
 * @classdesc
 * Abstract base class; only used for creating subclasses; do not instantiate
 * in apps, as cannot be rendered.
 *
 * @abstract
 * @api
 */
var SimpleGeometry = /*@__PURE__*/(function (Geometry) {
  function SimpleGeometry() {

    Geometry.call(this);

    /**
     * @protected
     * @type {GeometryLayout}
     */
    this.layout = _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XY;

    /**
     * @protected
     * @type {number}
     */
    this.stride = 2;

    /**
     * @protected
     * @type {Array<number>}
     */
    this.flatCoordinates = null;

  }

  if ( Geometry ) SimpleGeometry.__proto__ = Geometry;
  SimpleGeometry.prototype = Object.create( Geometry && Geometry.prototype );
  SimpleGeometry.prototype.constructor = SimpleGeometry;

  /**
   * @inheritDoc
   */
  SimpleGeometry.prototype.computeExtent = function computeExtent (extent) {
    return Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["createOrUpdateFromFlatCoordinates"])(this.flatCoordinates,
      0, this.flatCoordinates.length, this.stride, extent);
  };

  /**
   * @abstract
   * @return {Array} Coordinates.
   */
  SimpleGeometry.prototype.getCoordinates = function getCoordinates () {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Return the first coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} First coordinate.
   * @api
   */
  SimpleGeometry.prototype.getFirstCoordinate = function getFirstCoordinate () {
    return this.flatCoordinates.slice(0, this.stride);
  };

  /**
   * @return {Array<number>} Flat coordinates.
   */
  SimpleGeometry.prototype.getFlatCoordinates = function getFlatCoordinates () {
    return this.flatCoordinates;
  };

  /**
   * Return the last coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} Last point.
   * @api
   */
  SimpleGeometry.prototype.getLastCoordinate = function getLastCoordinate () {
    return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);
  };

  /**
   * Return the {@link module:ol/geom/GeometryLayout layout} of the geometry.
   * @return {GeometryLayout} Layout.
   * @api
   */
  SimpleGeometry.prototype.getLayout = function getLayout () {
    return this.layout;
  };

  /**
   * @inheritDoc
   */
  SimpleGeometry.prototype.getSimplifiedGeometry = function getSimplifiedGeometry (squaredTolerance) {
    if (this.simplifiedGeometryRevision != this.getRevision()) {
      Object(_obj_js__WEBPACK_IMPORTED_MODULE_5__["clear"])(this.simplifiedGeometryCache);
      this.simplifiedGeometryMaxMinSquaredTolerance = 0;
      this.simplifiedGeometryRevision = this.getRevision();
    }
    // If squaredTolerance is negative or if we know that simplification will not
    // have any effect then just return this.
    if (squaredTolerance < 0 ||
        (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&
         squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance)) {
      return this;
    }
    var key = squaredTolerance.toString();
    if (this.simplifiedGeometryCache.hasOwnProperty(key)) {
      return this.simplifiedGeometryCache[key];
    } else {
      var simplifiedGeometry =
          this.getSimplifiedGeometryInternal(squaredTolerance);
      var simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();
      if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
        this.simplifiedGeometryCache[key] = simplifiedGeometry;
        return simplifiedGeometry;
      } else {
        // Simplification did not actually remove any coordinates.  We now know
        // that any calls to getSimplifiedGeometry with a squaredTolerance less
        // than or equal to the current squaredTolerance will also not have any
        // effect.  This allows us to short circuit simplification (saving CPU
        // cycles) and prevents the cache of simplified geometries from filling
        // up with useless identical copies of this geometry (saving memory).
        this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
        return this;
      }
    }
  };

  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   * @protected
   */
  SimpleGeometry.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {
    return this;
  };

  /**
   * @return {number} Stride.
   */
  SimpleGeometry.prototype.getStride = function getStride () {
    return this.stride;
  };

  /**
   * @param {GeometryLayout} layout Layout.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   */
  SimpleGeometry.prototype.setFlatCoordinates = function setFlatCoordinates (layout, flatCoordinates) {
    this.stride = getStrideForLayout(layout);
    this.layout = layout;
    this.flatCoordinates = flatCoordinates;
  };

  /**
   * @abstract
   * @param {!Array} coordinates Coordinates.
   * @param {GeometryLayout=} opt_layout Layout.
   */
  SimpleGeometry.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {
    Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * @param {GeometryLayout|undefined} layout Layout.
   * @param {Array} coordinates Coordinates.
   * @param {number} nesting Nesting.
   * @protected
   */
  SimpleGeometry.prototype.setLayout = function setLayout (layout, coordinates, nesting) {
    /** @type {number} */
    var stride;
    if (layout) {
      stride = getStrideForLayout(layout);
    } else {
      for (var i = 0; i < nesting; ++i) {
        if (coordinates.length === 0) {
          this.layout = _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XY;
          this.stride = 2;
          return;
        } else {
          coordinates = /** @type {Array} */ (coordinates[0]);
        }
      }
      stride = coordinates.length;
      layout = getLayoutForStride(stride);
    }
    this.layout = layout;
    this.stride = stride;
  };

  /**
   * @inheritDoc
   * @api
   */
  SimpleGeometry.prototype.applyTransform = function applyTransform (transformFn) {
    if (this.flatCoordinates) {
      transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);
      this.changed();
    }
  };

  /**
   * @inheritDoc
   * @api
   */
  SimpleGeometry.prototype.rotate = function rotate$1 (angle, anchor) {
    var flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      var stride = this.getStride();
      Object(_flat_transform_js__WEBPACK_IMPORTED_MODULE_4__["rotate"])(
        flatCoordinates, 0, flatCoordinates.length,
        stride, angle, anchor, flatCoordinates);
      this.changed();
    }
  };

  /**
   * @inheritDoc
   * @api
   */
  SimpleGeometry.prototype.scale = function scale$1 (sx, opt_sy, opt_anchor) {
    var sy = opt_sy;
    if (sy === undefined) {
      sy = sx;
    }
    var anchor = opt_anchor;
    if (!anchor) {
      anchor = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getCenter"])(this.getExtent());
    }
    var flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      var stride = this.getStride();
      Object(_flat_transform_js__WEBPACK_IMPORTED_MODULE_4__["scale"])(
        flatCoordinates, 0, flatCoordinates.length,
        stride, sx, sy, anchor, flatCoordinates);
      this.changed();
    }
  };

  /**
   * @inheritDoc
   * @api
   */
  SimpleGeometry.prototype.translate = function translate$1 (deltaX, deltaY) {
    var flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      var stride = this.getStride();
      Object(_flat_transform_js__WEBPACK_IMPORTED_MODULE_4__["translate"])(
        flatCoordinates, 0, flatCoordinates.length, stride,
        deltaX, deltaY, flatCoordinates);
      this.changed();
    }
  };

  return SimpleGeometry;
}(_Geometry_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/**
 * @param {number} stride Stride.
 * @return {GeometryLayout} layout Layout.
 */
function getLayoutForStride(stride) {
  var layout;
  if (stride == 2) {
    layout = _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XY;
  } else if (stride == 3) {
    layout = _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XYZ;
  } else if (stride == 4) {
    layout = _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XYZM;
  }
  return (
    /** @type {GeometryLayout} */ (layout)
  );
}


/**
 * @param {GeometryLayout} layout Layout.
 * @return {number} Stride.
 */
function getStrideForLayout(layout) {
  var stride;
  if (layout == _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XY) {
    stride = 2;
  } else if (layout == _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XYZ || layout == _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XYM) {
    stride = 3;
  } else if (layout == _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XYZM) {
    stride = 4;
  }
  return /** @type {number} */ (stride);
}


/**
 * @param {SimpleGeometry} simpleGeometry Simple geometry.
 * @param {import("../transform.js").Transform} transform Transform.
 * @param {Array<number>=} opt_dest Destination.
 * @return {Array<number>} Transformed flat coordinates.
 */
function transformGeom2D(simpleGeometry, transform, opt_dest) {
  var flatCoordinates = simpleGeometry.getFlatCoordinates();
  if (!flatCoordinates) {
    return null;
  } else {
    var stride = simpleGeometry.getStride();
    return Object(_flat_transform_js__WEBPACK_IMPORTED_MODULE_4__["transform2D"])(
      flatCoordinates, 0, flatCoordinates.length, stride,
      transform, opt_dest);
  }
}

/* harmony default export */ __webpack_exports__["default"] = (SimpleGeometry);

//# sourceMappingURL=SimpleGeometry.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/deflate.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/flat/deflate.js ***!
  \**********************************************/
/*! exports provided: deflateCoordinate, deflateCoordinates, deflateCoordinatesArray, deflateMultiCoordinatesArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deflateCoordinate", function() { return deflateCoordinate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deflateCoordinates", function() { return deflateCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deflateCoordinatesArray", function() { return deflateCoordinatesArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deflateMultiCoordinatesArray", function() { return deflateMultiCoordinatesArray; });
/**
 * @module ol/geom/flat/deflate
 */


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */
function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {
  for (var i = 0, ii = coordinate.length; i < ii; ++i) {
    flatCoordinates[offset++] = coordinate[i];
  }
  return offset;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<import("../../coordinate.js").Coordinate>} coordinates Coordinates.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */
function deflateCoordinates(flatCoordinates, offset, coordinates, stride) {
  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    var coordinate = coordinates[i];
    for (var j = 0; j < stride; ++j) {
      flatCoordinates[offset++] = coordinate[j];
    }
  }
  return offset;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<import("../../coordinate.js").Coordinate>>} coordinatess Coordinatess.
 * @param {number} stride Stride.
 * @param {Array<number>=} opt_ends Ends.
 * @return {Array<number>} Ends.
 */
function deflateCoordinatesArray(flatCoordinates, offset, coordinatess, stride, opt_ends) {
  var ends = opt_ends ? opt_ends : [];
  var i = 0;
  for (var j = 0, jj = coordinatess.length; j < jj; ++j) {
    var end = deflateCoordinates(
      flatCoordinates, offset, coordinatess[j], stride);
    ends[i++] = end;
    offset = end;
  }
  ends.length = i;
  return ends;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} coordinatesss Coordinatesss.
 * @param {number} stride Stride.
 * @param {Array<Array<number>>=} opt_endss Endss.
 * @return {Array<Array<number>>} Endss.
 */
function deflateMultiCoordinatesArray(flatCoordinates, offset, coordinatesss, stride, opt_endss) {
  var endss = opt_endss ? opt_endss : [];
  var i = 0;
  for (var j = 0, jj = coordinatesss.length; j < jj; ++j) {
    var ends = deflateCoordinatesArray(
      flatCoordinates, offset, coordinatesss[j], stride, endss[i]);
    endss[i++] = ends;
    offset = ends[ends.length - 1];
  }
  endss.length = i;
  return endss;
}

//# sourceMappingURL=deflate.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/transform.js":
/*!************************************************!*\
  !*** ./node_modules/ol/geom/flat/transform.js ***!
  \************************************************/
/*! exports provided: transform2D, rotate, scale, translate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transform2D", function() { return transform2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/**
 * @module ol/geom/flat/transform
 */


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../transform.js").Transform} transform Transform.
 * @param {Array<number>=} opt_dest Destination.
 * @return {Array<number>} Transformed coordinates.
 */
function transform2D(flatCoordinates, offset, end, stride, transform, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var i = 0;
  for (var j = offset; j < end; j += stride) {
    var x = flatCoordinates[j];
    var y = flatCoordinates[j + 1];
    dest[i++] = transform[0] * x + transform[2] * y + transform[4];
    dest[i++] = transform[1] * x + transform[3] * y + transform[5];
  }
  if (opt_dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} angle Angle.
 * @param {Array<number>} anchor Rotation anchor point.
 * @param {Array<number>=} opt_dest Destination.
 * @return {Array<number>} Transformed coordinates.
 */
function rotate(flatCoordinates, offset, end, stride, angle, anchor, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var cos = Math.cos(angle);
  var sin = Math.sin(angle);
  var anchorX = anchor[0];
  var anchorY = anchor[1];
  var i = 0;
  for (var j = offset; j < end; j += stride) {
    var deltaX = flatCoordinates[j] - anchorX;
    var deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + deltaX * cos - deltaY * sin;
    dest[i++] = anchorY + deltaX * sin + deltaY * cos;
    for (var k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (opt_dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}


/**
 * Scale the coordinates.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} sx Scale factor in the x-direction.
 * @param {number} sy Scale factor in the y-direction.
 * @param {Array<number>} anchor Scale anchor point.
 * @param {Array<number>=} opt_dest Destination.
 * @return {Array<number>} Transformed coordinates.
 */
function scale(flatCoordinates, offset, end, stride, sx, sy, anchor, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var anchorX = anchor[0];
  var anchorY = anchor[1];
  var i = 0;
  for (var j = offset; j < end; j += stride) {
    var deltaX = flatCoordinates[j] - anchorX;
    var deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + sx * deltaX;
    dest[i++] = anchorY + sy * deltaY;
    for (var k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (opt_dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} deltaX Delta X.
 * @param {number} deltaY Delta Y.
 * @param {Array<number>=} opt_dest Destination.
 * @return {Array<number>} Transformed coordinates.
 */
function translate(flatCoordinates, offset, end, stride, deltaX, deltaY, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var i = 0;
  for (var j = offset; j < end; j += stride) {
    dest[i++] = flatCoordinates[j] + deltaX;
    dest[i++] = flatCoordinates[j + 1] + deltaY;
    for (var k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (opt_dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}

//# sourceMappingURL=transform.js.map

/***/ }),

/***/ "./node_modules/ol/has.js":
/*!********************************!*\
  !*** ./node_modules/ol/has.js ***!
  \********************************/
/*! exports provided: FIREFOX, SAFARI, WEBKIT, MAC, DEVICE_PIXEL_RATIO, CANVAS_LINE_DASH, GEOLOCATION, TOUCH, POINTER, MSPOINTER, WEBGL */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FIREFOX", function() { return FIREFOX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SAFARI", function() { return SAFARI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEBKIT", function() { return WEBKIT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAC", function() { return MAC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEVICE_PIXEL_RATIO", function() { return DEVICE_PIXEL_RATIO; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CANVAS_LINE_DASH", function() { return CANVAS_LINE_DASH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GEOLOCATION", function() { return GEOLOCATION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOUCH", function() { return TOUCH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POINTER", function() { return POINTER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MSPOINTER", function() { return MSPOINTER; });
/* harmony import */ var _webgl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webgl.js */ "./node_modules/ol/webgl.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WEBGL", function() { return _webgl_js__WEBPACK_IMPORTED_MODULE_0__["HAS"]; });

/**
 * @module ol/has
 */

var ua = typeof navigator !== 'undefined' ?
  navigator.userAgent.toLowerCase() : '';

/**
 * User agent string says we are dealing with Firefox as browser.
 * @type {boolean}
 */
var FIREFOX = ua.indexOf('firefox') !== -1;

/**
 * User agent string says we are dealing with Safari as browser.
 * @type {boolean}
 */
var SAFARI = ua.indexOf('safari') !== -1 && ua.indexOf('chrom') == -1;

/**
 * User agent string says we are dealing with a WebKit engine.
 * @type {boolean}
 */
var WEBKIT = ua.indexOf('webkit') !== -1 && ua.indexOf('edge') == -1;

/**
 * User agent string says we are dealing with a Mac as platform.
 * @type {boolean}
 */
var MAC = ua.indexOf('macintosh') !== -1;


/**
 * The ratio between physical pixels and device-independent pixels
 * (dips) on the device (`window.devicePixelRatio`).
 * @const
 * @type {number}
 * @api
 */
var DEVICE_PIXEL_RATIO = window.devicePixelRatio || 1;


/**
 * True if the browser's Canvas implementation implements {get,set}LineDash.
 * @type {boolean}
 */
var CANVAS_LINE_DASH = function() {
  var has = false;
  try {
    has = !!document.createElement('canvas').getContext('2d').setLineDash;
  } catch (e) {
    // pass
  }
  return has;
}();


/**
 * Is HTML5 geolocation supported in the current browser?
 * @const
 * @type {boolean}
 * @api
 */
var GEOLOCATION = 'geolocation' in navigator;


/**
 * True if browser supports touch events.
 * @const
 * @type {boolean}
 * @api
 */
var TOUCH = 'ontouchstart' in window;


/**
 * True if browser supports pointer events.
 * @const
 * @type {boolean}
 */
var POINTER = 'PointerEvent' in window;


/**
 * True if browser supports ms pointer events (IE 10).
 * @const
 * @type {boolean}
 */
var MSPOINTER = !!(navigator.msPointerEnabled);




//# sourceMappingURL=has.js.map

/***/ }),

/***/ "./node_modules/ol/layer.js":
/*!**********************************!*\
  !*** ./node_modules/ol/layer.js ***!
  \**********************************/
/*! exports provided: Group, Heatmap, Image, Layer, Tile, Vector, VectorTile */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _layer_Group_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./layer/Group.js */ "./node_modules/ol/layer/Group.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Group", function() { return _layer_Group_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _layer_Heatmap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./layer/Heatmap.js */ "./node_modules/ol/layer/Heatmap.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Heatmap", function() { return _layer_Heatmap_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _layer_Image_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./layer/Image.js */ "./node_modules/ol/layer/Image.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Image", function() { return _layer_Image_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _layer_Layer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./layer/Layer.js */ "./node_modules/ol/layer/Layer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Layer", function() { return _layer_Layer_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _layer_Tile_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./layer/Tile.js */ "./node_modules/ol/layer/Tile.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tile", function() { return _layer_Tile_js__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _layer_Vector_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./layer/Vector.js */ "./node_modules/ol/layer/Vector.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Vector", function() { return _layer_Vector_js__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _layer_VectorTile_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./layer/VectorTile.js */ "./node_modules/ol/layer/VectorTile.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VectorTile", function() { return _layer_VectorTile_js__WEBPACK_IMPORTED_MODULE_6__["default"]; });


/**
 * @module ol/layer
 */









//# sourceMappingURL=layer.js.map

/***/ }),

/***/ "./node_modules/ol/layer/Base.js":
/*!***************************************!*\
  !*** ./node_modules/ol/layer/Base.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _Property_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Property.js */ "./node_modules/ol/layer/Property.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/layer/Base
 */







/**
 * @typedef {Object} Options
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 */


/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Note that with {@link module:ol/layer/Base} and all its subclasses, any property set in
 * the options is set as a {@link module:ol/Object} property on the layer object, so
 * is observable, and has get/set accessors.
 *
 * @api
 */
var BaseLayer = /*@__PURE__*/(function (BaseObject) {
  function BaseLayer(options) {

    BaseObject.call(this);

    /**
     * @type {Object<string, *>}
     */
    var properties = Object(_obj_js__WEBPACK_IMPORTED_MODULE_4__["assign"])({}, options);
    properties[_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].OPACITY] =
       options.opacity !== undefined ? options.opacity : 1;
    properties[_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].VISIBLE] =
       options.visible !== undefined ? options.visible : true;
    properties[_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].Z_INDEX] = options.zIndex;
    properties[_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].MAX_RESOLUTION] =
       options.maxResolution !== undefined ? options.maxResolution : Infinity;
    properties[_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].MIN_RESOLUTION] =
       options.minResolution !== undefined ? options.minResolution : 0;

    this.setProperties(properties);

    /**
     * @type {import("./Layer.js").State}
     * @private
     */
    this.state_ = null;

    /**
     * The layer type.
     * @type {import("../LayerType.js").default}
     * @protected;
     */
    this.type;

  }

  if ( BaseObject ) BaseLayer.__proto__ = BaseObject;
  BaseLayer.prototype = Object.create( BaseObject && BaseObject.prototype );
  BaseLayer.prototype.constructor = BaseLayer;

  /**
   * Get the layer type (used when creating a layer renderer).
   * @return {import("../LayerType.js").default} The layer type.
   */
  BaseLayer.prototype.getType = function getType () {
    return this.type;
  };

  /**
   * @return {import("./Layer.js").State} Layer state.
   */
  BaseLayer.prototype.getLayerState = function getLayerState () {
    /** @type {import("./Layer.js").State} */
    var state = this.state_ || /** @type {?} */ ({
      layer: this,
      managed: true
    });
    state.opacity = Object(_math_js__WEBPACK_IMPORTED_MODULE_3__["clamp"])(this.getOpacity(), 0, 1);
    state.sourceState = this.getSourceState();
    state.visible = this.getVisible();
    state.extent = this.getExtent();
    state.zIndex = this.getZIndex() || 0;
    state.maxResolution = this.getMaxResolution();
    state.minResolution = Math.max(this.getMinResolution(), 0);
    this.state_ = state;

    return state;
  };

  /**
   * @abstract
   * @param {Array<import("./Layer.js").default>=} opt_array Array of layers (to be
   *     modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  BaseLayer.prototype.getLayersArray = function getLayersArray (opt_array) {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * @abstract
   * @param {Array<import("./Layer.js").State>=} opt_states Optional list of layer
   *     states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  BaseLayer.prototype.getLayerStatesArray = function getLayerStatesArray (opt_states) {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
   * will be visible regardless of extent.
   * @return {import("../extent.js").Extent|undefined} The layer extent.
   * @observable
   * @api
   */
  BaseLayer.prototype.getExtent = function getExtent () {
    return (
      /** @type {import("../extent.js").Extent|undefined} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].EXTENT))
    );
  };

  /**
   * Return the maximum resolution of the layer.
   * @return {number} The maximum resolution of the layer.
   * @observable
   * @api
   */
  BaseLayer.prototype.getMaxResolution = function getMaxResolution () {
    return /** @type {number} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].MAX_RESOLUTION));
  };

  /**
   * Return the minimum resolution of the layer.
   * @return {number} The minimum resolution of the layer.
   * @observable
   * @api
   */
  BaseLayer.prototype.getMinResolution = function getMinResolution () {
    return /** @type {number} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].MIN_RESOLUTION));
  };

  /**
   * Return the opacity of the layer (between 0 and 1).
   * @return {number} The opacity of the layer.
   * @observable
   * @api
   */
  BaseLayer.prototype.getOpacity = function getOpacity () {
    return /** @type {number} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].OPACITY));
  };

  /**
   * @abstract
   * @return {import("../source/State.js").default} Source state.
   */
  BaseLayer.prototype.getSourceState = function getSourceState () {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Return the visibility of the layer (`true` or `false`).
   * @return {boolean} The visibility of the layer.
   * @observable
   * @api
   */
  BaseLayer.prototype.getVisible = function getVisible () {
    return /** @type {boolean} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].VISIBLE));
  };

  /**
   * Return the Z-index of the layer, which is used to order layers before
   * rendering. The default Z-index is 0.
   * @return {number} The Z-index of the layer.
   * @observable
   * @api
   */
  BaseLayer.prototype.getZIndex = function getZIndex () {
    return /** @type {number} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].Z_INDEX));
  };

  /**
   * Set the extent at which the layer is visible.  If `undefined`, the layer
   * will be visible at all extents.
   * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
   * @observable
   * @api
   */
  BaseLayer.prototype.setExtent = function setExtent (extent) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].EXTENT, extent);
  };

  /**
   * Set the maximum resolution at which the layer is visible.
   * @param {number} maxResolution The maximum resolution of the layer.
   * @observable
   * @api
   */
  BaseLayer.prototype.setMaxResolution = function setMaxResolution (maxResolution) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].MAX_RESOLUTION, maxResolution);
  };

  /**
   * Set the minimum resolution at which the layer is visible.
   * @param {number} minResolution The minimum resolution of the layer.
   * @observable
   * @api
   */
  BaseLayer.prototype.setMinResolution = function setMinResolution (minResolution) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].MIN_RESOLUTION, minResolution);
  };

  /**
   * Set the opacity of the layer, allowed values range from 0 to 1.
   * @param {number} opacity The opacity of the layer.
   * @observable
   * @api
   */
  BaseLayer.prototype.setOpacity = function setOpacity (opacity) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].OPACITY, opacity);
  };

  /**
   * Set the visibility of the layer (`true` or `false`).
   * @param {boolean} visible The visibility of the layer.
   * @observable
   * @api
   */
  BaseLayer.prototype.setVisible = function setVisible (visible) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].VISIBLE, visible);
  };

  /**
   * Set Z-index of the layer, which is used to order layers before rendering.
   * The default Z-index is 0.
   * @param {number} zindex The z-index of the layer.
   * @observable
   * @api
   */
  BaseLayer.prototype.setZIndex = function setZIndex (zindex) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].Z_INDEX, zindex);
  };

  return BaseLayer;
}(_Object_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (BaseLayer);

//# sourceMappingURL=Base.js.map

/***/ }),

/***/ "./node_modules/ol/layer/Group.js":
/*!****************************************!*\
  !*** ./node_modules/ol/layer/Group.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Collection.js */ "./node_modules/ol/Collection.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../CollectionEventType.js */ "./node_modules/ol/CollectionEventType.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ObjectEventType.js */ "./node_modules/ol/ObjectEventType.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _Base_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Base.js */ "./node_modules/ol/layer/Base.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _source_State_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../source/State.js */ "./node_modules/ol/source/State.js");
/**
 * @module ol/layer/Group
 */














/**
 * @typedef {Object} Options
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {Array<import("./Base.js").default>|import("../Collection.js").default<import("./Base.js").default>} [layers] Child layers.
 */


/**
 * @enum {string}
 * @private
 */
var Property = {
  LAYERS: 'layers'
};


/**
 * @classdesc
 * A {@link module:ol/Collection~Collection} of layers that are handled together.
 *
 * A generic `change` event is triggered when the group/Collection changes.
 *
 * @api
 */
var LayerGroup = /*@__PURE__*/(function (BaseLayer) {
  function LayerGroup(opt_options) {

    var options = opt_options || {};
    var baseOptions = /** @type {Options} */ (Object(_obj_js__WEBPACK_IMPORTED_MODULE_10__["assign"])({}, options));
    delete baseOptions.layers;

    var layers = options.layers;

    BaseLayer.call(this, baseOptions);

    /**
     * @private
     * @type {Array<import("../events.js").EventsKey>}
     */
    this.layersListenerKeys_ = [];

    /**
     * @private
     * @type {Object<string, Array<import("../events.js").EventsKey>>}
     */
    this.listenerKeys_ = {};

    Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(this,
      Object(_Object_js__WEBPACK_IMPORTED_MODULE_3__["getChangeEventType"])(Property.LAYERS),
      this.handleLayersChanged_, this);

    if (layers) {
      if (Array.isArray(layers)) {
        layers = new _Collection_js__WEBPACK_IMPORTED_MODULE_1__["default"](layers.slice(), {unique: true});
      } else {
        Object(_asserts_js__WEBPACK_IMPORTED_MODULE_5__["assert"])(typeof /** @type {?} */ (layers).getArray === 'function',
          43); // Expected `layers` to be an array or a `Collection`
      }
    } else {
      layers = new _Collection_js__WEBPACK_IMPORTED_MODULE_1__["default"](undefined, {unique: true});
    }

    this.setLayers(layers);

  }

  if ( BaseLayer ) LayerGroup.__proto__ = BaseLayer;
  LayerGroup.prototype = Object.create( BaseLayer && BaseLayer.prototype );
  LayerGroup.prototype.constructor = LayerGroup;

  /**
   * @private
   */
  LayerGroup.prototype.handleLayerChange_ = function handleLayerChange_ () {
    this.changed();
  };

  /**
   * @private
   */
  LayerGroup.prototype.handleLayersChanged_ = function handleLayersChanged_ () {
    this.layersListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_6__["unlistenByKey"]);
    this.layersListenerKeys_.length = 0;

    var layers = this.getLayers();
    this.layersListenerKeys_.push(
      Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(layers, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].ADD, this.handleLayersAdd_, this),
      Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(layers, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].REMOVE, this.handleLayersRemove_, this)
    );

    for (var id in this.listenerKeys_) {
      this.listenerKeys_[id].forEach(_events_js__WEBPACK_IMPORTED_MODULE_6__["unlistenByKey"]);
    }
    Object(_obj_js__WEBPACK_IMPORTED_MODULE_10__["clear"])(this.listenerKeys_);

    var layersArray = layers.getArray();
    for (var i = 0, ii = layersArray.length; i < ii; i++) {
      var layer = layersArray[i];
      this.listenerKeys_[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(layer)] = [
        Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(layer, _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].PROPERTYCHANGE, this.handleLayerChange_, this),
        Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(layer, _events_EventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].CHANGE, this.handleLayerChange_, this)
      ];
    }

    this.changed();
  };

  /**
   * @param {import("../Collection.js").CollectionEvent} collectionEvent CollectionEvent.
   * @private
   */
  LayerGroup.prototype.handleLayersAdd_ = function handleLayersAdd_ (collectionEvent) {
    var layer = /** @type {import("./Base.js").default} */ (collectionEvent.element);
    this.listenerKeys_[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(layer)] = [
      Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(layer, _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].PROPERTYCHANGE, this.handleLayerChange_, this),
      Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(layer, _events_EventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].CHANGE, this.handleLayerChange_, this)
    ];
    this.changed();
  };

  /**
   * @param {import("../Collection.js").CollectionEvent} collectionEvent CollectionEvent.
   * @private
   */
  LayerGroup.prototype.handleLayersRemove_ = function handleLayersRemove_ (collectionEvent) {
    var layer = /** @type {import("./Base.js").default} */ (collectionEvent.element);
    var key = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(layer);
    this.listenerKeys_[key].forEach(_events_js__WEBPACK_IMPORTED_MODULE_6__["unlistenByKey"]);
    delete this.listenerKeys_[key];
    this.changed();
  };

  /**
   * Returns the {@link module:ol/Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @return {!import("../Collection.js").default<import("./Base.js").default>} Collection of
   *   {@link module:ol/layer/Base layers} that are part of this group.
   * @observable
   * @api
   */
  LayerGroup.prototype.getLayers = function getLayers () {
    return (
      /** @type {!import("../Collection.js").default<import("./Base.js").default>} */ (this.get(Property.LAYERS))
    );
  };

  /**
   * Set the {@link module:ol/Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @param {!import("../Collection.js").default<import("./Base.js").default>} layers Collection of
   *   {@link module:ol/layer/Base layers} that are part of this group.
   * @observable
   * @api
   */
  LayerGroup.prototype.setLayers = function setLayers (layers) {
    this.set(Property.LAYERS, layers);
  };

  /**
   * @inheritDoc
   */
  LayerGroup.prototype.getLayersArray = function getLayersArray (opt_array) {
    var array = opt_array !== undefined ? opt_array : [];
    this.getLayers().forEach(function(layer) {
      layer.getLayersArray(array);
    });
    return array;
  };

  /**
   * @inheritDoc
   */
  LayerGroup.prototype.getLayerStatesArray = function getLayerStatesArray (opt_states) {
    var states = opt_states !== undefined ? opt_states : [];

    var pos = states.length;

    this.getLayers().forEach(function(layer) {
      layer.getLayerStatesArray(states);
    });

    var ownLayerState = this.getLayerState();
    for (var i = pos, ii = states.length; i < ii; i++) {
      var layerState = states[i];
      layerState.opacity *= ownLayerState.opacity;
      layerState.visible = layerState.visible && ownLayerState.visible;
      layerState.maxResolution = Math.min(
        layerState.maxResolution, ownLayerState.maxResolution);
      layerState.minResolution = Math.max(
        layerState.minResolution, ownLayerState.minResolution);
      if (ownLayerState.extent !== undefined) {
        if (layerState.extent !== undefined) {
          layerState.extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_8__["getIntersection"])(layerState.extent, ownLayerState.extent);
        } else {
          layerState.extent = ownLayerState.extent;
        }
      }
    }

    return states;
  };

  /**
   * @inheritDoc
   */
  LayerGroup.prototype.getSourceState = function getSourceState () {
    return _source_State_js__WEBPACK_IMPORTED_MODULE_11__["default"].READY;
  };

  return LayerGroup;
}(_Base_js__WEBPACK_IMPORTED_MODULE_9__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (LayerGroup);

//# sourceMappingURL=Group.js.map

/***/ }),

/***/ "./node_modules/ol/layer/Heatmap.js":
/*!******************************************!*\
  !*** ./node_modules/ol/layer/Heatmap.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Vector.js */ "./node_modules/ol/layer/Vector.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _render_EventType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../render/EventType.js */ "./node_modules/ol/render/EventType.js");
/* harmony import */ var _style_Icon_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../style/Icon.js */ "./node_modules/ol/style/Icon.js");
/* harmony import */ var _style_Style_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../style/Style.js */ "./node_modules/ol/style/Style.js");
/**
 * @module ol/layer/Heatmap
 */











/**
 * @typedef {Object} Options
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {Array<string>} [gradient=['#00f', '#0ff', '#0f0', '#ff0', '#f00']] The color gradient
 * of the heatmap, specified as an array of CSS color strings.
 * @property {number} [radius=8] Radius size in pixels.
 * @property {number} [blur=15] Blur size in pixels.
 * @property {number} [shadow=250] Shadow size in pixels.
 * @property {string|function(import("../Feature.js").default):number} [weight='weight'] The feature
 * attribute to use for the weight or a function that returns a weight from a feature. Weight values
 * should range from 0 to 1 (and values outside will be clamped to that range).
 * @property {import("./VectorRenderType.js").default|string} [renderMode='vector'] Render mode for vector layers:
 *  * `'image'`: Vector layers are rendered as images. Great performance, but point symbols and
 *    texts are always rotated with the view and pixels are scaled during zoom animations.
 *  * `'vector'`: Vector layers are rendered as vectors. Most accurate rendering even during
 *    animations, but slower performance.
 * @property {import("../source/Vector.js").default} [source] Source.
 */


/**
 * @enum {string}
 * @private
 */
var Property = {
  BLUR: 'blur',
  GRADIENT: 'gradient',
  RADIUS: 'radius'
};


/**
 * @const
 * @type {Array<string>}
 */
var DEFAULT_GRADIENT = ['#00f', '#0ff', '#0f0', '#ff0', '#f00'];


/**
 * @classdesc
 * Layer for rendering vector data as a heatmap.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @fires import("../render/Event.js").RenderEvent
 * @api
 */
var Heatmap = /*@__PURE__*/(function (VectorLayer) {
  function Heatmap(opt_options) {
    var options = opt_options ? opt_options : {};

    var baseOptions = Object(_obj_js__WEBPACK_IMPORTED_MODULE_5__["assign"])({}, options);

    delete baseOptions.gradient;
    delete baseOptions.radius;
    delete baseOptions.blur;
    delete baseOptions.shadow;
    delete baseOptions.weight;
    VectorLayer.call(this, baseOptions);

    /**
     * @private
     * @type {Uint8ClampedArray}
     */
    this.gradient_ = null;

    /**
     * @private
     * @type {number}
     */
    this.shadow_ = options.shadow !== undefined ? options.shadow : 250;

    /**
     * @private
     * @type {string|undefined}
     */
    this.circleImage_ = undefined;

    /**
     * @private
     * @type {Array<Array<import("../style/Style.js").default>>}
     */
    this.styleCache_ = null;

    Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listen"])(this,
      Object(_Object_js__WEBPACK_IMPORTED_MODULE_1__["getChangeEventType"])(Property.GRADIENT),
      this.handleGradientChanged_, this);

    this.setGradient(options.gradient ? options.gradient : DEFAULT_GRADIENT);

    this.setBlur(options.blur !== undefined ? options.blur : 15);

    this.setRadius(options.radius !== undefined ? options.radius : 8);

    Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listen"])(this,
      Object(_Object_js__WEBPACK_IMPORTED_MODULE_1__["getChangeEventType"])(Property.BLUR),
      this.handleStyleChanged_, this);
    Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listen"])(this,
      Object(_Object_js__WEBPACK_IMPORTED_MODULE_1__["getChangeEventType"])(Property.RADIUS),
      this.handleStyleChanged_, this);

    this.handleStyleChanged_();

    var weight = options.weight ? options.weight : 'weight';
    var weightFunction;
    if (typeof weight === 'string') {
      weightFunction = function(feature) {
        return feature.get(weight);
      };
    } else {
      weightFunction = weight;
    }

    this.setStyle(function(feature, resolution) {
      var weight = weightFunction(feature);
      var opacity = weight !== undefined ? Object(_math_js__WEBPACK_IMPORTED_MODULE_4__["clamp"])(weight, 0, 1) : 1;
      // cast to 8 bits
      var index = (255 * opacity) | 0;
      var style = this.styleCache_[index];
      if (!style) {
        style = [
          new _style_Style_js__WEBPACK_IMPORTED_MODULE_8__["default"]({
            image: new _style_Icon_js__WEBPACK_IMPORTED_MODULE_7__["default"]({
              opacity: opacity,
              src: this.circleImage_
            })
          })
        ];
        this.styleCache_[index] = style;
      }
      return style;
    }.bind(this));

    // For performance reasons, don't sort the features before rendering.
    // The render order is not relevant for a heatmap representation.
    this.setRenderOrder(null);

    Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listen"])(this, _render_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].RENDER, this.handleRender_, this);
  }

  if ( VectorLayer ) Heatmap.__proto__ = VectorLayer;
  Heatmap.prototype = Object.create( VectorLayer && VectorLayer.prototype );
  Heatmap.prototype.constructor = Heatmap;

  /**
   * @return {string} Data URL for a circle.
   * @private
   */
  Heatmap.prototype.createCircle_ = function createCircle_ () {
    var radius = this.getRadius();
    var blur = this.getBlur();
    var halfSize = radius + blur + 1;
    var size = 2 * halfSize;
    var context = Object(_dom_js__WEBPACK_IMPORTED_MODULE_2__["createCanvasContext2D"])(size, size);
    context.shadowOffsetX = context.shadowOffsetY = this.shadow_;
    context.shadowBlur = blur;
    context.shadowColor = '#000';
    context.beginPath();
    var center = halfSize - this.shadow_;
    context.arc(center, center, radius, 0, Math.PI * 2, true);
    context.fill();
    return context.canvas.toDataURL();
  };

  /**
   * Return the blur size in pixels.
   * @return {number} Blur size in pixels.
   * @api
   * @observable
   */
  Heatmap.prototype.getBlur = function getBlur () {
    return /** @type {number} */ (this.get(Property.BLUR));
  };

  /**
   * Return the gradient colors as array of strings.
   * @return {Array<string>} Colors.
   * @api
   * @observable
   */
  Heatmap.prototype.getGradient = function getGradient () {
    return /** @type {Array<string>} */ (this.get(Property.GRADIENT));
  };

  /**
   * Return the size of the radius in pixels.
   * @return {number} Radius size in pixel.
   * @api
   * @observable
   */
  Heatmap.prototype.getRadius = function getRadius () {
    return /** @type {number} */ (this.get(Property.RADIUS));
  };

  /**
   * @private
   */
  Heatmap.prototype.handleGradientChanged_ = function handleGradientChanged_ () {
    this.gradient_ = createGradient(this.getGradient());
  };

  /**
   * @private
   */
  Heatmap.prototype.handleStyleChanged_ = function handleStyleChanged_ () {
    this.circleImage_ = this.createCircle_();
    this.styleCache_ = new Array(256);
    this.changed();
  };

  /**
   * @param {import("../render/Event.js").default} event Post compose event
   * @private
   */
  Heatmap.prototype.handleRender_ = function handleRender_ (event) {
    var context = event.context;
    var canvas = context.canvas;
    var image = context.getImageData(0, 0, canvas.width, canvas.height);
    var view8 = image.data;
    for (var i = 0, ii = view8.length; i < ii; i += 4) {
      var alpha = view8[i + 3] * 4;
      if (alpha) {
        view8[i] = this.gradient_[alpha];
        view8[i + 1] = this.gradient_[alpha + 1];
        view8[i + 2] = this.gradient_[alpha + 2];
      }
    }
    context.putImageData(image, 0, 0);
  };

  /**
   * Set the blur size in pixels.
   * @param {number} blur Blur size in pixels.
   * @api
   * @observable
   */
  Heatmap.prototype.setBlur = function setBlur (blur) {
    this.set(Property.BLUR, blur);
  };

  /**
   * Set the gradient colors as array of strings.
   * @param {Array<string>} colors Gradient.
   * @api
   * @observable
   */
  Heatmap.prototype.setGradient = function setGradient (colors) {
    this.set(Property.GRADIENT, colors);
  };

  /**
   * Set the size of the radius in pixels.
   * @param {number} radius Radius size in pixel.
   * @api
   * @observable
   */
  Heatmap.prototype.setRadius = function setRadius (radius) {
    this.set(Property.RADIUS, radius);
  };

  return Heatmap;
}(_Vector_js__WEBPACK_IMPORTED_MODULE_3__["default"]));


/**
 * @param {Array<string>} colors A list of colored.
 * @return {Uint8ClampedArray} An array.
 */
function createGradient(colors) {
  var width = 1;
  var height = 256;
  var context = Object(_dom_js__WEBPACK_IMPORTED_MODULE_2__["createCanvasContext2D"])(width, height);

  var gradient = context.createLinearGradient(0, 0, width, height);
  var step = 1 / (colors.length - 1);
  for (var i = 0, ii = colors.length; i < ii; ++i) {
    gradient.addColorStop(i * step, colors[i]);
  }

  context.fillStyle = gradient;
  context.fillRect(0, 0, width, height);

  return context.getImageData(0, 0, width, height).data;
}


/* harmony default export */ __webpack_exports__["default"] = (Heatmap);

//# sourceMappingURL=Heatmap.js.map

/***/ }),

/***/ "./node_modules/ol/layer/Image.js":
/*!****************************************!*\
  !*** ./node_modules/ol/layer/Image.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _LayerType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../LayerType.js */ "./node_modules/ol/LayerType.js");
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Layer.js */ "./node_modules/ol/layer/Layer.js");
/**
 * @module ol/layer/Image
 */




/**
 * @typedef {Object} Options
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link module:ol/Map#addLayer}.
 * @property {import("../source/Image.js").default} [source] Source for this layer.
 */


/**
 * @classdesc
 * Server-rendered images that are available for arbitrary extents and
 * resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @fires import("../render/Event.js").RenderEvent
 * @api
 */
var ImageLayer = /*@__PURE__*/(function (Layer) {
  function ImageLayer(opt_options) {
    var options = opt_options ? opt_options : {};
    Layer.call(this, options);

    /**
     * The layer type.
     * @protected
     * @type {import("../LayerType.js").default}
     */
    this.type = _LayerType_js__WEBPACK_IMPORTED_MODULE_0__["default"].IMAGE;

  }

  if ( Layer ) ImageLayer.__proto__ = Layer;
  ImageLayer.prototype = Object.create( Layer && Layer.prototype );
  ImageLayer.prototype.constructor = ImageLayer;

  return ImageLayer;
}(_Layer_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/**
 * Return the associated {@link module:ol/source/Image source} of the image layer.
 * @function
 * @return {import("../source/Image.js").default} Source.
 * @api
 */
ImageLayer.prototype.getSource;
/* harmony default export */ __webpack_exports__["default"] = (ImageLayer);

//# sourceMappingURL=Image.js.map

/***/ }),

/***/ "./node_modules/ol/layer/Layer.js":
/*!****************************************!*\
  !*** ./node_modules/ol/layer/Layer.js ***!
  \****************************************/
/*! exports provided: visibleAtResolution, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "visibleAtResolution", function() { return visibleAtResolution; });
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _Base_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Base.js */ "./node_modules/ol/layer/Base.js");
/* harmony import */ var _Property_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Property.js */ "./node_modules/ol/layer/Property.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _render_EventType_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../render/EventType.js */ "./node_modules/ol/render/EventType.js");
/* harmony import */ var _source_State_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../source/State.js */ "./node_modules/ol/source/State.js");
/**
 * @module ol/layer/Layer
 */











/**
 * @typedef {Object} Options
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {import("../source/Source.js").default} [source] Source for this layer.  If not provided to the constructor,
 * the source can be set by calling {@link module:ol/layer/Layer#setSource layer.setSource(source)} after
 * construction.
 * @property {import("../PluggableMap.js").default} [map] Map.
 */


/**
 * @typedef {Object} State
 * @property {import("./Base.js").default} layer
 * @property {number} opacity
 * @property {SourceState} sourceState
 * @property {boolean} visible
 * @property {boolean} managed
 * @property {import("../extent.js").Extent} [extent]
 * @property {number} zIndex
 * @property {number} maxResolution
 * @property {number} minResolution
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * A visual representation of raster or vector map data.
 * Layers group together those properties that pertain to how the data is to be
 * displayed, irrespective of the source of that data.
 *
 * Layers are usually added to a map with {@link module:ol/Map#addLayer}. Components
 * like {@link module:ol/interaction/Select~Select} use unmanaged layers
 * internally. These unmanaged layers are associated with the map using
 * {@link module:ol/layer/Layer~Layer#setMap} instead.
 *
 * A generic `change` event is fired when the state of the source changes.
 *
 * @fires import("../render/Event.js").RenderEvent
 */
var Layer = /*@__PURE__*/(function (BaseLayer) {
  function Layer(options) {

    var baseOptions = Object(_obj_js__WEBPACK_IMPORTED_MODULE_6__["assign"])({}, options);
    delete baseOptions.source;

    BaseLayer.call(this, baseOptions);

    /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */
    this.mapPrecomposeKey_ = null;

    /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */
    this.mapRenderKey_ = null;

    /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */
    this.sourceChangeKey_ = null;

    if (options.map) {
      this.setMap(options.map);
    }

    Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listen"])(this,
      Object(_Object_js__WEBPACK_IMPORTED_MODULE_3__["getChangeEventType"])(_Property_js__WEBPACK_IMPORTED_MODULE_5__["default"].SOURCE),
      this.handleSourcePropertyChange_, this);

    var source = options.source ? options.source : null;
    this.setSource(source);
  }

  if ( BaseLayer ) Layer.__proto__ = BaseLayer;
  Layer.prototype = Object.create( BaseLayer && BaseLayer.prototype );
  Layer.prototype.constructor = Layer;

  /**
   * @inheritDoc
   */
  Layer.prototype.getLayersArray = function getLayersArray (opt_array) {
    var array = opt_array ? opt_array : [];
    array.push(this);
    return array;
  };

  /**
   * @inheritDoc
   */
  Layer.prototype.getLayerStatesArray = function getLayerStatesArray (opt_states) {
    var states = opt_states ? opt_states : [];
    states.push(this.getLayerState());
    return states;
  };

  /**
   * Get the layer source.
   * @return {import("../source/Source.js").default} The layer source (or `null` if not yet set).
   * @observable
   * @api
   */
  Layer.prototype.getSource = function getSource () {
    var source = this.get(_Property_js__WEBPACK_IMPORTED_MODULE_5__["default"].SOURCE);
    return (
      /** @type {import("../source/Source.js").default} */ (source) || null
    );
  };

  /**
    * @inheritDoc
    */
  Layer.prototype.getSourceState = function getSourceState () {
    var source = this.getSource();
    return !source ? _source_State_js__WEBPACK_IMPORTED_MODULE_8__["default"].UNDEFINED : source.getState();
  };

  /**
   * @private
   */
  Layer.prototype.handleSourceChange_ = function handleSourceChange_ () {
    this.changed();
  };

  /**
   * @private
   */
  Layer.prototype.handleSourcePropertyChange_ = function handleSourcePropertyChange_ () {
    if (this.sourceChangeKey_) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["unlistenByKey"])(this.sourceChangeKey_);
      this.sourceChangeKey_ = null;
    }
    var source = this.getSource();
    if (source) {
      this.sourceChangeKey_ = Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listen"])(source,
        _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CHANGE, this.handleSourceChange_, this);
    }
    this.changed();
  };

  /**
   * Sets the layer to be rendered on top of other layers on a map. The map will
   * not manage this layer in its layers collection, and the callback in
   * {@link module:ol/Map#forEachLayerAtPixel} will receive `null` as layer. This
   * is useful for temporary layers. To remove an unmanaged layer from the map,
   * use `#setMap(null)`.
   *
   * To add the layer to a map and have it managed by the map, use
   * {@link module:ol/Map#addLayer} instead.
   * @param {import("../PluggableMap.js").default} map Map.
   * @api
   */
  Layer.prototype.setMap = function setMap (map) {
    if (this.mapPrecomposeKey_) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["unlistenByKey"])(this.mapPrecomposeKey_);
      this.mapPrecomposeKey_ = null;
    }
    if (!map) {
      this.changed();
    }
    if (this.mapRenderKey_) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["unlistenByKey"])(this.mapRenderKey_);
      this.mapRenderKey_ = null;
    }
    if (map) {
      this.mapPrecomposeKey_ = Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listen"])(map, _render_EventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].PRECOMPOSE, function(evt) {
        var renderEvent = /** @type {import("../render/Event.js").default} */ (evt);
        var layerState = this.getLayerState();
        layerState.managed = false;
        if (this.getZIndex() === undefined) {
          layerState.zIndex = Infinity;
        }
        renderEvent.frameState.layerStatesArray.push(layerState);
        renderEvent.frameState.layerStates[Object(_util_js__WEBPACK_IMPORTED_MODULE_2__["getUid"])(this)] = layerState;
      }, this);
      this.mapRenderKey_ = Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listen"])(this, _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CHANGE, map.render, map);
      this.changed();
    }
  };

  /**
   * Set the layer source.
   * @param {import("../source/Source.js").default} source The layer source.
   * @observable
   * @api
   */
  Layer.prototype.setSource = function setSource (source) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_5__["default"].SOURCE, source);
  };

  return Layer;
}(_Base_js__WEBPACK_IMPORTED_MODULE_4__["default"]));


/**
 * Return `true` if the layer is visible, and if the passed resolution is
 * between the layer's minResolution and maxResolution. The comparison is
 * inclusive for `minResolution` and exclusive for `maxResolution`.
 * @param {State} layerState Layer state.
 * @param {number} resolution Resolution.
 * @return {boolean} The layer is visible at the given resolution.
 */
function visibleAtResolution(layerState, resolution) {
  return layerState.visible && resolution >= layerState.minResolution &&
      resolution < layerState.maxResolution;
}


/* harmony default export */ __webpack_exports__["default"] = (Layer);

//# sourceMappingURL=Layer.js.map

/***/ }),

/***/ "./node_modules/ol/layer/Property.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/layer/Property.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/layer/Property
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  OPACITY: 'opacity',
  VISIBLE: 'visible',
  EXTENT: 'extent',
  Z_INDEX: 'zIndex',
  MAX_RESOLUTION: 'maxResolution',
  MIN_RESOLUTION: 'minResolution',
  SOURCE: 'source'
});

//# sourceMappingURL=Property.js.map

/***/ }),

/***/ "./node_modules/ol/layer/Tile.js":
/*!***************************************!*\
  !*** ./node_modules/ol/layer/Tile.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _LayerType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../LayerType.js */ "./node_modules/ol/LayerType.js");
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Layer.js */ "./node_modules/ol/layer/Layer.js");
/* harmony import */ var _TileProperty_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TileProperty.js */ "./node_modules/ol/layer/TileProperty.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/layer/Tile
 */






/**
 * @typedef {Object} Options
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`
 * means no preloading.
 * @property {import("../source/Tile.js").default} [source] Source for this layer.
 * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link module:ol/Map#addLayer}.
 * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.
 */

/**
 * @classdesc
 * For layer sources that provide pre-rendered, tiled images in grids that are
 * organized by zoom levels for specific resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @api
 */
var TileLayer = /*@__PURE__*/(function (Layer) {
  function TileLayer(opt_options) {
    var options = opt_options ? opt_options : {};

    var baseOptions = Object(_obj_js__WEBPACK_IMPORTED_MODULE_3__["assign"])({}, options);

    delete baseOptions.preload;
    delete baseOptions.useInterimTilesOnError;
    Layer.call(this, baseOptions);

    this.setPreload(options.preload !== undefined ? options.preload : 0);
    this.setUseInterimTilesOnError(options.useInterimTilesOnError !== undefined ?
      options.useInterimTilesOnError : true);

    /**
    * The layer type.
    * @protected
    * @type {import("../LayerType.js").default}
    */
    this.type = _LayerType_js__WEBPACK_IMPORTED_MODULE_0__["default"].TILE;

  }

  if ( Layer ) TileLayer.__proto__ = Layer;
  TileLayer.prototype = Object.create( Layer && Layer.prototype );
  TileLayer.prototype.constructor = TileLayer;

  /**
  * Return the level as number to which we will preload tiles up to.
  * @return {number} The level to preload tiles up to.
  * @observable
  * @api
  */
  TileLayer.prototype.getPreload = function getPreload () {
    return /** @type {number} */ (this.get(_TileProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].PRELOAD));
  };

  /**
  * Set the level as number to which we will preload tiles up to.
  * @param {number} preload The level to preload tiles up to.
  * @observable
  * @api
  */
  TileLayer.prototype.setPreload = function setPreload (preload) {
    this.set(_TileProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].PRELOAD, preload);
  };

  /**
  * Whether we use interim tiles on error.
  * @return {boolean} Use interim tiles on error.
  * @observable
  * @api
  */
  TileLayer.prototype.getUseInterimTilesOnError = function getUseInterimTilesOnError () {
    return /** @type {boolean} */ (this.get(_TileProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].USE_INTERIM_TILES_ON_ERROR));
  };

  /**
  * Set whether we use interim tiles on error.
  * @param {boolean} useInterimTilesOnError Use interim tiles on error.
  * @observable
  * @api
  */
  TileLayer.prototype.setUseInterimTilesOnError = function setUseInterimTilesOnError (useInterimTilesOnError) {
    this.set(_TileProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
  };

  return TileLayer;
}(_Layer_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/**
 * Return the associated {@link module:ol/source/Tile tilesource} of the layer.
 * @function
 * @return {import("../source/Tile.js").default} Source.
 * @api
 */
TileLayer.prototype.getSource;


/* harmony default export */ __webpack_exports__["default"] = (TileLayer);

//# sourceMappingURL=Tile.js.map

/***/ }),

/***/ "./node_modules/ol/layer/TileProperty.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/layer/TileProperty.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/layer/TileProperty
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  PRELOAD: 'preload',
  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError'
});

//# sourceMappingURL=TileProperty.js.map

/***/ }),

/***/ "./node_modules/ol/layer/Vector.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/layer/Vector.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _LayerType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../LayerType.js */ "./node_modules/ol/LayerType.js");
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Layer.js */ "./node_modules/ol/layer/Layer.js");
/* harmony import */ var _VectorRenderType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VectorRenderType.js */ "./node_modules/ol/layer/VectorRenderType.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _style_Style_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../style/Style.js */ "./node_modules/ol/style/Style.js");
/**
 * @module ol/layer/Vector
 */







/**
 * @typedef {Object} Options
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {import("../render.js").OrderFunction} [renderOrder] Render order. Function to be used when sorting
 * features before rendering. By default features are drawn in the order that they are created. Use
 * `null` to avoid the sort, but get an undefined draw order.
 * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the
 * renderer when getting features from the vector source for the rendering or hit-detection.
 * Recommended value: the size of the largest symbol, line width or label.
 * @property {import("./VectorRenderType.js").default|string} [renderMode='vector'] Render mode for vector layers:
 *  * `'image'`: Vector layers are rendered as images. Great performance, but point symbols and
 *    texts are always rotated with the view and pixels are scaled during zoom animations.
 *  * `'vector'`: Vector layers are rendered as vectors. Most accurate rendering even during
 *    animations, but slower performance.
 * @property {import("../source/Vector.js").default} [source] Source.
 * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link module:ol/Map#addLayer}.
 * @property {boolean} [declutter=false] Declutter images and text. Decluttering is applied to all
 * image and text styles, and the priority is defined by the z-index of the style. Lower z-index
 * means higher priority.
 * @property {import("../style/Style.js").StyleLike} [style] Layer style. See
 * {@link module:ol/style} for default style which will be used if this is not defined.
 * @property {boolean} [updateWhileAnimating=false] When set to `true` and `renderMode`
 * is `vector`, feature batches will be recreated during animations. This means that no
 * vectors will be shown clipped, but the setting will have a performance impact for large
 * amounts of vector data. When set to `false`, batches will be recreated when no animation
 * is active.
 * @property {boolean} [updateWhileInteracting=false] When set to `true` and `renderMode`
 * is `vector`, feature batches will be recreated during interactions. See also
 * `updateWhileAnimating`.
 */


/**
 * @enum {string}
 * @private
 */
var Property = {
  RENDER_ORDER: 'renderOrder'
};


/**
 * @classdesc
 * Vector data that is rendered client-side.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @api
 */
var VectorLayer = /*@__PURE__*/(function (Layer) {
  function VectorLayer(opt_options) {
    var options = opt_options ?
      opt_options : /** @type {Options} */ ({});

    var baseOptions = Object(_obj_js__WEBPACK_IMPORTED_MODULE_3__["assign"])({}, options);

    delete baseOptions.style;
    delete baseOptions.renderBuffer;
    delete baseOptions.updateWhileAnimating;
    delete baseOptions.updateWhileInteracting;
    Layer.call(this, baseOptions);

    /**
    * @private
    * @type {boolean}
    */
    this.declutter_ = options.declutter !== undefined ? options.declutter : false;

    /**
    * @type {number}
    * @private
    */
    this.renderBuffer_ = options.renderBuffer !== undefined ?
      options.renderBuffer : 100;

    /**
    * User provided style.
    * @type {import("../style/Style.js").StyleLike}
    * @private
    */
    this.style_ = null;

    /**
    * Style function for use within the library.
    * @type {import("../style/Style.js").StyleFunction|undefined}
    * @private
    */
    this.styleFunction_ = undefined;

    this.setStyle(options.style);

    /**
    * @type {boolean}
    * @private
    */
    this.updateWhileAnimating_ = options.updateWhileAnimating !== undefined ?
      options.updateWhileAnimating : false;

    /**
    * @type {boolean}
    * @private
    */
    this.updateWhileInteracting_ = options.updateWhileInteracting !== undefined ?
      options.updateWhileInteracting : false;

    /**
    * @private
    * @type {import("./VectorTileRenderType.js").default|string}
    */
    this.renderMode_ = options.renderMode || _VectorRenderType_js__WEBPACK_IMPORTED_MODULE_2__["default"].VECTOR;

    /**
    * The layer type.
    * @protected
    * @type {import("../LayerType.js").default}
    */
    this.type = _LayerType_js__WEBPACK_IMPORTED_MODULE_0__["default"].VECTOR;

  }

  if ( Layer ) VectorLayer.__proto__ = Layer;
  VectorLayer.prototype = Object.create( Layer && Layer.prototype );
  VectorLayer.prototype.constructor = VectorLayer;

  /**
  * @return {boolean} Declutter.
  */
  VectorLayer.prototype.getDeclutter = function getDeclutter () {
    return this.declutter_;
  };

  /**
  * @param {boolean} declutter Declutter.
  */
  VectorLayer.prototype.setDeclutter = function setDeclutter (declutter) {
    this.declutter_ = declutter;
  };

  /**
  * @return {number|undefined} Render buffer.
  */
  VectorLayer.prototype.getRenderBuffer = function getRenderBuffer () {
    return this.renderBuffer_;
  };

  /**
  * @return {function(import("../Feature.js").default, import("../Feature.js").default): number|null|undefined} Render
  *     order.
  */
  VectorLayer.prototype.getRenderOrder = function getRenderOrder () {
    return (
    /** @type {import("../render.js").OrderFunction|null|undefined} */ (this.get(Property.RENDER_ORDER))
    );
  };

  /**
  * Get the style for features.  This returns whatever was passed to the `style`
  * option at construction or to the `setStyle` method.
  * @return {import("../style/Style.js").StyleLike}
  *     Layer style.
  * @api
  */
  VectorLayer.prototype.getStyle = function getStyle () {
    return this.style_;
  };

  /**
  * Get the style function.
  * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
  * @api
  */
  VectorLayer.prototype.getStyleFunction = function getStyleFunction () {
    return this.styleFunction_;
  };

  /**
  * @return {boolean} Whether the rendered layer should be updated while
  *     animating.
  */
  VectorLayer.prototype.getUpdateWhileAnimating = function getUpdateWhileAnimating () {
    return this.updateWhileAnimating_;
  };

  /**
  * @return {boolean} Whether the rendered layer should be updated while
  *     interacting.
  */
  VectorLayer.prototype.getUpdateWhileInteracting = function getUpdateWhileInteracting () {
    return this.updateWhileInteracting_;
  };

  /**
  * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
  *     Render order.
  */
  VectorLayer.prototype.setRenderOrder = function setRenderOrder (renderOrder) {
    this.set(Property.RENDER_ORDER, renderOrder);
  };

  /**
  * Set the style for features.  This can be a single style object, an array
  * of styles, or a function that takes a feature and resolution and returns
  * an array of styles. If it is `undefined` the default style is used. If
  * it is `null` the layer has no style (a `null` style), so only features
  * that have their own styles will be rendered in the layer. See
  * {@link module:ol/style} for information on the default style.
  * @param {import("../style/Style.js").default|Array<import("../style/Style.js").default>|import("../style/Style.js").StyleFunction|null|undefined} style Layer style.
  * @api
  */
  VectorLayer.prototype.setStyle = function setStyle (style) {
    this.style_ = style !== undefined ? style : _style_Style_js__WEBPACK_IMPORTED_MODULE_4__["createDefaultStyle"];
    this.styleFunction_ = style === null ?
      undefined : Object(_style_Style_js__WEBPACK_IMPORTED_MODULE_4__["toFunction"])(this.style_);
    this.changed();
  };

  /**
  * @return {import("./VectorRenderType.js").default|string} The render mode.
  */
  VectorLayer.prototype.getRenderMode = function getRenderMode () {
    return this.renderMode_;
  };

  return VectorLayer;
}(_Layer_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/**
 * Return the associated {@link module:ol/source/Vector vectorsource} of the layer.
 * @function
 * @return {import("../source/Vector.js").default} Source.
 * @api
 */
VectorLayer.prototype.getSource;


/* harmony default export */ __webpack_exports__["default"] = (VectorLayer);

//# sourceMappingURL=Vector.js.map

/***/ }),

/***/ "./node_modules/ol/layer/VectorRenderType.js":
/*!***************************************************!*\
  !*** ./node_modules/ol/layer/VectorRenderType.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/layer/VectorRenderType
 */

/**
 * @enum {string}
 * Render mode for vector layers:
 *  * `'image'`: Vector layers are rendered as images. Great performance, but
 *    point symbols and texts are always rotated with the view and pixels are
 *    scaled during zoom animations.
 *  * `'vector'`: Vector layers are rendered as vectors. Most accurate rendering
 *    even during animations, but slower performance.
 * @api
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  IMAGE: 'image',
  VECTOR: 'vector'
});

//# sourceMappingURL=VectorRenderType.js.map

/***/ }),

/***/ "./node_modules/ol/layer/VectorTile.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/layer/VectorTile.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _LayerType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../LayerType.js */ "./node_modules/ol/LayerType.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _TileProperty_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TileProperty.js */ "./node_modules/ol/layer/TileProperty.js");
/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Vector.js */ "./node_modules/ol/layer/Vector.js");
/* harmony import */ var _VectorTileRenderType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./VectorTileRenderType.js */ "./node_modules/ol/layer/VectorTileRenderType.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/layer/VectorTile
 */








/**
 * @typedef {Object} Options
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {import("../render.js").OrderFunction} [renderOrder] Render order. Function to be used when sorting
 * features before rendering. By default features are drawn in the order that they are created. Use
 * `null` to avoid the sort, but get an undefined draw order.
 * @property {number} [renderBuffer=100] The buffer in pixels around the tile extent used by the
 * renderer when getting features from the vector tile for the rendering or hit-detection.
 * Recommended value: Vector tiles are usually generated with a buffer, so this value should match
 * the largest possible buffer of the used tiles. It should be at least the size of the largest
 * point symbol or line width.
 * @property {import("./VectorTileRenderType.js").default|string} [renderMode='hybrid'] Render mode for vector tiles:
 *  * `'image'`: Vector tiles are rendered as images. Great performance, but point symbols and texts
 *    are always rotated with the view and pixels are scaled during zoom animations.
 *  * `'hybrid'`: Polygon and line elements are rendered as images, so pixels are scaled during zoom
 *    animations. Point symbols and texts are accurately rendered as vectors and can stay upright on
 *    rotated views.
 *  * `'vector'`: Vector tiles are rendered as vectors. Most accurate rendering even during
 *    animations, but slower performance than the other options.
 *
 * When `declutter` is set to `true`, `'hybrid'` will be used instead of `'image'`.
 * @property {import("../source/VectorTile.js").default} [source] Source.
 * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link module:ol/Map#addLayer}.
 * @property {boolean} [declutter=false] Declutter images and text. Decluttering is applied to all
 * image and text styles, and the priority is defined by the z-index of the style. Lower z-index
 * means higher priority. When set to `true`, a `renderMode` of `'image'` will be overridden with
 * `'hybrid'`.
 * @property {import("../style/Style.js").StyleLike} [style] Layer style. See
 * {@link module:ol/style} for default style which will be used if this is not defined.
 * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will be
 * recreated during animations. This means that no vectors will be shown clipped, but the setting
 * will have a performance impact for large amounts of vector data. When set to `false`, batches
 * will be recreated when no animation is active.
 * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will be
 * recreated during interactions. See also `updateWhileAnimating`.
 * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`
 * means no preloading.
 * @property {import("../render.js").OrderFunction} [renderOrder] Render order. Function to be used when sorting
 * features before rendering. By default features are drawn in the order that they are created.
 * @property {import("../style/Style.js").StyleLike} [style] Layer style. See
 * {@link module:ol/style} for default style which will be used if this is not defined.
 * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.
 */


/**
 * @classdesc
 * Layer for vector tile data that is rendered client-side.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @param {Options=} opt_options Options.
 * @api
 */
var VectorTileLayer = /*@__PURE__*/(function (VectorLayer) {
  function VectorTileLayer(opt_options) {
    var options = opt_options ? opt_options : {};

    var renderMode = options.renderMode || _VectorTileRenderType_js__WEBPACK_IMPORTED_MODULE_4__["default"].HYBRID;
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_1__["assert"])(renderMode == undefined ||
       renderMode == _VectorTileRenderType_js__WEBPACK_IMPORTED_MODULE_4__["default"].IMAGE ||
       renderMode == _VectorTileRenderType_js__WEBPACK_IMPORTED_MODULE_4__["default"].HYBRID ||
       renderMode == _VectorTileRenderType_js__WEBPACK_IMPORTED_MODULE_4__["default"].VECTOR,
    28); // `renderMode` must be `'image'`, `'hybrid'` or `'vector'`
    if (options.declutter && renderMode == _VectorTileRenderType_js__WEBPACK_IMPORTED_MODULE_4__["default"].IMAGE) {
      renderMode = _VectorTileRenderType_js__WEBPACK_IMPORTED_MODULE_4__["default"].HYBRID;
    }
    options.renderMode = renderMode;

    var baseOptions = /** @type {Object} */ (Object(_obj_js__WEBPACK_IMPORTED_MODULE_5__["assign"])({}, options));
    delete baseOptions.preload;
    delete baseOptions.useInterimTilesOnError;

    VectorLayer.call(/** @type {import("./Vector.js").Options} */ this, (baseOptions));

    this.setPreload(options.preload ? options.preload : 0);
    this.setUseInterimTilesOnError(options.useInterimTilesOnError !== undefined ?
      options.useInterimTilesOnError : true);

    /**
    * The layer type.
    * @protected
    * @type {import("../LayerType.js").default}
    */
    this.type = _LayerType_js__WEBPACK_IMPORTED_MODULE_0__["default"].VECTOR_TILE;

  }

  if ( VectorLayer ) VectorTileLayer.__proto__ = VectorLayer;
  VectorTileLayer.prototype = Object.create( VectorLayer && VectorLayer.prototype );
  VectorTileLayer.prototype.constructor = VectorTileLayer;

  /**
  * Return the level as number to which we will preload tiles up to.
  * @return {number} The level to preload tiles up to.
  * @observable
  * @api
  */
  VectorTileLayer.prototype.getPreload = function getPreload () {
    return /** @type {number} */ (this.get(_TileProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].PRELOAD));
  };

  /**
  * Whether we use interim tiles on error.
  * @return {boolean} Use interim tiles on error.
  * @observable
  * @api
  */
  VectorTileLayer.prototype.getUseInterimTilesOnError = function getUseInterimTilesOnError () {
    return /** @type {boolean} */ (this.get(_TileProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].USE_INTERIM_TILES_ON_ERROR));
  };

  /**
  * Set the level as number to which we will preload tiles up to.
  * @param {number} preload The level to preload tiles up to.
  * @observable
  * @api
  */
  VectorTileLayer.prototype.setPreload = function setPreload (preload) {
    this.set(_TileProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].PRELOAD, preload);
  };

  /**
  * Set whether we use interim tiles on error.
  * @param {boolean} useInterimTilesOnError Use interim tiles on error.
  * @observable
  * @api
  */
  VectorTileLayer.prototype.setUseInterimTilesOnError = function setUseInterimTilesOnError (useInterimTilesOnError) {
    this.set(_TileProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
  };

  return VectorTileLayer;
}(_Vector_js__WEBPACK_IMPORTED_MODULE_3__["default"]));


/**
 * Return the associated {@link module:ol/source/VectorTile vectortilesource} of the layer.
 * @function
 * @return {import("../source/VectorTile.js").default} Source.
 * @api
 */
VectorTileLayer.prototype.getSource;
/* harmony default export */ __webpack_exports__["default"] = (VectorTileLayer);

//# sourceMappingURL=VectorTile.js.map

/***/ }),

/***/ "./node_modules/ol/layer/VectorTileRenderType.js":
/*!*******************************************************!*\
  !*** ./node_modules/ol/layer/VectorTileRenderType.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/layer/VectorTileRenderType
 */

/**
 * @enum {string}
 * Render mode for vector tiles:
 *  * `'image'`: Vector tiles are rendered as images. Great performance, but
 *    point symbols and texts are always rotated with the view and pixels are
 *    scaled during zoom animations.
 *  * `'hybrid'`: Polygon and line elements are rendered as images, so pixels
 *    are scaled during zoom animations. Point symbols and texts are accurately
 *    rendered as vectors and can stay upright on rotated views.
 *  * `'vector'`: Vector tiles are rendered as vectors. Most accurate rendering
 *    even during animations, but slower performance than the other options.
 * @api
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  IMAGE: 'image',
  HYBRID: 'hybrid',
  VECTOR: 'vector'
});

//# sourceMappingURL=VectorTileRenderType.js.map

/***/ }),

/***/ "./node_modules/ol/loadingstrategy.js":
/*!********************************************!*\
  !*** ./node_modules/ol/loadingstrategy.js ***!
  \********************************************/
/*! exports provided: all, bbox, tile */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "all", function() { return all; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bbox", function() { return bbox; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tile", function() { return tile; });
/**
 * @module ol/loadingstrategy
 */


/**
 * Strategy function for loading all features with a single request.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array<import("./extent.js").Extent>} Extents.
 * @api
 */
function all(extent, resolution) {
  return [[-Infinity, -Infinity, Infinity, Infinity]];
}


/**
 * Strategy function for loading features based on the view's extent and
 * resolution.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array<import("./extent.js").Extent>} Extents.
 * @api
 */
function bbox(extent, resolution) {
  return [extent];
}


/**
 * Creates a strategy function for loading features based on a tile grid.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {function(import("./extent.js").Extent, number): Array<import("./extent.js").Extent>} Loading strategy.
 * @api
 */
function tile(tileGrid) {
  return (
    /**
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @return {Array<import("./extent.js").Extent>} Extents.
     */
    function(extent, resolution) {
      var z = tileGrid.getZForResolution(resolution);
      var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
      /** @type {Array<import("./extent.js").Extent>} */
      var extents = [];
      /** @type {import("./tilecoord.js").TileCoord} */
      var tileCoord = [z, 0, 0];
      for (tileCoord[1] = tileRange.minX; tileCoord[1] <= tileRange.maxX; ++tileCoord[1]) {
        for (tileCoord[2] = tileRange.minY; tileCoord[2] <= tileRange.maxY; ++tileCoord[2]) {
          extents.push(tileGrid.getTileCoordExtent(tileCoord));
        }
      }
      return extents;
    }
  );
}

//# sourceMappingURL=loadingstrategy.js.map

/***/ }),

/***/ "./node_modules/ol/math.js":
/*!*********************************!*\
  !*** ./node_modules/ol/math.js ***!
  \*********************************/
/*! exports provided: clamp, cosh, roundUpToPowerOfTwo, squaredSegmentDistance, squaredDistance, solveLinearSystem, toDegrees, toRadians, modulo, lerp */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clamp", function() { return clamp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cosh", function() { return cosh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "roundUpToPowerOfTwo", function() { return roundUpToPowerOfTwo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredSegmentDistance", function() { return squaredSegmentDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "solveLinearSystem", function() { return solveLinearSystem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toDegrees", function() { return toDegrees; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toRadians", function() { return toRadians; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "modulo", function() { return modulo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/**
 * @module ol/math
 */


/**
 * Takes a number and clamps it to within the provided bounds.
 * @param {number} value The input number.
 * @param {number} min The minimum value to return.
 * @param {number} max The maximum value to return.
 * @return {number} The input number if it is within bounds, or the nearest
 *     number within the bounds.
 */
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}


/**
 * Return the hyperbolic cosine of a given number. The method will use the
 * native `Math.cosh` function if it is available, otherwise the hyperbolic
 * cosine will be calculated via the reference implementation of the Mozilla
 * developer network.
 *
 * @param {number} x X.
 * @return {number} Hyperbolic cosine of x.
 */
var cosh = (function() {
  // Wrapped in a iife, to save the overhead of checking for the native
  // implementation on every invocation.
  var cosh;
  if ('cosh' in Math) {
    // The environment supports the native Math.cosh function, use it…
    cosh = Math.cosh;
  } else {
    // … else, use the reference implementation of MDN:
    cosh = function(x) {
      var y = /** @type {Math} */ (Math).exp(x);
      return (y + 1 / y) / 2;
    };
  }
  return cosh;
}());


/**
 * @param {number} x X.
 * @return {number} The smallest power of two greater than or equal to x.
 */
function roundUpToPowerOfTwo(x) {
  Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(0 < x, 29); // `x` must be greater than `0`
  return Math.pow(2, Math.ceil(Math.log(x) / Math.LN2));
}


/**
 * Returns the square of the closest distance between the point (x, y) and the
 * line segment (x1, y1) to (x2, y2).
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */
function squaredSegmentDistance(x, y, x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  if (dx !== 0 || dy !== 0) {
    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      x1 = x2;
      y1 = y2;
    } else if (t > 0) {
      x1 += dx * t;
      y1 += dy * t;
    }
  }
  return squaredDistance(x, y, x1, y1);
}


/**
 * Returns the square of the distance between the points (x1, y1) and (x2, y2).
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */
function squaredDistance(x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  return dx * dx + dy * dy;
}


/**
 * Solves system of linear equations using Gaussian elimination method.
 *
 * @param {Array<Array<number>>} mat Augmented matrix (n x n + 1 column)
 *                                     in row-major order.
 * @return {Array<number>} The resulting vector.
 */
function solveLinearSystem(mat) {
  var n = mat.length;

  for (var i = 0; i < n; i++) {
    // Find max in the i-th column (ignoring i - 1 first rows)
    var maxRow = i;
    var maxEl = Math.abs(mat[i][i]);
    for (var r = i + 1; r < n; r++) {
      var absValue = Math.abs(mat[r][i]);
      if (absValue > maxEl) {
        maxEl = absValue;
        maxRow = r;
      }
    }

    if (maxEl === 0) {
      return null; // matrix is singular
    }

    // Swap max row with i-th (current) row
    var tmp = mat[maxRow];
    mat[maxRow] = mat[i];
    mat[i] = tmp;

    // Subtract the i-th row to make all the remaining rows 0 in the i-th column
    for (var j = i + 1; j < n; j++) {
      var coef = -mat[j][i] / mat[i][i];
      for (var k = i; k < n + 1; k++) {
        if (i == k) {
          mat[j][k] = 0;
        } else {
          mat[j][k] += coef * mat[i][k];
        }
      }
    }
  }

  // Solve Ax=b for upper triangular matrix A (mat)
  var x = new Array(n);
  for (var l = n - 1; l >= 0; l--) {
    x[l] = mat[l][n] / mat[l][l];
    for (var m = l - 1; m >= 0; m--) {
      mat[m][n] -= mat[m][l] * x[l];
    }
  }
  return x;
}


/**
 * Converts radians to to degrees.
 *
 * @param {number} angleInRadians Angle in radians.
 * @return {number} Angle in degrees.
 */
function toDegrees(angleInRadians) {
  return angleInRadians * 180 / Math.PI;
}


/**
 * Converts degrees to radians.
 *
 * @param {number} angleInDegrees Angle in degrees.
 * @return {number} Angle in radians.
 */
function toRadians(angleInDegrees) {
  return angleInDegrees * Math.PI / 180;
}

/**
 * Returns the modulo of a / b, depending on the sign of b.
 *
 * @param {number} a Dividend.
 * @param {number} b Divisor.
 * @return {number} Modulo.
 */
function modulo(a, b) {
  var r = a % b;
  return r * b < 0 ? r + b : r;
}

/**
 * Calculates the linearly interpolated value of x between a and b.
 *
 * @param {number} a Number
 * @param {number} b Number
 * @param {number} x Value to be interpolated.
 * @return {number} Interpolated value.
 */
function lerp(a, b, x) {
  return a + x * (b - a);
}

//# sourceMappingURL=math.js.map

/***/ }),

/***/ "./node_modules/ol/net.js":
/*!********************************!*\
  !*** ./node_modules/ol/net.js ***!
  \********************************/
/*! exports provided: jsonp */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "jsonp", function() { return jsonp; });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ "./node_modules/ol/util.js");
/**
 * @module ol/net
 */



/**
 * Simple JSONP helper. Supports error callbacks and a custom callback param.
 * The error callback will be called when no JSONP is executed after 10 seconds.
 *
 * @param {string} url Request url. A 'callback' query parameter will be
 *     appended.
 * @param {Function} callback Callback on success.
 * @param {function()=} opt_errback Callback on error.
 * @param {string=} opt_callbackParam Custom query parameter for the JSONP
 *     callback. Default is 'callback'.
 */
function jsonp(url, callback, opt_errback, opt_callbackParam) {
  var script = document.createElement('script');
  var key = 'olc_' + Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(callback);
  function cleanup() {
    delete window[key];
    script.parentNode.removeChild(script);
  }
  script.async = true;
  script.src = url + (url.indexOf('?') == -1 ? '?' : '&') +
      (opt_callbackParam || 'callback') + '=' + key;
  var timer = setTimeout(function() {
    cleanup();
    if (opt_errback) {
      opt_errback();
    }
  }, 10000);
  window[key] = function(data) {
    clearTimeout(timer);
    cleanup();
    callback(data);
  };
  document.getElementsByTagName('head')[0].appendChild(script);
}

//# sourceMappingURL=net.js.map

/***/ }),

/***/ "./node_modules/ol/node_modules/rbush/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/ol/node_modules/rbush/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = rbush;
module.exports.default = rbush;

var quickselect = __webpack_require__(/*! quickselect */ "./node_modules/quickselect/quickselect.js");

function rbush(maxEntries, format) {
    if (!(this instanceof rbush)) return new rbush(maxEntries, format);

    // max entries in a node is 9 by default; min node fill is 40% for best performance
    this._maxEntries = Math.max(4, maxEntries || 9);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

    if (format) {
        this._initFormat(format);
    }

    this.clear();
}

rbush.prototype = {

    all: function () {
        return this._all(this.data, []);
    },

    search: function (bbox) {

        var node = this.data,
            result = [],
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) return result;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf) result.push(child);
                    else if (contains(bbox, childBBox)) this._all(child, result);
                    else nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return result;
    },

    collides: function (bbox) {

        var node = this.data,
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) return false;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf || contains(bbox, childBBox)) return true;
                    nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return false;
    },

    load: function (data) {
        if (!(data && data.length)) return this;

        if (data.length < this._minEntries) {
            for (var i = 0, len = data.length; i < len; i++) {
                this.insert(data[i]);
            }
            return this;
        }

        // recursively build the tree with the given data from scratch using OMT algorithm
        var node = this._build(data.slice(), 0, data.length - 1, 0);

        if (!this.data.children.length) {
            // save as is if tree is empty
            this.data = node;

        } else if (this.data.height === node.height) {
            // split root if trees have the same height
            this._splitRoot(this.data, node);

        } else {
            if (this.data.height < node.height) {
                // swap trees if inserted one is bigger
                var tmpNode = this.data;
                this.data = node;
                node = tmpNode;
            }

            // insert the small tree into the large tree at appropriate level
            this._insert(node, this.data.height - node.height - 1, true);
        }

        return this;
    },

    insert: function (item) {
        if (item) this._insert(item, this.data.height - 1);
        return this;
    },

    clear: function () {
        this.data = createNode([]);
        return this;
    },

    remove: function (item, equalsFn) {
        if (!item) return this;

        var node = this.data,
            bbox = this.toBBox(item),
            path = [],
            indexes = [],
            i, parent, index, goingUp;

        // depth-first iterative tree traversal
        while (node || path.length) {

            if (!node) { // go up
                node = path.pop();
                parent = path[path.length - 1];
                i = indexes.pop();
                goingUp = true;
            }

            if (node.leaf) { // check current node
                index = findItem(item, node.children, equalsFn);

                if (index !== -1) {
                    // item found, remove the item and condense tree upwards
                    node.children.splice(index, 1);
                    path.push(node);
                    this._condense(path);
                    return this;
                }
            }

            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down
                path.push(node);
                indexes.push(i);
                i = 0;
                parent = node;
                node = node.children[0];

            } else if (parent) { // go right
                i++;
                node = parent.children[i];
                goingUp = false;

            } else node = null; // nothing found
        }

        return this;
    },

    toBBox: function (item) { return item; },

    compareMinX: compareNodeMinX,
    compareMinY: compareNodeMinY,

    toJSON: function () { return this.data; },

    fromJSON: function (data) {
        this.data = data;
        return this;
    },

    _all: function (node, result) {
        var nodesToSearch = [];
        while (node) {
            if (node.leaf) result.push.apply(result, node.children);
            else nodesToSearch.push.apply(nodesToSearch, node.children);

            node = nodesToSearch.pop();
        }
        return result;
    },

    _build: function (items, left, right, height) {

        var N = right - left + 1,
            M = this._maxEntries,
            node;

        if (N <= M) {
            // reached leaf level; return leaf
            node = createNode(items.slice(left, right + 1));
            calcBBox(node, this.toBBox);
            return node;
        }

        if (!height) {
            // target height of the bulk-loaded tree
            height = Math.ceil(Math.log(N) / Math.log(M));

            // target number of root entries to maximize storage utilization
            M = Math.ceil(N / Math.pow(M, height - 1));
        }

        node = createNode([]);
        node.leaf = false;
        node.height = height;

        // split the items into M mostly square tiles

        var N2 = Math.ceil(N / M),
            N1 = N2 * Math.ceil(Math.sqrt(M)),
            i, j, right2, right3;

        multiSelect(items, left, right, N1, this.compareMinX);

        for (i = left; i <= right; i += N1) {

            right2 = Math.min(i + N1 - 1, right);

            multiSelect(items, i, right2, N2, this.compareMinY);

            for (j = i; j <= right2; j += N2) {

                right3 = Math.min(j + N2 - 1, right2);

                // pack each entry recursively
                node.children.push(this._build(items, j, right3, height - 1));
            }
        }

        calcBBox(node, this.toBBox);

        return node;
    },

    _chooseSubtree: function (bbox, node, level, path) {

        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

        while (true) {
            path.push(node);

            if (node.leaf || path.length - 1 === level) break;

            minArea = minEnlargement = Infinity;

            for (i = 0, len = node.children.length; i < len; i++) {
                child = node.children[i];
                area = bboxArea(child);
                enlargement = enlargedArea(bbox, child) - area;

                // choose entry with the least area enlargement
                if (enlargement < minEnlargement) {
                    minEnlargement = enlargement;
                    minArea = area < minArea ? area : minArea;
                    targetNode = child;

                } else if (enlargement === minEnlargement) {
                    // otherwise choose one with the smallest area
                    if (area < minArea) {
                        minArea = area;
                        targetNode = child;
                    }
                }
            }

            node = targetNode || node.children[0];
        }

        return node;
    },

    _insert: function (item, level, isNode) {

        var toBBox = this.toBBox,
            bbox = isNode ? item : toBBox(item),
            insertPath = [];

        // find the best node for accommodating the item, saving all nodes along the path too
        var node = this._chooseSubtree(bbox, this.data, level, insertPath);

        // put the item into the node
        node.children.push(item);
        extend(node, bbox);

        // split on node overflow; propagate upwards if necessary
        while (level >= 0) {
            if (insertPath[level].children.length > this._maxEntries) {
                this._split(insertPath, level);
                level--;
            } else break;
        }

        // adjust bboxes along the insertion path
        this._adjustParentBBoxes(bbox, insertPath, level);
    },

    // split overflowed node into two
    _split: function (insertPath, level) {

        var node = insertPath[level],
            M = node.children.length,
            m = this._minEntries;

        this._chooseSplitAxis(node, m, M);

        var splitIndex = this._chooseSplitIndex(node, m, M);

        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;

        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);

        if (level) insertPath[level - 1].children.push(newNode);
        else this._splitRoot(node, newNode);
    },

    _splitRoot: function (node, newNode) {
        // split root node
        this.data = createNode([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
    },

    _chooseSplitIndex: function (node, m, M) {

        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

        minOverlap = minArea = Infinity;

        for (i = m; i <= M - m; i++) {
            bbox1 = distBBox(node, 0, i, this.toBBox);
            bbox2 = distBBox(node, i, M, this.toBBox);

            overlap = intersectionArea(bbox1, bbox2);
            area = bboxArea(bbox1) + bboxArea(bbox2);

            // choose distribution with minimum overlap
            if (overlap < minOverlap) {
                minOverlap = overlap;
                index = i;

                minArea = area < minArea ? area : minArea;

            } else if (overlap === minOverlap) {
                // otherwise choose distribution with minimum area
                if (area < minArea) {
                    minArea = area;
                    index = i;
                }
            }
        }

        return index;
    },

    // sorts node children by the best axis for split
    _chooseSplitAxis: function (node, m, M) {

        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
            xMargin = this._allDistMargin(node, m, M, compareMinX),
            yMargin = this._allDistMargin(node, m, M, compareMinY);

        // if total distributions margin value is minimal for x, sort by minX,
        // otherwise it's already sorted by minY
        if (xMargin < yMargin) node.children.sort(compareMinX);
    },

    // total margin of all possible split distributions where each node is at least m full
    _allDistMargin: function (node, m, M, compare) {

        node.children.sort(compare);

        var toBBox = this.toBBox,
            leftBBox = distBBox(node, 0, m, toBBox),
            rightBBox = distBBox(node, M - m, M, toBBox),
            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
            i, child;

        for (i = m; i < M - m; i++) {
            child = node.children[i];
            extend(leftBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(leftBBox);
        }

        for (i = M - m - 1; i >= m; i--) {
            child = node.children[i];
            extend(rightBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(rightBBox);
        }

        return margin;
    },

    _adjustParentBBoxes: function (bbox, path, level) {
        // adjust bboxes along the given tree path
        for (var i = level; i >= 0; i--) {
            extend(path[i], bbox);
        }
    },

    _condense: function (path) {
        // go through the path, removing empty nodes and updating bboxes
        for (var i = path.length - 1, siblings; i >= 0; i--) {
            if (path[i].children.length === 0) {
                if (i > 0) {
                    siblings = path[i - 1].children;
                    siblings.splice(siblings.indexOf(path[i]), 1);

                } else this.clear();

            } else calcBBox(path[i], this.toBBox);
        }
    },

    _initFormat: function (format) {
        // data format (minX, minY, maxX, maxY accessors)

        // uses eval-type function compilation instead of just accepting a toBBox function
        // because the algorithms are very sensitive to sorting functions performance,
        // so they should be dead simple and without inner calls

        var compareArr = ['return a', ' - b', ';'];

        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));

        this.toBBox = new Function('a',
            'return {minX: a' + format[0] +
            ', minY: a' + format[1] +
            ', maxX: a' + format[2] +
            ', maxY: a' + format[3] + '};');
    }
};

function findItem(item, items, equalsFn) {
    if (!equalsFn) return items.indexOf(item);

    for (var i = 0; i < items.length; i++) {
        if (equalsFn(item, items[i])) return i;
    }
    return -1;
}

// calculate node's bbox from bboxes of its children
function calcBBox(node, toBBox) {
    distBBox(node, 0, node.children.length, toBBox, node);
}

// min bounding rectangle of node children from k to p-1
function distBBox(node, k, p, toBBox, destNode) {
    if (!destNode) destNode = createNode(null);
    destNode.minX = Infinity;
    destNode.minY = Infinity;
    destNode.maxX = -Infinity;
    destNode.maxY = -Infinity;

    for (var i = k, child; i < p; i++) {
        child = node.children[i];
        extend(destNode, node.leaf ? toBBox(child) : child);
    }

    return destNode;
}

function extend(a, b) {
    a.minX = Math.min(a.minX, b.minX);
    a.minY = Math.min(a.minY, b.minY);
    a.maxX = Math.max(a.maxX, b.maxX);
    a.maxY = Math.max(a.maxY, b.maxY);
    return a;
}

function compareNodeMinX(a, b) { return a.minX - b.minX; }
function compareNodeMinY(a, b) { return a.minY - b.minY; }

function bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }
function bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }

function enlargedArea(a, b) {
    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}

function intersectionArea(a, b) {
    var minX = Math.max(a.minX, b.minX),
        minY = Math.max(a.minY, b.minY),
        maxX = Math.min(a.maxX, b.maxX),
        maxY = Math.min(a.maxY, b.maxY);

    return Math.max(0, maxX - minX) *
           Math.max(0, maxY - minY);
}

function contains(a, b) {
    return a.minX <= b.minX &&
           a.minY <= b.minY &&
           b.maxX <= a.maxX &&
           b.maxY <= a.maxY;
}

function intersects(a, b) {
    return b.minX <= a.maxX &&
           b.minY <= a.maxY &&
           b.maxX >= a.minX &&
           b.maxY >= a.minY;
}

function createNode(children) {
    return {
        children: children,
        height: 1,
        leaf: true,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
    };
}

// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide & conquer approach

function multiSelect(arr, left, right, n, compare) {
    var stack = [left, right],
        mid;

    while (stack.length) {
        right = stack.pop();
        left = stack.pop();

        if (right - left <= n) continue;

        mid = left + Math.ceil((right - left) / n / 2) * n;
        quickselect(arr, mid, left, right, compare);

        stack.push(left, mid, mid, right);
    }
}


/***/ }),

/***/ "./node_modules/ol/obj.js":
/*!********************************!*\
  !*** ./node_modules/ol/obj.js ***!
  \********************************/
/*! exports provided: assign, clear, getValues, isEmpty */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assign", function() { return assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clear", function() { return clear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getValues", function() { return getValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEmpty", function() { return isEmpty; });
/**
 * @module ol/obj
 */


/**
 * Polyfill for Object.assign().  Assigns enumerable and own properties from
 * one or more source objects to a target object.
 * See https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign.
 *
 * @param {!Object} target The target object.
 * @param {...Object} var_sources The source object(s).
 * @return {!Object} The modified target object.
 */
var assign = (typeof Object.assign === 'function') ? Object.assign : function(target, var_sources) {
  var arguments$1 = arguments;

  if (target === undefined || target === null) {
    throw new TypeError('Cannot convert undefined or null to object');
  }

  var output = Object(target);
  for (var i = 1, ii = arguments.length; i < ii; ++i) {
    var source = arguments$1[i];
    if (source !== undefined && source !== null) {
      for (var key in source) {
        if (source.hasOwnProperty(key)) {
          output[key] = source[key];
        }
      }
    }
  }
  return output;
};


/**
 * Removes all properties from an object.
 * @param {Object} object The object to clear.
 */
function clear(object) {
  for (var property in object) {
    delete object[property];
  }
}


/**
 * Get an array of property values from an object.
 * @param {Object<K,V>} object The object from which to get the values.
 * @return {!Array<V>} The property values.
 * @template K,V
 */
function getValues(object) {
  var values = [];
  for (var property in object) {
    values.push(object[property]);
  }
  return values;
}


/**
 * Determine if an object has any properties.
 * @param {Object} object The object to check.
 * @return {boolean} The object is empty.
 */
function isEmpty(object) {
  var property;
  for (property in object) {
    return false;
  }
  return !property;
}

//# sourceMappingURL=obj.js.map

/***/ }),

/***/ "./node_modules/ol/proj.js":
/*!*********************************!*\
  !*** ./node_modules/ol/proj.js ***!
  \*********************************/
/*! exports provided: METERS_PER_UNIT, Projection, cloneTransform, identityTransform, addProjection, addProjections, get, getPointResolution, addEquivalentProjections, addEquivalentTransforms, clearAllProjections, createProjection, createTransformFromCoordinateTransform, addCoordinateTransforms, fromLonLat, toLonLat, equivalent, getTransformFromProjections, getTransform, transform, transformExtent, transformWithProjections, addCommon */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cloneTransform", function() { return cloneTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identityTransform", function() { return identityTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addProjection", function() { return addProjection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addProjections", function() { return addProjections; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPointResolution", function() { return getPointResolution; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addEquivalentProjections", function() { return addEquivalentProjections; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addEquivalentTransforms", function() { return addEquivalentTransforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clearAllProjections", function() { return clearAllProjections; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createProjection", function() { return createProjection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createTransformFromCoordinateTransform", function() { return createTransformFromCoordinateTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addCoordinateTransforms", function() { return addCoordinateTransforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromLonLat", function() { return fromLonLat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toLonLat", function() { return toLonLat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equivalent", function() { return equivalent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTransformFromProjections", function() { return getTransformFromProjections; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTransform", function() { return getTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transform", function() { return transform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformExtent", function() { return transformExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformWithProjections", function() { return transformWithProjections; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addCommon", function() { return addCommon; });
/* harmony import */ var _sphere_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sphere.js */ "./node_modules/ol/sphere.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./proj/epsg3857.js */ "./node_modules/ol/proj/epsg3857.js");
/* harmony import */ var _proj_epsg4326_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./proj/epsg4326.js */ "./node_modules/ol/proj/epsg4326.js");
/* harmony import */ var _proj_Projection_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./proj/Projection.js */ "./node_modules/ol/proj/Projection.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Projection", function() { return _proj_Projection_js__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _proj_Units_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./proj/Units.js */ "./node_modules/ol/proj/Units.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "METERS_PER_UNIT", function() { return _proj_Units_js__WEBPACK_IMPORTED_MODULE_6__["METERS_PER_UNIT"]; });

/* harmony import */ var _proj_projections_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./proj/projections.js */ "./node_modules/ol/proj/projections.js");
/* harmony import */ var _proj_transforms_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./proj/transforms.js */ "./node_modules/ol/proj/transforms.js");
/**
 * @module ol/proj
 */

/**
 * The ol/proj module stores:
 * * a list of {@link module:ol/proj/Projection}
 * objects, one for each projection supported by the application
 * * a list of transform functions needed to convert coordinates in one projection
 * into another.
 *
 * The static functions are the methods used to maintain these.
 * Each transform function can handle not only simple coordinate pairs, but also
 * large arrays of coordinates such as vector geometries.
 *
 * When loaded, the library adds projection objects for EPSG:4326 (WGS84
 * geographic coordinates) and EPSG:3857 (Web or Spherical Mercator, as used
 * for example by Bing Maps or OpenStreetMap), together with the relevant
 * transform functions.
 *
 * Additional transforms may be added by using the http://proj4js.org/
 * library (version 2.2 or later). You can use the full build supplied by
 * Proj4js, or create a custom build to support those projections you need; see
 * the Proj4js website for how to do this. You also need the Proj4js definitions
 * for the required projections. These definitions can be obtained from
 * https://epsg.io/, and are a JS function, so can be loaded in a script
 * tag (as in the examples) or pasted into your application.
 *
 * After all required projection definitions are added to proj4's registry (by
 * using `proj4.defs()`), simply call `register(proj4)` from the `ol/proj/proj4`
 * package. Existing transforms are not changed by this function. See
 * examples/wms-image-custom-proj for an example of this.
 *
 * Additional projection definitions can be registered with `proj4.defs()` any
 * time. Just make sure to call `register(proj4)` again; for example, with user-supplied data where you don't
 * know in advance what projections are needed, you can initially load minimal
 * support and then load whichever are requested.
 *
 * Note that Proj4js does not support projection extents. If you want to add
 * one for creating default tile grids, you can add it after the Projection
 * object has been created with `setExtent`, for example,
 * `get('EPSG:1234').setExtent(extent)`.
 *
 * In addition to Proj4js support, any transform functions can be added with
 * {@link module:ol/proj~addCoordinateTransforms}. To use this, you must first create
 * a {@link module:ol/proj/Projection} object for the new projection and add it with
 * {@link module:ol/proj~addProjection}. You can then add the forward and inverse
 * functions with {@link module:ol/proj~addCoordinateTransforms}. See
 * examples/wms-custom-proj for an example of this.
 *
 * Note that if no transforms are needed and you only need to define the
 * projection, just add a {@link module:ol/proj/Projection} with
 * {@link module:ol/proj~addProjection}. See examples/wms-no-proj for an example of
 * this.
 */











/**
 * A projection as {@link module:ol/proj/Projection}, SRS identifier
 * string or undefined.
 * @typedef {Projection|string|undefined} ProjectionLike
 * @api
 */


/**
 * A transform function accepts an array of input coordinate values, an optional
 * output array, and an optional dimension (default should be 2).  The function
 * transforms the input coordinate values, populates the output array, and
 * returns the output array.
 *
 * @typedef {function(Array<number>, Array<number>=, number=): Array<number>} TransformFunction
 * @api
 */






/**
 * @param {Array<number>} input Input coordinate array.
 * @param {Array<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension.
 * @return {Array<number>} Output coordinate array (new array, same coordinate
 *     values).
 */
function cloneTransform(input, opt_output, opt_dimension) {
  var output;
  if (opt_output !== undefined) {
    for (var i = 0, ii = input.length; i < ii; ++i) {
      opt_output[i] = input[i];
    }
    output = opt_output;
  } else {
    output = input.slice();
  }
  return output;
}


/**
 * @param {Array<number>} input Input coordinate array.
 * @param {Array<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension.
 * @return {Array<number>} Input coordinate array (same array as input).
 */
function identityTransform(input, opt_output, opt_dimension) {
  if (opt_output !== undefined && input !== opt_output) {
    for (var i = 0, ii = input.length; i < ii; ++i) {
      opt_output[i] = input[i];
    }
    input = opt_output;
  }
  return input;
}


/**
 * Add a Projection object to the list of supported projections that can be
 * looked up by their code.
 *
 * @param {Projection} projection Projection instance.
 * @api
 */
function addProjection(projection) {
  _proj_projections_js__WEBPACK_IMPORTED_MODULE_7__["add"](projection.getCode(), projection);
  Object(_proj_transforms_js__WEBPACK_IMPORTED_MODULE_8__["add"])(projection, projection, cloneTransform);
}


/**
 * @param {Array<Projection>} projections Projections.
 */
function addProjections(projections) {
  projections.forEach(addProjection);
}


/**
 * Fetches a Projection object for the code specified.
 *
 * @param {ProjectionLike} projectionLike Either a code string which is
 *     a combination of authority and identifier such as "EPSG:4326", or an
 *     existing projection object, or undefined.
 * @return {Projection} Projection object, or null if not in list.
 * @api
 */
function get(projectionLike) {
  return typeof projectionLike === 'string' ?
    _proj_projections_js__WEBPACK_IMPORTED_MODULE_7__["get"](/** @type {string} */ (projectionLike)) :
    (/** @type {Projection} */ (projectionLike) || null);
}


/**
 * Get the resolution of the point in degrees or distance units.
 * For projections with degrees as the unit this will simply return the
 * provided resolution. For other projections the point resolution is
 * by default estimated by transforming the 'point' pixel to EPSG:4326,
 * measuring its width and height on the normal sphere,
 * and taking the average of the width and height.
 * A custom function can be provided for a specific projection, either
 * by setting the `getPointResolution` option in the
 * {@link module:ol/proj/Projection~Projection} constructor or by using
 * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing
 * projection object.
 * @param {ProjectionLike} projection The projection.
 * @param {number} resolution Nominal resolution in projection units.
 * @param {import("./coordinate.js").Coordinate} point Point to find adjusted resolution at.
 * @param {Units=} opt_units Units to get the point resolution in.
 * Default is the projection's units.
 * @return {number} Point resolution.
 * @api
 */
function getPointResolution(projection, resolution, point, opt_units) {
  projection = get(projection);
  var pointResolution;
  var getter = projection.getPointResolutionFunc();
  if (getter) {
    pointResolution = getter(resolution, point);
  } else {
    var units = projection.getUnits();
    if (units == _proj_Units_js__WEBPACK_IMPORTED_MODULE_6__["default"].DEGREES && !opt_units || opt_units == _proj_Units_js__WEBPACK_IMPORTED_MODULE_6__["default"].DEGREES) {
      pointResolution = resolution;
    } else {
      // Estimate point resolution by transforming the center pixel to EPSG:4326,
      // measuring its width and height on the normal sphere, and taking the
      // average of the width and height.
      var toEPSG4326 = getTransformFromProjections(projection, get('EPSG:4326'));
      var vertices = [
        point[0] - resolution / 2, point[1],
        point[0] + resolution / 2, point[1],
        point[0], point[1] - resolution / 2,
        point[0], point[1] + resolution / 2
      ];
      vertices = toEPSG4326(vertices, vertices, 2);
      var width = Object(_sphere_js__WEBPACK_IMPORTED_MODULE_0__["getDistance"])(vertices.slice(0, 2), vertices.slice(2, 4));
      var height = Object(_sphere_js__WEBPACK_IMPORTED_MODULE_0__["getDistance"])(vertices.slice(4, 6), vertices.slice(6, 8));
      pointResolution = (width + height) / 2;
      var metersPerUnit = opt_units ?
        _proj_Units_js__WEBPACK_IMPORTED_MODULE_6__["METERS_PER_UNIT"][opt_units] :
        projection.getMetersPerUnit();
      if (metersPerUnit !== undefined) {
        pointResolution /= metersPerUnit;
      }
    }
  }
  return pointResolution;
}


/**
 * Registers transformation functions that don't alter coordinates. Those allow
 * to transform between projections with equal meaning.
 *
 * @param {Array<Projection>} projections Projections.
 * @api
 */
function addEquivalentProjections(projections) {
  addProjections(projections);
  projections.forEach(function(source) {
    projections.forEach(function(destination) {
      if (source !== destination) {
        Object(_proj_transforms_js__WEBPACK_IMPORTED_MODULE_8__["add"])(source, destination, cloneTransform);
      }
    });
  });
}


/**
 * Registers transformation functions to convert coordinates in any projection
 * in projection1 to any projection in projection2.
 *
 * @param {Array<Projection>} projections1 Projections with equal
 *     meaning.
 * @param {Array<Projection>} projections2 Projections with equal
 *     meaning.
 * @param {TransformFunction} forwardTransform Transformation from any
 *   projection in projection1 to any projection in projection2.
 * @param {TransformFunction} inverseTransform Transform from any projection
 *   in projection2 to any projection in projection1..
 */
function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
  projections1.forEach(function(projection1) {
    projections2.forEach(function(projection2) {
      Object(_proj_transforms_js__WEBPACK_IMPORTED_MODULE_8__["add"])(projection1, projection2, forwardTransform);
      Object(_proj_transforms_js__WEBPACK_IMPORTED_MODULE_8__["add"])(projection2, projection1, inverseTransform);
    });
  });
}


/**
 * Clear all cached projections and transforms.
 */
function clearAllProjections() {
  _proj_projections_js__WEBPACK_IMPORTED_MODULE_7__["clear"]();
  Object(_proj_transforms_js__WEBPACK_IMPORTED_MODULE_8__["clear"])();
}


/**
 * @param {Projection|string|undefined} projection Projection.
 * @param {string} defaultCode Default code.
 * @return {Projection} Projection.
 */
function createProjection(projection, defaultCode) {
  if (!projection) {
    return get(defaultCode);
  } else if (typeof projection === 'string') {
    return get(projection);
  } else {
    return (
      /** @type {Projection} */ (projection)
    );
  }
}


/**
 * Creates a {@link module:ol/proj~TransformFunction} from a simple 2D coordinate transform
 * function.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} coordTransform Coordinate
 *     transform.
 * @return {TransformFunction} Transform function.
 */
function createTransformFromCoordinateTransform(coordTransform) {
  return (
    /**
     * @param {Array<number>} input Input.
     * @param {Array<number>=} opt_output Output.
     * @param {number=} opt_dimension Dimension.
     * @return {Array<number>} Output.
     */
    function(input, opt_output, opt_dimension) {
      var length = input.length;
      var dimension = opt_dimension !== undefined ? opt_dimension : 2;
      var output = opt_output !== undefined ? opt_output : new Array(length);
      for (var i = 0; i < length; i += dimension) {
        var point = coordTransform([input[i], input[i + 1]]);
        output[i] = point[0];
        output[i + 1] = point[1];
        for (var j = dimension - 1; j >= 2; --j) {
          output[i + j] = input[i + j];
        }
      }
      return output;
    });
}


/**
 * Registers coordinate transform functions to convert coordinates between the
 * source projection and the destination projection.
 * The forward and inverse functions convert coordinate pairs; this function
 * converts these into the functions used internally which also handle
 * extents and coordinate arrays.
 *
 * @param {ProjectionLike} source Source projection.
 * @param {ProjectionLike} destination Destination projection.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} forward The forward transform
 *     function (that is, from the source projection to the destination
 *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:ol/coordinate~Coordinate}.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} inverse The inverse transform
 *     function (that is, from the destination projection to the source
 *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:ol/coordinate~Coordinate}.
 * @api
 */
function addCoordinateTransforms(source, destination, forward, inverse) {
  var sourceProj = get(source);
  var destProj = get(destination);
  Object(_proj_transforms_js__WEBPACK_IMPORTED_MODULE_8__["add"])(sourceProj, destProj, createTransformFromCoordinateTransform(forward));
  Object(_proj_transforms_js__WEBPACK_IMPORTED_MODULE_8__["add"])(destProj, sourceProj, createTransformFromCoordinateTransform(inverse));
}


/**
 * Transforms a coordinate from longitude/latitude to a different projection.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate as longitude and latitude, i.e.
 *     an array with longitude as 1st and latitude as 2nd element.
 * @param {ProjectionLike=} opt_projection Target projection. The
 *     default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {import("./coordinate.js").Coordinate} Coordinate projected to the target projection.
 * @api
 */
function fromLonLat(coordinate, opt_projection) {
  return transform(coordinate, 'EPSG:4326',
    opt_projection !== undefined ? opt_projection : 'EPSG:3857');
}


/**
 * Transforms a coordinate to longitude/latitude.
 * @param {import("./coordinate.js").Coordinate} coordinate Projected coordinate.
 * @param {ProjectionLike=} opt_projection Projection of the coordinate.
 *     The default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {import("./coordinate.js").Coordinate} Coordinate as longitude and latitude, i.e. an array
 *     with longitude as 1st and latitude as 2nd element.
 * @api
 */
function toLonLat(coordinate, opt_projection) {
  var lonLat = transform(coordinate,
    opt_projection !== undefined ? opt_projection : 'EPSG:3857', 'EPSG:4326');
  var lon = lonLat[0];
  if (lon < -180 || lon > 180) {
    lonLat[0] = Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["modulo"])(lon + 180, 360) - 180;
  }
  return lonLat;
}


/**
 * Checks if two projections are the same, that is every coordinate in one
 * projection does represent the same geographic point as the same coordinate in
 * the other projection.
 *
 * @param {Projection} projection1 Projection 1.
 * @param {Projection} projection2 Projection 2.
 * @return {boolean} Equivalent.
 * @api
 */
function equivalent(projection1, projection2) {
  if (projection1 === projection2) {
    return true;
  }
  var equalUnits = projection1.getUnits() === projection2.getUnits();
  if (projection1.getCode() === projection2.getCode()) {
    return equalUnits;
  } else {
    var transformFunc = getTransformFromProjections(projection1, projection2);
    return transformFunc === cloneTransform && equalUnits;
  }
}


/**
 * Searches in the list of transform functions for the function for converting
 * coordinates from the source projection to the destination projection.
 *
 * @param {Projection} sourceProjection Source Projection object.
 * @param {Projection} destinationProjection Destination Projection
 *     object.
 * @return {TransformFunction} Transform function.
 */
function getTransformFromProjections(sourceProjection, destinationProjection) {
  var sourceCode = sourceProjection.getCode();
  var destinationCode = destinationProjection.getCode();
  var transformFunc = Object(_proj_transforms_js__WEBPACK_IMPORTED_MODULE_8__["get"])(sourceCode, destinationCode);
  if (!transformFunc) {
    transformFunc = identityTransform;
  }
  return transformFunc;
}


/**
 * Given the projection-like objects, searches for a transformation
 * function to convert a coordinates array from the source projection to the
 * destination projection.
 *
 * @param {ProjectionLike} source Source.
 * @param {ProjectionLike} destination Destination.
 * @return {TransformFunction} Transform function.
 * @api
 */
function getTransform(source, destination) {
  var sourceProjection = get(source);
  var destinationProjection = get(destination);
  return getTransformFromProjections(sourceProjection, destinationProjection);
}


/**
 * Transforms a coordinate from source projection to destination projection.
 * This returns a new coordinate (and does not modify the original).
 *
 * See {@link module:ol/proj~transformExtent} for extent transformation.
 * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its
 * subclasses for geometry transforms.
 *
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {ProjectionLike} source Source projection-like.
 * @param {ProjectionLike} destination Destination projection-like.
 * @return {import("./coordinate.js").Coordinate} Coordinate.
 * @api
 */
function transform(coordinate, source, destination) {
  var transformFunc = getTransform(source, destination);
  return transformFunc(coordinate, undefined, coordinate.length);
}


/**
 * Transforms an extent from source projection to destination projection.  This
 * returns a new extent (and does not modify the original).
 *
 * @param {import("./extent.js").Extent} extent The extent to transform.
 * @param {ProjectionLike} source Source projection-like.
 * @param {ProjectionLike} destination Destination projection-like.
 * @return {import("./extent.js").Extent} The transformed extent.
 * @api
 */
function transformExtent(extent, source, destination) {
  var transformFunc = getTransform(source, destination);
  return Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["applyTransform"])(extent, transformFunc);
}


/**
 * Transforms the given point to the destination projection.
 *
 * @param {import("./coordinate.js").Coordinate} point Point.
 * @param {Projection} sourceProjection Source projection.
 * @param {Projection} destinationProjection Destination projection.
 * @return {import("./coordinate.js").Coordinate} Point.
 */
function transformWithProjections(point, sourceProjection, destinationProjection) {
  var transformFunc = getTransformFromProjections(sourceProjection, destinationProjection);
  return transformFunc(point);
}

/**
 * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called
 * by when this module is executed and should only need to be called again after
 * `clearAllProjections()` is called (e.g. in tests).
 */
function addCommon() {
  // Add transformations that don't alter coordinates to convert within set of
  // projections with equal meaning.
  addEquivalentProjections(_proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_3__["PROJECTIONS"]);
  addEquivalentProjections(_proj_epsg4326_js__WEBPACK_IMPORTED_MODULE_4__["PROJECTIONS"]);
  // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like
  // coordinates and back.
  addEquivalentTransforms(_proj_epsg4326_js__WEBPACK_IMPORTED_MODULE_4__["PROJECTIONS"], _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_3__["PROJECTIONS"], _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_3__["fromEPSG4326"], _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_3__["toEPSG4326"]);
}

addCommon();

//# sourceMappingURL=proj.js.map

/***/ }),

/***/ "./node_modules/ol/proj/Projection.js":
/*!********************************************!*\
  !*** ./node_modules/ol/proj/Projection.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Units_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Units.js */ "./node_modules/ol/proj/Units.js");
/**
 * @module ol/proj/Projection
 */



/**
 * @typedef {Object} Options
 * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.
 * @property {import("./Units.js").default|string} [units] Units. Required unless a
 * proj4 projection is defined for `code`.
 * @property {import("../extent.js").Extent} [extent] The validity extent for the SRS.
 * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.
 * @property {boolean} [global=false] Whether the projection is valid for the whole globe.
 * @property {number} [metersPerUnit] The meters per unit for the SRS.
 * If not provided, the `units` are used to get the meters per unit from the {@link module:ol/proj/Units~METERS_PER_UNIT}
 * lookup table.
 * @property {import("../extent.js").Extent} [worldExtent] The world extent for the SRS.
 * @property {function(number, import("../coordinate.js").Coordinate):number} [getPointResolution]
 * Function to determine resolution at a point. The function is called with a
 * `{number}` view resolution and an `{import("../coordinate.js").Coordinate}` as arguments, and returns
 * the `{number}` resolution at the passed coordinate. If this is `undefined`,
 * the default {@link module:ol/proj#getPointResolution} function will be used.
 */


/**
 * @classdesc
 * Projection definition class. One of these is created for each projection
 * supported in the application and stored in the {@link module:ol/proj} namespace.
 * You can use these in applications, but this is not required, as API params
 * and options use {@link module:ol/proj~ProjectionLike} which means the simple string
 * code will suffice.
 *
 * You can use {@link module:ol/proj~get} to retrieve the object for a particular
 * projection.
 *
 * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together
 * with the following aliases:
 * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,
 *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,
 *     http://www.opengis.net/gml/srs/epsg.xml#4326,
 *     urn:x-ogc:def:crs:EPSG:4326
 * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,
 *     urn:ogc:def:crs:EPSG:6.18:3:3857,
 *     http://www.opengis.net/gml/srs/epsg.xml#3857
 *
 * If you use [proj4js](https://github.com/proj4js/proj4js), aliases can
 * be added using `proj4.defs()`. After all required projection definitions are
 * added, call the {@link module:ol/proj/proj4~register} function.
 *
 * @api
 */
var Projection = function Projection(options) {
  /**
   * @private
   * @type {string}
   */
  this.code_ = options.code;

  /**
   * Units of projected coordinates. When set to `TILE_PIXELS`, a
   * `this.extent_` and `this.worldExtent_` must be configured properly for each
   * tile.
   * @private
   * @type {import("./Units.js").default}
   */
  this.units_ = /** @type {import("./Units.js").default} */ (options.units);

  /**
   * Validity extent of the projection in projected coordinates. For projections
   * with `TILE_PIXELS` units, this is the extent of the tile in
   * tile pixel space.
   * @private
   * @type {import("../extent.js").Extent}
   */
  this.extent_ = options.extent !== undefined ? options.extent : null;

  /**
   * Extent of the world in EPSG:4326. For projections with
   * `TILE_PIXELS` units, this is the extent of the tile in
   * projected coordinate space.
   * @private
   * @type {import("../extent.js").Extent}
   */
  this.worldExtent_ = options.worldExtent !== undefined ?
    options.worldExtent : null;

  /**
   * @private
   * @type {string}
   */
  this.axisOrientation_ = options.axisOrientation !== undefined ?
    options.axisOrientation : 'enu';

  /**
   * @private
   * @type {boolean}
   */
  this.global_ = options.global !== undefined ? options.global : false;

  /**
   * @private
   * @type {boolean}
   */
  this.canWrapX_ = !!(this.global_ && this.extent_);

  /**
   * @private
   * @type {function(number, import("../coordinate.js").Coordinate):number|undefined}
   */
  this.getPointResolutionFunc_ = options.getPointResolution;

  /**
   * @private
   * @type {import("../tilegrid/TileGrid.js").default}
   */
  this.defaultTileGrid_ = null;

  /**
   * @private
   * @type {number|undefined}
   */
  this.metersPerUnit_ = options.metersPerUnit;
};

/**
 * @return {boolean} The projection is suitable for wrapping the x-axis
 */
Projection.prototype.canWrapX = function canWrapX () {
  return this.canWrapX_;
};

/**
 * Get the code for this projection, e.g. 'EPSG:4326'.
 * @return {string} Code.
 * @api
 */
Projection.prototype.getCode = function getCode () {
  return this.code_;
};

/**
 * Get the validity extent for this projection.
 * @return {import("../extent.js").Extent} Extent.
 * @api
 */
Projection.prototype.getExtent = function getExtent () {
  return this.extent_;
};

/**
 * Get the units of this projection.
 * @return {import("./Units.js").default} Units.
 * @api
 */
Projection.prototype.getUnits = function getUnits () {
  return this.units_;
};

/**
 * Get the amount of meters per unit of this projection.If the projection is
 * not configured with `metersPerUnit` or a units identifier, the return is
 * `undefined`.
 * @return {number|undefined} Meters.
 * @api
 */
Projection.prototype.getMetersPerUnit = function getMetersPerUnit () {
  return this.metersPerUnit_ || _Units_js__WEBPACK_IMPORTED_MODULE_0__["METERS_PER_UNIT"][this.units_];
};

/**
 * Get the world extent for this projection.
 * @return {import("../extent.js").Extent} Extent.
 * @api
 */
Projection.prototype.getWorldExtent = function getWorldExtent () {
  return this.worldExtent_;
};

/**
 * Get the axis orientation of this projection.
 * Example values are:
 * enu - the default easting, northing, elevation.
 * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
 *   or south orientated transverse mercator.
 * wnu - westing, northing, up - some planetary coordinate systems have
 *   "west positive" coordinate systems
 * @return {string} Axis orientation.
 * @api
 */
Projection.prototype.getAxisOrientation = function getAxisOrientation () {
  return this.axisOrientation_;
};

/**
 * Is this projection a global projection which spans the whole world?
 * @return {boolean} Whether the projection is global.
 * @api
 */
Projection.prototype.isGlobal = function isGlobal () {
  return this.global_;
};

/**
 * Set if the projection is a global projection which spans the whole world
 * @param {boolean} global Whether the projection is global.
 * @api
 */
Projection.prototype.setGlobal = function setGlobal (global) {
  this.global_ = global;
  this.canWrapX_ = !!(global && this.extent_);
};

/**
 * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
 */
Projection.prototype.getDefaultTileGrid = function getDefaultTileGrid () {
  return this.defaultTileGrid_;
};

/**
 * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
 */
Projection.prototype.setDefaultTileGrid = function setDefaultTileGrid (tileGrid) {
  this.defaultTileGrid_ = tileGrid;
};

/**
 * Set the validity extent for this projection.
 * @param {import("../extent.js").Extent} extent Extent.
 * @api
 */
Projection.prototype.setExtent = function setExtent (extent) {
  this.extent_ = extent;
  this.canWrapX_ = !!(this.global_ && extent);
};

/**
 * Set the world extent for this projection.
 * @param {import("../extent.js").Extent} worldExtent World extent
 *   [minlon, minlat, maxlon, maxlat].
 * @api
 */
Projection.prototype.setWorldExtent = function setWorldExtent (worldExtent) {
  this.worldExtent_ = worldExtent;
};

/**
 * Set the getPointResolution function (see {@link module:ol/proj~getPointResolution}
 * for this projection.
 * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
 * @api
 */
Projection.prototype.setGetPointResolution = function setGetPointResolution (func) {
  this.getPointResolutionFunc_ = func;
};

/**
 * Get the custom point resolution function for this projection (if set).
 * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
 * resolution function (if set).
 */
Projection.prototype.getPointResolutionFunc = function getPointResolutionFunc () {
  return this.getPointResolutionFunc_;
};

/* harmony default export */ __webpack_exports__["default"] = (Projection);

//# sourceMappingURL=Projection.js.map

/***/ }),

/***/ "./node_modules/ol/proj/Units.js":
/*!***************************************!*\
  !*** ./node_modules/ol/proj/Units.js ***!
  \***************************************/
/*! exports provided: METERS_PER_UNIT, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "METERS_PER_UNIT", function() { return METERS_PER_UNIT; });
/**
 * @module ol/proj/Units
 */

/**
 * Projection units: `'degrees'`, `'ft'`, `'m'`, `'pixels'`, `'tile-pixels'` or
 * `'us-ft'`.
 * @enum {string}
 */
var Units = {
  DEGREES: 'degrees',
  FEET: 'ft',
  METERS: 'm',
  PIXELS: 'pixels',
  TILE_PIXELS: 'tile-pixels',
  USFEET: 'us-ft'
};


/**
 * Meters per unit lookup table.
 * @const
 * @type {Object<Units, number>}
 * @api
 */
var METERS_PER_UNIT = {};
// use the radius of the Normal sphere
METERS_PER_UNIT[Units.DEGREES] = 2 * Math.PI * 6370997 / 360;
METERS_PER_UNIT[Units.FEET] = 0.3048;
METERS_PER_UNIT[Units.METERS] = 1;
METERS_PER_UNIT[Units.USFEET] = 1200 / 3937;

/* harmony default export */ __webpack_exports__["default"] = (Units);

//# sourceMappingURL=Units.js.map

/***/ }),

/***/ "./node_modules/ol/proj/epsg3857.js":
/*!******************************************!*\
  !*** ./node_modules/ol/proj/epsg3857.js ***!
  \******************************************/
/*! exports provided: RADIUS, HALF_SIZE, EXTENT, WORLD_EXTENT, PROJECTIONS, fromEPSG4326, toEPSG4326 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RADIUS", function() { return RADIUS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HALF_SIZE", function() { return HALF_SIZE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EXTENT", function() { return EXTENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WORLD_EXTENT", function() { return WORLD_EXTENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PROJECTIONS", function() { return PROJECTIONS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromEPSG4326", function() { return fromEPSG4326; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toEPSG4326", function() { return toEPSG4326; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _Projection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Projection.js */ "./node_modules/ol/proj/Projection.js");
/* harmony import */ var _Units_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Units.js */ "./node_modules/ol/proj/Units.js");
/**
 * @module ol/proj/epsg3857
 */





/**
 * Radius of WGS84 sphere
 *
 * @const
 * @type {number}
 */
var RADIUS = 6378137;


/**
 * @const
 * @type {number}
 */
var HALF_SIZE = Math.PI * RADIUS;


/**
 * @const
 * @type {import("../extent.js").Extent}
 */
var EXTENT = [
  -HALF_SIZE, -HALF_SIZE,
  HALF_SIZE, HALF_SIZE
];


/**
 * @const
 * @type {import("../extent.js").Extent}
 */
var WORLD_EXTENT = [-180, -85, 180, 85];


/**
 * @classdesc
 * Projection object for web/spherical Mercator (EPSG:3857).
 */
var EPSG3857Projection = /*@__PURE__*/(function (Projection) {
  function EPSG3857Projection(code) {
    Projection.call(this, {
      code: code,
      units: _Units_js__WEBPACK_IMPORTED_MODULE_2__["default"].METERS,
      extent: EXTENT,
      global: true,
      worldExtent: WORLD_EXTENT,
      getPointResolution: function(resolution, point) {
        return resolution / Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["cosh"])(point[1] / RADIUS);
      }
    });

  }

  if ( Projection ) EPSG3857Projection.__proto__ = Projection;
  EPSG3857Projection.prototype = Object.create( Projection && Projection.prototype );
  EPSG3857Projection.prototype.constructor = EPSG3857Projection;

  return EPSG3857Projection;
}(_Projection_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/**
 * Projections equal to EPSG:3857.
 *
 * @const
 * @type {Array<import("./Projection.js").default>}
 */
var PROJECTIONS = [
  new EPSG3857Projection('EPSG:3857'),
  new EPSG3857Projection('EPSG:102100'),
  new EPSG3857Projection('EPSG:102113'),
  new EPSG3857Projection('EPSG:900913'),
  new EPSG3857Projection('urn:ogc:def:crs:EPSG:6.18:3:3857'),
  new EPSG3857Projection('urn:ogc:def:crs:EPSG::3857'),
  new EPSG3857Projection('http://www.opengis.net/gml/srs/epsg.xml#3857')
];


/**
 * Transformation from EPSG:4326 to EPSG:3857.
 *
 * @param {Array<number>} input Input array of coordinate values.
 * @param {Array<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension (default is `2`).
 * @return {Array<number>} Output array of coordinate values.
 */
function fromEPSG4326(input, opt_output, opt_dimension) {
  var length = input.length;
  var dimension = opt_dimension > 1 ? opt_dimension : 2;
  var output = opt_output;
  if (output === undefined) {
    if (dimension > 2) {
      // preserve values beyond second dimension
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  var halfSize = HALF_SIZE;
  for (var i = 0; i < length; i += dimension) {
    output[i] = halfSize * input[i] / 180;
    var y = RADIUS *
        Math.log(Math.tan(Math.PI * (input[i + 1] + 90) / 360));
    if (y > halfSize) {
      y = halfSize;
    } else if (y < -halfSize) {
      y = -halfSize;
    }
    output[i + 1] = y;
  }
  return output;
}


/**
 * Transformation from EPSG:3857 to EPSG:4326.
 *
 * @param {Array<number>} input Input array of coordinate values.
 * @param {Array<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension (default is `2`).
 * @return {Array<number>} Output array of coordinate values.
 */
function toEPSG4326(input, opt_output, opt_dimension) {
  var length = input.length;
  var dimension = opt_dimension > 1 ? opt_dimension : 2;
  var output = opt_output;
  if (output === undefined) {
    if (dimension > 2) {
      // preserve values beyond second dimension
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (var i = 0; i < length; i += dimension) {
    output[i] = 180 * input[i] / HALF_SIZE;
    output[i + 1] = 360 * Math.atan(
      Math.exp(input[i + 1] / RADIUS)) / Math.PI - 90;
  }
  return output;
}

//# sourceMappingURL=epsg3857.js.map

/***/ }),

/***/ "./node_modules/ol/proj/epsg4326.js":
/*!******************************************!*\
  !*** ./node_modules/ol/proj/epsg4326.js ***!
  \******************************************/
/*! exports provided: RADIUS, EXTENT, METERS_PER_UNIT, PROJECTIONS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RADIUS", function() { return RADIUS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EXTENT", function() { return EXTENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "METERS_PER_UNIT", function() { return METERS_PER_UNIT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PROJECTIONS", function() { return PROJECTIONS; });
/* harmony import */ var _Projection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Projection.js */ "./node_modules/ol/proj/Projection.js");
/* harmony import */ var _Units_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Units.js */ "./node_modules/ol/proj/Units.js");
/**
 * @module ol/proj/epsg4326
 */




/**
 * Semi-major radius of the WGS84 ellipsoid.
 *
 * @const
 * @type {number}
 */
var RADIUS = 6378137;


/**
 * Extent of the EPSG:4326 projection which is the whole world.
 *
 * @const
 * @type {import("../extent.js").Extent}
 */
var EXTENT = [-180, -90, 180, 90];


/**
 * @const
 * @type {number}
 */
var METERS_PER_UNIT = Math.PI * RADIUS / 180;


/**
 * @classdesc
 * Projection object for WGS84 geographic coordinates (EPSG:4326).
 *
 * Note that OpenLayers does not strictly comply with the EPSG definition.
 * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).
 * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.
 */
var EPSG4326Projection = /*@__PURE__*/(function (Projection) {
  function EPSG4326Projection(code, opt_axisOrientation) {
    Projection.call(this, {
      code: code,
      units: _Units_js__WEBPACK_IMPORTED_MODULE_1__["default"].DEGREES,
      extent: EXTENT,
      axisOrientation: opt_axisOrientation,
      global: true,
      metersPerUnit: METERS_PER_UNIT,
      worldExtent: EXTENT
    });

  }

  if ( Projection ) EPSG4326Projection.__proto__ = Projection;
  EPSG4326Projection.prototype = Object.create( Projection && Projection.prototype );
  EPSG4326Projection.prototype.constructor = EPSG4326Projection;

  return EPSG4326Projection;
}(_Projection_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/**
 * Projections equal to EPSG:4326.
 *
 * @const
 * @type {Array<import("./Projection.js").default>}
 */
var PROJECTIONS = [
  new EPSG4326Projection('CRS:84'),
  new EPSG4326Projection('EPSG:4326', 'neu'),
  new EPSG4326Projection('urn:ogc:def:crs:EPSG::4326', 'neu'),
  new EPSG4326Projection('urn:ogc:def:crs:EPSG:6.6:4326', 'neu'),
  new EPSG4326Projection('urn:ogc:def:crs:OGC:1.3:CRS84'),
  new EPSG4326Projection('urn:ogc:def:crs:OGC:2:84'),
  new EPSG4326Projection('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'),
  new EPSG4326Projection('urn:x-ogc:def:crs:EPSG:4326', 'neu')
];

//# sourceMappingURL=epsg4326.js.map

/***/ }),

/***/ "./node_modules/ol/proj/projections.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/proj/projections.js ***!
  \*********************************************/
/*! exports provided: clear, get, add */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clear", function() { return clear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/**
 * @module ol/proj/projections
 */


/**
 * @type {Object<string, import("./Projection.js").default>}
 */
var cache = {};


/**
 * Clear the projections cache.
 */
function clear() {
  cache = {};
}


/**
 * Get a cached projection by code.
 * @param {string} code The code for the projection.
 * @return {import("./Projection.js").default} The projection (if cached).
 */
function get(code) {
  return cache[code] || null;
}


/**
 * Add a projection to the cache.
 * @param {string} code The projection code.
 * @param {import("./Projection.js").default} projection The projection to cache.
 */
function add(code, projection) {
  cache[code] = projection;
}

//# sourceMappingURL=projections.js.map

/***/ }),

/***/ "./node_modules/ol/proj/transforms.js":
/*!********************************************!*\
  !*** ./node_modules/ol/proj/transforms.js ***!
  \********************************************/
/*! exports provided: clear, add, remove, get */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clear", function() { return clear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "remove", function() { return remove; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/proj/transforms
 */



/**
 * @private
 * @type {!Object<string, Object<string, import("../proj.js").TransformFunction>>}
 */
var transforms = {};


/**
 * Clear the transform cache.
 */
function clear() {
  transforms = {};
}


/**
 * Registers a conversion function to convert coordinates from the source
 * projection to the destination projection.
 *
 * @param {import("./Projection.js").default} source Source.
 * @param {import("./Projection.js").default} destination Destination.
 * @param {import("../proj.js").TransformFunction} transformFn Transform.
 */
function add(source, destination, transformFn) {
  var sourceCode = source.getCode();
  var destinationCode = destination.getCode();
  if (!(sourceCode in transforms)) {
    transforms[sourceCode] = {};
  }
  transforms[sourceCode][destinationCode] = transformFn;
}


/**
 * Unregisters the conversion function to convert coordinates from the source
 * projection to the destination projection.  This method is used to clean up
 * cached transforms during testing.
 *
 * @param {import("./Projection.js").default} source Source projection.
 * @param {import("./Projection.js").default} destination Destination projection.
 * @return {import("../proj.js").TransformFunction} transformFn The unregistered transform.
 */
function remove(source, destination) {
  var sourceCode = source.getCode();
  var destinationCode = destination.getCode();
  var transform = transforms[sourceCode][destinationCode];
  delete transforms[sourceCode][destinationCode];
  if (Object(_obj_js__WEBPACK_IMPORTED_MODULE_0__["isEmpty"])(transforms[sourceCode])) {
    delete transforms[sourceCode];
  }
  return transform;
}


/**
 * Get a transform given a source code and a destination code.
 * @param {string} sourceCode The code for the source projection.
 * @param {string} destinationCode The code for the destination projection.
 * @return {import("../proj.js").TransformFunction|undefined} The transform function (if found).
 */
function get(sourceCode, destinationCode) {
  var transform;
  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
    transform = transforms[sourceCode][destinationCode];
  }
  return transform;
}

//# sourceMappingURL=transforms.js.map

/***/ }),

/***/ "./node_modules/ol/render/Event.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/render/Event.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/**
 * @module ol/render/Event
 */



var RenderEvent = /*@__PURE__*/(function (Event) {
  function RenderEvent(type, opt_vectorContext, opt_frameState, opt_context, opt_glContext) {

    Event.call(this, type);

    /**
     * For canvas, this is an instance of {@link module:ol/render/canvas/Immediate}.
     * @type {import("./VectorContext.js").default|undefined}
     * @api
     */
    this.vectorContext = opt_vectorContext;

    /**
     * An object representing the current render frame state.
     * @type {import("../PluggableMap.js").FrameState|undefined}
     * @api
     */
    this.frameState = opt_frameState;

    /**
     * Canvas context. Only available when a Canvas renderer is used, null
     * otherwise.
     * @type {CanvasRenderingContext2D|null|undefined}
     * @api
     */
    this.context = opt_context;

    /**
     * WebGL context. Only available when a WebGL renderer is used, null
     * otherwise.
     * @type {import("../webgl/Context.js").default|null|undefined}
     * @api
     */
    this.glContext = opt_glContext;

  }

  if ( Event ) RenderEvent.__proto__ = Event;
  RenderEvent.prototype = Object.create( Event && Event.prototype );
  RenderEvent.prototype.constructor = RenderEvent;

  return RenderEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_0__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (RenderEvent);

//# sourceMappingURL=Event.js.map

/***/ }),

/***/ "./node_modules/ol/render/EventType.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/render/EventType.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/render/EventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  /**
   * @event module:ol/render/Event~RenderEvent#postcompose
   * @api
   */
  POSTCOMPOSE: 'postcompose',
  /**
   * @event module:ol/render/Event~RenderEvent#precompose
   * @api
   */
  PRECOMPOSE: 'precompose',
  /**
   * @event module:ol/render/Event~RenderEvent#render
   * @api
   */
  RENDER: 'render',
  /**
   * Triggered when rendering is complete, i.e. all sources and tiles have
   * finished loading for the current viewport, and all tiles are faded in.
   * @event module:ol/render/Event~RenderEvent#rendercomplete
   * @api
   */
  RENDERCOMPLETE: 'rendercomplete'
});

//# sourceMappingURL=EventType.js.map

/***/ }),

/***/ "./node_modules/ol/render/VectorContext.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/render/VectorContext.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/render/VectorContext
 */

/**
 * @classdesc
 * Context for drawing geometries.  A vector context is available on render
 * events and does not need to be constructed directly.
 * @api
 */
var VectorContext = function VectorContext () {};

VectorContext.prototype.drawCustom = function drawCustom (geometry, feature, renderer) {};

/**
 * Render a geometry.
 *
 * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
 */
VectorContext.prototype.drawGeometry = function drawGeometry (geometry) {};

/**
 * Set the rendering style.
 *
 * @param {import("../style/Style.js").default} style The rendering style.
 */
VectorContext.prototype.setStyle = function setStyle (style) {};

/**
 * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
 * @param {import("../Feature.js").default} feature Feature.
 */
VectorContext.prototype.drawCircle = function drawCircle (circleGeometry, feature) {};

/**
 * @param {import("../Feature.js").default} feature Feature.
 * @param {import("../style/Style.js").default} style Style.
 */
VectorContext.prototype.drawFeature = function drawFeature (feature, style) {};

/**
 * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
 * @param {import("../Feature.js").default} feature Feature.
 */
VectorContext.prototype.drawGeometryCollection = function drawGeometryCollection (geometryCollectionGeometry, feature) {};

/**
 * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
 * @param {import("../Feature.js").default|import("./Feature.js").default} feature Feature.
 */
VectorContext.prototype.drawLineString = function drawLineString (lineStringGeometry, feature) {};

/**
 * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
 * @param {import("../Feature.js").default|import("./Feature.js").default} feature Feature.
 */
VectorContext.prototype.drawMultiLineString = function drawMultiLineString (multiLineStringGeometry, feature) {};

/**
 * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
 * @param {import("../Feature.js").default|import("./Feature.js").default} feature Feature.
 */
VectorContext.prototype.drawMultiPoint = function drawMultiPoint (multiPointGeometry, feature) {};

/**
 * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
 * @param {import("../Feature.js").default|import("./Feature.js").default} feature Feature.
 */
VectorContext.prototype.drawMultiPolygon = function drawMultiPolygon (multiPolygonGeometry, feature) {};

/**
 * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
 * @param {import("../Feature.js").default|import("./Feature.js").default} feature Feature.
 */
VectorContext.prototype.drawPoint = function drawPoint (pointGeometry, feature) {};

/**
 * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
 * @param {import("../Feature.js").default|import("./Feature.js").default} feature Feature.
 */
VectorContext.prototype.drawPolygon = function drawPolygon (polygonGeometry, feature) {};

/**
 * @param {import("../geom/Geometry.js").default|import("./Feature.js").default} geometry Geometry.
 * @param {import("../Feature.js").default|import("./Feature.js").default} feature Feature.
 */
VectorContext.prototype.drawText = function drawText (geometry, feature) {};

/**
 * @param {import("../style/Fill.js").default} fillStyle Fill style.
 * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
 */
VectorContext.prototype.setFillStrokeStyle = function setFillStrokeStyle (fillStyle, strokeStyle) {};

/**
 * @param {import("../style/Image.js").default} imageStyle Image style.
 * @param {import("./canvas.js").DeclutterGroup=} opt_declutterGroup Declutter.
 */
VectorContext.prototype.setImageStyle = function setImageStyle (imageStyle, opt_declutterGroup) {};

/**
 * @param {import("../style/Text.js").default} textStyle Text style.
 * @param {import("./canvas.js").DeclutterGroup=} opt_declutterGroup Declutter.
 */
VectorContext.prototype.setTextStyle = function setTextStyle (textStyle, opt_declutterGroup) {};

/* harmony default export */ __webpack_exports__["default"] = (VectorContext);

//# sourceMappingURL=VectorContext.js.map

/***/ }),

/***/ "./node_modules/ol/render/canvas.js":
/*!******************************************!*\
  !*** ./node_modules/ol/render/canvas.js ***!
  \******************************************/
/*! exports provided: defaultFont, defaultFillStyle, defaultLineCap, defaultLineDash, defaultLineDashOffset, defaultLineJoin, defaultMiterLimit, defaultStrokeStyle, defaultTextAlign, defaultTextBaseline, defaultPadding, defaultLineWidth, labelCache, checkedFonts, textHeights, checkFont, measureTextHeight, measureTextWidth, rotateAtOffset, resetTransform, drawImage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultFont", function() { return defaultFont; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultFillStyle", function() { return defaultFillStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultLineCap", function() { return defaultLineCap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultLineDash", function() { return defaultLineDash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultLineDashOffset", function() { return defaultLineDashOffset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultLineJoin", function() { return defaultLineJoin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultMiterLimit", function() { return defaultMiterLimit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultStrokeStyle", function() { return defaultStrokeStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultTextAlign", function() { return defaultTextAlign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultTextBaseline", function() { return defaultTextBaseline; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultPadding", function() { return defaultPadding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultLineWidth", function() { return defaultLineWidth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "labelCache", function() { return labelCache; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkedFonts", function() { return checkedFonts; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "textHeights", function() { return textHeights; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkFont", function() { return checkFont; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "measureTextHeight", function() { return measureTextHeight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "measureTextWidth", function() { return measureTextWidth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateAtOffset", function() { return rotateAtOffset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resetTransform", function() { return resetTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawImage", function() { return drawImage; });
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../css.js */ "./node_modules/ol/css.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _structs_LRUCache_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../structs/LRUCache.js */ "./node_modules/ol/structs/LRUCache.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/render/canvas
 */







/**
 * @typedef {Object} FillState
 * @property {import("../colorlike.js").ColorLike} fillStyle
 */


/**
 * @typedef {Object} FillStrokeState
 * @property {import("../colorlike.js").ColorLike} [currentFillStyle]
 * @property {import("../colorlike.js").ColorLike} [currentStrokeStyle]
 * @property {string} [currentLineCap]
 * @property {Array<number>} currentLineDash
 * @property {number} [currentLineDashOffset]
 * @property {string} [currentLineJoin]
 * @property {number} [currentLineWidth]
 * @property {number} [currentMiterLimit]
 * @property {number} [lastStroke]
 * @property {import("../colorlike.js").ColorLike} [fillStyle]
 * @property {import("../colorlike.js").ColorLike} [strokeStyle]
 * @property {string} [lineCap]
 * @property {Array<number>} lineDash
 * @property {number} [lineDashOffset]
 * @property {string} [lineJoin]
 * @property {number} [lineWidth]
 * @property {number} [miterLimit]
 */


/**
 * @typedef {Object} StrokeState
 * @property {string} lineCap
 * @property {Array<number>} lineDash
 * @property {number} lineDashOffset
 * @property {string} lineJoin
 * @property {number} lineWidth
 * @property {number} miterLimit
 * @property {import("../colorlike.js").ColorLike} strokeStyle
 */


/**
 * @typedef {Object} TextState
 * @property {string} font
 * @property {string} [textAlign]
 * @property {string} textBaseline
 * @property {string} [placement]
 * @property {number} [maxAngle]
 * @property {boolean} [overflow]
 * @property {import("../style/Fill.js").default} [backgroundFill]
 * @property {import("../style/Stroke.js").default} [backgroundStroke]
 * @property {number} [scale]
 * @property {Array<number>} [padding]
 */


/**
 * Container for decluttered replay instructions that need to be rendered or
 * omitted together, i.e. when styles render both an image and text, or for the
 * characters that form text along lines. The basic elements of this array are
 * `[minX, minY, maxX, maxY, count]`, where the first four entries are the
 * rendered extent of the group in pixel space. `count` is the number of styles
 * in the group, i.e. 2 when an image and a text are grouped, or 1 otherwise.
 * In addition to these four elements, declutter instruction arrays (i.e. the
 * arguments to {@link module:ol/render/canvas~drawImage} are appended to the array.
 * @typedef {Array<*>} DeclutterGroup
 */


/**
 * @const
 * @type {string}
 */
var defaultFont = '10px sans-serif';


/**
 * @const
 * @type {import("../color.js").Color}
 */
var defaultFillStyle = [0, 0, 0, 1];


/**
 * @const
 * @type {string}
 */
var defaultLineCap = 'round';


/**
 * @const
 * @type {Array<number>}
 */
var defaultLineDash = [];


/**
 * @const
 * @type {number}
 */
var defaultLineDashOffset = 0;


/**
 * @const
 * @type {string}
 */
var defaultLineJoin = 'round';


/**
 * @const
 * @type {number}
 */
var defaultMiterLimit = 10;


/**
 * @const
 * @type {import("../color.js").Color}
 */
var defaultStrokeStyle = [0, 0, 0, 1];


/**
 * @const
 * @type {string}
 */
var defaultTextAlign = 'center';


/**
 * @const
 * @type {string}
 */
var defaultTextBaseline = 'middle';


/**
 * @const
 * @type {Array<number>}
 */
var defaultPadding = [0, 0, 0, 0];


/**
 * @const
 * @type {number}
 */
var defaultLineWidth = 1;


/**
 * The label cache for text rendering. To change the default cache size of 2048
 * entries, use {@link module:ol/structs/LRUCache#setSize}.
 * @type {LRUCache<HTMLCanvasElement>}
 * @api
 */
var labelCache = new _structs_LRUCache_js__WEBPACK_IMPORTED_MODULE_3__["default"]();


/**
 * @type {!Object<string, number>}
 */
var checkedFonts = {};


/**
 * @type {CanvasRenderingContext2D}
 */
var measureContext = null;


/**
 * @type {!Object<string, number>}
 */
var textHeights = {};


/**
 * Clears the label cache when a font becomes available.
 * @param {string} fontSpec CSS font spec.
 */
var checkFont = (function() {
  var retries = 60;
  var checked = checkedFonts;
  var size = '32px ';
  var referenceFonts = ['monospace', 'serif'];
  var len = referenceFonts.length;
  var text = 'wmytzilWMYTZIL@#/&?$%10\uF013';
  var interval, referenceWidth;

  function isAvailable(font) {
    var context = getMeasureContext();
    // Check weight ranges according to
    // https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight#Fallback_weights
    for (var weight = 100; weight <= 700; weight += 300) {
      var fontWeight = weight + ' ';
      var available = true;
      for (var i = 0; i < len; ++i) {
        var referenceFont = referenceFonts[i];
        context.font = fontWeight + size + referenceFont;
        referenceWidth = context.measureText(text).width;
        if (font != referenceFont) {
          context.font = fontWeight + size + font + ',' + referenceFont;
          var width = context.measureText(text).width;
          // If width and referenceWidth are the same, then the fallback was used
          // instead of the font we wanted, so the font is not available.
          available = available && width != referenceWidth;
        }
      }
      if (available) {
        // Consider font available when it is available in one weight range.
        //FIXME With this we miss rare corner cases, so we should consider
        //FIXME checking availability for each requested weight range.
        return true;
      }
    }
    return false;
  }

  function check() {
    var done = true;
    for (var font in checked) {
      if (checked[font] < retries) {
        if (isAvailable(font)) {
          checked[font] = retries;
          Object(_obj_js__WEBPACK_IMPORTED_MODULE_2__["clear"])(textHeights);
          // Make sure that loaded fonts are picked up by Safari
          measureContext = null;
          labelCache.clear();
        } else {
          ++checked[font];
          done = false;
        }
      }
    }
    if (done) {
      clearInterval(interval);
      interval = undefined;
    }
  }

  return function(fontSpec) {
    var fontFamilies = Object(_css_js__WEBPACK_IMPORTED_MODULE_0__["getFontFamilies"])(fontSpec);
    if (!fontFamilies) {
      return;
    }
    for (var i = 0, ii = fontFamilies.length; i < ii; ++i) {
      var fontFamily = fontFamilies[i];
      if (!(fontFamily in checked)) {
        checked[fontFamily] = retries;
        if (!isAvailable(fontFamily)) {
          checked[fontFamily] = 0;
          if (interval === undefined) {
            interval = setInterval(check, 32);
          }
        }
      }
    }
  };
})();


/**
 * @return {CanvasRenderingContext2D} Measure context.
 */
function getMeasureContext() {
  if (!measureContext) {
    measureContext = Object(_dom_js__WEBPACK_IMPORTED_MODULE_1__["createCanvasContext2D"])(1, 1);
  }
  return measureContext;
}


/**
 * @param {string} font Font to use for measuring.
 * @return {import("../size.js").Size} Measurement.
 */
var measureTextHeight = (function() {
  var span;
  var heights = textHeights;
  return function(font) {
    var height = heights[font];
    if (height == undefined) {
      if (!span) {
        span = document.createElement('span');
        span.textContent = 'M';
        span.style.margin = span.style.padding = '0 !important';
        span.style.position = 'absolute !important';
        span.style.left = '-99999px !important';
      }
      span.style.font = font;
      document.body.appendChild(span);
      height = heights[font] = span.offsetHeight;
      document.body.removeChild(span);
    }
    return height;
  };
})();


/**
 * @param {string} font Font.
 * @param {string} text Text.
 * @return {number} Width.
 */
function measureTextWidth(font, text) {
  var measureContext = getMeasureContext();
  if (font != measureContext.font) {
    measureContext.font = font;
  }
  return measureContext.measureText(text).width;
}


/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} rotation Rotation.
 * @param {number} offsetX X offset.
 * @param {number} offsetY Y offset.
 */
function rotateAtOffset(context, rotation, offsetX, offsetY) {
  if (rotation !== 0) {
    context.translate(offsetX, offsetY);
    context.rotate(rotation);
    context.translate(-offsetX, -offsetY);
  }
}


var resetTransform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_4__["create"])();


/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {import("../transform.js").Transform|null} transform Transform.
 * @param {number} opacity Opacity.
 * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} image Image.
 * @param {number} originX Origin X.
 * @param {number} originY Origin Y.
 * @param {number} w Width.
 * @param {number} h Height.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} scale Scale.
 */
function drawImage(context,
  transform, opacity, image, originX, originY, w, h, x, y, scale) {
  var alpha;
  if (opacity != 1) {
    alpha = context.globalAlpha;
    context.globalAlpha = alpha * opacity;
  }
  if (transform) {
    context.setTransform.apply(context, transform);
  }

  context.drawImage(image, originX, originY, w, h, x, y, w * scale, h * scale);

  if (alpha) {
    context.globalAlpha = alpha;
  }
  if (transform) {
    context.setTransform.apply(context, resetTransform);
  }
}

//# sourceMappingURL=canvas.js.map

/***/ }),

/***/ "./node_modules/ol/render/canvas/Immediate.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/render/canvas/Immediate.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _colorlike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../colorlike.js */ "./node_modules/ol/colorlike.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../geom/SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../geom/flat/transform.js */ "./node_modules/ol/geom/flat/transform.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _VectorContext_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../VectorContext.js */ "./node_modules/ol/render/VectorContext.js");
/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/render/canvas/Immediate
 */
// FIXME test, especially polygons with holes and multipolygons
// FIXME need to handle large thick features (where pixel size matters)
// FIXME add offset and end to ol/geom/flat/transform~transform2D?












/**
 * @classdesc
 * A concrete subclass of {@link module:ol/render/VectorContext} that implements
 * direct rendering of features and geometries to an HTML5 Canvas context.
 * Instances of this class are created internally by the library and
 * provided to application code as vectorContext member of the
 * {@link module:ol/render/Event~RenderEvent} object associated with postcompose, precompose and
 * render events emitted by layers and maps.
 */
var CanvasImmediateRenderer = /*@__PURE__*/(function (VectorContext) {
  function CanvasImmediateRenderer(context, pixelRatio, extent, transform, viewRotation) {
    VectorContext.call(this);

    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */
    this.context_ = context;

    /**
     * @private
     * @type {number}
     */
    this.pixelRatio_ = pixelRatio;

    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */
    this.extent_ = extent;

    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    this.transform_ = transform;

    /**
     * @private
     * @type {number}
     */
    this.viewRotation_ = viewRotation;

    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */
    this.contextFillState_ = null;

    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */
    this.contextStrokeState_ = null;

    /**
     * @private
     * @type {?import("../canvas.js").TextState}
     */
    this.contextTextState_ = null;

    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */
    this.fillState_ = null;

    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */
    this.strokeState_ = null;

    /**
     * @private
     * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
     */
    this.image_ = null;

    /**
     * @private
     * @type {number}
     */
    this.imageAnchorX_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.imageAnchorY_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.imageHeight_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.imageOpacity_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.imageOriginX_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.imageOriginY_ = 0;

    /**
     * @private
     * @type {boolean}
     */
    this.imageRotateWithView_ = false;

    /**
     * @private
     * @type {number}
     */
    this.imageRotation_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.imageScale_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.imageWidth_ = 0;

    /**
     * @private
     * @type {string}
     */
    this.text_ = '';

    /**
     * @private
     * @type {number}
     */
    this.textOffsetX_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.textOffsetY_ = 0;

    /**
     * @private
     * @type {boolean}
     */
    this.textRotateWithView_ = false;

    /**
     * @private
     * @type {number}
     */
    this.textRotation_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.textScale_ = 0;

    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */
    this.textFillState_ = null;

    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */
    this.textStrokeState_ = null;

    /**
     * @private
     * @type {?import("../canvas.js").TextState}
     */
    this.textState_ = null;

    /**
     * @private
     * @type {Array<number>}
     */
    this.pixelCoordinates_ = [];

    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    this.tmpLocalTransform_ = Object(_transform_js__WEBPACK_IMPORTED_MODULE_9__["create"])();

  }

  if ( VectorContext ) CanvasImmediateRenderer.__proto__ = VectorContext;
  CanvasImmediateRenderer.prototype = Object.create( VectorContext && VectorContext.prototype );
  CanvasImmediateRenderer.prototype.constructor = CanvasImmediateRenderer;

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  CanvasImmediateRenderer.prototype.drawImages_ = function drawImages_ (flatCoordinates, offset, end, stride) {
    if (!this.image_) {
      return;
    }
    var pixelCoordinates = Object(_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_5__["transform2D"])(
      flatCoordinates, offset, end, 2, this.transform_,
      this.pixelCoordinates_);
    var context = this.context_;
    var localTransform = this.tmpLocalTransform_;
    var alpha = context.globalAlpha;
    if (this.imageOpacity_ != 1) {
      context.globalAlpha = alpha * this.imageOpacity_;
    }
    var rotation = this.imageRotation_;
    if (this.imageRotateWithView_) {
      rotation += this.viewRotation_;
    }
    for (var i = 0, ii = pixelCoordinates.length; i < ii; i += 2) {
      var x = pixelCoordinates[i] - this.imageAnchorX_;
      var y = pixelCoordinates[i + 1] - this.imageAnchorY_;
      if (rotation !== 0 || this.imageScale_ != 1) {
        var centerX = x + this.imageAnchorX_;
        var centerY = y + this.imageAnchorY_;
        Object(_transform_js__WEBPACK_IMPORTED_MODULE_9__["compose"])(localTransform,
          centerX, centerY,
          this.imageScale_, this.imageScale_,
          rotation,
          -centerX, -centerY);
        context.setTransform.apply(context, localTransform);
      }
      context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_,
        this.imageWidth_, this.imageHeight_, x, y,
        this.imageWidth_, this.imageHeight_);
    }
    if (rotation !== 0 || this.imageScale_ != 1) {
      context.setTransform(1, 0, 0, 1, 0, 0);
    }
    if (this.imageOpacity_ != 1) {
      context.globalAlpha = alpha;
    }
  };

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  CanvasImmediateRenderer.prototype.drawText_ = function drawText_ (flatCoordinates, offset, end, stride) {
    if (!this.textState_ || this.text_ === '') {
      return;
    }
    if (this.textFillState_) {
      this.setContextFillState_(this.textFillState_);
    }
    if (this.textStrokeState_) {
      this.setContextStrokeState_(this.textStrokeState_);
    }
    this.setContextTextState_(this.textState_);
    var pixelCoordinates = Object(_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_5__["transform2D"])(
      flatCoordinates, offset, end, stride, this.transform_,
      this.pixelCoordinates_);
    var context = this.context_;
    var rotation = this.textRotation_;
    if (this.textRotateWithView_) {
      rotation += this.viewRotation_;
    }
    for (; offset < end; offset += stride) {
      var x = pixelCoordinates[offset] + this.textOffsetX_;
      var y = pixelCoordinates[offset + 1] + this.textOffsetY_;
      if (rotation !== 0 || this.textScale_ != 1) {
        var localTransform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_9__["compose"])(this.tmpLocalTransform_,
          x, y,
          this.textScale_, this.textScale_,
          rotation,
          -x, -y);
        context.setTransform.apply(context, localTransform);
      }
      if (this.textStrokeState_) {
        context.strokeText(this.text_, x, y);
      }
      if (this.textFillState_) {
        context.fillText(this.text_, x, y);
      }
    }
    if (rotation !== 0 || this.textScale_ != 1) {
      context.setTransform(1, 0, 0, 1, 0, 0);
    }
  };

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} close Close.
   * @private
   * @return {number} end End.
   */
  CanvasImmediateRenderer.prototype.moveToLineTo_ = function moveToLineTo_ (flatCoordinates, offset, end, stride, close) {
    var context = this.context_;
    var pixelCoordinates = Object(_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_5__["transform2D"])(
      flatCoordinates, offset, end, stride, this.transform_,
      this.pixelCoordinates_);
    context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);
    var length = pixelCoordinates.length;
    if (close) {
      length -= 2;
    }
    for (var i = 2; i < length; i += 2) {
      context.lineTo(pixelCoordinates[i], pixelCoordinates[i + 1]);
    }
    if (close) {
      context.closePath();
    }
    return end;
  };

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */
  CanvasImmediateRenderer.prototype.drawRings_ = function drawRings_ (flatCoordinates, offset, ends, stride) {
    for (var i = 0, ii = ends.length; i < ii; ++i) {
      offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, true);
    }
    return offset;
  };

  /**
   * Render a circle geometry into the canvas.  Rendering is immediate and uses
   * the current fill and stroke styles.
   *
   * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
   * @override
   * @api
   */
  CanvasImmediateRenderer.prototype.drawCircle = function drawCircle (geometry) {
    if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["intersects"])(this.extent_, geometry.getExtent())) {
      return;
    }
    if (this.fillState_ || this.strokeState_) {
      if (this.fillState_) {
        this.setContextFillState_(this.fillState_);
      }
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
      }
      var pixelCoordinates = Object(_geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_4__["transformGeom2D"])(
        geometry, this.transform_, this.pixelCoordinates_);
      var dx = pixelCoordinates[2] - pixelCoordinates[0];
      var dy = pixelCoordinates[3] - pixelCoordinates[1];
      var radius = Math.sqrt(dx * dx + dy * dy);
      var context = this.context_;
      context.beginPath();
      context.arc(
        pixelCoordinates[0], pixelCoordinates[1], radius, 0, 2 * Math.PI);
      if (this.fillState_) {
        context.fill();
      }
      if (this.strokeState_) {
        context.stroke();
      }
    }
    if (this.text_ !== '') {
      this.drawText_(geometry.getCenter(), 0, 2, 2);
    }
  };

  /**
   * Set the rendering style.  Note that since this is an immediate rendering API,
   * any `zIndex` on the provided style will be ignored.
   *
   * @param {import("../../style/Style.js").default} style The rendering style.
   * @override
   * @api
   */
  CanvasImmediateRenderer.prototype.setStyle = function setStyle (style) {
    this.setFillStrokeStyle(style.getFill(), style.getStroke());
    this.setImageStyle(style.getImage());
    this.setTextStyle(style.getText());
  };

  /**
   * Render a geometry into the canvas.  Call
   * {@link module:ol/render/canvas/Immediate#setStyle} first to set the rendering style.
   *
   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
   * @override
   * @api
   */
  CanvasImmediateRenderer.prototype.drawGeometry = function drawGeometry (geometry) {
    var type = geometry.getType();
    switch (type) {
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POINT:
        this.drawPoint(/** @type {import("../../geom/Point.js").default} */ (geometry));
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].LINE_STRING:
        this.drawLineString(/** @type {import("../../geom/LineString.js").default} */ (geometry));
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POLYGON:
        this.drawPolygon(/** @type {import("../../geom/Polygon.js").default} */ (geometry));
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].MULTI_POINT:
        this.drawMultiPoint(/** @type {import("../../geom/MultiPoint.js").default} */ (geometry));
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].MULTI_LINE_STRING:
        this.drawMultiLineString(/** @type {import("../../geom/MultiLineString.js").default} */ (geometry));
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].MULTI_POLYGON:
        this.drawMultiPolygon(/** @type {import("../../geom/MultiPolygon.js").default} */ (geometry));
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].GEOMETRY_COLLECTION:
        this.drawGeometryCollection(/** @type {import("../../geom/GeometryCollection.js").default} */ (geometry));
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].CIRCLE:
        this.drawCircle(/** @type {import("../../geom/Circle.js").default} */ (geometry));
        break;
      default:
    }
  };

  /**
   * Render a feature into the canvas.  Note that any `zIndex` on the provided
   * style will be ignored - features are rendered immediately in the order that
   * this method is called.  If you need `zIndex` support, you should be using an
   * {@link module:ol/layer/Vector~VectorLayer} instead.
   *
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {import("../../style/Style.js").default} style Style.
   * @override
   * @api
   */
  CanvasImmediateRenderer.prototype.drawFeature = function drawFeature (feature, style) {
    var geometry = style.getGeometryFunction()(feature);
    if (!geometry || !Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["intersects"])(this.extent_, geometry.getExtent())) {
      return;
    }
    this.setStyle(style);
    this.drawGeometry(geometry);
  };

  /**
   * Render a GeometryCollection to the canvas.  Rendering is immediate and
   * uses the current styles appropriate for each geometry in the collection.
   *
   * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
   * @override
   */
  CanvasImmediateRenderer.prototype.drawGeometryCollection = function drawGeometryCollection (geometry) {
    var geometries = geometry.getGeometriesArray();
    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      this.drawGeometry(geometries[i]);
    }
  };

  /**
   * Render a Point geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
   * @override
   */
  CanvasImmediateRenderer.prototype.drawPoint = function drawPoint (geometry) {
    var flatCoordinates = geometry.getFlatCoordinates();
    var stride = geometry.getStride();
    if (this.image_) {
      this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
    if (this.text_ !== '') {
      this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
  };

  /**
   * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
   * uses the current style.
   *
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
   * @override
   */
  CanvasImmediateRenderer.prototype.drawMultiPoint = function drawMultiPoint (geometry) {
    var flatCoordinates = geometry.getFlatCoordinates();
    var stride = geometry.getStride();
    if (this.image_) {
      this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
    if (this.text_ !== '') {
      this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
  };

  /**
   * Render a LineString into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
   * @override
   */
  CanvasImmediateRenderer.prototype.drawLineString = function drawLineString (geometry) {
    if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["intersects"])(this.extent_, geometry.getExtent())) {
      return;
    }
    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
      var context = this.context_;
      var flatCoordinates = geometry.getFlatCoordinates();
      context.beginPath();
      this.moveToLineTo_(flatCoordinates, 0, flatCoordinates.length,
        geometry.getStride(), false);
      context.stroke();
    }
    if (this.text_ !== '') {
      var flatMidpoint = geometry.getFlatMidpoint();
      this.drawText_(flatMidpoint, 0, 2, 2);
    }
  };

  /**
   * Render a MultiLineString geometry into the canvas.  Rendering is immediate
   * and uses the current style.
   *
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
   * @override
   */
  CanvasImmediateRenderer.prototype.drawMultiLineString = function drawMultiLineString (geometry) {
    var geometryExtent = geometry.getExtent();
    if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["intersects"])(this.extent_, geometryExtent)) {
      return;
    }
    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
      var context = this.context_;
      var flatCoordinates = geometry.getFlatCoordinates();
      var offset = 0;
      var ends = /** @type {Array<number>} */ (geometry.getEnds());
      var stride = geometry.getStride();
      context.beginPath();
      for (var i = 0, ii = ends.length; i < ii; ++i) {
        offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, false);
      }
      context.stroke();
    }
    if (this.text_ !== '') {
      var flatMidpoints = geometry.getFlatMidpoints();
      this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);
    }
  };

  /**
   * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
   * @override
   */
  CanvasImmediateRenderer.prototype.drawPolygon = function drawPolygon (geometry) {
    if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["intersects"])(this.extent_, geometry.getExtent())) {
      return;
    }
    if (this.strokeState_ || this.fillState_) {
      if (this.fillState_) {
        this.setContextFillState_(this.fillState_);
      }
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
      }
      var context = this.context_;
      context.beginPath();
      this.drawRings_(geometry.getOrientedFlatCoordinates(),
        0, /** @type {Array<number>} */ (geometry.getEnds()), geometry.getStride());
      if (this.fillState_) {
        context.fill();
      }
      if (this.strokeState_) {
        context.stroke();
      }
    }
    if (this.text_ !== '') {
      var flatInteriorPoint = geometry.getFlatInteriorPoint();
      this.drawText_(flatInteriorPoint, 0, 2, 2);
    }
  };

  /**
   * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
   * uses the current style.
   * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
   * @override
   */
  CanvasImmediateRenderer.prototype.drawMultiPolygon = function drawMultiPolygon (geometry) {
    if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["intersects"])(this.extent_, geometry.getExtent())) {
      return;
    }
    if (this.strokeState_ || this.fillState_) {
      if (this.fillState_) {
        this.setContextFillState_(this.fillState_);
      }
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
      }
      var context = this.context_;
      var flatCoordinates = geometry.getOrientedFlatCoordinates();
      var offset = 0;
      var endss = geometry.getEndss();
      var stride = geometry.getStride();
      context.beginPath();
      for (var i = 0, ii = endss.length; i < ii; ++i) {
        var ends = endss[i];
        offset = this.drawRings_(flatCoordinates, offset, ends, stride);
      }
      if (this.fillState_) {
        context.fill();
      }
      if (this.strokeState_) {
        context.stroke();
      }
    }
    if (this.text_ !== '') {
      var flatInteriorPoints = geometry.getFlatInteriorPoints();
      this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);
    }
  };

  /**
   * @param {import("../canvas.js").FillState} fillState Fill state.
   * @private
   */
  CanvasImmediateRenderer.prototype.setContextFillState_ = function setContextFillState_ (fillState) {
    var context = this.context_;
    var contextFillState = this.contextFillState_;
    if (!contextFillState) {
      context.fillStyle = fillState.fillStyle;
      this.contextFillState_ = {
        fillStyle: fillState.fillStyle
      };
    } else {
      if (contextFillState.fillStyle != fillState.fillStyle) {
        contextFillState.fillStyle = context.fillStyle = fillState.fillStyle;
      }
    }
  };

  /**
   * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
   * @private
   */
  CanvasImmediateRenderer.prototype.setContextStrokeState_ = function setContextStrokeState_ (strokeState) {
    var context = this.context_;
    var contextStrokeState = this.contextStrokeState_;
    if (!contextStrokeState) {
      context.lineCap = /** @type {CanvasLineCap} */ (strokeState.lineCap);
      if (_has_js__WEBPACK_IMPORTED_MODULE_6__["CANVAS_LINE_DASH"]) {
        context.setLineDash(strokeState.lineDash);
        context.lineDashOffset = strokeState.lineDashOffset;
      }
      context.lineJoin = /** @type {CanvasLineJoin} */ (strokeState.lineJoin);
      context.lineWidth = strokeState.lineWidth;
      context.miterLimit = strokeState.miterLimit;
      context.strokeStyle = strokeState.strokeStyle;
      this.contextStrokeState_ = {
        lineCap: strokeState.lineCap,
        lineDash: strokeState.lineDash,
        lineDashOffset: strokeState.lineDashOffset,
        lineJoin: strokeState.lineJoin,
        lineWidth: strokeState.lineWidth,
        miterLimit: strokeState.miterLimit,
        strokeStyle: strokeState.strokeStyle
      };
    } else {
      if (contextStrokeState.lineCap != strokeState.lineCap) {
        contextStrokeState.lineCap = context.lineCap = /** @type {CanvasLineCap} */ (strokeState.lineCap);
      }
      if (_has_js__WEBPACK_IMPORTED_MODULE_6__["CANVAS_LINE_DASH"]) {
        if (!Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["equals"])(contextStrokeState.lineDash, strokeState.lineDash)) {
          context.setLineDash(contextStrokeState.lineDash = strokeState.lineDash);
        }
        if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {
          contextStrokeState.lineDashOffset = context.lineDashOffset =
              strokeState.lineDashOffset;
        }
      }
      if (contextStrokeState.lineJoin != strokeState.lineJoin) {
        contextStrokeState.lineJoin = context.lineJoin = /** @type {CanvasLineJoin} */ (strokeState.lineJoin);
      }
      if (contextStrokeState.lineWidth != strokeState.lineWidth) {
        contextStrokeState.lineWidth = context.lineWidth = strokeState.lineWidth;
      }
      if (contextStrokeState.miterLimit != strokeState.miterLimit) {
        contextStrokeState.miterLimit = context.miterLimit =
            strokeState.miterLimit;
      }
      if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {
        contextStrokeState.strokeStyle = context.strokeStyle =
            strokeState.strokeStyle;
      }
    }
  };

  /**
   * @param {import("../canvas.js").TextState} textState Text state.
   * @private
   */
  CanvasImmediateRenderer.prototype.setContextTextState_ = function setContextTextState_ (textState) {
    var context = this.context_;
    var contextTextState = this.contextTextState_;
    var textAlign = textState.textAlign ?
      textState.textAlign : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultTextAlign"];
    if (!contextTextState) {
      context.font = textState.font;
      context.textAlign = /** @type {CanvasTextAlign} */ (textAlign);
      context.textBaseline = /** @type {CanvasTextBaseline} */ (textState.textBaseline);
      this.contextTextState_ = {
        font: textState.font,
        textAlign: textAlign,
        textBaseline: textState.textBaseline
      };
    } else {
      if (contextTextState.font != textState.font) {
        contextTextState.font = context.font = textState.font;
      }
      if (contextTextState.textAlign != textAlign) {
        contextTextState.textAlign = context.textAlign = /** @type {CanvasTextAlign} */ (textAlign);
      }
      if (contextTextState.textBaseline != textState.textBaseline) {
        contextTextState.textBaseline = context.textBaseline =
          /** @type {CanvasTextBaseline} */ (textState.textBaseline);
      }
    }
  };

  /**
   * Set the fill and stroke style for subsequent draw operations.  To clear
   * either fill or stroke styles, pass null for the appropriate parameter.
   *
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   * @override
   */
  CanvasImmediateRenderer.prototype.setFillStrokeStyle = function setFillStrokeStyle (fillStyle, strokeStyle) {
    if (!fillStyle) {
      this.fillState_ = null;
    } else {
      var fillStyleColor = fillStyle.getColor();
      this.fillState_ = {
        fillStyle: Object(_colorlike_js__WEBPACK_IMPORTED_MODULE_1__["asColorLike"])(fillStyleColor ?
          fillStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultFillStyle"])
      };
    }
    if (!strokeStyle) {
      this.strokeState_ = null;
    } else {
      var strokeStyleColor = strokeStyle.getColor();
      var strokeStyleLineCap = strokeStyle.getLineCap();
      var strokeStyleLineDash = strokeStyle.getLineDash();
      var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
      var strokeStyleLineJoin = strokeStyle.getLineJoin();
      var strokeStyleWidth = strokeStyle.getWidth();
      var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
      this.strokeState_ = {
        lineCap: strokeStyleLineCap !== undefined ?
          strokeStyleLineCap : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultLineCap"],
        lineDash: strokeStyleLineDash ?
          strokeStyleLineDash : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultLineDash"],
        lineDashOffset: strokeStyleLineDashOffset ?
          strokeStyleLineDashOffset : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultLineDashOffset"],
        lineJoin: strokeStyleLineJoin !== undefined ?
          strokeStyleLineJoin : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultLineJoin"],
        lineWidth: this.pixelRatio_ * (strokeStyleWidth !== undefined ?
          strokeStyleWidth : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultLineWidth"]),
        miterLimit: strokeStyleMiterLimit !== undefined ?
          strokeStyleMiterLimit : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultMiterLimit"],
        strokeStyle: Object(_colorlike_js__WEBPACK_IMPORTED_MODULE_1__["asColorLike"])(strokeStyleColor ?
          strokeStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultStrokeStyle"])
      };
    }
  };

  /**
   * Set the image style for subsequent draw operations.  Pass null to remove
   * the image style.
   *
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   * @override
   */
  CanvasImmediateRenderer.prototype.setImageStyle = function setImageStyle (imageStyle) {
    if (!imageStyle) {
      this.image_ = null;
    } else {
      var imageAnchor = imageStyle.getAnchor();
      // FIXME pixel ratio
      var imageImage = imageStyle.getImage(1);
      var imageOrigin = imageStyle.getOrigin();
      var imageSize = imageStyle.getSize();
      this.imageAnchorX_ = imageAnchor[0];
      this.imageAnchorY_ = imageAnchor[1];
      this.imageHeight_ = imageSize[1];
      this.image_ = imageImage;
      this.imageOpacity_ = imageStyle.getOpacity();
      this.imageOriginX_ = imageOrigin[0];
      this.imageOriginY_ = imageOrigin[1];
      this.imageRotateWithView_ = imageStyle.getRotateWithView();
      this.imageRotation_ = imageStyle.getRotation();
      this.imageScale_ = imageStyle.getScale() * this.pixelRatio_;
      this.imageWidth_ = imageSize[0];
    }
  };

  /**
   * Set the text style for subsequent draw operations.  Pass null to
   * remove the text style.
   *
   * @param {import("../../style/Text.js").default} textStyle Text style.
   * @override
   */
  CanvasImmediateRenderer.prototype.setTextStyle = function setTextStyle (textStyle) {
    if (!textStyle) {
      this.text_ = '';
    } else {
      var textFillStyle = textStyle.getFill();
      if (!textFillStyle) {
        this.textFillState_ = null;
      } else {
        var textFillStyleColor = textFillStyle.getColor();
        this.textFillState_ = {
          fillStyle: Object(_colorlike_js__WEBPACK_IMPORTED_MODULE_1__["asColorLike"])(textFillStyleColor ?
            textFillStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultFillStyle"])
        };
      }
      var textStrokeStyle = textStyle.getStroke();
      if (!textStrokeStyle) {
        this.textStrokeState_ = null;
      } else {
        var textStrokeStyleColor = textStrokeStyle.getColor();
        var textStrokeStyleLineCap = textStrokeStyle.getLineCap();
        var textStrokeStyleLineDash = textStrokeStyle.getLineDash();
        var textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();
        var textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
        var textStrokeStyleWidth = textStrokeStyle.getWidth();
        var textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
        this.textStrokeState_ = {
          lineCap: textStrokeStyleLineCap !== undefined ?
            textStrokeStyleLineCap : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultLineCap"],
          lineDash: textStrokeStyleLineDash ?
            textStrokeStyleLineDash : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultLineDash"],
          lineDashOffset: textStrokeStyleLineDashOffset ?
            textStrokeStyleLineDashOffset : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultLineDashOffset"],
          lineJoin: textStrokeStyleLineJoin !== undefined ?
            textStrokeStyleLineJoin : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultLineJoin"],
          lineWidth: textStrokeStyleWidth !== undefined ?
            textStrokeStyleWidth : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultLineWidth"],
          miterLimit: textStrokeStyleMiterLimit !== undefined ?
            textStrokeStyleMiterLimit : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultMiterLimit"],
          strokeStyle: Object(_colorlike_js__WEBPACK_IMPORTED_MODULE_1__["asColorLike"])(textStrokeStyleColor ?
            textStrokeStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultStrokeStyle"])
        };
      }
      var textFont = textStyle.getFont();
      var textOffsetX = textStyle.getOffsetX();
      var textOffsetY = textStyle.getOffsetY();
      var textRotateWithView = textStyle.getRotateWithView();
      var textRotation = textStyle.getRotation();
      var textScale = textStyle.getScale();
      var textText = textStyle.getText();
      var textTextAlign = textStyle.getTextAlign();
      var textTextBaseline = textStyle.getTextBaseline();
      this.textState_ = {
        font: textFont !== undefined ?
          textFont : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultFont"],
        textAlign: textTextAlign !== undefined ?
          textTextAlign : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultTextAlign"],
        textBaseline: textTextBaseline !== undefined ?
          textTextBaseline : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultTextBaseline"]
      };
      this.text_ = textText !== undefined ? textText : '';
      this.textOffsetX_ =
          textOffsetX !== undefined ? (this.pixelRatio_ * textOffsetX) : 0;
      this.textOffsetY_ =
          textOffsetY !== undefined ? (this.pixelRatio_ * textOffsetY) : 0;
      this.textRotateWithView_ = textRotateWithView !== undefined ? textRotateWithView : false;
      this.textRotation_ = textRotation !== undefined ? textRotation : 0;
      this.textScale_ = this.pixelRatio_ * (textScale !== undefined ?
        textScale : 1);
    }
  };

  return CanvasImmediateRenderer;
}(_VectorContext_js__WEBPACK_IMPORTED_MODULE_7__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (CanvasImmediateRenderer);

//# sourceMappingURL=Immediate.js.map

/***/ }),

/***/ "./node_modules/ol/renderer/Layer.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/renderer/Layer.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ImageState.js */ "./node_modules/ol/ImageState.js");
/* harmony import */ var _Observable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Observable.js */ "./node_modules/ol/Observable.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _source_State_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../source/State.js */ "./node_modules/ol/source/State.js");
/**
 * @module ol/renderer/Layer
 */








var LayerRenderer = /*@__PURE__*/(function (Observable) {
  function LayerRenderer(layer) {

    Observable.call(this);

    /**
     * @private
     * @type {import("../layer/Layer.js").default}
     */
    this.layer_ = layer;

  }

  if ( Observable ) LayerRenderer.__proto__ = Observable;
  LayerRenderer.prototype = Object.create( Observable && Observable.prototype );
  LayerRenderer.prototype.constructor = LayerRenderer;

  /**
   * Create a function that adds loaded tiles to the tile lookup.
   * @param {import("../source/Tile.js").default} source Tile source.
   * @param {import("../proj/Projection.js").default} projection Projection of the tiles.
   * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @return {function(number, import("../TileRange.js").default):boolean} A function that can be
   *     called with a zoom level and a tile range to add loaded tiles to the lookup.
   * @protected
   */
  LayerRenderer.prototype.createLoadedTileFinder = function createLoadedTileFinder (source, projection, tiles) {
    return (
      /**
       * @param {number} zoom Zoom level.
       * @param {import("../TileRange.js").default} tileRange Tile range.
       * @return {boolean} The tile range is fully loaded.
       */
      function(zoom, tileRange) {
        /**
         * @param {import("../Tile.js").default} tile Tile.
         */
        function callback(tile) {
          if (!tiles[zoom]) {
            tiles[zoom] = {};
          }
          tiles[zoom][tile.tileCoord.toString()] = tile;
        }
        return source.forEachLoadedTile(projection, zoom, tileRange, callback);
      }
    );
  };

  /**
   * @abstract
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(import("../Feature.js").FeatureLike, import("../layer/Layer.js").default): T} callback Feature callback.
   * @return {T|void} Callback result.
   * @template T
   */
  LayerRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate (coordinate, frameState, hitTolerance, callback) {};

  /**
   * @return {import("../layer/Layer.js").default} Layer.
   */
  LayerRenderer.prototype.getLayer = function getLayer () {
    return this.layer_;
  };

  /**
   * Handle changes in image state.
   * @param {import("../events/Event.js").default} event Image change event.
   * @private
   */
  LayerRenderer.prototype.handleImageChange_ = function handleImageChange_ (event) {
    var image = /** @type {import("../Image.js").default} */ (event.target);
    if (image.getState() === _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED) {
      this.renderIfReadyAndVisible();
    }
  };

  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @return {boolean} Is there a feature at the given coordinate?
   */
  LayerRenderer.prototype.hasFeatureAtCoordinate = function hasFeatureAtCoordinate (coordinate, frameState) {
    return false;
  };

  /**
   * Load the image if not already loaded, and register the image change
   * listener if needed.
   * @param {import("../ImageBase.js").default} image Image.
   * @return {boolean} `true` if the image is already loaded, `false` otherwise.
   * @protected
   */
  LayerRenderer.prototype.loadImage = function loadImage (image) {
    var imageState = image.getState();
    if (imageState != _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED && imageState != _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_4__["listen"])(image, _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].CHANGE, this.handleImageChange_, this);
    }
    if (imageState == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE) {
      image.load();
      imageState = image.getState();
    }
    return imageState == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;
  };

  /**
   * @protected
   */
  LayerRenderer.prototype.renderIfReadyAndVisible = function renderIfReadyAndVisible () {
    var layer = this.getLayer();
    if (layer.getVisible() && layer.getSourceState() == _source_State_js__WEBPACK_IMPORTED_MODULE_6__["default"].READY) {
      this.changed();
    }
  };

  /**
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../source/Tile.js").default} tileSource Tile source.
   * @protected
   */
  LayerRenderer.prototype.scheduleExpireCache = function scheduleExpireCache (frameState, tileSource) {
    if (tileSource.canExpireCache()) {
      /**
       * @param {import("../source/Tile.js").default} tileSource Tile source.
       * @param {import("../PluggableMap.js").default} map Map.
       * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
       */
      var postRenderFunction = function(tileSource, map, frameState) {
        var tileSourceKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(tileSource);
        if (tileSourceKey in frameState.usedTiles) {
          tileSource.expireCache(frameState.viewState.projection,
            frameState.usedTiles[tileSourceKey]);
        }
      }.bind(null, tileSource);

      frameState.postRenderFunctions.push(
        /** @type {import("../PluggableMap.js").PostRenderFunction} */ (postRenderFunction)
      );
    }
  };

  /**
   * @param {!Object<string, !Object<string, import("../TileRange.js").default>>} usedTiles Used tiles.
   * @param {import("../source/Tile.js").default} tileSource Tile source.
   * @param {number} z Z.
   * @param {import("../TileRange.js").default} tileRange Tile range.
   * @protected
   */
  LayerRenderer.prototype.updateUsedTiles = function updateUsedTiles (usedTiles, tileSource, z, tileRange) {
    // FIXME should we use tilesToDrawByZ instead?
    var tileSourceKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(tileSource);
    var zKey = z.toString();
    if (tileSourceKey in usedTiles) {
      if (zKey in usedTiles[tileSourceKey]) {
        usedTiles[tileSourceKey][zKey].extend(tileRange);
      } else {
        usedTiles[tileSourceKey][zKey] = tileRange;
      }
    } else {
      usedTiles[tileSourceKey] = {};
      usedTiles[tileSourceKey][zKey] = tileRange;
    }
  };

  /**
   * Manage tile pyramid.
   * This function performs a number of functions related to the tiles at the
   * current zoom and lower zoom levels:
   * - registers idle tiles in frameState.wantedTiles so that they are not
   *   discarded by the tile queue
   * - enqueues missing tiles
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../source/Tile.js").default} tileSource Tile source.
   * @param {import("../tilegrid/TileGrid.js").default} tileGrid Tile grid.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} currentZ Current Z.
   * @param {number} preload Load low resolution tiles up to 'preload' levels.
   * @param {function(this: T, import("../Tile.js").default)=} opt_tileCallback Tile callback.
   * @param {T=} opt_this Object to use as `this` in `opt_tileCallback`.
   * @protected
   * @template T
   */
  LayerRenderer.prototype.manageTilePyramid = function manageTilePyramid (
    frameState,
    tileSource,
    tileGrid,
    pixelRatio,
    projection,
    extent,
    currentZ,
    preload,
    opt_tileCallback,
    opt_this
  ) {
    var tileSourceKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(tileSource);
    if (!(tileSourceKey in frameState.wantedTiles)) {
      frameState.wantedTiles[tileSourceKey] = {};
    }
    var wantedTiles = frameState.wantedTiles[tileSourceKey];
    var tileQueue = frameState.tileQueue;
    var minZoom = tileGrid.getMinZoom();
    var tile, tileRange, tileResolution, x, y, z;
    for (z = minZoom; z <= currentZ; ++z) {
      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);
      tileResolution = tileGrid.getResolution(z);
      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
          if (currentZ - z <= preload) {
            tile = tileSource.getTile(z, x, y, pixelRatio, projection);
            if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_3__["default"].IDLE) {
              wantedTiles[tile.getKey()] = true;
              if (!tileQueue.isKeyQueued(tile.getKey())) {
                tileQueue.enqueue([tile, tileSourceKey,
                  tileGrid.getTileCoordCenter(tile.tileCoord), tileResolution]);
              }
            }
            if (opt_tileCallback !== undefined) {
              opt_tileCallback.call(opt_this, tile);
            }
          } else {
            tileSource.useTile(z, x, y, projection);
          }
        }
      }
    }
  };

  return LayerRenderer;
}(_Observable_js__WEBPACK_IMPORTED_MODULE_2__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (LayerRenderer);

//# sourceMappingURL=Layer.js.map

/***/ }),

/***/ "./node_modules/ol/renderer/Map.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/renderer/Map.js ***!
  \*****************************************/
/*! exports provided: sortByZIndex, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sortByZIndex", function() { return sortByZIndex; });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _Disposable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Disposable.js */ "./node_modules/ol/Disposable.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _layer_Layer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../layer/Layer.js */ "./node_modules/ol/layer/Layer.js");
/* harmony import */ var _style_IconImageCache_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../style/IconImageCache.js */ "./node_modules/ol/style/IconImageCache.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/renderer/Map
 */










/**
 * @abstract
 */
var MapRenderer = /*@__PURE__*/(function (Disposable) {
  function MapRenderer(map) {
    Disposable.call(this);

    /**
     * @private
     * @type {import("../PluggableMap.js").default}
     */
    this.map_ = map;

    /**
     * @private
     * @type {!Object<string, import("./Layer.js").default>}
     */
    this.layerRenderers_ = {};

    /**
     * @private
     * @type {Object<string, import("../events.js").EventsKey>}
     */
    this.layerRendererListeners_ = {};

    /**
     * @private
     * @type {Array<typeof import("./Layer.js").default>}
     */
    this.layerRendererConstructors_ = [];

  }

  if ( Disposable ) MapRenderer.__proto__ = Disposable;
  MapRenderer.prototype = Object.create( Disposable && Disposable.prototype );
  MapRenderer.prototype.constructor = MapRenderer;

  /**
   * @abstract
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   */
  MapRenderer.prototype.dispatchRenderEvent = function dispatchRenderEvent (type, frameState) {
    Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Register layer renderer constructors.
   * @param {Array<typeof import("./Layer.js").default>} constructors Layer renderers.
   */
  MapRenderer.prototype.registerLayerRenderers = function registerLayerRenderers (constructors) {
    this.layerRendererConstructors_.push.apply(this.layerRendererConstructors_, constructors);
  };

  /**
   * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
   * @protected
   */
  MapRenderer.prototype.calculateMatrices2D = function calculateMatrices2D (frameState) {
    var viewState = frameState.viewState;
    var coordinateToPixelTransform = frameState.coordinateToPixelTransform;
    var pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;

    Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["compose"])(coordinateToPixelTransform,
      frameState.size[0] / 2, frameState.size[1] / 2,
      1 / viewState.resolution, -1 / viewState.resolution,
      -viewState.rotation,
      -viewState.center[0], -viewState.center[1]);

    Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["invert"])(
      Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["setFromArray"])(pixelToCoordinateTransform, coordinateToPixelTransform));
  };

  /**
   * Removes all layer renderers.
   */
  MapRenderer.prototype.removeLayerRenderers = function removeLayerRenderers () {
    for (var key in this.layerRenderers_) {
      this.removeLayerRendererByKey_(key).dispose();
    }
  };

  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(this: S, import("../Feature.js").FeatureLike,
   *     import("../layer/Layer.js").default): T} callback Feature callback.
   * @param {S} thisArg Value to use as `this` when executing `callback`.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
   * @return {T|undefined} Callback result.
   * @template S,T,U
   */
  MapRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate (
    coordinate,
    frameState,
    hitTolerance,
    callback,
    thisArg,
    layerFilter,
    thisArg2
  ) {
    var result;
    var viewState = frameState.viewState;
    var viewResolution = viewState.resolution;

    /**
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {import("../layer/Layer.js").default} layer Layer.
     * @return {?} Callback result.
     */
    function forEachFeatureAtCoordinate(feature, layer) {
      var managed = frameState.layerStates[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(layer)].managed;
      if (!(Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature) in frameState.skippedFeatureUids && !managed)) {
        return callback.call(thisArg, feature, managed ? layer : null);
      }
    }

    var projection = viewState.projection;

    var translatedCoordinate = coordinate;
    if (projection.canWrapX()) {
      var projectionExtent = projection.getExtent();
      var worldWidth = Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["getWidth"])(projectionExtent);
      var x = coordinate[0];
      if (x < projectionExtent[0] || x > projectionExtent[2]) {
        var worldsAway = Math.ceil((projectionExtent[0] - x) / worldWidth);
        translatedCoordinate = [x + worldWidth * worldsAway, coordinate[1]];
      }
    }

    var layerStates = frameState.layerStatesArray;
    var numLayers = layerStates.length;
    var i;
    for (i = numLayers - 1; i >= 0; --i) {
      var layerState = layerStates[i];
      var layer = layerState.layer;
      if (Object(_layer_Layer_js__WEBPACK_IMPORTED_MODULE_6__["visibleAtResolution"])(layerState, viewResolution) && layerFilter.call(thisArg2, layer)) {
        var layerRenderer = this.getLayerRenderer(layer);
        var source = /** @type {import("../layer/Layer.js").default} */ (layer).getSource();
        if (source) {
          result = layerRenderer.forEachFeatureAtCoordinate(
            source.getWrapX() ? translatedCoordinate : coordinate,
            frameState, hitTolerance, forEachFeatureAtCoordinate);
        }
        if (result) {
          return result;
        }
      }
    }
    return undefined;
  };

  /**
   * @abstract
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(this: S, import("../layer/Layer.js").default, (Uint8ClampedArray|Uint8Array)): T} callback Layer
   *     callback.
   * @param {S} thisArg Value to use as `this` when executing `callback`.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
   * @return {T|undefined} Callback result.
   * @template S,T,U
   */
  MapRenderer.prototype.forEachLayerAtPixel = function forEachLayerAtPixel (pixel, frameState, hitTolerance, callback, thisArg, layerFilter, thisArg2) {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
   * @return {boolean} Is there a feature at the given coordinate?
   * @template U
   */
  MapRenderer.prototype.hasFeatureAtCoordinate = function hasFeatureAtCoordinate (coordinate, frameState, hitTolerance, layerFilter, thisArg) {
    var hasFeature = this.forEachFeatureAtCoordinate(
      coordinate, frameState, hitTolerance, _functions_js__WEBPACK_IMPORTED_MODULE_5__["TRUE"], this, layerFilter, thisArg);

    return hasFeature !== undefined;
  };

  /**
   * @param {import("../layer/Base.js").default} layer Layer.
   * @protected
   * @return {import("./Layer.js").default} Layer renderer.
   */
  MapRenderer.prototype.getLayerRenderer = function getLayerRenderer (layer) {
    var layerKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(layer);
    if (layerKey in this.layerRenderers_) {
      return this.layerRenderers_[layerKey];
    } else {
      var renderer;
      for (var i = 0, ii = this.layerRendererConstructors_.length; i < ii; ++i) {
        var candidate = this.layerRendererConstructors_[i];
        if (candidate['handles'](layer)) {
          renderer = candidate['create'](this, layer);
          break;
        }
      }
      if (renderer) {
        this.layerRenderers_[layerKey] = renderer;
        this.layerRendererListeners_[layerKey] = Object(_events_js__WEBPACK_IMPORTED_MODULE_2__["listen"])(renderer,
          _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].CHANGE, this.handleLayerRendererChange_, this);
      } else {
        throw new Error('Unable to create renderer for layer: ' + layer.getType());
      }
      return renderer;
    }
  };

  /**
   * @param {string} layerKey Layer key.
   * @protected
   * @return {import("./Layer.js").default} Layer renderer.
   */
  MapRenderer.prototype.getLayerRendererByKey = function getLayerRendererByKey (layerKey) {
    return this.layerRenderers_[layerKey];
  };

  /**
   * @protected
   * @return {Object<string, import("./Layer.js").default>} Layer renderers.
   */
  MapRenderer.prototype.getLayerRenderers = function getLayerRenderers () {
    return this.layerRenderers_;
  };

  /**
   * @return {import("../PluggableMap.js").default} Map.
   */
  MapRenderer.prototype.getMap = function getMap () {
    return this.map_;
  };

  /**
   * Handle changes in a layer renderer.
   * @private
   */
  MapRenderer.prototype.handleLayerRendererChange_ = function handleLayerRendererChange_ () {
    this.map_.render();
  };

  /**
   * @param {string} layerKey Layer key.
   * @return {import("./Layer.js").default} Layer renderer.
   * @private
   */
  MapRenderer.prototype.removeLayerRendererByKey_ = function removeLayerRendererByKey_ (layerKey) {
    var layerRenderer = this.layerRenderers_[layerKey];
    delete this.layerRenderers_[layerKey];

    Object(_events_js__WEBPACK_IMPORTED_MODULE_2__["unlistenByKey"])(this.layerRendererListeners_[layerKey]);
    delete this.layerRendererListeners_[layerKey];

    return layerRenderer;
  };

  /**
   * @param {import("../PluggableMap.js").default} map Map.
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @private
   */
  MapRenderer.prototype.removeUnusedLayerRenderers_ = function removeUnusedLayerRenderers_ (map, frameState) {
    for (var layerKey in this.layerRenderers_) {
      if (!frameState || !(layerKey in frameState.layerStates)) {
        this.removeLayerRendererByKey_(layerKey).dispose();
      }
    }
  };

  /**
   * Render.
   * @abstract
   * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
   */
  MapRenderer.prototype.renderFrame = function renderFrame (frameState) {
    Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @protected
   */
  MapRenderer.prototype.scheduleExpireIconCache = function scheduleExpireIconCache (frameState) {
    frameState.postRenderFunctions.push(/** @type {import("../PluggableMap.js").PostRenderFunction} */ (expireIconCache));
  };

  /**
   * @param {!import("../PluggableMap.js").FrameState} frameState Frame state.
   * @protected
   */
  MapRenderer.prototype.scheduleRemoveUnusedLayerRenderers = function scheduleRemoveUnusedLayerRenderers (frameState) {
    for (var layerKey in this.layerRenderers_) {
      if (!(layerKey in frameState.layerStates)) {
        frameState.postRenderFunctions.push(
          /** @type {import("../PluggableMap.js").PostRenderFunction} */ (this.removeUnusedLayerRenderers_.bind(this))
        );
        return;
      }
    }
  };

  return MapRenderer;
}(_Disposable_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/**
 * @param {import("../PluggableMap.js").default} map Map.
 * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
 */
function expireIconCache(map, frameState) {
  _style_IconImageCache_js__WEBPACK_IMPORTED_MODULE_7__["shared"].expire();
}


/**
 * @param {import("../layer/Layer.js").State} state1 First layer state.
 * @param {import("../layer/Layer.js").State} state2 Second layer state.
 * @return {number} The zIndex difference.
 */
function sortByZIndex(state1, state2) {
  return state1.zIndex - state2.zIndex;
}
/* harmony default export */ __webpack_exports__["default"] = (MapRenderer);

//# sourceMappingURL=Map.js.map

/***/ }),

/***/ "./node_modules/ol/renderer/canvas/ImageLayer.js":
/*!*******************************************************!*\
  !*** ./node_modules/ol/renderer/canvas/ImageLayer.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _reproj_common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../reproj/common.js */ "./node_modules/ol/reproj/common.js");
/* harmony import */ var _ImageCanvas_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../ImageCanvas.js */ "./node_modules/ol/ImageCanvas.js");
/* harmony import */ var _LayerType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../LayerType.js */ "./node_modules/ol/LayerType.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _layer_VectorRenderType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../layer/VectorRenderType.js */ "./node_modules/ol/layer/VectorRenderType.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _Map_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Map.js */ "./node_modules/ol/renderer/canvas/Map.js");
/* harmony import */ var _IntermediateCanvas_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./IntermediateCanvas.js */ "./node_modules/ol/renderer/canvas/IntermediateCanvas.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/renderer/canvas/ImageLayer
 */












/**
 * @classdesc
 * Canvas renderer for image layers.
 * @api
 */
var CanvasImageLayerRenderer = /*@__PURE__*/(function (IntermediateCanvasRenderer) {
  function CanvasImageLayerRenderer(imageLayer) {

    IntermediateCanvasRenderer.call(this, imageLayer);

    /**
     * @private
     * @type {?import("../../ImageBase.js").default}
     */
    this.image_ = null;

    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    this.imageTransform_ = Object(_transform_js__WEBPACK_IMPORTED_MODULE_10__["create"])();

    /**
     * @type {!Array<string>}
     */
    this.skippedFeatures_ = [];

    /**
     * @private
     * @type {import("./VectorLayer.js").default}
     */
    this.vectorRenderer_ = null;

    if (imageLayer.getType() === _LayerType_js__WEBPACK_IMPORTED_MODULE_2__["default"].VECTOR) {
      for (var i = 0, ii = _Map_js__WEBPACK_IMPORTED_MODULE_8__["layerRendererConstructors"].length; i < ii; ++i) {
        var ctor = _Map_js__WEBPACK_IMPORTED_MODULE_8__["layerRendererConstructors"][i];
        if (ctor !== CanvasImageLayerRenderer && ctor['handles'](imageLayer)) {
          this.vectorRenderer_ = /** @type {import("./VectorLayer.js").default} */ (new ctor(imageLayer));
          break;
        }
      }
    }

  }

  if ( IntermediateCanvasRenderer ) CanvasImageLayerRenderer.__proto__ = IntermediateCanvasRenderer;
  CanvasImageLayerRenderer.prototype = Object.create( IntermediateCanvasRenderer && IntermediateCanvasRenderer.prototype );
  CanvasImageLayerRenderer.prototype.constructor = CanvasImageLayerRenderer;

  /**
   * @inheritDoc
   */
  CanvasImageLayerRenderer.prototype.disposeInternal = function disposeInternal () {
    if (this.vectorRenderer_) {
      this.vectorRenderer_.dispose();
    }
    IntermediateCanvasRenderer.prototype.disposeInternal.call(this);
  };

  /**
   * @inheritDoc
   */
  CanvasImageLayerRenderer.prototype.getImage = function getImage () {
    return !this.image_ ? null : this.image_.getImage();
  };

  /**
   * @inheritDoc
   */
  CanvasImageLayerRenderer.prototype.getImageTransform = function getImageTransform () {
    return this.imageTransform_;
  };

  /**
   * @inheritDoc
   */
  CanvasImageLayerRenderer.prototype.prepareFrame = function prepareFrame (frameState, layerState) {

    var pixelRatio = frameState.pixelRatio;
    var size = frameState.size;
    var viewState = frameState.viewState;
    var viewCenter = viewState.center;
    var viewResolution = viewState.resolution;

    var image;
    var imageLayer = /** @type {import("../../layer/Image.js").default} */ (this.getLayer());
    var imageSource = /** @type {import("../../source/Image.js").default} */ (imageLayer.getSource());

    var hints = frameState.viewHints;

    var vectorRenderer = this.vectorRenderer_;
    var renderedExtent = frameState.extent;
    if (!vectorRenderer && layerState.extent !== undefined) {
      renderedExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getIntersection"])(renderedExtent, layerState.extent);
    }

    if (!hints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_3__["default"].ANIMATING] && !hints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_3__["default"].INTERACTING] &&
        !Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["isEmpty"])(renderedExtent)) {
      var projection = viewState.projection;
      if (!_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"]) {
        var sourceProjection = imageSource.getProjection();
        if (sourceProjection) {
          projection = sourceProjection;
        }
      }
      var skippedFeatures = this.skippedFeatures_;
      if (vectorRenderer) {
        var context = vectorRenderer.context;
        var imageFrameState = /** @type {import("../../PluggableMap.js").FrameState} */ (Object(_obj_js__WEBPACK_IMPORTED_MODULE_7__["assign"])({}, frameState, {
          size: [
            Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getWidth"])(renderedExtent) / viewResolution,
            Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getHeight"])(renderedExtent) / viewResolution
          ],
          viewState: /** @type {import("../../View.js").State} */ (Object(_obj_js__WEBPACK_IMPORTED_MODULE_7__["assign"])({}, frameState.viewState, {
            rotation: 0
          }))
        }));
        var newSkippedFeatures = Object.keys(imageFrameState.skippedFeatureUids).sort();
        image = new _ImageCanvas_js__WEBPACK_IMPORTED_MODULE_1__["default"](renderedExtent, viewResolution, pixelRatio, context.canvas, function(callback) {
          if (vectorRenderer.prepareFrame(imageFrameState, layerState) &&
              (vectorRenderer.replayGroupChanged ||
              !Object(_array_js__WEBPACK_IMPORTED_MODULE_4__["equals"])(skippedFeatures, newSkippedFeatures))) {
            context.canvas.width = imageFrameState.size[0] * pixelRatio;
            context.canvas.height = imageFrameState.size[1] * pixelRatio;
            vectorRenderer.compose(context, imageFrameState, layerState);
            skippedFeatures = newSkippedFeatures;
            callback();
          }
        });
      } else {
        image = imageSource.getImage(
          renderedExtent, viewResolution, pixelRatio, projection);
      }
      if (image && this.loadImage(image)) {
        this.image_ = image;
        this.skippedFeatures_ = skippedFeatures;
      }
    }

    if (this.image_) {
      image = this.image_;
      var imageExtent = image.getExtent();
      var imageResolution = image.getResolution();
      var imagePixelRatio = image.getPixelRatio();
      var scale = pixelRatio * imageResolution /
          (viewResolution * imagePixelRatio);
      var transform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_10__["compose"])(this.imageTransform_,
        pixelRatio * size[0] / 2, pixelRatio * size[1] / 2,
        scale, scale,
        0,
        imagePixelRatio * (imageExtent[0] - viewCenter[0]) / imageResolution,
        imagePixelRatio * (viewCenter[1] - imageExtent[3]) / imageResolution);
      Object(_transform_js__WEBPACK_IMPORTED_MODULE_10__["compose"])(this.coordinateToCanvasPixelTransform,
        pixelRatio * size[0] / 2 - transform[4], pixelRatio * size[1] / 2 - transform[5],
        pixelRatio / viewResolution, -pixelRatio / viewResolution,
        0,
        -viewCenter[0], -viewCenter[1]);

      this.renderedResolution = imageResolution * pixelRatio / imagePixelRatio;
    }

    return !!this.image_;
  };

  /**
   * @inheritDoc
   */
  CanvasImageLayerRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate (coordinate, frameState, hitTolerance, callback) {
    if (this.vectorRenderer_) {
      return this.vectorRenderer_.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback);
    } else {
      return IntermediateCanvasRenderer.prototype.forEachFeatureAtCoordinate.call(this, coordinate, frameState, hitTolerance, callback);
    }
  };

  return CanvasImageLayerRenderer;
}(_IntermediateCanvas_js__WEBPACK_IMPORTED_MODULE_9__["default"]));


/**
 * Determine if this renderer handles the provided layer.
 * @param {import("../../layer/Layer.js").default} layer The candidate layer.
 * @return {boolean} The renderer can render the layer.
 */
CanvasImageLayerRenderer['handles'] = function(layer) {
  return layer.getType() === _LayerType_js__WEBPACK_IMPORTED_MODULE_2__["default"].IMAGE ||
    layer.getType() === _LayerType_js__WEBPACK_IMPORTED_MODULE_2__["default"].VECTOR &&
    /** @type {import("../../layer/Vector.js").default} */ (layer).getRenderMode() === _layer_VectorRenderType_js__WEBPACK_IMPORTED_MODULE_6__["default"].IMAGE;
};


/**
 * Create a layer renderer.
 * @param {import("../Map.js").default} mapRenderer The map renderer.
 * @param {import("../../layer/Layer.js").default} layer The layer to be rendererd.
 * @return {CanvasImageLayerRenderer} The layer renderer.
 */
CanvasImageLayerRenderer['create'] = function(mapRenderer, layer) {
  return new CanvasImageLayerRenderer(/** @type {import("../../layer/Image.js").default} */ (layer));
};


/* harmony default export */ __webpack_exports__["default"] = (CanvasImageLayerRenderer);

//# sourceMappingURL=ImageLayer.js.map

/***/ }),

/***/ "./node_modules/ol/renderer/canvas/IntermediateCanvas.js":
/*!***************************************************************!*\
  !*** ./node_modules/ol/renderer/canvas/IntermediateCanvas.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../coordinate.js */ "./node_modules/ol/coordinate.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Layer.js */ "./node_modules/ol/renderer/canvas/Layer.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/renderer/canvas/IntermediateCanvas
 */







/**
 * @abstract
 */
var IntermediateCanvasRenderer = /*@__PURE__*/(function (CanvasLayerRenderer) {
  function IntermediateCanvasRenderer(layer) {

    CanvasLayerRenderer.call(this, layer);

    /**
     * @protected
     * @type {import("../../transform.js").Transform}
     */
    this.coordinateToCanvasPixelTransform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_5__["create"])();

    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */
    this.hitCanvasContext_ = null;

  }

  if ( CanvasLayerRenderer ) IntermediateCanvasRenderer.__proto__ = CanvasLayerRenderer;
  IntermediateCanvasRenderer.prototype = Object.create( CanvasLayerRenderer && CanvasLayerRenderer.prototype );
  IntermediateCanvasRenderer.prototype.constructor = IntermediateCanvasRenderer;

  /**
   * @inheritDoc
   */
  IntermediateCanvasRenderer.prototype.composeFrame = function composeFrame (frameState, layerState, context) {

    this.preCompose(context, frameState);

    var image = this.getImage();
    if (image) {

      // clipped rendering if layer extent is set
      var extent = layerState.extent;
      var clipped = extent !== undefined &&
          !Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["containsExtent"])(extent, frameState.extent) &&
          Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["intersects"])(extent, frameState.extent);
      if (clipped) {
        this.clip(context, frameState, /** @type {import("../../extent.js").Extent} */ (extent));
      }

      var imageTransform = this.getImageTransform();
      // for performance reasons, context.save / context.restore is not used
      // to save and restore the transformation matrix and the opacity.
      // see http://jsperf.com/context-save-restore-versus-variable
      var alpha = context.globalAlpha;
      context.globalAlpha = layerState.opacity;

      // for performance reasons, context.setTransform is only used
      // when the view is rotated. see http://jsperf.com/canvas-transform
      var dx = imageTransform[4];
      var dy = imageTransform[5];
      var dw = image.width * imageTransform[0];
      var dh = image.height * imageTransform[3];
      if (dw >= 0.5 && dh >= 0.5) {
        context.drawImage(image, 0, 0, +image.width, +image.height,
          Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));
      }
      context.globalAlpha = alpha;

      if (clipped) {
        context.restore();
      }
    }

    this.postCompose(context, frameState, layerState);
  };

  /**
   * @abstract
   * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Canvas.
   */
  IntermediateCanvasRenderer.prototype.getImage = function getImage () {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * @abstract
   * @return {!import("../../transform.js").Transform} Image transform.
   */
  IntermediateCanvasRenderer.prototype.getImageTransform = function getImageTransform () {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * @inheritDoc
   */
  IntermediateCanvasRenderer.prototype.forEachLayerAtCoordinate = function forEachLayerAtCoordinate (coordinate, frameState, hitTolerance, callback, thisArg) {
    if (!this.getImage()) {
      return undefined;
    }

    var pixel = Object(_transform_js__WEBPACK_IMPORTED_MODULE_5__["apply"])(this.coordinateToCanvasPixelTransform, coordinate.slice());
    Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_1__["scale"])(pixel, frameState.viewState.resolution / this.renderedResolution);

    if (!this.hitCanvasContext_) {
      this.hitCanvasContext_ = Object(_dom_js__WEBPACK_IMPORTED_MODULE_2__["createCanvasContext2D"])(1, 1);
    }

    this.hitCanvasContext_.clearRect(0, 0, 1, 1);
    this.hitCanvasContext_.drawImage(this.getImage(), pixel[0], pixel[1], 1, 1, 0, 0, 1, 1);

    var imageData = this.hitCanvasContext_.getImageData(0, 0, 1, 1).data;
    if (imageData[3] > 0) {
      return callback.call(thisArg, this.getLayer(), imageData);
    } else {
      return undefined;
    }
  };

  return IntermediateCanvasRenderer;
}(_Layer_js__WEBPACK_IMPORTED_MODULE_4__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (IntermediateCanvasRenderer);

//# sourceMappingURL=IntermediateCanvas.js.map

/***/ }),

/***/ "./node_modules/ol/renderer/canvas/Layer.js":
/*!**************************************************!*\
  !*** ./node_modules/ol/renderer/canvas/Layer.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _render_Event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../render/Event.js */ "./node_modules/ol/render/Event.js");
/* harmony import */ var _render_EventType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../render/EventType.js */ "./node_modules/ol/render/EventType.js");
/* harmony import */ var _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../render/canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _render_canvas_Immediate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../render/canvas/Immediate.js */ "./node_modules/ol/render/canvas/Immediate.js");
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Layer.js */ "./node_modules/ol/renderer/Layer.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/renderer/canvas/Layer
 */










/**
 * @abstract
 */
var CanvasLayerRenderer = /*@__PURE__*/(function (LayerRenderer) {
  function CanvasLayerRenderer(layer) {

    LayerRenderer.call(this, layer);

    /**
     * @protected
     * @type {number}
     */
    this.renderedResolution;

    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    this.transform_ = Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["create"])();

  }

  if ( LayerRenderer ) CanvasLayerRenderer.__proto__ = LayerRenderer;
  CanvasLayerRenderer.prototype = Object.create( LayerRenderer && LayerRenderer.prototype );
  CanvasLayerRenderer.prototype.constructor = CanvasLayerRenderer;

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent Clip extent.
   * @protected
   */
  CanvasLayerRenderer.prototype.clip = function clip (context, frameState, extent) {
    var pixelRatio = frameState.pixelRatio;
    var width = frameState.size[0] * pixelRatio;
    var height = frameState.size[1] * pixelRatio;
    var rotation = frameState.viewState.rotation;
    var topLeft = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getTopLeft"])(extent);
    var topRight = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getTopRight"])(extent);
    var bottomRight = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getBottomRight"])(extent);
    var bottomLeft = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getBottomLeft"])(extent);

    Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["apply"])(frameState.coordinateToPixelTransform, topLeft);
    Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["apply"])(frameState.coordinateToPixelTransform, topRight);
    Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["apply"])(frameState.coordinateToPixelTransform, bottomRight);
    Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["apply"])(frameState.coordinateToPixelTransform, bottomLeft);

    context.save();
    Object(_render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["rotateAtOffset"])(context, -rotation, width / 2, height / 2);
    context.beginPath();
    context.moveTo(topLeft[0] * pixelRatio, topLeft[1] * pixelRatio);
    context.lineTo(topRight[0] * pixelRatio, topRight[1] * pixelRatio);
    context.lineTo(bottomRight[0] * pixelRatio, bottomRight[1] * pixelRatio);
    context.lineTo(bottomLeft[0] * pixelRatio, bottomLeft[1] * pixelRatio);
    context.clip();
    Object(_render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["rotateAtOffset"])(context, rotation, width / 2, height / 2);
  };

  /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../../transform.js").Transform=} opt_transform Transform.
   * @private
   */
  CanvasLayerRenderer.prototype.dispatchComposeEvent_ = function dispatchComposeEvent_ (type, context, frameState, opt_transform) {
    var layer = this.getLayer();
    if (layer.hasListener(type)) {
      var width = frameState.size[0] * frameState.pixelRatio;
      var height = frameState.size[1] * frameState.pixelRatio;
      var rotation = frameState.viewState.rotation;
      Object(_render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["rotateAtOffset"])(context, -rotation, width / 2, height / 2);
      var transform = opt_transform !== undefined ?
        opt_transform : this.getTransform(frameState, 0);
      var render = new _render_canvas_Immediate_js__WEBPACK_IMPORTED_MODULE_6__["default"](
        context, frameState.pixelRatio, frameState.extent, transform,
        frameState.viewState.rotation);
      var composeEvent = new _render_Event_js__WEBPACK_IMPORTED_MODULE_3__["default"](type, render, frameState,
        context, null);
      layer.dispatchEvent(composeEvent);
      Object(_render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["rotateAtOffset"])(context, rotation, width / 2, height / 2);
    }
  };

  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../PluggableMap.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(this: S, import("../../layer/Layer.js").default, (Uint8ClampedArray|Uint8Array)): T} callback Layer
   *     callback.
   * @param {S} thisArg Value to use as `this` when executing `callback`.
   * @return {T|undefined} Callback result.
   * @template S,T,U
   */
  CanvasLayerRenderer.prototype.forEachLayerAtCoordinate = function forEachLayerAtCoordinate (coordinate, frameState, hitTolerance, callback, thisArg) {
    var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, _functions_js__WEBPACK_IMPORTED_MODULE_2__["TRUE"]);

    if (hasFeature) {
      return callback.call(thisArg, this.getLayer(), null);
    } else {
      return undefined;
    }
  };

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../../layer/Layer.js").State} layerState Layer state.
   * @param {import("../../transform.js").Transform=} opt_transform Transform.
   * @protected
   */
  CanvasLayerRenderer.prototype.postCompose = function postCompose (context, frameState, layerState, opt_transform) {
    this.dispatchComposeEvent_(_render_EventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].POSTCOMPOSE, context, frameState, opt_transform);
  };

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../../transform.js").Transform=} opt_transform Transform.
   * @protected
   */
  CanvasLayerRenderer.prototype.preCompose = function preCompose (context, frameState, opt_transform) {
    this.dispatchComposeEvent_(_render_EventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].PRECOMPOSE, context, frameState, opt_transform);
  };

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../../transform.js").Transform=} opt_transform Transform.
   * @protected
   */
  CanvasLayerRenderer.prototype.dispatchRenderEvent = function dispatchRenderEvent (context, frameState, opt_transform) {
    this.dispatchComposeEvent_(_render_EventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].RENDER, context, frameState, opt_transform);
  };

  /**
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {number} offsetX Offset on the x-axis in view coordinates.
   * @protected
   * @return {!import("../../transform.js").Transform} Transform.
   */
  CanvasLayerRenderer.prototype.getTransform = function getTransform (frameState, offsetX) {
    var viewState = frameState.viewState;
    var pixelRatio = frameState.pixelRatio;
    var dx1 = pixelRatio * frameState.size[0] / 2;
    var dy1 = pixelRatio * frameState.size[1] / 2;
    var sx = pixelRatio / viewState.resolution;
    var sy = -sx;
    var angle = -viewState.rotation;
    var dx2 = -viewState.center[0] + offsetX;
    var dy2 = -viewState.center[1];
    return Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["compose"])(this.transform_, dx1, dy1, sx, sy, angle, dx2, dy2);
  };

  /**
   * @abstract
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../../layer/Layer.js").State} layerState Layer state.
   * @param {CanvasRenderingContext2D} context Context.
   */
  CanvasLayerRenderer.prototype.composeFrame = function composeFrame (frameState, layerState, context) {
    Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * @abstract
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../../layer/Layer.js").State} layerState Layer state.
   * @return {boolean} whether composeFrame should be called.
   */
  CanvasLayerRenderer.prototype.prepareFrame = function prepareFrame (frameState, layerState) {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  return CanvasLayerRenderer;
}(_Layer_js__WEBPACK_IMPORTED_MODULE_7__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (CanvasLayerRenderer);

//# sourceMappingURL=Layer.js.map

/***/ }),

/***/ "./node_modules/ol/renderer/canvas/Map.js":
/*!************************************************!*\
  !*** ./node_modules/ol/renderer/canvas/Map.js ***!
  \************************************************/
/*! exports provided: layerRendererConstructors, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "layerRendererConstructors", function() { return layerRendererConstructors; });
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../css.js */ "./node_modules/ol/css.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _layer_Layer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../layer/Layer.js */ "./node_modules/ol/layer/Layer.js");
/* harmony import */ var _render_Event_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../render/Event.js */ "./node_modules/ol/render/Event.js");
/* harmony import */ var _render_EventType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../render/EventType.js */ "./node_modules/ol/render/EventType.js");
/* harmony import */ var _render_canvas_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../render/canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _render_canvas_Immediate_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../render/canvas/Immediate.js */ "./node_modules/ol/render/canvas/Immediate.js");
/* harmony import */ var _Map_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../Map.js */ "./node_modules/ol/renderer/Map.js");
/* harmony import */ var _source_State_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../source/State.js */ "./node_modules/ol/source/State.js");
/**
 * @module ol/renderer/canvas/Map
 */













/**
 * @type {Array<typeof import("../Layer.js").default>}
 */
var layerRendererConstructors = [];

/**
 * @classdesc
 * Canvas map renderer.
 * @api
 */
var CanvasMapRenderer = /*@__PURE__*/(function (MapRenderer) {
  function CanvasMapRenderer(map) {
    MapRenderer.call(this, map);

    var container = map.getViewport();

    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */
    this.context_ = Object(_dom_js__WEBPACK_IMPORTED_MODULE_3__["createCanvasContext2D"])();

    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    this.canvas_ = this.context_.canvas;

    this.canvas_.style.width = '100%';
    this.canvas_.style.height = '100%';
    this.canvas_.style.display = 'block';
    this.canvas_.className = _css_js__WEBPACK_IMPORTED_MODULE_2__["CLASS_UNSELECTABLE"];
    container.insertBefore(this.canvas_, container.childNodes[0] || null);

    /**
     * @private
     * @type {boolean}
     */
    this.renderedVisible_ = true;

    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    this.transform_ = Object(_transform_js__WEBPACK_IMPORTED_MODULE_0__["create"])();

  }

  if ( MapRenderer ) CanvasMapRenderer.__proto__ = MapRenderer;
  CanvasMapRenderer.prototype = Object.create( MapRenderer && MapRenderer.prototype );
  CanvasMapRenderer.prototype.constructor = CanvasMapRenderer;

  /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   */
  CanvasMapRenderer.prototype.dispatchRenderEvent = function dispatchRenderEvent (type, frameState) {
    var map = this.getMap();
    var context = this.context_;
    if (map.hasListener(type)) {
      var extent = frameState.extent;
      var pixelRatio = frameState.pixelRatio;
      var viewState = frameState.viewState;
      var rotation = viewState.rotation;

      var transform = this.getTransform(frameState);

      var vectorContext = new _render_canvas_Immediate_js__WEBPACK_IMPORTED_MODULE_8__["default"](context, pixelRatio,
        extent, transform, rotation);
      var composeEvent = new _render_Event_js__WEBPACK_IMPORTED_MODULE_5__["default"](type, vectorContext,
        frameState, context, null);
      map.dispatchEvent(composeEvent);
    }
  };

  /**
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @protected
   * @return {!import("../../transform.js").Transform} Transform.
   */
  CanvasMapRenderer.prototype.getTransform = function getTransform (frameState) {
    var viewState = frameState.viewState;
    var dx1 = this.canvas_.width / 2;
    var dy1 = this.canvas_.height / 2;
    var sx = frameState.pixelRatio / viewState.resolution;
    var sy = -sx;
    var angle = -viewState.rotation;
    var dx2 = -viewState.center[0];
    var dy2 = -viewState.center[1];
    return Object(_transform_js__WEBPACK_IMPORTED_MODULE_0__["compose"])(this.transform_, dx1, dy1, sx, sy, angle, dx2, dy2);
  };

  /**
   * @inheritDoc
   */
  CanvasMapRenderer.prototype.renderFrame = function renderFrame (frameState) {

    if (!frameState) {
      if (this.renderedVisible_) {
        this.canvas_.style.display = 'none';
        this.renderedVisible_ = false;
      }
      return;
    }

    var context = this.context_;
    var pixelRatio = frameState.pixelRatio;
    var width = Math.round(frameState.size[0] * pixelRatio);
    var height = Math.round(frameState.size[1] * pixelRatio);
    if (this.canvas_.width != width || this.canvas_.height != height) {
      this.canvas_.width = width;
      this.canvas_.height = height;
    } else {
      context.clearRect(0, 0, width, height);
    }

    var rotation = frameState.viewState.rotation;

    this.calculateMatrices2D(frameState);

    this.dispatchRenderEvent(_render_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].PRECOMPOSE, frameState);

    var layerStatesArray = frameState.layerStatesArray;
    Object(_array_js__WEBPACK_IMPORTED_MODULE_1__["stableSort"])(layerStatesArray, _Map_js__WEBPACK_IMPORTED_MODULE_9__["sortByZIndex"]);

    if (rotation) {
      context.save();
      Object(_render_canvas_js__WEBPACK_IMPORTED_MODULE_7__["rotateAtOffset"])(context, rotation, width / 2, height / 2);
    }

    var viewResolution = frameState.viewState.resolution;
    var i, ii;
    for (i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      var layerState = layerStatesArray[i];
      var layer = layerState.layer;
      var layerRenderer = /** @type {import("./Layer.js").default} */ (this.getLayerRenderer(layer));
      if (!Object(_layer_Layer_js__WEBPACK_IMPORTED_MODULE_4__["visibleAtResolution"])(layerState, viewResolution) ||
          layerState.sourceState != _source_State_js__WEBPACK_IMPORTED_MODULE_10__["default"].READY) {
        continue;
      }
      if (layerRenderer.prepareFrame(frameState, layerState)) {
        layerRenderer.composeFrame(frameState, layerState, context);
      }
    }

    if (rotation) {
      context.restore();
    }

    this.dispatchRenderEvent(_render_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POSTCOMPOSE, frameState);

    if (!this.renderedVisible_) {
      this.canvas_.style.display = '';
      this.renderedVisible_ = true;
    }

    this.scheduleRemoveUnusedLayerRenderers(frameState);
    this.scheduleExpireIconCache(frameState);
  };

  /**
   * @inheritDoc
   */
  CanvasMapRenderer.prototype.forEachLayerAtPixel = function forEachLayerAtPixel (pixel, frameState, hitTolerance, callback, thisArg, layerFilter, thisArg2) {
    var result;
    var viewState = frameState.viewState;
    var viewResolution = viewState.resolution;

    var layerStates = frameState.layerStatesArray;
    var numLayers = layerStates.length;

    var coordinate = Object(_transform_js__WEBPACK_IMPORTED_MODULE_0__["apply"])(
      frameState.pixelToCoordinateTransform, pixel.slice());

    var i;
    for (i = numLayers - 1; i >= 0; --i) {
      var layerState = layerStates[i];
      var layer = layerState.layer;
      if (Object(_layer_Layer_js__WEBPACK_IMPORTED_MODULE_4__["visibleAtResolution"])(layerState, viewResolution) && layerFilter.call(thisArg2, layer)) {
        var layerRenderer = /** @type {import("./Layer.js").default} */ (this.getLayerRenderer(layer));
        result = layerRenderer.forEachLayerAtCoordinate(
          coordinate, frameState, hitTolerance, callback, thisArg);
        if (result) {
          return result;
        }
      }
    }
    return undefined;
  };

  /**
   * @inheritDoc
   */
  CanvasMapRenderer.prototype.registerLayerRenderers = function registerLayerRenderers (constructors) {
    MapRenderer.prototype.registerLayerRenderers.call(this, constructors);
    for (var i = 0, ii = constructors.length; i < ii; ++i) {
      var ctor = constructors[i];
      if (!Object(_array_js__WEBPACK_IMPORTED_MODULE_1__["includes"])(layerRendererConstructors, ctor)) {
        layerRendererConstructors.push(ctor);
      }
    }
  };

  return CanvasMapRenderer;
}(_Map_js__WEBPACK_IMPORTED_MODULE_9__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (CanvasMapRenderer);

//# sourceMappingURL=Map.js.map

/***/ }),

/***/ "./node_modules/ol/renderer/canvas/TileLayer.js":
/*!******************************************************!*\
  !*** ./node_modules/ol/renderer/canvas/TileLayer.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _LayerType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../LayerType.js */ "./node_modules/ol/LayerType.js");
/* harmony import */ var _TileRange_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../TileRange.js */ "./node_modules/ol/TileRange.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _IntermediateCanvas_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./IntermediateCanvas.js */ "./node_modules/ol/renderer/canvas/IntermediateCanvas.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/renderer/canvas/TileLayer
 */










/**
 * @classdesc
 * Canvas renderer for tile layers.
 * @api
 */
var CanvasTileLayerRenderer = /*@__PURE__*/(function (IntermediateCanvasRenderer) {
  function CanvasTileLayerRenderer(tileLayer, opt_noContext) {

    IntermediateCanvasRenderer.call(this, tileLayer);

    /**
     * @protected
     * @type {CanvasRenderingContext2D}
     */
    this.context = opt_noContext ? null : Object(_dom_js__WEBPACK_IMPORTED_MODULE_5__["createCanvasContext2D"])();

    /**
     * @private
     * @type {number}
     */
    this.oversampling_;

    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */
    this.renderedExtent_ = null;

    /**
     * @protected
     * @type {number}
     */
    this.renderedRevision;

    /**
     * @protected
     * @type {!Array<import("../../Tile.js").default>}
     */
    this.renderedTiles = [];

    /**
     * @private
     * @type {boolean}
     */
    this.newTiles_ = false;

    /**
     * @protected
     * @type {import("../../extent.js").Extent}
     */
    this.tmpExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_6__["createEmpty"])();

    /**
     * @private
     * @type {import("../../TileRange.js").default}
     */
    this.tmpTileRange_ = new _TileRange_js__WEBPACK_IMPORTED_MODULE_2__["default"](0, 0, 0, 0);

    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    this.imageTransform_ = Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["create"])();

    /**
     * @protected
     * @type {number}
     */
    this.zDirection = 0;

  }

  if ( IntermediateCanvasRenderer ) CanvasTileLayerRenderer.__proto__ = IntermediateCanvasRenderer;
  CanvasTileLayerRenderer.prototype = Object.create( IntermediateCanvasRenderer && IntermediateCanvasRenderer.prototype );
  CanvasTileLayerRenderer.prototype.constructor = CanvasTileLayerRenderer;

  /**
   * @private
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {boolean} Tile is drawable.
   */
  CanvasTileLayerRenderer.prototype.isDrawableTile_ = function isDrawableTile_ (tile) {
    var tileLayer = /** @type {import("../../layer/Tile.js").default} */ (this.getLayer());
    var tileState = tile.getState();
    var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();
    return tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOADED ||
        tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_3__["default"].EMPTY ||
        tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_3__["default"].ERROR && !useInterimTilesOnError;
  };

  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection.js").default} projection Projection.
   * @return {!import("../../Tile.js").default} Tile.
   */
  CanvasTileLayerRenderer.prototype.getTile = function getTile (z, x, y, pixelRatio, projection) {
    var tileLayer = /** @type {import("../../layer/Tile.js").default} */ (this.getLayer());
    var tileSource = /** @type {import("../../source/Tile.js").default} */ (tileLayer.getSource());
    var tile = tileSource.getTile(z, x, y, pixelRatio, projection);
    if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_3__["default"].ERROR) {
      if (!tileLayer.getUseInterimTilesOnError()) {
        // When useInterimTilesOnError is false, we consider the error tile as loaded.
        tile.setState(_TileState_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOADED);
      } else if (tileLayer.getPreload() > 0) {
        // Preloaded tiles for lower resolutions might have finished loading.
        this.newTiles_ = true;
      }
    }
    if (!this.isDrawableTile_(tile)) {
      tile = tile.getInterimTile();
    }
    return tile;
  };

  /**
   * @inheritDoc
   */
  CanvasTileLayerRenderer.prototype.prepareFrame = function prepareFrame (frameState, layerState) {

    var pixelRatio = frameState.pixelRatio;
    var size = frameState.size;
    var viewState = frameState.viewState;
    var projection = viewState.projection;
    var viewResolution = viewState.resolution;
    var viewCenter = viewState.center;

    var tileLayer = /** @type {import("../../layer/Tile.js").default} */ (this.getLayer());
    var tileSource = /** @type {import("../../source/Tile.js").default} */ (tileLayer.getSource());
    var sourceRevision = tileSource.getRevision();
    var tileGrid = tileSource.getTileGridForProjection(projection);
    var z = tileGrid.getZForResolution(viewResolution, this.zDirection);
    var tileResolution = tileGrid.getResolution(z);
    var oversampling = Math.round(viewResolution / tileResolution) || 1;
    var extent = frameState.extent;

    if (layerState.extent !== undefined) {
      extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_6__["getIntersection"])(extent, layerState.extent);
    }
    if (Object(_extent_js__WEBPACK_IMPORTED_MODULE_6__["isEmpty"])(extent)) {
      // Return false to prevent the rendering of the layer.
      return false;
    }

    var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
    var imageExtent = tileGrid.getTileRangeExtent(z, tileRange);

    var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);

    /**
     * @type {Object<number, Object<string, import("../../Tile.js").default>>}
     */
    var tilesToDrawByZ = {};
    tilesToDrawByZ[z] = {};

    var findLoadedTiles = this.createLoadedTileFinder(
      tileSource, projection, tilesToDrawByZ);

    var hints = frameState.viewHints;
    var animatingOrInteracting = hints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_4__["default"].ANIMATING] || hints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_4__["default"].INTERACTING];

    var tmpExtent = this.tmpExtent;
    var tmpTileRange = this.tmpTileRange_;
    this.newTiles_ = false;
    var tile, x, y;
    for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
        if (Date.now() - frameState.time > 16 && animatingOrInteracting) {
          continue;
        }
        tile = this.getTile(z, x, y, pixelRatio, projection);
        if (this.isDrawableTile_(tile)) {
          var uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(this);
          if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOADED) {
            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;
            var inTransition = tile.inTransition(uid);
            if (!this.newTiles_ && (inTransition || this.renderedTiles.indexOf(tile) === -1)) {
              this.newTiles_ = true;
            }
          }
          if (tile.getAlpha(uid, frameState.time) === 1) {
            // don't look for alt tiles if alpha is 1
            continue;
          }
        }

        var childTileRange = tileGrid.getTileCoordChildTileRange(
          tile.tileCoord, tmpTileRange, tmpExtent);
        var covered = false;
        if (childTileRange) {
          covered = findLoadedTiles(z + 1, childTileRange);
        }
        if (!covered) {
          tileGrid.forEachTileCoordParentTileRange(
            tile.tileCoord, findLoadedTiles, null, tmpTileRange, tmpExtent);
        }

      }
    }

    var renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;
    if (!(this.renderedResolution && Date.now() - frameState.time > 16 && animatingOrInteracting) && (
      this.newTiles_ ||
          !(this.renderedExtent_ && Object(_extent_js__WEBPACK_IMPORTED_MODULE_6__["containsExtent"])(this.renderedExtent_, extent)) ||
          this.renderedRevision != sourceRevision ||
          oversampling != this.oversampling_ ||
          !animatingOrInteracting && renderedResolution != this.renderedResolution
    )) {

      var context = this.context;
      if (context) {
        var tilePixelSize = tileSource.getTilePixelSize(z, pixelRatio, projection);
        var width = Math.round(tileRange.getWidth() * tilePixelSize[0] / oversampling);
        var height = Math.round(tileRange.getHeight() * tilePixelSize[1] / oversampling);
        var canvas = context.canvas;
        if (canvas.width != width || canvas.height != height) {
          this.oversampling_ = oversampling;
          canvas.width = width;
          canvas.height = height;
        } else {
          if (this.renderedExtent_ && !Object(_extent_js__WEBPACK_IMPORTED_MODULE_6__["equals"])(imageExtent, this.renderedExtent_)) {
            context.clearRect(0, 0, width, height);
          }
          oversampling = this.oversampling_;
        }
      }

      this.renderedTiles.length = 0;
      /** @type {Array<number>} */
      var zs = Object.keys(tilesToDrawByZ).map(Number);
      zs.sort(function(a, b) {
        if (a === z) {
          return 1;
        } else if (b === z) {
          return -1;
        } else {
          return a > b ? 1 : a < b ? -1 : 0;
        }
      });
      var currentResolution, currentScale, currentTilePixelSize, currentZ, i, ii;
      var tileExtent, tileGutter, tilesToDraw, w, h;
      for (i = 0, ii = zs.length; i < ii; ++i) {
        currentZ = zs[i];
        currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);
        currentResolution = tileGrid.getResolution(currentZ);
        currentScale = currentResolution / tileResolution;
        tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);
        tilesToDraw = tilesToDrawByZ[currentZ];
        for (var tileCoordKey in tilesToDraw) {
          tile = tilesToDraw[tileCoordKey];
          tileExtent = tileGrid.getTileCoordExtent(tile.getTileCoord(), tmpExtent);
          x = (tileExtent[0] - imageExtent[0]) / tileResolution * tilePixelRatio / oversampling;
          y = (imageExtent[3] - tileExtent[3]) / tileResolution * tilePixelRatio / oversampling;
          w = currentTilePixelSize[0] * currentScale / oversampling;
          h = currentTilePixelSize[1] * currentScale / oversampling;
          this.drawTileImage(tile, frameState, layerState, x, y, w, h, tileGutter, z === currentZ);
          this.renderedTiles.push(tile);
        }
      }

      this.renderedRevision = sourceRevision;
      this.renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;
      this.renderedExtent_ = imageExtent;
    }

    var scale = this.renderedResolution / viewResolution;
    var transform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["compose"])(this.imageTransform_,
      pixelRatio * size[0] / 2, pixelRatio * size[1] / 2,
      scale, scale,
      0,
      (this.renderedExtent_[0] - viewCenter[0]) / this.renderedResolution * pixelRatio,
      (viewCenter[1] - this.renderedExtent_[3]) / this.renderedResolution * pixelRatio);
    Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["compose"])(this.coordinateToCanvasPixelTransform,
      pixelRatio * size[0] / 2 - transform[4], pixelRatio * size[1] / 2 - transform[5],
      pixelRatio / viewResolution, -pixelRatio / viewResolution,
      0,
      -viewCenter[0], -viewCenter[1]);


    this.updateUsedTiles(frameState.usedTiles, tileSource, z, tileRange);
    this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio,
      projection, extent, z, tileLayer.getPreload());
    this.scheduleExpireCache(frameState, tileSource);

    return this.renderedTiles.length > 0;
  };

  /**
   * @param {import("../../Tile.js").default} tile Tile.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../../layer/Layer.js").State} layerState Layer state.
   * @param {number} x Left of the tile.
   * @param {number} y Top of the tile.
   * @param {number} w Width of the tile.
   * @param {number} h Height of the tile.
   * @param {number} gutter Tile gutter.
   * @param {boolean} transition Apply an alpha transition.
   */
  CanvasTileLayerRenderer.prototype.drawTileImage = function drawTileImage (tile, frameState, layerState, x, y, w, h, gutter, transition) {
    var image = this.getTileImage(tile);
    if (!image) {
      return;
    }
    var uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(this);
    var alpha = transition ? tile.getAlpha(uid, frameState.time) : 1;
    var tileLayer = /** @type {import("../../layer/Tile.js").default} */ (this.getLayer());
    var tileSource = /** @type {import("../../source/Tile.js").default} */ (tileLayer.getSource());
    if (alpha === 1 && !tileSource.getOpaque(frameState.viewState.projection)) {
      this.context.clearRect(x, y, w, h);
    }
    var alphaChanged = alpha !== this.context.globalAlpha;
    if (alphaChanged) {
      this.context.save();
      this.context.globalAlpha = alpha;
    }
    this.context.drawImage(image, gutter, gutter,
      image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);

    if (alphaChanged) {
      this.context.restore();
    }
    if (alpha !== 1) {
      frameState.animate = true;
    } else if (transition) {
      tile.endTransition(uid);
    }
  };

  /**
   * @inheritDoc
   */
  CanvasTileLayerRenderer.prototype.getImage = function getImage () {
    var context = this.context;
    return context ? context.canvas : null;
  };

  /**
   * @inheritDoc
   */
  CanvasTileLayerRenderer.prototype.getImageTransform = function getImageTransform () {
    return this.imageTransform_;
  };

  /**
   * Get the image from a tile.
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @protected
   */
  CanvasTileLayerRenderer.prototype.getTileImage = function getTileImage (tile) {
    return /** @type {import("../../ImageTile.js").default} */ (tile).getImage();
  };

  return CanvasTileLayerRenderer;
}(_IntermediateCanvas_js__WEBPACK_IMPORTED_MODULE_7__["default"]));


/**
 * Determine if this renderer handles the provided layer.
 * @param {import("../../layer/Layer.js").default} layer The candidate layer.
 * @return {boolean} The renderer can render the layer.
 */
CanvasTileLayerRenderer['handles'] = function(layer) {
  return layer.getType() === _LayerType_js__WEBPACK_IMPORTED_MODULE_1__["default"].TILE;
};


/**
 * Create a layer renderer.
 * @param {import("../Map.js").default} mapRenderer The map renderer.
 * @param {import("../../layer/Layer.js").default} layer The layer to be rendererd.
 * @return {CanvasTileLayerRenderer} The layer renderer.
 */
CanvasTileLayerRenderer['create'] = function(mapRenderer, layer) {
  return new CanvasTileLayerRenderer(/** @type {import("../../layer/Tile.js").default} */ (layer));
};


/**
 * @function
 * @return {import("../../layer/Tile.js").default|import("../../layer/VectorTile.js").default}
 */
CanvasTileLayerRenderer.prototype.getLayer;


/* harmony default export */ __webpack_exports__["default"] = (CanvasTileLayerRenderer);

//# sourceMappingURL=TileLayer.js.map

/***/ }),

/***/ "./node_modules/ol/reproj.js":
/*!***********************************!*\
  !*** ./node_modules/ol/reproj.js ***!
  \***********************************/
/*! exports provided: calculateSourceResolution, render */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calculateSourceResolution", function() { return calculateSourceResolution; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./proj.js */ "./node_modules/ol/proj.js");
/**
 * @module ol/reproj
 */






/**
 * Calculates ideal resolution to use from the source in order to achieve
 * pixel mapping as close as possible to 1:1 during reprojection.
 * The resolution is calculated regardless of what resolutions
 * are actually available in the dataset (TileGrid, Image, ...).
 *
 * @param {import("./proj/Projection.js").default} sourceProj Source projection.
 * @param {import("./proj/Projection.js").default} targetProj Target projection.
 * @param {import("./coordinate.js").Coordinate} targetCenter Target center.
 * @param {number} targetResolution Target resolution.
 * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
 */
function calculateSourceResolution(sourceProj, targetProj,
  targetCenter, targetResolution) {

  var sourceCenter = Object(_proj_js__WEBPACK_IMPORTED_MODULE_3__["transform"])(targetCenter, targetProj, sourceProj);

  // calculate the ideal resolution of the source data
  var sourceResolution = Object(_proj_js__WEBPACK_IMPORTED_MODULE_3__["getPointResolution"])(targetProj, targetResolution, targetCenter);

  var targetMetersPerUnit = targetProj.getMetersPerUnit();
  if (targetMetersPerUnit !== undefined) {
    sourceResolution *= targetMetersPerUnit;
  }
  var sourceMetersPerUnit = sourceProj.getMetersPerUnit();
  if (sourceMetersPerUnit !== undefined) {
    sourceResolution /= sourceMetersPerUnit;
  }

  // Based on the projection properties, the point resolution at the specified
  // coordinates may be slightly different. We need to reverse-compensate this
  // in order to achieve optimal results.

  var sourceExtent = sourceProj.getExtent();
  if (!sourceExtent || Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["containsCoordinate"])(sourceExtent, sourceCenter)) {
    var compensationFactor = Object(_proj_js__WEBPACK_IMPORTED_MODULE_3__["getPointResolution"])(sourceProj, sourceResolution, sourceCenter) /
        sourceResolution;
    if (isFinite(compensationFactor) && compensationFactor > 0) {
      sourceResolution /= compensationFactor;
    }
  }

  return sourceResolution;
}


/**
 * Enlarge the clipping triangle point by 1 pixel to ensure the edges overlap
 * in order to mask gaps caused by antialiasing.
 *
 * @param {number} centroidX Centroid of the triangle (x coordinate in pixels).
 * @param {number} centroidY Centroid of the triangle (y coordinate in pixels).
 * @param {number} x X coordinate of the point (in pixels).
 * @param {number} y Y coordinate of the point (in pixels).
 * @return {import("./coordinate.js").Coordinate} New point 1 px farther from the centroid.
 */
function enlargeClipPoint(centroidX, centroidY, x, y) {
  var dX = x - centroidX;
  var dY = y - centroidY;
  var distance = Math.sqrt(dX * dX + dY * dY);
  return [Math.round(x + dX / distance), Math.round(y + dY / distance)];
}


/**
 * Renders the source data into new canvas based on the triangulation.
 *
 * @param {number} width Width of the canvas.
 * @param {number} height Height of the canvas.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} sourceResolution Source resolution.
 * @param {import("./extent.js").Extent} sourceExtent Extent of the data source.
 * @param {number} targetResolution Target resolution.
 * @param {import("./extent.js").Extent} targetExtent Target extent.
 * @param {import("./reproj/Triangulation.js").default} triangulation
 * Calculated triangulation.
 * @param {Array<{extent: import("./extent.js").Extent,
 *                 image: (HTMLCanvasElement|HTMLImageElement|HTMLVideoElement)}>} sources
 * Array of sources.
 * @param {number} gutter Gutter of the sources.
 * @param {boolean=} opt_renderEdges Render reprojection edges.
 * @return {HTMLCanvasElement} Canvas with reprojected data.
 */
function render(width, height, pixelRatio,
  sourceResolution, sourceExtent, targetResolution, targetExtent,
  triangulation, sources, gutter, opt_renderEdges) {

  var context = Object(_dom_js__WEBPACK_IMPORTED_MODULE_0__["createCanvasContext2D"])(Math.round(pixelRatio * width),
    Math.round(pixelRatio * height));

  if (sources.length === 0) {
    return context.canvas;
  }

  context.scale(pixelRatio, pixelRatio);

  var sourceDataExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["createEmpty"])();
  sources.forEach(function(src, i, arr) {
    Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["extend"])(sourceDataExtent, src.extent);
  });

  var canvasWidthInUnits = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getWidth"])(sourceDataExtent);
  var canvasHeightInUnits = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getHeight"])(sourceDataExtent);
  var stitchContext = Object(_dom_js__WEBPACK_IMPORTED_MODULE_0__["createCanvasContext2D"])(
    Math.round(pixelRatio * canvasWidthInUnits / sourceResolution),
    Math.round(pixelRatio * canvasHeightInUnits / sourceResolution));

  var stitchScale = pixelRatio / sourceResolution;

  sources.forEach(function(src, i, arr) {
    var xPos = src.extent[0] - sourceDataExtent[0];
    var yPos = -(src.extent[3] - sourceDataExtent[3]);
    var srcWidth = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getWidth"])(src.extent);
    var srcHeight = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getHeight"])(src.extent);

    stitchContext.drawImage(
      src.image,
      gutter, gutter,
      src.image.width - 2 * gutter, src.image.height - 2 * gutter,
      xPos * stitchScale, yPos * stitchScale,
      srcWidth * stitchScale, srcHeight * stitchScale);
  });

  var targetTopLeft = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getTopLeft"])(targetExtent);

  triangulation.getTriangles().forEach(function(triangle, i, arr) {
    /* Calculate affine transform (src -> dst)
     * Resulting matrix can be used to transform coordinate
     * from `sourceProjection` to destination pixels.
     *
     * To optimize number of context calls and increase numerical stability,
     * we also do the following operations:
     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)
     * here before solving the linear system so [ui, vi] are pixel coordinates.
     *
     * Src points: xi, yi
     * Dst points: ui, vi
     * Affine coefficients: aij
     *
     * | x0 y0 1  0  0 0 |   |a00|   |u0|
     * | x1 y1 1  0  0 0 |   |a01|   |u1|
     * | x2 y2 1  0  0 0 | x |a02| = |u2|
     * |  0  0 0 x0 y0 1 |   |a10|   |v0|
     * |  0  0 0 x1 y1 1 |   |a11|   |v1|
     * |  0  0 0 x2 y2 1 |   |a12|   |v2|
     */
    var source = triangle.source;
    var target = triangle.target;
    var x0 = source[0][0], y0 = source[0][1];
    var x1 = source[1][0], y1 = source[1][1];
    var x2 = source[2][0], y2 = source[2][1];
    var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
    var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
    var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
    var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
    var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
    var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;

    // Shift all the source points to improve numerical stability
    // of all the subsequent calculations. The [x0, y0] is used here.
    // This is also used to simplify the linear system.
    var sourceNumericalShiftX = x0;
    var sourceNumericalShiftY = y0;
    x0 = 0;
    y0 = 0;
    x1 -= sourceNumericalShiftX;
    y1 -= sourceNumericalShiftY;
    x2 -= sourceNumericalShiftX;
    y2 -= sourceNumericalShiftY;

    var augmentedMatrix = [
      [x1, y1, 0, 0, u1 - u0],
      [x2, y2, 0, 0, u2 - u0],
      [0, 0, x1, y1, v1 - v0],
      [0, 0, x2, y2, v2 - v0]
    ];
    var affineCoefs = Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["solveLinearSystem"])(augmentedMatrix);
    if (!affineCoefs) {
      return;
    }

    context.save();
    context.beginPath();
    var centroidX = (u0 + u1 + u2) / 3;
    var centroidY = (v0 + v1 + v2) / 3;
    var p0 = enlargeClipPoint(centroidX, centroidY, u0, v0);
    var p1 = enlargeClipPoint(centroidX, centroidY, u1, v1);
    var p2 = enlargeClipPoint(centroidX, centroidY, u2, v2);

    context.moveTo(p1[0], p1[1]);
    context.lineTo(p0[0], p0[1]);
    context.lineTo(p2[0], p2[1]);
    context.clip();

    context.transform(
      affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);

    context.translate(sourceDataExtent[0] - sourceNumericalShiftX,
      sourceDataExtent[3] - sourceNumericalShiftY);

    context.scale(sourceResolution / pixelRatio,
      -sourceResolution / pixelRatio);

    context.drawImage(stitchContext.canvas, 0, 0);
    context.restore();
  });

  if (opt_renderEdges) {
    context.save();

    context.strokeStyle = 'black';
    context.lineWidth = 1;

    triangulation.getTriangles().forEach(function(triangle, i, arr) {
      var target = triangle.target;
      var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
      var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
      var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
      var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
      var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
      var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;

      context.beginPath();
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
      context.closePath();
      context.stroke();
    });

    context.restore();
  }
  return context.canvas;
}

//# sourceMappingURL=reproj.js.map

/***/ }),

/***/ "./node_modules/ol/reproj/Image.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/reproj/Image.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/ol/reproj/common.js");
/* harmony import */ var _ImageBase_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ImageBase.js */ "./node_modules/ol/ImageBase.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ImageState.js */ "./node_modules/ol/ImageState.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _reproj_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../reproj.js */ "./node_modules/ol/reproj.js");
/* harmony import */ var _Triangulation_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Triangulation.js */ "./node_modules/ol/reproj/Triangulation.js");
/**
 * @module ol/reproj/Image
 */











/**
 * @typedef {function(import("../extent.js").Extent, number, number) : import("../ImageBase.js").default} FunctionType
 */


/**
 * @classdesc
 * Class encapsulating single reprojected image.
 * See {@link module:ol/source/Image~ImageSource}.
 */
var ReprojImage = /*@__PURE__*/(function (ImageBase) {
  function ReprojImage(sourceProj, targetProj, targetExtent, targetResolution, pixelRatio, getImageFunction) {
    var maxSourceExtent = sourceProj.getExtent();
    var maxTargetExtent = targetProj.getExtent();

    var limitedTargetExtent = maxTargetExtent ?
      Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getIntersection"])(targetExtent, maxTargetExtent) : targetExtent;

    var targetCenter = Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getCenter"])(limitedTargetExtent);
    var sourceResolution = Object(_reproj_js__WEBPACK_IMPORTED_MODULE_6__["calculateSourceResolution"])(
      sourceProj, targetProj, targetCenter, targetResolution);

    var errorThresholdInPixels = _common_js__WEBPACK_IMPORTED_MODULE_0__["ERROR_THRESHOLD"];

    var triangulation = new _Triangulation_js__WEBPACK_IMPORTED_MODULE_7__["default"](
      sourceProj, targetProj, limitedTargetExtent, maxSourceExtent,
      sourceResolution * errorThresholdInPixels);

    var sourceExtent = triangulation.calculateSourceExtent();
    var sourceImage = getImageFunction(sourceExtent, sourceResolution, pixelRatio);
    var state = _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED;
    if (sourceImage) {
      state = _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE;
    }
    var sourcePixelRatio = sourceImage ? sourceImage.getPixelRatio() : 1;

    ImageBase.call(this, targetExtent, targetResolution, sourcePixelRatio, state);

    /**
     * @private
     * @type {import("../proj/Projection.js").default}
     */
    this.targetProj_ = targetProj;

    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    this.maxSourceExtent_ = maxSourceExtent;

    /**
     * @private
     * @type {!import("./Triangulation.js").default}
     */
    this.triangulation_ = triangulation;

    /**
     * @private
     * @type {number}
     */
    this.targetResolution_ = targetResolution;

    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    this.targetExtent_ = targetExtent;

    /**
     * @private
     * @type {import("../ImageBase.js").default}
     */
    this.sourceImage_ = sourceImage;

    /**
     * @private
     * @type {number}
     */
    this.sourcePixelRatio_ = sourcePixelRatio;

    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    this.canvas_ = null;

    /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */
    this.sourceListenerKey_ = null;
  }

  if ( ImageBase ) ReprojImage.__proto__ = ImageBase;
  ReprojImage.prototype = Object.create( ImageBase && ImageBase.prototype );
  ReprojImage.prototype.constructor = ReprojImage;

  /**
   * @inheritDoc
   */
  ReprojImage.prototype.disposeInternal = function disposeInternal () {
    if (this.state == _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING) {
      this.unlistenSource_();
    }
    ImageBase.prototype.disposeInternal.call(this);
  };

  /**
   * @inheritDoc
   */
  ReprojImage.prototype.getImage = function getImage () {
    return this.canvas_;
  };

  /**
   * @return {import("../proj/Projection.js").default} Projection.
   */
  ReprojImage.prototype.getProjection = function getProjection () {
    return this.targetProj_;
  };

  /**
   * @private
   */
  ReprojImage.prototype.reproject_ = function reproject_ () {
    var sourceState = this.sourceImage_.getState();
    if (sourceState == _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
      var width = Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getWidth"])(this.targetExtent_) / this.targetResolution_;
      var height = Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getHeight"])(this.targetExtent_) / this.targetResolution_;

      this.canvas_ = Object(_reproj_js__WEBPACK_IMPORTED_MODULE_6__["render"])(width, height, this.sourcePixelRatio_,
        this.sourceImage_.getResolution(), this.maxSourceExtent_,
        this.targetResolution_, this.targetExtent_, this.triangulation_, [{
          extent: this.sourceImage_.getExtent(),
          image: this.sourceImage_.getImage()
        }], 0);
    }
    this.state = sourceState;
    this.changed();
  };

  /**
   * @inheritDoc
   */
  ReprojImage.prototype.load = function load () {
    if (this.state == _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE) {
      this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING;
      this.changed();

      var sourceState = this.sourceImage_.getState();
      if (sourceState == _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED || sourceState == _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR) {
        this.reproject_();
      } else {
        this.sourceListenerKey_ = Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(this.sourceImage_,
          _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].CHANGE, function(e) {
            var sourceState = this.sourceImage_.getState();
            if (sourceState == _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED || sourceState == _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR) {
              this.unlistenSource_();
              this.reproject_();
            }
          }, this);
        this.sourceImage_.load();
      }
    }
  };

  /**
   * @private
   */
  ReprojImage.prototype.unlistenSource_ = function unlistenSource_ () {
    Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["unlistenByKey"])(/** @type {!import("../events.js").EventsKey} */ (this.sourceListenerKey_));
    this.sourceListenerKey_ = null;
  };

  return ReprojImage;
}(_ImageBase_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (ReprojImage);

//# sourceMappingURL=Image.js.map

/***/ }),

/***/ "./node_modules/ol/reproj/Tile.js":
/*!****************************************!*\
  !*** ./node_modules/ol/reproj/Tile.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/ol/reproj/common.js");
/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Tile.js */ "./node_modules/ol/Tile.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _reproj_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../reproj.js */ "./node_modules/ol/reproj.js");
/* harmony import */ var _Triangulation_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Triangulation.js */ "./node_modules/ol/reproj/Triangulation.js");
/**
 * @module ol/reproj/Tile
 */












/**
 * @typedef {function(number, number, number, number) : import("../Tile.js").default} FunctionType
 */


/**
 * @classdesc
 * Class encapsulating single reprojected tile.
 * See {@link module:ol/source/TileImage~TileImage}.
 *
 */
var ReprojTile = /*@__PURE__*/(function (Tile) {
  function ReprojTile(
    sourceProj,
    sourceTileGrid,
    targetProj,
    targetTileGrid,
    tileCoord,
    wrappedTileCoord,
    pixelRatio,
    gutter,
    getTileFunction,
    opt_errorThreshold,
    opt_renderEdges
  ) {
    Tile.call(this, tileCoord, _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE);

    /**
     * @private
     * @type {boolean}
     */
    this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;

    /**
     * @private
     * @type {number}
     */
    this.pixelRatio_ = pixelRatio;

    /**
     * @private
     * @type {number}
     */
    this.gutter_ = gutter;

    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    this.canvas_ = null;

    /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */
    this.sourceTileGrid_ = sourceTileGrid;

    /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */
    this.targetTileGrid_ = targetTileGrid;

    /**
     * @private
     * @type {import("../tilecoord.js").TileCoord}
     */
    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;

    /**
     * @private
     * @type {!Array<import("../Tile.js").default>}
     */
    this.sourceTiles_ = [];

    /**
     * @private
     * @type {Array<import("../events.js").EventsKey>}
     */
    this.sourcesListenerKeys_ = null;

    /**
     * @private
     * @type {number}
     */
    this.sourceZ_ = 0;

    var targetExtent = targetTileGrid.getTileCoordExtent(this.wrappedTileCoord_);
    var maxTargetExtent = this.targetTileGrid_.getExtent();
    var maxSourceExtent = this.sourceTileGrid_.getExtent();

    var limitedTargetExtent = maxTargetExtent ?
      Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getIntersection"])(targetExtent, maxTargetExtent) : targetExtent;

    if (Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getArea"])(limitedTargetExtent) === 0) {
      // Tile is completely outside range -> EMPTY
      // TODO: is it actually correct that the source even creates the tile ?
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY;
      return;
    }

    var sourceProjExtent = sourceProj.getExtent();
    if (sourceProjExtent) {
      if (!maxSourceExtent) {
        maxSourceExtent = sourceProjExtent;
      } else {
        maxSourceExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getIntersection"])(maxSourceExtent, sourceProjExtent);
      }
    }

    var targetResolution = targetTileGrid.getResolution(
      this.wrappedTileCoord_[0]);

    var targetCenter = Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getCenter"])(limitedTargetExtent);
    var sourceResolution = Object(_reproj_js__WEBPACK_IMPORTED_MODULE_7__["calculateSourceResolution"])(
      sourceProj, targetProj, targetCenter, targetResolution);

    if (!isFinite(sourceResolution) || sourceResolution <= 0) {
      // invalid sourceResolution -> EMPTY
      // probably edges of the projections when no extent is defined
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY;
      return;
    }

    var errorThresholdInPixels = opt_errorThreshold !== undefined ?
      opt_errorThreshold : _common_js__WEBPACK_IMPORTED_MODULE_0__["ERROR_THRESHOLD"];

    /**
     * @private
     * @type {!import("./Triangulation.js").default}
     */
    this.triangulation_ = new _Triangulation_js__WEBPACK_IMPORTED_MODULE_8__["default"](
      sourceProj, targetProj, limitedTargetExtent, maxSourceExtent,
      sourceResolution * errorThresholdInPixels);

    if (this.triangulation_.getTriangles().length === 0) {
      // no valid triangles -> EMPTY
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY;
      return;
    }

    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);
    var sourceExtent = this.triangulation_.calculateSourceExtent();

    if (maxSourceExtent) {
      if (sourceProj.canWrapX()) {
        sourceExtent[1] = Object(_math_js__WEBPACK_IMPORTED_MODULE_6__["clamp"])(
          sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);
        sourceExtent[3] = Object(_math_js__WEBPACK_IMPORTED_MODULE_6__["clamp"])(
          sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);
      } else {
        sourceExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getIntersection"])(sourceExtent, maxSourceExtent);
      }
    }

    if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getArea"])(sourceExtent)) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY;
    } else {
      var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(
        sourceExtent, this.sourceZ_);

      for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
        for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
          var tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);
          if (tile) {
            this.sourceTiles_.push(tile);
          }
        }
      }

      if (this.sourceTiles_.length === 0) {
        this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY;
      }
    }
  }

  if ( Tile ) ReprojTile.__proto__ = Tile;
  ReprojTile.prototype = Object.create( Tile && Tile.prototype );
  ReprojTile.prototype.constructor = ReprojTile;

  /**
   * @inheritDoc
   */
  ReprojTile.prototype.disposeInternal = function disposeInternal () {
    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING) {
      this.unlistenSources_();
    }
    Tile.prototype.disposeInternal.call(this);
  };

  /**
   * Get the HTML Canvas element for this tile.
   * @return {HTMLCanvasElement} Canvas.
   */
  ReprojTile.prototype.getImage = function getImage () {
    return this.canvas_;
  };

  /**
   * @private
   */
  ReprojTile.prototype.reproject_ = function reproject_ () {
    var sources = [];
    this.sourceTiles_.forEach(function(tile, i, arr) {
      if (tile && tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
        sources.push({
          extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),
          image: tile.getImage()
        });
      }
    }.bind(this));
    this.sourceTiles_.length = 0;

    if (sources.length === 0) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR;
    } else {
      var z = this.wrappedTileCoord_[0];
      var size = this.targetTileGrid_.getTileSize(z);
      var width = typeof size === 'number' ? size : size[0];
      var height = typeof size === 'number' ? size : size[1];
      var targetResolution = this.targetTileGrid_.getResolution(z);
      var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);

      var targetExtent = this.targetTileGrid_.getTileCoordExtent(
        this.wrappedTileCoord_);
      this.canvas_ = Object(_reproj_js__WEBPACK_IMPORTED_MODULE_7__["render"])(width, height, this.pixelRatio_,
        sourceResolution, this.sourceTileGrid_.getExtent(),
        targetResolution, targetExtent, this.triangulation_, sources,
        this.gutter_, this.renderEdges_);

      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED;
    }
    this.changed();
  };

  /**
   * @inheritDoc
   */
  ReprojTile.prototype.load = function load () {
    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING;
      this.changed();

      var leftToLoad = 0;

      this.sourcesListenerKeys_ = [];
      this.sourceTiles_.forEach(function(tile, i, arr) {
        var state = tile.getState();
        if (state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE || state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING) {
          leftToLoad++;

          var sourceListenKey = Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(tile, _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].CHANGE,
            function(e) {
              var state = tile.getState();
              if (state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED ||
                    state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR ||
                    state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY) {
                Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["unlistenByKey"])(sourceListenKey);
                leftToLoad--;
                if (leftToLoad === 0) {
                  this.unlistenSources_();
                  this.reproject_();
                }
              }
            }, this);
          this.sourcesListenerKeys_.push(sourceListenKey);
        }
      }.bind(this));

      this.sourceTiles_.forEach(function(tile, i, arr) {
        var state = tile.getState();
        if (state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE) {
          tile.load();
        }
      });

      if (leftToLoad === 0) {
        setTimeout(this.reproject_.bind(this), 0);
      }
    }
  };

  /**
   * @private
   */
  ReprojTile.prototype.unlistenSources_ = function unlistenSources_ () {
    this.sourcesListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_3__["unlistenByKey"]);
    this.sourcesListenerKeys_ = null;
  };

  return ReprojTile;
}(_Tile_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (ReprojTile);

//# sourceMappingURL=Tile.js.map

/***/ }),

/***/ "./node_modules/ol/reproj/Triangulation.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/reproj/Triangulation.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/**
 * @module ol/reproj/Triangulation
 */





/**
 * Single triangle; consists of 3 source points and 3 target points.
 * @typedef {Object} Triangle
 * @property {Array<import("../coordinate.js").Coordinate>} source
 * @property {Array<import("../coordinate.js").Coordinate>} target
 */


/**
 * Maximum number of subdivision steps during raster reprojection triangulation.
 * Prevents high memory usage and large number of proj4 calls (for certain
 * transformations and areas). At most `2*(2^this)` triangles are created for
 * each triangulated extent (tile/image).
 * @type {number}
 */
var MAX_SUBDIVISION = 10;


/**
 * Maximum allowed size of triangle relative to world width. When transforming
 * corners of world extent between certain projections, the resulting
 * triangulation seems to have zero error and no subdivision is performed. If
 * the triangle width is more than this (relative to world width; 0-1),
 * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.
 * @type {number}
 */
var MAX_TRIANGLE_WIDTH = 0.25;


/**
 * @classdesc
 * Class containing triangulation of the given target extent.
 * Used for determining source data and the reprojection itself.
 */
var Triangulation = function Triangulation(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold) {

  /**
   * @type {import("../proj/Projection.js").default}
   * @private
   */
  this.sourceProj_ = sourceProj;

  /**
   * @type {import("../proj/Projection.js").default}
   * @private
   */
  this.targetProj_ = targetProj;

  /** @type {!Object<string, import("../coordinate.js").Coordinate>} */
  var transformInvCache = {};
  var transformInv = Object(_proj_js__WEBPACK_IMPORTED_MODULE_2__["getTransform"])(this.targetProj_, this.sourceProj_);

  /**
   * @param {import("../coordinate.js").Coordinate} c A coordinate.
   * @return {import("../coordinate.js").Coordinate} Transformed coordinate.
   * @private
   */
  this.transformInv_ = function(c) {
    var key = c[0] + '/' + c[1];
    if (!transformInvCache[key]) {
      transformInvCache[key] = transformInv(c);
    }
    return transformInvCache[key];
  };

  /**
   * @type {import("../extent.js").Extent}
   * @private
   */
  this.maxSourceExtent_ = maxSourceExtent;

  /**
   * @type {number}
   * @private
   */
  this.errorThresholdSquared_ = errorThreshold * errorThreshold;

  /**
   * @type {Array<Triangle>}
   * @private
   */
  this.triangles_ = [];

  /**
   * Indicates that the triangulation crosses edge of the source projection.
   * @type {boolean}
   * @private
   */
  this.wrapsXInSource_ = false;

  /**
   * @type {boolean}
   * @private
   */
  this.canWrapXInSource_ = this.sourceProj_.canWrapX() &&
      !!maxSourceExtent &&
      !!this.sourceProj_.getExtent() &&
      (Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getWidth"])(maxSourceExtent) == Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getWidth"])(this.sourceProj_.getExtent()));

  /**
   * @type {?number}
   * @private
   */
  this.sourceWorldWidth_ = this.sourceProj_.getExtent() ?
    Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getWidth"])(this.sourceProj_.getExtent()) : null;

  /**
   * @type {?number}
   * @private
   */
  this.targetWorldWidth_ = this.targetProj_.getExtent() ?
    Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getWidth"])(this.targetProj_.getExtent()) : null;

  var destinationTopLeft = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getTopLeft"])(targetExtent);
  var destinationTopRight = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getTopRight"])(targetExtent);
  var destinationBottomRight = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getBottomRight"])(targetExtent);
  var destinationBottomLeft = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getBottomLeft"])(targetExtent);
  var sourceTopLeft = this.transformInv_(destinationTopLeft);
  var sourceTopRight = this.transformInv_(destinationTopRight);
  var sourceBottomRight = this.transformInv_(destinationBottomRight);
  var sourceBottomLeft = this.transformInv_(destinationBottomLeft);

  this.addQuad_(
    destinationTopLeft, destinationTopRight,
    destinationBottomRight, destinationBottomLeft,
    sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft,
    MAX_SUBDIVISION);

  if (this.wrapsXInSource_) {
    var leftBound = Infinity;
    this.triangles_.forEach(function(triangle, i, arr) {
      leftBound = Math.min(leftBound,
        triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);
    });

    // Shift triangles to be as close to `leftBound` as possible
    // (if the distance is more than `worldWidth / 2` it can be closer.
    this.triangles_.forEach(function(triangle) {
      if (Math.max(triangle.source[0][0], triangle.source[1][0],
        triangle.source[2][0]) - leftBound > this.sourceWorldWidth_ / 2) {
        var newTriangle = [[triangle.source[0][0], triangle.source[0][1]],
          [triangle.source[1][0], triangle.source[1][1]],
          [triangle.source[2][0], triangle.source[2][1]]];
        if ((newTriangle[0][0] - leftBound) > this.sourceWorldWidth_ / 2) {
          newTriangle[0][0] -= this.sourceWorldWidth_;
        }
        if ((newTriangle[1][0] - leftBound) > this.sourceWorldWidth_ / 2) {
          newTriangle[1][0] -= this.sourceWorldWidth_;
        }
        if ((newTriangle[2][0] - leftBound) > this.sourceWorldWidth_ / 2) {
          newTriangle[2][0] -= this.sourceWorldWidth_;
        }

        // Rarely (if the extent contains both the dateline and prime meridian)
        // the shift can in turn break some triangles.
        // Detect this here and don't shift in such cases.
        var minX = Math.min(
          newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
        var maxX = Math.max(
          newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
        if ((maxX - minX) < this.sourceWorldWidth_ / 2) {
          triangle.source = newTriangle;
        }
      }
    }.bind(this));
  }

  transformInvCache = {};
};

/**
 * Adds triangle to the triangulation.
 * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
 * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
 * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
 * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
 * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
 * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
 * @private
 */
Triangulation.prototype.addTriangle_ = function addTriangle_ (a, b, c, aSrc, bSrc, cSrc) {
  this.triangles_.push({
    source: [aSrc, bSrc, cSrc],
    target: [a, b, c]
  });
};

/**
 * Adds quad (points in clock-wise order) to the triangulation
 * (and reprojects the vertices) if valid.
 * Performs quad subdivision if needed to increase precision.
 *
 * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
 * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
 * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
 * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
 * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
 * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
 * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
 * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
 * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
 * @private
 */
Triangulation.prototype.addQuad_ = function addQuad_ (a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {

  var sourceQuadExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["boundingExtent"])([aSrc, bSrc, cSrc, dSrc]);
  var sourceCoverageX = this.sourceWorldWidth_ ?
    Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getWidth"])(sourceQuadExtent) / this.sourceWorldWidth_ : null;
  var sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);

  // when the quad is wrapped in the source projection
  // it covers most of the projection extent, but not fully
  var wrapsX = this.sourceProj_.canWrapX() &&
               sourceCoverageX > 0.5 && sourceCoverageX < 1;

  var needsSubdivision = false;

  if (maxSubdivision > 0) {
    if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
      var targetQuadExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["boundingExtent"])([a, b, c, d]);
      var targetCoverageX = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getWidth"])(targetQuadExtent) / this.targetWorldWidth_;
      needsSubdivision = targetCoverageX > MAX_TRIANGLE_WIDTH ||
        needsSubdivision;
    }
    if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {
      needsSubdivision = sourceCoverageX > MAX_TRIANGLE_WIDTH ||
          needsSubdivision;
    }
  }

  if (!needsSubdivision && this.maxSourceExtent_) {
    if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["intersects"])(sourceQuadExtent, this.maxSourceExtent_)) {
      // whole quad outside source projection extent -> ignore
      return;
    }
  }

  if (!needsSubdivision) {
    if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ||
        !isFinite(bSrc[0]) || !isFinite(bSrc[1]) ||
        !isFinite(cSrc[0]) || !isFinite(cSrc[1]) ||
        !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {
      if (maxSubdivision > 0) {
        needsSubdivision = true;
      } else {
        return;
      }
    }
  }

  if (maxSubdivision > 0) {
    if (!needsSubdivision) {
      var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];
      var centerSrc = this.transformInv_(center);

      var dx;
      if (wrapsX) {
        var centerSrcEstimX =
            (Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["modulo"])(aSrc[0], sourceWorldWidth) +
             Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["modulo"])(cSrc[0], sourceWorldWidth)) / 2;
        dx = centerSrcEstimX -
            Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["modulo"])(centerSrc[0], sourceWorldWidth);
      } else {
        dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
      }
      var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
      var centerSrcErrorSquared = dx * dx + dy * dy;
      needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
    }
    if (needsSubdivision) {
      if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {
        // split horizontally (top & bottom)
        var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];
        var bcSrc = this.transformInv_(bc);
        var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];
        var daSrc = this.transformInv_(da);

        this.addQuad_(
          a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);
        this.addQuad_(
          da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);
      } else {
        // split vertically (left & right)
        var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];
        var abSrc = this.transformInv_(ab);
        var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];
        var cdSrc = this.transformInv_(cd);

        this.addQuad_(
          a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);
        this.addQuad_(
          ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);
      }
      return;
    }
  }

  if (wrapsX) {
    if (!this.canWrapXInSource_) {
      return;
    }
    this.wrapsXInSource_ = true;
  }

  this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);
  this.addTriangle_(a, b, c, aSrc, bSrc, cSrc);
};

/**
 * Calculates extent of the 'source' coordinates from all the triangles.
 *
 * @return {import("../extent.js").Extent} Calculated extent.
 */
Triangulation.prototype.calculateSourceExtent = function calculateSourceExtent () {
  var extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["createEmpty"])();

  this.triangles_.forEach(function(triangle, i, arr) {
    var src = triangle.source;
    Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["extendCoordinate"])(extent, src[0]);
    Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["extendCoordinate"])(extent, src[1]);
    Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["extendCoordinate"])(extent, src[2]);
  });

  return extent;
};

/**
 * @return {Array<Triangle>} Array of the calculated triangles.
 */
Triangulation.prototype.getTriangles = function getTriangles () {
  return this.triangles_;
};

/* harmony default export */ __webpack_exports__["default"] = (Triangulation);

//# sourceMappingURL=Triangulation.js.map

/***/ }),

/***/ "./node_modules/ol/reproj/common.js":
/*!******************************************!*\
  !*** ./node_modules/ol/reproj/common.js ***!
  \******************************************/
/*! exports provided: ERROR_THRESHOLD, ENABLE_RASTER_REPROJECTION */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ERROR_THRESHOLD", function() { return ERROR_THRESHOLD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENABLE_RASTER_REPROJECTION", function() { return ENABLE_RASTER_REPROJECTION; });
/**
 * @module ol/reproj/common
 */

/**
 * Default maximum allowed threshold  (in pixels) for reprojection
 * triangulation.
 * @type {number}
 */
var ERROR_THRESHOLD = 0.5;

/**
 * Enable automatic reprojection of raster sources. Default is `true`.
 * TODO: decide if we want to expose this as a build flag or remove it
 * @type {boolean}
 */
var ENABLE_RASTER_REPROJECTION = true;

//# sourceMappingURL=common.js.map

/***/ }),

/***/ "./node_modules/ol/size.js":
/*!*********************************!*\
  !*** ./node_modules/ol/size.js ***!
  \*********************************/
/*! exports provided: buffer, hasArea, scale, toSize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buffer", function() { return buffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasArea", function() { return hasArea; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toSize", function() { return toSize; });
/**
 * @module ol/size
 */


/**
 * An array of numbers representing a size: `[width, height]`.
 * @typedef {Array<number>} Size
 * @api
 */


/**
 * Returns a buffered size.
 * @param {Size} size Size.
 * @param {number} num The amount by which to buffer.
 * @param {Size=} opt_size Optional reusable size array.
 * @return {Size} The buffered size.
 */
function buffer(size, num, opt_size) {
  if (opt_size === undefined) {
    opt_size = [0, 0];
  }
  opt_size[0] = size[0] + 2 * num;
  opt_size[1] = size[1] + 2 * num;
  return opt_size;
}


/**
 * Determines if a size has a positive area.
 * @param {Size} size The size to test.
 * @return {boolean} The size has a positive area.
 */
function hasArea(size) {
  return size[0] > 0 && size[1] > 0;
}


/**
 * Returns a size scaled by a ratio. The result will be an array of integers.
 * @param {Size} size Size.
 * @param {number} ratio Ratio.
 * @param {Size=} opt_size Optional reusable size array.
 * @return {Size} The scaled size.
 */
function scale(size, ratio, opt_size) {
  if (opt_size === undefined) {
    opt_size = [0, 0];
  }
  opt_size[0] = (size[0] * ratio + 0.5) | 0;
  opt_size[1] = (size[1] * ratio + 0.5) | 0;
  return opt_size;
}


/**
 * Returns an `Size` array for the passed in number (meaning: square) or
 * `Size` array.
 * (meaning: non-square),
 * @param {number|Size} size Width and height.
 * @param {Size=} opt_size Optional reusable size array.
 * @return {Size} Size.
 * @api
 */
function toSize(size, opt_size) {
  if (Array.isArray(size)) {
    return size;
  } else {
    if (opt_size === undefined) {
      opt_size = [size, size];
    } else {
      opt_size[0] = opt_size[1] = /** @type {number} */ (size);
    }
    return opt_size;
  }
}

//# sourceMappingURL=size.js.map

/***/ }),

/***/ "./node_modules/ol/source.js":
/*!***********************************!*\
  !*** ./node_modules/ol/source.js ***!
  \***********************************/
/*! exports provided: BingMaps, CartoDB, Cluster, Image, ImageArcGISRest, ImageCanvas, ImageMapGuide, ImageStatic, ImageWMS, OSM, Raster, Source, Stamen, Tile, TileArcGISRest, TileDebug, TileImage, TileJSON, TileWMS, UrlTile, UTFGrid, Vector, VectorTile, WMTS, XYZ, Zoomify */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _source_BingMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./source/BingMaps.js */ "./node_modules/ol/source/BingMaps.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BingMaps", function() { return _source_BingMaps_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _source_CartoDB_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./source/CartoDB.js */ "./node_modules/ol/source/CartoDB.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CartoDB", function() { return _source_CartoDB_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _source_Cluster_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./source/Cluster.js */ "./node_modules/ol/source/Cluster.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Cluster", function() { return _source_Cluster_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _source_Image_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./source/Image.js */ "./node_modules/ol/source/Image.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Image", function() { return _source_Image_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _source_ImageArcGISRest_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./source/ImageArcGISRest.js */ "./node_modules/ol/source/ImageArcGISRest.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ImageArcGISRest", function() { return _source_ImageArcGISRest_js__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _source_ImageCanvas_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./source/ImageCanvas.js */ "./node_modules/ol/source/ImageCanvas.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ImageCanvas", function() { return _source_ImageCanvas_js__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _source_ImageMapGuide_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./source/ImageMapGuide.js */ "./node_modules/ol/source/ImageMapGuide.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ImageMapGuide", function() { return _source_ImageMapGuide_js__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _source_ImageStatic_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./source/ImageStatic.js */ "./node_modules/ol/source/ImageStatic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ImageStatic", function() { return _source_ImageStatic_js__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _source_ImageWMS_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./source/ImageWMS.js */ "./node_modules/ol/source/ImageWMS.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ImageWMS", function() { return _source_ImageWMS_js__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _source_OSM_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./source/OSM.js */ "./node_modules/ol/source/OSM.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "OSM", function() { return _source_OSM_js__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _source_Raster_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./source/Raster.js */ "./node_modules/ol/source/Raster.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Raster", function() { return _source_Raster_js__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _source_Source_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./source/Source.js */ "./node_modules/ol/source/Source.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Source", function() { return _source_Source_js__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _source_Stamen_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./source/Stamen.js */ "./node_modules/ol/source/Stamen.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Stamen", function() { return _source_Stamen_js__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _source_Tile_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./source/Tile.js */ "./node_modules/ol/source/Tile.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tile", function() { return _source_Tile_js__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _source_TileArcGISRest_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./source/TileArcGISRest.js */ "./node_modules/ol/source/TileArcGISRest.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TileArcGISRest", function() { return _source_TileArcGISRest_js__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony import */ var _source_TileDebug_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./source/TileDebug.js */ "./node_modules/ol/source/TileDebug.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TileDebug", function() { return _source_TileDebug_js__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony import */ var _source_TileImage_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./source/TileImage.js */ "./node_modules/ol/source/TileImage.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TileImage", function() { return _source_TileImage_js__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony import */ var _source_TileJSON_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./source/TileJSON.js */ "./node_modules/ol/source/TileJSON.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TileJSON", function() { return _source_TileJSON_js__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony import */ var _source_TileWMS_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./source/TileWMS.js */ "./node_modules/ol/source/TileWMS.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TileWMS", function() { return _source_TileWMS_js__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony import */ var _source_UrlTile_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./source/UrlTile.js */ "./node_modules/ol/source/UrlTile.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "UrlTile", function() { return _source_UrlTile_js__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony import */ var _source_UTFGrid_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./source/UTFGrid.js */ "./node_modules/ol/source/UTFGrid.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "UTFGrid", function() { return _source_UTFGrid_js__WEBPACK_IMPORTED_MODULE_20__["default"]; });

/* harmony import */ var _source_Vector_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./source/Vector.js */ "./node_modules/ol/source/Vector.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Vector", function() { return _source_Vector_js__WEBPACK_IMPORTED_MODULE_21__["default"]; });

/* harmony import */ var _source_VectorTile_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./source/VectorTile.js */ "./node_modules/ol/source/VectorTile.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VectorTile", function() { return _source_VectorTile_js__WEBPACK_IMPORTED_MODULE_22__["default"]; });

/* harmony import */ var _source_WMTS_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./source/WMTS.js */ "./node_modules/ol/source/WMTS.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WMTS", function() { return _source_WMTS_js__WEBPACK_IMPORTED_MODULE_23__["default"]; });

/* harmony import */ var _source_XYZ_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./source/XYZ.js */ "./node_modules/ol/source/XYZ.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "XYZ", function() { return _source_XYZ_js__WEBPACK_IMPORTED_MODULE_24__["default"]; });

/* harmony import */ var _source_Zoomify_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./source/Zoomify.js */ "./node_modules/ol/source/Zoomify.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Zoomify", function() { return _source_Zoomify_js__WEBPACK_IMPORTED_MODULE_25__["default"]; });

/**
 * @module ol/source
 */




























//# sourceMappingURL=source.js.map

/***/ }),

/***/ "./node_modules/ol/source/BingMaps.js":
/*!********************************************!*\
  !*** ./node_modules/ol/source/BingMaps.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tileurlfunction.js */ "./node_modules/ol/tileurlfunction.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _net_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../net.js */ "./node_modules/ol/net.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _State_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./State.js */ "./node_modules/ol/source/State.js");
/* harmony import */ var _TileImage_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./TileImage.js */ "./node_modules/ol/source/TileImage.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../tilegrid.js */ "./node_modules/ol/tilegrid.js");
/**
 * @module ol/source/BingMaps
 */











/**
 * The attribution containing a link to the Microsoft® Bing™ Maps Platform APIs’
 * Terms Of Use.
 * @const
 * @type {string}
 */
var TOS_ATTRIBUTION = '<a class="ol-attribution-bing-tos" ' +
      'href="https://www.microsoft.com/maps/product/terms.html">' +
      'Terms of Use</a>';


/**
 * @typedef {Object} Options
 * @property {number} [cacheSize=2048] Cache size.
 * @property {boolean} [hidpi=false] If `true` hidpi tiles will be requested.
 * @property {string} [culture='en-us'] Culture code.
 * @property {string} key Bing Maps API key. Get yours at http://www.bingmapsportal.com/.
 * @property {string} imagerySet Type of imagery.
 * @property {number} [maxZoom=21] Max zoom. Default is what's advertized by the BingMaps service.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 */


/**
 * @typedef {Object} BingMapsImageryMetadataResponse
 * @property {number} statusCode The response status code
 * @property {string} statusDescription The response status description
 * @property {string} authenticationResultCode The authentication result code
 * @property {Array<ResourceSet>} resourceSets The array of resource sets
 */


/**
 * @typedef {Object} ResourceSet
 * @property {Array<Resource>} resources
 */


/**
 * @typedef {Object} Resource
 * @property {number} imageHeight The image height
 * @property {number} imageWidth The image width
 * @property {number} zoomMin The minimum zoom level
 * @property {number} zoomMax The maximum zoom level
 * @property {string} imageUrl The image URL
 * @property {Array<string>} imageUrlSubdomains The image URL subdomains for rotation
 * @property {Array<ImageryProvider>} [imageryProviders] The array of ImageryProviders
 */


/**
 * @typedef {Object} ImageryProvider
 * @property {Array<CoverageArea>} coverageAreas The coverage areas
 * @property {string} [attribution] The attribution
 */


/**
 * @typedef {Object} CoverageArea
 * @property {number} zoomMin The minimum zoom
 * @property {number} zoomMax The maximum zoom
 * @property {Array<number>} bbox The coverage bounding box
 */


/**
 * @classdesc
 * Layer source for Bing Maps tile data.
 * @api
 */
var BingMaps = /*@__PURE__*/(function (TileImage) {
  function BingMaps(options) {

    var hidpi = options.hidpi !== undefined ? options.hidpi : false;

    TileImage.call(this, {
      cacheSize: options.cacheSize,
      crossOrigin: 'anonymous',
      opaque: true,
      projection: Object(_proj_js__WEBPACK_IMPORTED_MODULE_3__["get"])('EPSG:3857'),
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      state: _State_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOADING,
      tileLoadFunction: options.tileLoadFunction,
      tilePixelRatio: hidpi ? 2 : 1,
      wrapX: options.wrapX !== undefined ? options.wrapX : true,
      transition: options.transition
    });

    /**
     * @private
     * @type {boolean}
     */
    this.hidpi_ = hidpi;


    /**
     * @private
     * @type {string}
     */
    this.culture_ = options.culture !== undefined ? options.culture : 'en-us';

    /**
     * @private
     * @type {number}
     */
    this.maxZoom_ = options.maxZoom !== undefined ? options.maxZoom : -1;

    /**
     * @private
     * @type {string}
     */
    this.apiKey_ = options.key;

    /**
     * @private
     * @type {string}
     */
    this.imagerySet_ = options.imagerySet;

    var url = 'https://dev.virtualearth.net/REST/v1/Imagery/Metadata/' +
        this.imagerySet_ +
        '?uriScheme=https&include=ImageryProviders&key=' + this.apiKey_ +
        '&c=' + this.culture_;

    Object(_net_js__WEBPACK_IMPORTED_MODULE_2__["jsonp"])(url, this.handleImageryMetadataResponse.bind(this), undefined,
      'jsonp');

  }

  if ( TileImage ) BingMaps.__proto__ = TileImage;
  BingMaps.prototype = Object.create( TileImage && TileImage.prototype );
  BingMaps.prototype.constructor = BingMaps;

  /**
   * Get the api key used for this source.
   *
   * @return {string} The api key.
   * @api
   */
  BingMaps.prototype.getApiKey = function getApiKey () {
    return this.apiKey_;
  };

  /**
   * Get the imagery set associated with this source.
   *
   * @return {string} The imagery set.
   * @api
   */
  BingMaps.prototype.getImagerySet = function getImagerySet () {
    return this.imagerySet_;
  };

  /**
   * @param {BingMapsImageryMetadataResponse} response Response.
   */
  BingMaps.prototype.handleImageryMetadataResponse = function handleImageryMetadataResponse (response) {
    if (response.statusCode != 200 ||
        response.statusDescription != 'OK' ||
        response.authenticationResultCode != 'ValidCredentials' ||
        response.resourceSets.length != 1 ||
        response.resourceSets[0].resources.length != 1) {
      this.setState(_State_js__WEBPACK_IMPORTED_MODULE_4__["default"].ERROR);
      return;
    }

    var resource = response.resourceSets[0].resources[0];
    var maxZoom = this.maxZoom_ == -1 ? resource.zoomMax : this.maxZoom_;

    var sourceProjection = this.getProjection();
    var extent = Object(_tilegrid_js__WEBPACK_IMPORTED_MODULE_7__["extentFromProjection"])(sourceProjection);
    var scale = this.hidpi_ ? 2 : 1;
    var tileSize = resource.imageWidth == resource.imageHeight ?
      resource.imageWidth / scale :
      [resource.imageWidth / scale, resource.imageHeight / scale];

    var tileGrid = Object(_tilegrid_js__WEBPACK_IMPORTED_MODULE_7__["createXYZ"])({
      extent: extent,
      minZoom: resource.zoomMin,
      maxZoom: maxZoom,
      tileSize: tileSize
    });
    this.tileGrid = tileGrid;

    var culture = this.culture_;
    var hidpi = this.hidpi_;
    this.tileUrlFunction = Object(_tileurlfunction_js__WEBPACK_IMPORTED_MODULE_0__["createFromTileUrlFunctions"])(
      resource.imageUrlSubdomains.map(function(subdomain) {
        var quadKeyTileCoord = [0, 0, 0];
        var imageUrl = resource.imageUrl
          .replace('{subdomain}', subdomain)
          .replace('{culture}', culture);
        return (
          /**
           * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
           * @param {number} pixelRatio Pixel ratio.
           * @param {import("../proj/Projection.js").default} projection Projection.
           * @return {string|undefined} Tile URL.
           */
          function(tileCoord, pixelRatio, projection) {
            if (!tileCoord) {
              return undefined;
            } else {
              Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_6__["createOrUpdate"])(tileCoord[0], tileCoord[1], -tileCoord[2] - 1, quadKeyTileCoord);
              var url = imageUrl;
              if (hidpi) {
                url += '&dpi=d1&device=mobile';
              }
              return url.replace('{quadkey}', Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_6__["quadKey"])(quadKeyTileCoord));
            }
          }
        );
      }));

    if (resource.imageryProviders) {
      var transform = Object(_proj_js__WEBPACK_IMPORTED_MODULE_3__["getTransformFromProjections"])(
        Object(_proj_js__WEBPACK_IMPORTED_MODULE_3__["get"])('EPSG:4326'), this.getProjection());

      this.setAttributions(function(frameState) {
        var attributions = [];
        var viewState = frameState.viewState;
        var tileGrid = this.getTileGrid();
        var tileCoord = tileGrid.getTileCoordForCoordAndResolution(viewState.center, viewState.resolution);
        var zoom = tileCoord[0];
        resource.imageryProviders.map(function(imageryProvider) {
          var intersecting = false;
          var coverageAreas = imageryProvider.coverageAreas;
          for (var i = 0, ii = coverageAreas.length; i < ii; ++i) {
            var coverageArea = coverageAreas[i];
            if (zoom >= coverageArea.zoomMin && zoom <= coverageArea.zoomMax) {
              var bbox = coverageArea.bbox;
              var epsg4326Extent = [bbox[1], bbox[0], bbox[3], bbox[2]];
              var extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["applyTransform"])(epsg4326Extent, transform);
              if (Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["intersects"])(extent, frameState.extent)) {
                intersecting = true;
                break;
              }
            }
          }
          if (intersecting) {
            attributions.push(imageryProvider.attribution);
          }
        });

        attributions.push(TOS_ATTRIBUTION);
        return attributions;
      }.bind(this));
    }

    this.setState(_State_js__WEBPACK_IMPORTED_MODULE_4__["default"].READY);
  };

  return BingMaps;
}(_TileImage_js__WEBPACK_IMPORTED_MODULE_5__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (BingMaps);

//# sourceMappingURL=BingMaps.js.map

/***/ }),

/***/ "./node_modules/ol/source/CartoDB.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/source/CartoDB.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _State_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./State.js */ "./node_modules/ol/source/State.js");
/* harmony import */ var _XYZ_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./XYZ.js */ "./node_modules/ol/source/XYZ.js");
/**
 * @module ol/source/CartoDB
 */





/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize=2048] Cache size.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to
 * access pixel data with the Canvas renderer.  See
 * https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {import("../proj.js").ProjectionLike} [projection='EPSG:3857'] Projection.
 * @property {number} [maxZoom=18] Max zoom.
 * @property {number} [minZoom] Minimum zoom.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {Object} [config] If using anonymous maps, the CartoDB config to use. See
 * http://docs.cartodb.com/cartodb-platform/maps-api/anonymous-maps/
 * for more detail.
 * If using named maps, a key-value lookup with the template parameters.
 * See http://docs.cartodb.com/cartodb-platform/maps-api/named-maps/
 * for more detail.
 * @property {string} [map] If using named maps, this will be the name of the template to load.
 * See http://docs.cartodb.com/cartodb-platform/maps-api/named-maps/
 * for more detail.
 * @property {string} account If using named maps, this will be the name of the template to load.
 */


/**
 * @typedef {Object} CartoDBLayerInfo
 * @property {string} layergroupid The layer group ID
 * @property {{https: string}} cdn_url The CDN URL
 */

/**
 * @classdesc
 * Layer source for the CartoDB Maps API.
 * @api
 */
var CartoDB = /*@__PURE__*/(function (XYZ) {
  function CartoDB(options) {
    XYZ.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      maxZoom: options.maxZoom !== undefined ? options.maxZoom : 18,
      minZoom: options.minZoom,
      projection: options.projection,
      wrapX: options.wrapX
    });

    /**
     * @type {string}
     * @private
     */
    this.account_ = options.account;

    /**
     * @type {string}
     * @private
     */
    this.mapId_ = options.map || '';

    /**
     * @type {!Object}
     * @private
     */
    this.config_ = options.config || {};

    /**
     * @type {!Object<string, CartoDBLayerInfo>}
     * @private
     */
    this.templateCache_ = {};

    this.initializeMap_();
  }

  if ( XYZ ) CartoDB.__proto__ = XYZ;
  CartoDB.prototype = Object.create( XYZ && XYZ.prototype );
  CartoDB.prototype.constructor = CartoDB;

  /**
   * Returns the current config.
   * @return {!Object} The current configuration.
   * @api
   */
  CartoDB.prototype.getConfig = function getConfig () {
    return this.config_;
  };

  /**
   * Updates the carto db config.
   * @param {Object} config a key-value lookup. Values will replace current values
   *     in the config.
   * @api
   */
  CartoDB.prototype.updateConfig = function updateConfig (config) {
    Object(_obj_js__WEBPACK_IMPORTED_MODULE_0__["assign"])(this.config_, config);
    this.initializeMap_();
  };

  /**
   * Sets the CartoDB config
   * @param {Object} config In the case of anonymous maps, a CartoDB configuration
   *     object.
   * If using named maps, a key-value lookup with the template parameters.
   * @api
   */
  CartoDB.prototype.setConfig = function setConfig (config) {
    this.config_ = config || {};
    this.initializeMap_();
  };

  /**
   * Issue a request to initialize the CartoDB map.
   * @private
   */
  CartoDB.prototype.initializeMap_ = function initializeMap_ () {
    var paramHash = JSON.stringify(this.config_);
    if (this.templateCache_[paramHash]) {
      this.applyTemplate_(this.templateCache_[paramHash]);
      return;
    }
    var mapUrl = 'https://' + this.account_ + '.carto.com/api/v1/map';

    if (this.mapId_) {
      mapUrl += '/named/' + this.mapId_;
    }

    var client = new XMLHttpRequest();
    client.addEventListener('load', this.handleInitResponse_.bind(this, paramHash));
    client.addEventListener('error', this.handleInitError_.bind(this));
    client.open('POST', mapUrl);
    client.setRequestHeader('Content-type', 'application/json');
    client.send(JSON.stringify(this.config_));
  };

  /**
   * Handle map initialization response.
   * @param {string} paramHash a hash representing the parameter set that was used
   *     for the request
   * @param {Event} event Event.
   * @private
   */
  CartoDB.prototype.handleInitResponse_ = function handleInitResponse_ (paramHash, event) {
    var client = /** @type {XMLHttpRequest} */ (event.target);
    // status will be 0 for file:// urls
    if (!client.status || client.status >= 200 && client.status < 300) {
      var response;
      try {
        response = /** @type {CartoDBLayerInfo} */(JSON.parse(client.responseText));
      } catch (err) {
        this.setState(_State_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR);
        return;
      }
      this.applyTemplate_(response);
      this.templateCache_[paramHash] = response;
      this.setState(_State_js__WEBPACK_IMPORTED_MODULE_1__["default"].READY);
    } else {
      this.setState(_State_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR);
    }
  };

  /**
   * @private
   * @param {Event} event Event.
   */
  CartoDB.prototype.handleInitError_ = function handleInitError_ (event) {
    this.setState(_State_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR);
  };

  /**
   * Apply the new tile urls returned by carto db
   * @param {CartoDBLayerInfo} data Result of carto db call.
   * @private
   */
  CartoDB.prototype.applyTemplate_ = function applyTemplate_ (data) {
    var tilesUrl = 'https://' + data.cdn_url.https + '/' + this.account_ +
        '/api/v1/map/' + data.layergroupid + '/{z}/{x}/{y}.png';
    this.setUrl(tilesUrl);
  };

  return CartoDB;
}(_XYZ_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (CartoDB);

//# sourceMappingURL=CartoDB.js.map

/***/ }),

/***/ "./node_modules/ol/source/Cluster.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/source/Cluster.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Feature.js */ "./node_modules/ol/Feature.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../coordinate.js */ "./node_modules/ol/coordinate.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../geom/Point.js */ "./node_modules/ol/geom/Point.js");
/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Vector.js */ "./node_modules/ol/source/Vector.js");
/**
 * @module ol/source/Cluster
 */












/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [distance=20] Minimum distance in pixels between clusters.
 * @property {function(Feature):Point} [geometryFunction]
 * Function that takes an {@link module:ol/Feature} as argument and returns an
 * {@link module:ol/geom/Point} as cluster calculation point for the feature. When a
 * feature should not be considered for clustering, the function should return
 * `null`. The default, which works when the underyling source contains point
 * features only, is
 * ```js
 * function(feature) {
 *   return feature.getGeometry();
 * }
 * ```
 * See {@link module:ol/geom/Polygon~Polygon#getInteriorPoint} for a way to get a cluster
 * calculation point for polygons.
 * @property {VectorSource} source Source.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 */


/**
 * @classdesc
 * Layer source to cluster vector data. Works out of the box with point
 * geometries. For other geometry types, or if not all geometries should be
 * considered for clustering, a custom `geometryFunction` can be defined.
 * @api
 */
var Cluster = /*@__PURE__*/(function (VectorSource) {
  function Cluster(options) {
    VectorSource.call(this, {
      attributions: options.attributions,
      wrapX: options.wrapX
    });

    /**
     * @type {number|undefined}
     * @protected
     */
    this.resolution = undefined;

    /**
     * @type {number}
     * @protected
     */
    this.distance = options.distance !== undefined ? options.distance : 20;

    /**
     * @type {Array<Feature>}
     * @protected
     */
    this.features = [];

    /**
     * @param {Feature} feature Feature.
     * @return {Point} Cluster calculation point.
     * @protected
     */
    this.geometryFunction = options.geometryFunction || function(feature) {
      var geometry = /** @type {Point} */ (feature.getGeometry());
      Object(_asserts_js__WEBPACK_IMPORTED_MODULE_1__["assert"])(geometry.getType() == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POINT,
        10); // The default `geometryFunction` can only handle `Point` geometries
      return geometry;
    };

    /**
     * @type {VectorSource}
     * @protected
     */
    this.source = options.source;

    Object(_events_js__WEBPACK_IMPORTED_MODULE_5__["listen"])(this.source, _events_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].CHANGE, this.refresh, this);
  }

  if ( VectorSource ) Cluster.__proto__ = VectorSource;
  Cluster.prototype = Object.create( VectorSource && VectorSource.prototype );
  Cluster.prototype.constructor = Cluster;

  /**
   * Get the distance in pixels between clusters.
   * @return {number} Distance.
   * @api
   */
  Cluster.prototype.getDistance = function getDistance () {
    return this.distance;
  };

  /**
   * Get a reference to the wrapped source.
   * @return {VectorSource} Source.
   * @api
   */
  Cluster.prototype.getSource = function getSource () {
    return this.source;
  };

  /**
   * @inheritDoc
   */
  Cluster.prototype.loadFeatures = function loadFeatures (extent, resolution, projection) {
    this.source.loadFeatures(extent, resolution, projection);
    if (resolution !== this.resolution) {
      this.clear();
      this.resolution = resolution;
      this.cluster();
      this.addFeatures(this.features);
    }
  };

  /**
   * Set the distance in pixels between clusters.
   * @param {number} distance The distance in pixels.
   * @api
   */
  Cluster.prototype.setDistance = function setDistance (distance) {
    this.distance = distance;
    this.refresh();
  };

  /**
   * handle the source changing
   * @override
   */
  Cluster.prototype.refresh = function refresh () {
    this.clear();
    this.cluster();
    this.addFeatures(this.features);
    VectorSource.prototype.refresh.call(this);
  };

  /**
   * @protected
   */
  Cluster.prototype.cluster = function cluster () {
    if (this.resolution === undefined) {
      return;
    }
    this.features.length = 0;
    var extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["createEmpty"])();
    var mapDistance = this.distance * this.resolution;
    var features = this.source.getFeatures();

    /**
     * @type {!Object<string, boolean>}
     */
    var clustered = {};

    for (var i = 0, ii = features.length; i < ii; i++) {
      var feature = features[i];
      if (!(Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature) in clustered)) {
        var geometry = this.geometryFunction(feature);
        if (geometry) {
          var coordinates = geometry.getCoordinates();
          Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["createOrUpdateFromCoordinate"])(coordinates, extent);
          Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["buffer"])(extent, mapDistance, extent);

          var neighbors = this.source.getFeaturesInExtent(extent);
          neighbors = neighbors.filter(function(neighbor) {
            var uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(neighbor);
            if (!(uid in clustered)) {
              clustered[uid] = true;
              return true;
            } else {
              return false;
            }
          });
          this.features.push(this.createCluster(neighbors));
        }
      }
    }
  };

  /**
   * @param {Array<Feature>} features Features
   * @return {Feature} The cluster feature.
   * @protected
   */
  Cluster.prototype.createCluster = function createCluster (features) {
    var centroid = [0, 0];
    for (var i = features.length - 1; i >= 0; --i) {
      var geometry = this.geometryFunction(features[i]);
      if (geometry) {
        Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_4__["add"])(centroid, geometry.getCoordinates());
      } else {
        features.splice(i, 1);
      }
    }
    Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_4__["scale"])(centroid, 1 / features.length);

    var cluster = new _Feature_js__WEBPACK_IMPORTED_MODULE_2__["default"](new _geom_Point_js__WEBPACK_IMPORTED_MODULE_8__["default"](centroid));
    cluster.set('features', features);
    return cluster;
  };

  return Cluster;
}(_Vector_js__WEBPACK_IMPORTED_MODULE_9__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (Cluster);

//# sourceMappingURL=Cluster.js.map

/***/ }),

/***/ "./node_modules/ol/source/Image.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/source/Image.js ***!
  \*****************************************/
/*! exports provided: defaultImageLoadFunction, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultImageLoadFunction", function() { return defaultImageLoadFunction; });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _reproj_common_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../reproj/common.js */ "./node_modules/ol/reproj/common.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ImageState.js */ "./node_modules/ol/ImageState.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _reproj_Image_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../reproj/Image.js */ "./node_modules/ol/reproj/Image.js");
/* harmony import */ var _Source_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Source.js */ "./node_modules/ol/source/Source.js");
/**
 * @module ol/source/Image
 */











/**
 * @enum {string}
 */
var ImageSourceEventType = {

  /**
   * Triggered when an image starts loading.
   * @event ol/source/Image~ImageSourceEvent#imageloadstart
   * @api
   */
  IMAGELOADSTART: 'imageloadstart',

  /**
   * Triggered when an image finishes loading.
   * @event ol/source/Image~ImageSourceEvent#imageloadend
   * @api
   */
  IMAGELOADEND: 'imageloadend',

  /**
   * Triggered if image loading results in an error.
   * @event ol/source/Image~ImageSourceEvent#imageloaderror
   * @api
   */
  IMAGELOADERROR: 'imageloaderror'

};


/**
 * @classdesc
 * Events emitted by {@link module:ol/source/Image~ImageSource} instances are instances of this
 * type.
 */
var ImageSourceEvent = /*@__PURE__*/(function (Event) {
  function ImageSourceEvent(type, image) {

    Event.call(this, type);

    /**
     * The image related to the event.
     * @type {import("../Image.js").default}
     * @api
     */
    this.image = image;

  }

  if ( Event ) ImageSourceEvent.__proto__ = Event;
  ImageSourceEvent.prototype = Object.create( Event && Event.prototype );
  ImageSourceEvent.prototype.constructor = ImageSourceEvent;

  return ImageSourceEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_4__["default"]));


/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions]
 * @property {import("../proj.js").ProjectionLike} projection
 * @property {Array<number>} [resolutions]
 * @property {import("./State.js").default} [state]
 */


/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for sources providing a single image.
 * @abstract
 * @api
 */
var ImageSource = /*@__PURE__*/(function (Source) {
  function ImageSource(options) {
    Source.call(this, {
      attributions: options.attributions,
      projection: options.projection,
      state: options.state
    });

    /**
     * @private
     * @type {Array<number>}
     */
    this.resolutions_ = options.resolutions !== undefined ?
      options.resolutions : null;


    /**
     * @private
     * @type {import("../reproj/Image.js").default}
     */
    this.reprojectedImage_ = null;


    /**
     * @private
     * @type {number}
     */
    this.reprojectedRevision_ = 0;
  }

  if ( Source ) ImageSource.__proto__ = Source;
  ImageSource.prototype = Object.create( Source && Source.prototype );
  ImageSource.prototype.constructor = ImageSource;

  /**
   * @return {Array<number>} Resolutions.
   * @override
   */
  ImageSource.prototype.getResolutions = function getResolutions () {
    return this.resolutions_;
  };

  /**
   * @protected
   * @param {number} resolution Resolution.
   * @return {number} Resolution.
   */
  ImageSource.prototype.findNearestResolution = function findNearestResolution (resolution) {
    if (this.resolutions_) {
      var idx = Object(_array_js__WEBPACK_IMPORTED_MODULE_3__["linearFindNearest"])(this.resolutions_, resolution, 0);
      resolution = this.resolutions_[idx];
    }
    return resolution;
  };

  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../ImageBase.js").default} Single image.
   */
  ImageSource.prototype.getImage = function getImage (extent, resolution, pixelRatio, projection) {
    var sourceProjection = this.getProjection();
    if (!_reproj_common_js__WEBPACK_IMPORTED_MODULE_1__["ENABLE_RASTER_REPROJECTION"] ||
        !sourceProjection ||
        !projection ||
        Object(_proj_js__WEBPACK_IMPORTED_MODULE_6__["equivalent"])(sourceProjection, projection)) {
      if (sourceProjection) {
        projection = sourceProjection;
      }
      return this.getImageInternal(extent, resolution, pixelRatio, projection);
    } else {
      if (this.reprojectedImage_) {
        if (this.reprojectedRevision_ == this.getRevision() &&
            Object(_proj_js__WEBPACK_IMPORTED_MODULE_6__["equivalent"])(
              this.reprojectedImage_.getProjection(), projection) &&
            this.reprojectedImage_.getResolution() == resolution &&
            Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["equals"])(this.reprojectedImage_.getExtent(), extent)) {
          return this.reprojectedImage_;
        }
        this.reprojectedImage_.dispose();
        this.reprojectedImage_ = null;
      }

      this.reprojectedImage_ = new _reproj_Image_js__WEBPACK_IMPORTED_MODULE_7__["default"](
        sourceProjection, projection, extent, resolution, pixelRatio,
        function(extent, resolution, pixelRatio) {
          return this.getImageInternal(extent, resolution,
            pixelRatio, sourceProjection);
        }.bind(this));
      this.reprojectedRevision_ = this.getRevision();

      return this.reprojectedImage_;
    }
  };

  /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../ImageBase.js").default} Single image.
   * @protected
   */
  ImageSource.prototype.getImageInternal = function getImageInternal (extent, resolution, pixelRatio, projection) {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Handle image change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */
  ImageSource.prototype.handleImageChange = function handleImageChange (event) {
    var image = /** @type {import("../Image.js").default} */ (event.target);
    switch (image.getState()) {
      case _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING:
        this.loading = true;
        this.dispatchEvent(
          new ImageSourceEvent(ImageSourceEventType.IMAGELOADSTART,
            image));
        break;
      case _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED:
        this.loading = false;
        this.dispatchEvent(
          new ImageSourceEvent(ImageSourceEventType.IMAGELOADEND,
            image));
        break;
      case _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR:
        this.loading = false;
        this.dispatchEvent(
          new ImageSourceEvent(ImageSourceEventType.IMAGELOADERROR,
            image));
        break;
      default:
        // pass
    }
  };

  return ImageSource;
}(_Source_js__WEBPACK_IMPORTED_MODULE_8__["default"]));


/**
 * Default image load function for image sources that use import("../Image.js").Image image
 * instances.
 * @param {import("../Image.js").default} image Image.
 * @param {string} src Source.
 */
function defaultImageLoadFunction(image, src) {
  /** @type {HTMLImageElement|HTMLVideoElement} */ (image.getImage()).src = src;
}


/* harmony default export */ __webpack_exports__["default"] = (ImageSource);

//# sourceMappingURL=Image.js.map

/***/ }),

/***/ "./node_modules/ol/source/ImageArcGISRest.js":
/*!***************************************************!*\
  !*** ./node_modules/ol/source/ImageArcGISRest.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Image.js */ "./node_modules/ol/Image.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Image.js */ "./node_modules/ol/source/Image.js");
/* harmony import */ var _uri_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../uri.js */ "./node_modules/ol/uri.js");
/**
 * @module ol/source/ImageArcGISRest
 */











/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to
 * access pixel data with the Canvas renderer.  See
 * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image} for more detail.
 * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting the image from
 * the remote server.
 * @property {import("../Image.js").LoadFunction} [imageLoadFunction] Optional function to load an image given
 * a URL.
 * @property {Object<string,*>} [params] ArcGIS Rest parameters. This field is optional. Service
 * defaults will be used for any fields not specified. `FORMAT` is `PNG32` by default. `F` is
 * `IMAGE` by default. `TRANSPARENT` is `true` by default.  `BBOX`, `SIZE`, `BBOXSR`, and `IMAGESR`
 * will be set dynamically. Set `LAYERS` to override the default service layer visibility. See
 * {@link http://resources.arcgis.com/en/help/arcgis-rest-api/index.html#/Export_Map/02r3000000v7000000/}
 * for further reference.
 * @property {import("../proj.js").ProjectionLike} projection Projection.
 * @property {number} [ratio=1.5] Ratio. `1` means image requests are the size of the map viewport,
 * `2` means twice the size of the map viewport, and so on.
 * @property {Array<number>} [resolutions] Resolutions. If specified, requests will be made for
 * these resolutions only.
 * @property {string} [url] ArcGIS Rest service URL for a Map Service or Image Service. The url
 * should include /MapServer or /ImageServer.
 */


/**
 * @classdesc
 * Source for data from ArcGIS Rest services providing single, untiled images.
 * Useful when underlying map service has labels.
 *
 * If underlying map service is not using labels,
 * take advantage of ol image caching and use
 * {@link module:ol/source/TileArcGISRest} data source.
 *
 * @fires ol/source/Image~ImageSourceEvent
 * @api
 */
var ImageArcGISRest = /*@__PURE__*/(function (ImageSource) {
  function ImageArcGISRest(opt_options) {

    var options = opt_options || /** @type {Options} */ ({});

    ImageSource.call(this, {
      attributions: options.attributions,
      projection: options.projection,
      resolutions: options.resolutions
    });

    /**
     * @private
     * @type {?string}
     */
    this.crossOrigin_ =
        options.crossOrigin !== undefined ? options.crossOrigin : null;

    /**
     * @private
     * @type {boolean}
     */
    this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;

    /**
     * @private
     * @type {string|undefined}
     */
    this.url_ = options.url;

    /**
     * @private
     * @type {import("../Image.js").LoadFunction}
     */
    this.imageLoadFunction_ = options.imageLoadFunction !== undefined ?
      options.imageLoadFunction : _Image_js__WEBPACK_IMPORTED_MODULE_6__["defaultImageLoadFunction"];


    /**
     * @private
     * @type {!Object}
     */
    this.params_ = options.params || {};

    /**
     * @private
     * @type {import("../Image.js").default}
     */
    this.image_ = null;

    /**
     * @private
     * @type {import("../size.js").Size}
     */
    this.imageSize_ = [0, 0];


    /**
     * @private
     * @type {number}
     */
    this.renderedRevision_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.ratio_ = options.ratio !== undefined ? options.ratio : 1.5;

  }

  if ( ImageSource ) ImageArcGISRest.__proto__ = ImageSource;
  ImageArcGISRest.prototype = Object.create( ImageSource && ImageSource.prototype );
  ImageArcGISRest.prototype.constructor = ImageArcGISRest;

  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */
  ImageArcGISRest.prototype.getParams = function getParams () {
    return this.params_;
  };

  /**
   * @inheritDoc
   */
  ImageArcGISRest.prototype.getImageInternal = function getImageInternal (extent, resolution, pixelRatio, projection) {

    if (this.url_ === undefined) {
      return null;
    }

    resolution = this.findNearestResolution(resolution);
    pixelRatio = this.hidpi_ ? pixelRatio : 1;

    var image = this.image_;
    if (image &&
        this.renderedRevision_ == this.getRevision() &&
        image.getResolution() == resolution &&
        image.getPixelRatio() == pixelRatio &&
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["containsExtent"])(image.getExtent(), extent)) {
      return image;
    }

    var params = {
      'F': 'image',
      'FORMAT': 'PNG32',
      'TRANSPARENT': true
    };
    Object(_obj_js__WEBPACK_IMPORTED_MODULE_5__["assign"])(params, this.params_);

    extent = extent.slice();
    var centerX = (extent[0] + extent[2]) / 2;
    var centerY = (extent[1] + extent[3]) / 2;
    if (this.ratio_ != 1) {
      var halfWidth = this.ratio_ * Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["getWidth"])(extent) / 2;
      var halfHeight = this.ratio_ * Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["getHeight"])(extent) / 2;
      extent[0] = centerX - halfWidth;
      extent[1] = centerY - halfHeight;
      extent[2] = centerX + halfWidth;
      extent[3] = centerY + halfHeight;
    }

    var imageResolution = resolution / pixelRatio;

    // Compute an integer width and height.
    var width = Math.ceil(Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["getWidth"])(extent) / imageResolution);
    var height = Math.ceil(Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["getHeight"])(extent) / imageResolution);

    // Modify the extent to match the integer width and height.
    extent[0] = centerX - imageResolution * width / 2;
    extent[2] = centerX + imageResolution * width / 2;
    extent[1] = centerY - imageResolution * height / 2;
    extent[3] = centerY + imageResolution * height / 2;

    this.imageSize_[0] = width;
    this.imageSize_[1] = height;

    var url = this.getRequestUrl_(extent, this.imageSize_, pixelRatio,
      projection, params);

    this.image_ = new _Image_js__WEBPACK_IMPORTED_MODULE_0__["default"](extent, resolution, pixelRatio,
      url, this.crossOrigin_, this.imageLoadFunction_);

    this.renderedRevision_ = this.getRevision();

    Object(_events_js__WEBPACK_IMPORTED_MODULE_2__["listen"])(this.image_, _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].CHANGE,
      this.handleImageChange, this);

    return this.image_;

  };

  /**
   * Return the image load function of the source.
   * @return {import("../Image.js").LoadFunction} The image load function.
   * @api
   */
  ImageArcGISRest.prototype.getImageLoadFunction = function getImageLoadFunction () {
    return this.imageLoadFunction_;
  };

  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {import("../size.js").Size} size Size.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {Object} params Params.
   * @return {string} Request URL.
   * @private
   */
  ImageArcGISRest.prototype.getRequestUrl_ = function getRequestUrl_ (extent, size, pixelRatio, projection, params) {
    // ArcGIS Server only wants the numeric portion of the projection ID.
    var srid = projection.getCode().split(':').pop();

    params['SIZE'] = size[0] + ',' + size[1];
    params['BBOX'] = extent.join(',');
    params['BBOXSR'] = srid;
    params['IMAGESR'] = srid;
    params['DPI'] = Math.round(90 * pixelRatio);

    var url = this.url_;

    var modifiedUrl = url
      .replace(/MapServer\/?$/, 'MapServer/export')
      .replace(/ImageServer\/?$/, 'ImageServer/exportImage');
    if (modifiedUrl == url) {
      Object(_asserts_js__WEBPACK_IMPORTED_MODULE_1__["assert"])(false, 50); // `options.featureTypes` should be an Array
    }
    return Object(_uri_js__WEBPACK_IMPORTED_MODULE_7__["appendParams"])(modifiedUrl, params);
  };

  /**
   * Return the URL used for this ArcGIS source.
   * @return {string|undefined} URL.
   * @api
   */
  ImageArcGISRest.prototype.getUrl = function getUrl () {
    return this.url_;
  };

  /**
   * Set the image load function of the source.
   * @param {import("../Image.js").LoadFunction} imageLoadFunction Image load function.
   * @api
   */
  ImageArcGISRest.prototype.setImageLoadFunction = function setImageLoadFunction (imageLoadFunction) {
    this.image_ = null;
    this.imageLoadFunction_ = imageLoadFunction;
    this.changed();
  };

  /**
   * Set the URL to use for requests.
   * @param {string|undefined} url URL.
   * @api
   */
  ImageArcGISRest.prototype.setUrl = function setUrl (url) {
    if (url != this.url_) {
      this.url_ = url;
      this.image_ = null;
      this.changed();
    }
  };

  /**
   * Update the user-provided params.
   * @param {Object} params Params.
   * @api
   */
  ImageArcGISRest.prototype.updateParams = function updateParams (params) {
    Object(_obj_js__WEBPACK_IMPORTED_MODULE_5__["assign"])(this.params_, params);
    this.image_ = null;
    this.changed();
  };

  return ImageArcGISRest;
}(_Image_js__WEBPACK_IMPORTED_MODULE_6__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (ImageArcGISRest);

//# sourceMappingURL=ImageArcGISRest.js.map

/***/ }),

/***/ "./node_modules/ol/source/ImageCanvas.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/source/ImageCanvas.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ImageCanvas_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ImageCanvas.js */ "./node_modules/ol/ImageCanvas.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Image.js */ "./node_modules/ol/source/Image.js");
/**
 * @module ol/source/ImageCanvas
 */






/**
 * A function returning the canvas element (`{HTMLCanvasElement}`)
 * used by the source as an image. The arguments passed to the function are:
 * {@link module:ol/extent~Extent} the image extent, `{number}` the image resolution,
 * `{number}` the device pixel ratio, {@link module:ol/size~Size} the image size, and
 * {@link module:ol/proj/Projection} the image projection. The canvas returned by
 * this function is cached by the source. The this keyword inside the function
 * references the {@link module:ol/source/ImageCanvas}.
 *
 * @typedef {function(this:import("../ImageCanvas.js").default, import("../extent.js").Extent, number,
 *     number, import("../size.js").Size, import("../proj/Projection.js").default): HTMLCanvasElement} FunctionType
 */


/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {FunctionType} [canvasFunction] Canvas function.
 * The function returning the canvas element used by the source
 * as an image. The arguments passed to the function are: `{import("../extent.js").Extent}` the
 * image extent, `{number}` the image resolution, `{number}` the device pixel
 * ratio, `{import("../size.js").Size}` the image size, and `{import("../proj/Projection.js").Projection}` the image
 * projection. The canvas returned by this function is cached by the source. If
 * the value returned by the function is later changed then
 * `changed` should be called on the source for the source to
 * invalidate the current cached image. See: {@link module:ol/Observable~Observable#changed}
 * @property {import("../proj.js").ProjectionLike} projection Projection.
 * @property {number} [ratio=1.5] Ratio. 1 means canvases are the size of the map viewport, 2 means twice the
 * width and height of the map viewport, and so on. Must be `1` or higher.
 * @property {Array<number>} [resolutions] Resolutions.
 * If specified, new canvases will be created for these resolutions
 * @property {import("./State.js").default} [state] Source state.
 */


/**
 * @classdesc
 * Base class for image sources where a canvas element is the image.
 * @api
 */
var ImageCanvasSource = /*@__PURE__*/(function (ImageSource) {
  function ImageCanvasSource(opt_options) {

    var options = opt_options || /** @type {Options} */ ({});

    ImageSource.call(this, {
      attributions: options.attributions,
      projection: options.projection,
      resolutions: options.resolutions,
      state: options.state
    });

    /**
    * @private
    * @type {FunctionType}
    */
    this.canvasFunction_ = options.canvasFunction;

    /**
    * @private
    * @type {import("../ImageCanvas.js").default}
    */
    this.canvas_ = null;

    /**
    * @private
    * @type {number}
    */
    this.renderedRevision_ = 0;

    /**
    * @private
    * @type {number}
    */
    this.ratio_ = options.ratio !== undefined ?
      options.ratio : 1.5;

  }

  if ( ImageSource ) ImageCanvasSource.__proto__ = ImageSource;
  ImageCanvasSource.prototype = Object.create( ImageSource && ImageSource.prototype );
  ImageCanvasSource.prototype.constructor = ImageCanvasSource;

  /**
  * @inheritDoc
  */
  ImageCanvasSource.prototype.getImageInternal = function getImageInternal (extent, resolution, pixelRatio, projection) {
    resolution = this.findNearestResolution(resolution);

    var canvas = this.canvas_;
    if (canvas &&
       this.renderedRevision_ == this.getRevision() &&
       canvas.getResolution() == resolution &&
       canvas.getPixelRatio() == pixelRatio &&
       Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["containsExtent"])(canvas.getExtent(), extent)) {
      return canvas;
    }

    extent = extent.slice();
    Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["scaleFromCenter"])(extent, this.ratio_);
    var width = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getWidth"])(extent) / resolution;
    var height = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getHeight"])(extent) / resolution;
    var size = [width * pixelRatio, height * pixelRatio];

    var canvasElement = this.canvasFunction_.call(
      this, extent, resolution, pixelRatio, size, projection);
    if (canvasElement) {
      canvas = new _ImageCanvas_js__WEBPACK_IMPORTED_MODULE_0__["default"](extent, resolution, pixelRatio, canvasElement);
    }
    this.canvas_ = canvas;
    this.renderedRevision_ = this.getRevision();

    return canvas;
  };

  return ImageCanvasSource;
}(_Image_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (ImageCanvasSource);

//# sourceMappingURL=ImageCanvas.js.map

/***/ }),

/***/ "./node_modules/ol/source/ImageMapGuide.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/source/ImageMapGuide.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Image.js */ "./node_modules/ol/Image.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Image.js */ "./node_modules/ol/source/Image.js");
/* harmony import */ var _uri_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../uri.js */ "./node_modules/ol/uri.js");
/**
 * @module ol/source/ImageMapGuide
 */









/**
 * @typedef {Object} Options
 * @property {string} [url] The mapagent url.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to
 * access pixel data with the Canvas renderer.  See
 * https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {number} [displayDpi=96] The display resolution.
 * @property {number} [metersPerUnit=1] The meters-per-unit value.
 * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting
 * the image from the remote server.
 * @property {boolean} [useOverlay] If `true`, will use `GETDYNAMICMAPOVERLAYIMAGE`.
 * @property {import("../proj.js").ProjectionLike} projection Projection.
 * @property {number} [ratio=1] Ratio. `1` means image requests are the size of the map viewport, `2` means
 * twice the width and height of the map viewport, and so on. Must be `1` or higher.
 * @property {Array<number>} [resolutions] Resolutions.
 * If specified, requests will be made for these resolutions only.
 * @property {import("../Image.js").LoadFunction} [imageLoadFunction] Optional function to load an image given a URL.
 * @property {Object} [params] Additional parameters.
 */


/**
 * @classdesc
 * Source for images from Mapguide servers
 *
 * @fires ol/source/Image~ImageSourceEvent
 * @api
 */
var ImageMapGuide = /*@__PURE__*/(function (ImageSource) {
  function ImageMapGuide(options) {

    ImageSource.call(this, {
      projection: options.projection,
      resolutions: options.resolutions
    });

    /**
     * @private
     * @type {?string}
     */
    this.crossOrigin_ =
        options.crossOrigin !== undefined ? options.crossOrigin : null;

    /**
     * @private
     * @type {number}
     */
    this.displayDpi_ = options.displayDpi !== undefined ?
      options.displayDpi : 96;

    /**
     * @private
     * @type {!Object}
     */
    this.params_ = options.params || {};

    /**
     * @private
     * @type {string|undefined}
     */
    this.url_ = options.url;

    /**
     * @private
     * @type {import("../Image.js").LoadFunction}
     */
    this.imageLoadFunction_ = options.imageLoadFunction !== undefined ?
      options.imageLoadFunction : _Image_js__WEBPACK_IMPORTED_MODULE_5__["defaultImageLoadFunction"];

    /**
     * @private
     * @type {boolean}
     */
    this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;

    /**
     * @private
     * @type {number}
     */
    this.metersPerUnit_ = options.metersPerUnit !== undefined ?
      options.metersPerUnit : 1;

    /**
     * @private
     * @type {number}
     */
    this.ratio_ = options.ratio !== undefined ? options.ratio : 1;

    /**
     * @private
     * @type {boolean}
     */
    this.useOverlay_ = options.useOverlay !== undefined ?
      options.useOverlay : false;

    /**
     * @private
     * @type {import("../Image.js").default}
     */
    this.image_ = null;

    /**
     * @private
     * @type {number}
     */
    this.renderedRevision_ = 0;

  }

  if ( ImageSource ) ImageMapGuide.__proto__ = ImageSource;
  ImageMapGuide.prototype = Object.create( ImageSource && ImageSource.prototype );
  ImageMapGuide.prototype.constructor = ImageMapGuide;

  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */
  ImageMapGuide.prototype.getParams = function getParams () {
    return this.params_;
  };

  /**
   * @inheritDoc
   */
  ImageMapGuide.prototype.getImageInternal = function getImageInternal (extent, resolution, pixelRatio, projection) {
    resolution = this.findNearestResolution(resolution);
    pixelRatio = this.hidpi_ ? pixelRatio : 1;

    var image = this.image_;
    if (image &&
        this.renderedRevision_ == this.getRevision() &&
        image.getResolution() == resolution &&
        image.getPixelRatio() == pixelRatio &&
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["containsExtent"])(image.getExtent(), extent)) {
      return image;
    }

    if (this.ratio_ != 1) {
      extent = extent.slice();
      Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["scaleFromCenter"])(extent, this.ratio_);
    }
    var width = Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["getWidth"])(extent) / resolution;
    var height = Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["getHeight"])(extent) / resolution;
    var size = [width * pixelRatio, height * pixelRatio];

    if (this.url_ !== undefined) {
      var imageUrl = this.getUrl(this.url_, this.params_, extent, size,
        projection);
      image = new _Image_js__WEBPACK_IMPORTED_MODULE_0__["default"](extent, resolution, pixelRatio,
        imageUrl, this.crossOrigin_,
        this.imageLoadFunction_);
      Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["listen"])(image, _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CHANGE,
        this.handleImageChange, this);
    } else {
      image = null;
    }
    this.image_ = image;
    this.renderedRevision_ = this.getRevision();

    return image;
  };

  /**
   * Return the image load function of the source.
   * @return {import("../Image.js").LoadFunction} The image load function.
   * @api
   */
  ImageMapGuide.prototype.getImageLoadFunction = function getImageLoadFunction () {
    return this.imageLoadFunction_;
  };

  /**
   * Update the user-provided params.
   * @param {Object} params Params.
   * @api
   */
  ImageMapGuide.prototype.updateParams = function updateParams (params) {
    Object(_obj_js__WEBPACK_IMPORTED_MODULE_4__["assign"])(this.params_, params);
    this.changed();
  };

  /**
   * @param {string} baseUrl The mapagent url.
   * @param {Object<string, string|number>} params Request parameters.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {import("../size.js").Size} size Size.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {string} The mapagent map image request URL.
   */
  ImageMapGuide.prototype.getUrl = function getUrl (baseUrl, params, extent, size, projection) {
    var scale = getScale(extent, size,
      this.metersPerUnit_, this.displayDpi_);
    var center = Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["getCenter"])(extent);
    var baseParams = {
      'OPERATION': this.useOverlay_ ? 'GETDYNAMICMAPOVERLAYIMAGE' : 'GETMAPIMAGE',
      'VERSION': '2.0.0',
      'LOCALE': 'en',
      'CLIENTAGENT': 'ol/source/ImageMapGuide source',
      'CLIP': '1',
      'SETDISPLAYDPI': this.displayDpi_,
      'SETDISPLAYWIDTH': Math.round(size[0]),
      'SETDISPLAYHEIGHT': Math.round(size[1]),
      'SETVIEWSCALE': scale,
      'SETVIEWCENTERX': center[0],
      'SETVIEWCENTERY': center[1]
    };
    Object(_obj_js__WEBPACK_IMPORTED_MODULE_4__["assign"])(baseParams, params);
    return Object(_uri_js__WEBPACK_IMPORTED_MODULE_6__["appendParams"])(baseUrl, baseParams);
  };

  /**
   * Set the image load function of the MapGuide source.
   * @param {import("../Image.js").LoadFunction} imageLoadFunction Image load function.
   * @api
   */
  ImageMapGuide.prototype.setImageLoadFunction = function setImageLoadFunction (imageLoadFunction) {
    this.image_ = null;
    this.imageLoadFunction_ = imageLoadFunction;
    this.changed();
  };

  return ImageMapGuide;
}(_Image_js__WEBPACK_IMPORTED_MODULE_5__["default"]));


/**
 * @param {import("../extent.js").Extent} extent The map extents.
 * @param {import("../size.js").Size} size The viewport size.
 * @param {number} metersPerUnit The meters-per-unit value.
 * @param {number} dpi The display resolution.
 * @return {number} The computed map scale.
 */
function getScale(extent, size, metersPerUnit, dpi) {
  var mcsW = Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["getWidth"])(extent);
  var mcsH = Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["getHeight"])(extent);
  var devW = size[0];
  var devH = size[1];
  var mpp = 0.0254 / dpi;
  if (devH * mcsW > devW * mcsH) {
    return mcsW * metersPerUnit / (devW * mpp); // width limited
  } else {
    return mcsH * metersPerUnit / (devH * mpp); // height limited
  }
}


/* harmony default export */ __webpack_exports__["default"] = (ImageMapGuide);

//# sourceMappingURL=ImageMapGuide.js.map

/***/ }),

/***/ "./node_modules/ol/source/ImageStatic.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/source/ImageStatic.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Image.js */ "./node_modules/ol/Image.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ImageState.js */ "./node_modules/ol/ImageState.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Image.js */ "./node_modules/ol/source/Image.js");
/**
 * @module ol/source/ImageStatic
 */










/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to
 * access pixel data with the Canvas renderer.  See
 * https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {import("../extent.js").Extent} [imageExtent] Extent of the image in map coordinates.
 * This is the [left, bottom, right, top] map coordinates of your image.
 * @property {import("../Image.js").LoadFunction} [imageLoadFunction] Optional function to load an image given a URL.
 * @property {import("../proj.js").ProjectionLike} projection Projection.
 * @property {import("../size.js").Size} [imageSize] Size of the image in pixels. Usually the image size is auto-detected, so this
 * only needs to be set if auto-detection fails for some reason.
 * @property {string} url Image URL.
 */


/**
 * @classdesc
 * A layer source for displaying a single, static image.
 * @api
 */
var Static = /*@__PURE__*/(function (ImageSource) {
  function Static(options) {
    var crossOrigin = options.crossOrigin !== undefined ?
      options.crossOrigin : null;

    var /** @type {import("../Image.js").LoadFunction} */ imageLoadFunction =
        options.imageLoadFunction !== undefined ?
          options.imageLoadFunction : _Image_js__WEBPACK_IMPORTED_MODULE_7__["defaultImageLoadFunction"];

    ImageSource.call(this, {
      attributions: options.attributions,
      projection: Object(_proj_js__WEBPACK_IMPORTED_MODULE_6__["get"])(options.projection)
    });

    /**
     * @private
     * @type {string}
     */
    this.url_ = options.url;

    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    this.imageExtent_ = options.imageExtent;

    /**
     * @private
     * @type {import("../Image.js").default}
     */
    this.image_ = new _Image_js__WEBPACK_IMPORTED_MODULE_0__["default"](this.imageExtent_, undefined, 1, this.url_, crossOrigin, imageLoadFunction);

    /**
     * @private
     * @type {import("../size.js").Size}
     */
    this.imageSize_ = options.imageSize ? options.imageSize : null;

    Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(this.image_, _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].CHANGE,
      this.handleImageChange, this);

  }

  if ( ImageSource ) Static.__proto__ = ImageSource;
  Static.prototype = Object.create( ImageSource && ImageSource.prototype );
  Static.prototype.constructor = Static;

  /**
   * Returns the image extent
   * @return {import("../extent.js").Extent} image extent.
   * @api
   */
  Static.prototype.getImageExtent = function getImageExtent () {
    return this.imageExtent_;
  };

  /**
   * @inheritDoc
   */
  Static.prototype.getImageInternal = function getImageInternal (extent, resolution, pixelRatio, projection) {
    if (Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["intersects"])(extent, this.image_.getExtent())) {
      return this.image_;
    }
    return null;
  };

  /**
   * Return the URL used for this image source.
   * @return {string} URL.
   * @api
   */
  Static.prototype.getUrl = function getUrl () {
    return this.url_;
  };

  /**
   * @inheritDoc
   */
  Static.prototype.handleImageChange = function handleImageChange (evt) {
    if (this.image_.getState() == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED) {
      var imageExtent = this.image_.getExtent();
      var image = this.image_.getImage();
      var imageWidth, imageHeight;
      if (this.imageSize_) {
        imageWidth = this.imageSize_[0];
        imageHeight = this.imageSize_[1];
      } else {
        imageWidth = image.width;
        imageHeight = image.height;
      }
      var resolution = Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getHeight"])(imageExtent) / imageHeight;
      var targetWidth = Math.ceil(Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getWidth"])(imageExtent) / resolution);
      if (targetWidth != imageWidth) {
        var context = Object(_dom_js__WEBPACK_IMPORTED_MODULE_2__["createCanvasContext2D"])(targetWidth, imageHeight);
        var canvas = context.canvas;
        context.drawImage(image, 0, 0, imageWidth, imageHeight,
          0, 0, canvas.width, canvas.height);
        this.image_.setImage(canvas);
      }
    }
    ImageSource.prototype.handleImageChange.call(this, evt);
  };

  return Static;
}(_Image_js__WEBPACK_IMPORTED_MODULE_7__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (Static);

//# sourceMappingURL=ImageStatic.js.map

/***/ }),

/***/ "./node_modules/ol/source/ImageWMS.js":
/*!********************************************!*\
  !*** ./node_modules/ol/source/ImageWMS.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/ol/source/common.js");
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Image.js */ "./node_modules/ol/Image.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _reproj_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../reproj.js */ "./node_modules/ol/reproj.js");
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Image.js */ "./node_modules/ol/source/Image.js");
/* harmony import */ var _WMSServerType_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./WMSServerType.js */ "./node_modules/ol/source/WMSServerType.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../string.js */ "./node_modules/ol/string.js");
/* harmony import */ var _uri_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../uri.js */ "./node_modules/ol/uri.js");
/**
 * @module ol/source/ImageWMS
 */

















/**
 * @const
 * @type {import("../size.js").Size}
 */
var GETFEATUREINFO_IMAGE_SIZE = [101, 101];


/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to
 * access pixel data with the Canvas renderer.  See
 * https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting
 * the image from the remote server.
 * @property {import("./WMSServerType.js").default|string} [serverType] The type of
 * the remote WMS server: `mapserver`, `geoserver` or `qgis`. Only needed if `hidpi` is `true`.
 * @property {import("../Image.js").LoadFunction} [imageLoadFunction] Optional function to load an image given a URL.
 * @property {Object<string,*>} params WMS request parameters.
 * At least a `LAYERS` param is required. `STYLES` is
 * `''` by default. `VERSION` is `1.3.0` by default. `WIDTH`, `HEIGHT`, `BBOX`
 * and `CRS` (`SRS` for WMS version < 1.3.0) will be set dynamically.
 * @property {import("../proj.js").ProjectionLike} projection Projection.
 * @property {number} [ratio=1.5] Ratio. `1` means image requests are the size of the map viewport, `2` means
 * twice the width and height of the map viewport, and so on. Must be `1` or
 * higher.
 * @property {Array<number>} [resolutions] Resolutions.
 * If specified, requests will be made for these resolutions only.
 * @property {string} url WMS service URL.
 */


/**
 * @classdesc
 * Source for WMS servers providing single, untiled images.
 *
 * @fires ol/source/Image~ImageSourceEvent
 * @api
 */
var ImageWMS = /*@__PURE__*/(function (ImageSource) {
  function ImageWMS(opt_options) {

    var options = opt_options || /** @type {Options} */ ({});

    ImageSource.call(this, {
      attributions: options.attributions,
      projection: options.projection,
      resolutions: options.resolutions
    });

    /**
     * @private
     * @type {?string}
     */
    this.crossOrigin_ =
        options.crossOrigin !== undefined ? options.crossOrigin : null;

    /**
     * @private
     * @type {string|undefined}
     */
    this.url_ = options.url;

    /**
     * @private
     * @type {import("../Image.js").LoadFunction}
     */
    this.imageLoadFunction_ = options.imageLoadFunction !== undefined ?
      options.imageLoadFunction : _Image_js__WEBPACK_IMPORTED_MODULE_9__["defaultImageLoadFunction"];

    /**
     * @private
     * @type {!Object}
     */
    this.params_ = options.params || {};

    /**
     * @private
     * @type {boolean}
     */
    this.v13_ = true;
    this.updateV13_();

    /**
     * @private
     * @type {import("./WMSServerType.js").default|undefined}
     */
    this.serverType_ = /** @type {import("./WMSServerType.js").default|undefined} */ (options.serverType);

    /**
     * @private
     * @type {boolean}
     */
    this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;

    /**
     * @private
     * @type {import("../Image.js").default}
     */
    this.image_ = null;

    /**
     * @private
     * @type {import("../size.js").Size}
     */
    this.imageSize_ = [0, 0];

    /**
     * @private
     * @type {number}
     */
    this.renderedRevision_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.ratio_ = options.ratio !== undefined ? options.ratio : 1.5;

  }

  if ( ImageSource ) ImageWMS.__proto__ = ImageSource;
  ImageWMS.prototype = Object.create( ImageSource && ImageSource.prototype );
  ImageWMS.prototype.constructor = ImageWMS;

  /**
   * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
   * projection. Return `undefined` if the GetFeatureInfo URL cannot be
   * constructed.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should
   *     be provided. If `QUERY_LAYERS` is not provided then the layers specified
   *     in the `LAYERS` parameter will be used. `VERSION` should not be
   *     specified here.
   * @return {string|undefined} GetFeatureInfo URL.
   * @api
   */
  ImageWMS.prototype.getGetFeatureInfoUrl = function getGetFeatureInfoUrl (coordinate, resolution, projection, params) {
    if (this.url_ === undefined) {
      return undefined;
    }
    var projectionObj = Object(_proj_js__WEBPACK_IMPORTED_MODULE_7__["get"])(projection);
    var sourceProjectionObj = this.getProjection();

    if (sourceProjectionObj && sourceProjectionObj !== projectionObj) {
      resolution = Object(_reproj_js__WEBPACK_IMPORTED_MODULE_8__["calculateSourceResolution"])(sourceProjectionObj, projectionObj, coordinate, resolution);
      coordinate = Object(_proj_js__WEBPACK_IMPORTED_MODULE_7__["transform"])(coordinate, projectionObj, sourceProjectionObj);
    }

    var extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getForViewAndSize"])(coordinate, resolution, 0,
      GETFEATUREINFO_IMAGE_SIZE);

    var baseParams = {
      'SERVICE': 'WMS',
      'VERSION': _common_js__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_WMS_VERSION"],
      'REQUEST': 'GetFeatureInfo',
      'FORMAT': 'image/png',
      'TRANSPARENT': true,
      'QUERY_LAYERS': this.params_['LAYERS']
    };
    Object(_obj_js__WEBPACK_IMPORTED_MODULE_6__["assign"])(baseParams, this.params_, params);

    var x = Math.floor((coordinate[0] - extent[0]) / resolution);
    var y = Math.floor((extent[3] - coordinate[1]) / resolution);
    baseParams[this.v13_ ? 'I' : 'X'] = x;
    baseParams[this.v13_ ? 'J' : 'Y'] = y;

    return this.getRequestUrl_(
      extent, GETFEATUREINFO_IMAGE_SIZE,
      1, sourceProjectionObj || projectionObj, baseParams);
  };

  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */
  ImageWMS.prototype.getParams = function getParams () {
    return this.params_;
  };

  /**
   * @inheritDoc
   */
  ImageWMS.prototype.getImageInternal = function getImageInternal (extent, resolution, pixelRatio, projection) {

    if (this.url_ === undefined) {
      return null;
    }

    resolution = this.findNearestResolution(resolution);

    if (pixelRatio != 1 && (!this.hidpi_ || this.serverType_ === undefined)) {
      pixelRatio = 1;
    }

    var imageResolution = resolution / pixelRatio;

    var center = Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getCenter"])(extent);
    var viewWidth = Math.ceil(Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getWidth"])(extent) / imageResolution);
    var viewHeight = Math.ceil(Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getHeight"])(extent) / imageResolution);
    var viewExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getForViewAndSize"])(center, imageResolution, 0,
      [viewWidth, viewHeight]);
    var requestWidth = Math.ceil(this.ratio_ * Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getWidth"])(extent) / imageResolution);
    var requestHeight = Math.ceil(this.ratio_ * Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getHeight"])(extent) / imageResolution);
    var requestExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getForViewAndSize"])(center, imageResolution, 0,
      [requestWidth, requestHeight]);

    var image = this.image_;
    if (image &&
        this.renderedRevision_ == this.getRevision() &&
        image.getResolution() == resolution &&
        image.getPixelRatio() == pixelRatio &&
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["containsExtent"])(image.getExtent(), viewExtent)) {
      return image;
    }

    var params = {
      'SERVICE': 'WMS',
      'VERSION': _common_js__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_WMS_VERSION"],
      'REQUEST': 'GetMap',
      'FORMAT': 'image/png',
      'TRANSPARENT': true
    };
    Object(_obj_js__WEBPACK_IMPORTED_MODULE_6__["assign"])(params, this.params_);

    this.imageSize_[0] = Math.round(Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getWidth"])(requestExtent) / imageResolution);
    this.imageSize_[1] = Math.round(Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getHeight"])(requestExtent) / imageResolution);

    var url = this.getRequestUrl_(requestExtent, this.imageSize_, pixelRatio,
      projection, params);

    this.image_ = new _Image_js__WEBPACK_IMPORTED_MODULE_1__["default"](requestExtent, resolution, pixelRatio,
      url, this.crossOrigin_, this.imageLoadFunction_);

    this.renderedRevision_ = this.getRevision();

    Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(this.image_, _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].CHANGE,
      this.handleImageChange, this);

    return this.image_;

  };

  /**
   * Return the image load function of the source.
   * @return {import("../Image.js").LoadFunction} The image load function.
   * @api
   */
  ImageWMS.prototype.getImageLoadFunction = function getImageLoadFunction () {
    return this.imageLoadFunction_;
  };

  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {import("../size.js").Size} size Size.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {Object} params Params.
   * @return {string} Request URL.
   * @private
   */
  ImageWMS.prototype.getRequestUrl_ = function getRequestUrl_ (extent, size, pixelRatio, projection, params) {

    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_2__["assert"])(this.url_ !== undefined, 9); // `url` must be configured or set using `#setUrl()`

    params[this.v13_ ? 'CRS' : 'SRS'] = projection.getCode();

    if (!('STYLES' in this.params_)) {
      params['STYLES'] = '';
    }

    if (pixelRatio != 1) {
      switch (this.serverType_) {
        case _WMSServerType_js__WEBPACK_IMPORTED_MODULE_10__["default"].GEOSERVER:
          var dpi = (90 * pixelRatio + 0.5) | 0;
          if ('FORMAT_OPTIONS' in params) {
            params['FORMAT_OPTIONS'] += ';dpi:' + dpi;
          } else {
            params['FORMAT_OPTIONS'] = 'dpi:' + dpi;
          }
          break;
        case _WMSServerType_js__WEBPACK_IMPORTED_MODULE_10__["default"].MAPSERVER:
          params['MAP_RESOLUTION'] = 90 * pixelRatio;
          break;
        case _WMSServerType_js__WEBPACK_IMPORTED_MODULE_10__["default"].CARMENTA_SERVER:
        case _WMSServerType_js__WEBPACK_IMPORTED_MODULE_10__["default"].QGIS:
          params['DPI'] = 90 * pixelRatio;
          break;
        default:
          Object(_asserts_js__WEBPACK_IMPORTED_MODULE_2__["assert"])(false, 8); // Unknown `serverType` configured
          break;
      }
    }

    params['WIDTH'] = size[0];
    params['HEIGHT'] = size[1];

    var axisOrientation = projection.getAxisOrientation();
    var bbox;
    if (this.v13_ && axisOrientation.substr(0, 2) == 'ne') {
      bbox = [extent[1], extent[0], extent[3], extent[2]];
    } else {
      bbox = extent;
    }
    params['BBOX'] = bbox.join(',');

    return Object(_uri_js__WEBPACK_IMPORTED_MODULE_12__["appendParams"])(/** @type {string} */ (this.url_), params);
  };

  /**
   * Return the URL used for this WMS source.
   * @return {string|undefined} URL.
   * @api
   */
  ImageWMS.prototype.getUrl = function getUrl () {
    return this.url_;
  };

  /**
   * Set the image load function of the source.
   * @param {import("../Image.js").LoadFunction} imageLoadFunction Image load function.
   * @api
   */
  ImageWMS.prototype.setImageLoadFunction = function setImageLoadFunction (imageLoadFunction) {
    this.image_ = null;
    this.imageLoadFunction_ = imageLoadFunction;
    this.changed();
  };

  /**
   * Set the URL to use for requests.
   * @param {string|undefined} url URL.
   * @api
   */
  ImageWMS.prototype.setUrl = function setUrl (url) {
    if (url != this.url_) {
      this.url_ = url;
      this.image_ = null;
      this.changed();
    }
  };

  /**
   * Update the user-provided params.
   * @param {Object} params Params.
   * @api
   */
  ImageWMS.prototype.updateParams = function updateParams (params) {
    Object(_obj_js__WEBPACK_IMPORTED_MODULE_6__["assign"])(this.params_, params);
    this.updateV13_();
    this.image_ = null;
    this.changed();
  };

  /**
   * @private
   */
  ImageWMS.prototype.updateV13_ = function updateV13_ () {
    var version = this.params_['VERSION'] || _common_js__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_WMS_VERSION"];
    this.v13_ = Object(_string_js__WEBPACK_IMPORTED_MODULE_11__["compareVersions"])(version, '1.3') >= 0;
  };

  return ImageWMS;
}(_Image_js__WEBPACK_IMPORTED_MODULE_9__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (ImageWMS);

//# sourceMappingURL=ImageWMS.js.map

/***/ }),

/***/ "./node_modules/ol/source/OSM.js":
/*!***************************************!*\
  !*** ./node_modules/ol/source/OSM.js ***!
  \***************************************/
/*! exports provided: ATTRIBUTION, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ATTRIBUTION", function() { return ATTRIBUTION; });
/* harmony import */ var _XYZ_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./XYZ.js */ "./node_modules/ol/source/XYZ.js");
/**
 * @module ol/source/OSM
 */




/**
 * The attribution containing a link to the OpenStreetMap Copyright and License
 * page.
 * @const
 * @type {string}
 * @api
 */
var ATTRIBUTION = '&#169; ' +
      '<a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> ' +
      'contributors.';


/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize=2048] Cache size.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to
 * access pixel data with the Canvas renderer.  See
 * https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {number} [maxZoom=19] Max zoom.
 * @property {boolean} [opaque=true] Whether the layer is opaque.
 * @property {number} [reprojectionErrorThreshold=1.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {string} [url='https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png'] URL template.
 * Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 */


/**
 * @classdesc
 * Layer source for the OpenStreetMap tile server.
 * @api
 */
var OSM = /*@__PURE__*/(function (XYZ) {
  function OSM(opt_options) {

    var options = opt_options || {};

    var attributions;
    if (options.attributions !== undefined) {
      attributions = options.attributions;
    } else {
      attributions = [ATTRIBUTION];
    }

    var crossOrigin = options.crossOrigin !== undefined ?
      options.crossOrigin : 'anonymous';

    var url = options.url !== undefined ?
      options.url : 'https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png';

    XYZ.call(this, {
      attributions: attributions,
      cacheSize: options.cacheSize,
      crossOrigin: crossOrigin,
      opaque: options.opaque !== undefined ? options.opaque : true,
      maxZoom: options.maxZoom !== undefined ? options.maxZoom : 19,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileLoadFunction: options.tileLoadFunction,
      url: url,
      wrapX: options.wrapX,
      attributionsCollapsible: false
    });

  }

  if ( XYZ ) OSM.__proto__ = XYZ;
  OSM.prototype = Object.create( XYZ && XYZ.prototype );
  OSM.prototype.constructor = OSM;

  return OSM;
}(_XYZ_js__WEBPACK_IMPORTED_MODULE_0__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (OSM);

//# sourceMappingURL=OSM.js.map

/***/ }),

/***/ "./node_modules/ol/source/Raster.js":
/*!******************************************!*\
  !*** ./node_modules/ol/source/Raster.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _ImageCanvas_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ImageCanvas.js */ "./node_modules/ol/ImageCanvas.js");
/* harmony import */ var _TileQueue_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../TileQueue.js */ "./node_modules/ol/TileQueue.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var pixelworks_lib_index__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! pixelworks/lib/index */ "./node_modules/pixelworks/lib/index.js");
/* harmony import */ var pixelworks_lib_index__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(pixelworks_lib_index__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _LayerType_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../LayerType.js */ "./node_modules/ol/LayerType.js");
/* harmony import */ var _layer_Image_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../layer/Image.js */ "./node_modules/ol/layer/Image.js");
/* harmony import */ var _layer_Tile_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../layer/Tile.js */ "./node_modules/ol/layer/Tile.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _renderer_canvas_ImageLayer_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../renderer/canvas/ImageLayer.js */ "./node_modules/ol/renderer/canvas/ImageLayer.js");
/* harmony import */ var _renderer_canvas_TileLayer_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../renderer/canvas/TileLayer.js */ "./node_modules/ol/renderer/canvas/TileLayer.js");
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./Image.js */ "./node_modules/ol/source/Image.js");
/* harmony import */ var _State_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./State.js */ "./node_modules/ol/source/State.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/source/Raster
 */




















/**
 * A function that takes an array of input data, performs some operation, and
 * returns an array of output data.
 * For `pixel` type operations, the function will be called with an array of
 * pixels, where each pixel is an array of four numbers (`[r, g, b, a]`) in the
 * range of 0 - 255. It should return a single pixel array.
 * For `'image'` type operations, functions will be called with an array of
 * {@link ImageData https://developer.mozilla.org/en-US/docs/Web/API/ImageData}
 * and should return a single {@link ImageData
 * https://developer.mozilla.org/en-US/docs/Web/API/ImageData}.  The operations
 * are called with a second "data" argument, which can be used for storage.  The
 * data object is accessible from raster events, where it can be initialized in
 * "beforeoperations" and accessed again in "afteroperations".
 *
 * @typedef {function((Array<Array<number>>|Array<ImageData>), Object):
 *     (Array<number>|ImageData)} Operation
 */


/**
 * @enum {string}
 */
var RasterEventType = {
  /**
   * Triggered before operations are run.
   * @event ol/source/Raster~RasterSourceEvent#beforeoperations
   * @api
   */
  BEFOREOPERATIONS: 'beforeoperations',

  /**
   * Triggered after operations are run.
   * @event ol/source/Raster~RasterSourceEvent#afteroperations
   * @api
   */
  AFTEROPERATIONS: 'afteroperations'
};


/**
 * Raster operation type. Supported values are `'pixel'` and `'image'`.
 * @enum {string}
 */
var RasterOperationType = {
  PIXEL: 'pixel',
  IMAGE: 'image'
};


/**
 * @classdesc
 * Events emitted by {@link module:ol/source/Raster} instances are instances of this
 * type.
 */
var RasterSourceEvent = /*@__PURE__*/(function (Event) {
  function RasterSourceEvent(type, frameState, data) {
    Event.call(this, type);

    /**
     * The raster extent.
     * @type {import("../extent.js").Extent}
     * @api
     */
    this.extent = frameState.extent;

    /**
     * The pixel resolution (map units per pixel).
     * @type {number}
     * @api
     */
    this.resolution = frameState.viewState.resolution / frameState.pixelRatio;

    /**
     * An object made available to all operations.  This can be used by operations
     * as a storage object (e.g. for calculating statistics).
     * @type {Object}
     * @api
     */
    this.data = data;

  }

  if ( Event ) RasterSourceEvent.__proto__ = Event;
  RasterSourceEvent.prototype = Object.create( Event && Event.prototype );
  RasterSourceEvent.prototype.constructor = RasterSourceEvent;

  return RasterSourceEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_5__["default"]));

/**
 * @typedef {Object} Options
 * @property {Array<import("./Source.js").default|import("../layer/Layer.js").default>} sources Input
 * sources or layers. Vector layers must be configured with `renderMode: 'image'`.
 * @property {Operation} [operation] Raster operation.
 * The operation will be called with data from input sources
 * and the output will be assigned to the raster source.
 * @property {Object} [lib] Functions that will be made available to operations run in a worker.
 * @property {number} [threads] By default, operations will be run in a single worker thread.
 * To avoid using workers altogether, set `threads: 0`.  For pixel operations, operations can
 * be run in multiple worker threads.  Note that there is additional overhead in
 * transferring data to multiple workers, and that depending on the user's
 * system, it may not be possible to parallelize the work.
 * @property {RasterOperationType} [operationType='pixel'] Operation type.
 * Supported values are `'pixel'` and `'image'`.  By default,
 * `'pixel'` operations are assumed, and operations will be called with an
 * array of pixels from input sources.  If set to `'image'`, operations will
 * be called with an array of ImageData objects from input sources.
 */


/**
 * @classdesc
 * A source that transforms data from any number of input sources using an
 * {@link module:ol/source/Raster~Operation} function to transform input pixel values into
 * output pixel values.
 *
 * @fires ol/source/Raster~RasterSourceEvent
 * @api
 */
var RasterSource = /*@__PURE__*/(function (ImageSource) {
  function RasterSource(options) {
    ImageSource.call(this, {
      projection: null
    });

    /**
     * @private
     * @type {*}
     */
    this.worker_ = null;

    /**
     * @private
     * @type {RasterOperationType}
     */
    this.operationType_ = options.operationType !== undefined ?
      options.operationType : RasterOperationType.PIXEL;

    /**
     * @private
     * @type {number}
     */
    this.threads_ = options.threads !== undefined ? options.threads : 1;

    /**
     * @private
     * @type {Array<import("../renderer/canvas/Layer.js").default>}
     */
    this.renderers_ = createRenderers(options.sources);

    for (var r = 0, rr = this.renderers_.length; r < rr; ++r) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_4__["listen"])(this.renderers_[r], _events_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].CHANGE,
        this.changed, this);
    }

    /**
     * @private
     * @type {import("../TileQueue.js").default}
     */
    this.tileQueue_ = new _TileQueue_js__WEBPACK_IMPORTED_MODULE_2__["default"](
      function() {
        return 1;
      },
      this.changed.bind(this));

    var layerStatesArray = getLayerStatesArray(this.renderers_);

    /**
     * @type {Object<string, import("../layer/Layer.js").State>}
     */
    var layerStates = {};
    for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      layerStates[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(layerStatesArray[i].layer)] = layerStatesArray[i];
    }

    /**
     * The most recently requested frame state.
     * @type {import("../PluggableMap.js").FrameState}
     * @private
     */
    this.requestedFrameState_;

    /**
     * The most recently rendered image canvas.
     * @type {import("../ImageCanvas.js").default}
     * @private
     */
    this.renderedImageCanvas_ = null;

    /**
     * The most recently rendered revision.
     * @type {number}
     */
    this.renderedRevision_;

    /**
     * @private
     * @type {import("../PluggableMap.js").FrameState}
     */
    this.frameState_ = {
      animate: false,
      coordinateToPixelTransform: Object(_transform_js__WEBPACK_IMPORTED_MODULE_17__["create"])(),
      extent: null,
      focus: null,
      index: 0,
      layerStates: layerStates,
      layerStatesArray: layerStatesArray,
      pixelRatio: 1,
      pixelToCoordinateTransform: Object(_transform_js__WEBPACK_IMPORTED_MODULE_17__["create"])(),
      postRenderFunctions: [],
      size: [0, 0],
      skippedFeatureUids: {},
      tileQueue: this.tileQueue_,
      time: Date.now(),
      usedTiles: {},
      viewState: /** @type {import("../View.js").State} */ ({
        rotation: 0
      }),
      viewHints: [],
      wantedTiles: {}
    };

    if (options.operation !== undefined) {
      this.setOperation(options.operation, options.lib);
    }

  }

  if ( ImageSource ) RasterSource.__proto__ = ImageSource;
  RasterSource.prototype = Object.create( ImageSource && ImageSource.prototype );
  RasterSource.prototype.constructor = RasterSource;

  /**
   * Set the operation.
   * @param {Operation} operation New operation.
   * @param {Object=} opt_lib Functions that will be available to operations run
   *     in a worker.
   * @api
   */
  RasterSource.prototype.setOperation = function setOperation (operation, opt_lib) {
    this.worker_ = new pixelworks_lib_index__WEBPACK_IMPORTED_MODULE_7__["Processor"]({
      operation: operation,
      imageOps: this.operationType_ === RasterOperationType.IMAGE,
      queue: 1,
      lib: opt_lib,
      threads: this.threads_
    });
    this.changed();
  };

  /**
   * Update the stored frame state.
   * @param {import("../extent.js").Extent} extent The view extent (in map units).
   * @param {number} resolution The view resolution.
   * @param {import("../proj/Projection.js").default} projection The view projection.
   * @return {import("../PluggableMap.js").FrameState} The updated frame state.
   * @private
   */
  RasterSource.prototype.updateFrameState_ = function updateFrameState_ (extent, resolution, projection) {

    var frameState = /** @type {import("../PluggableMap.js").FrameState} */ (Object(_obj_js__WEBPACK_IMPORTED_MODULE_12__["assign"])({}, this.frameState_));

    frameState.viewState = /** @type {import("../View.js").State} */ (Object(_obj_js__WEBPACK_IMPORTED_MODULE_12__["assign"])({}, frameState.viewState));

    var center = Object(_extent_js__WEBPACK_IMPORTED_MODULE_8__["getCenter"])(extent);

    frameState.extent = extent.slice();
    frameState.focus = center;
    frameState.size[0] = Math.round(Object(_extent_js__WEBPACK_IMPORTED_MODULE_8__["getWidth"])(extent) / resolution);
    frameState.size[1] = Math.round(Object(_extent_js__WEBPACK_IMPORTED_MODULE_8__["getHeight"])(extent) / resolution);
    frameState.time = Date.now();
    frameState.animate = false;

    var viewState = frameState.viewState;
    viewState.center = center;
    viewState.projection = projection;
    viewState.resolution = resolution;
    return frameState;
  };

  /**
   * Determine if all sources are ready.
   * @return {boolean} All sources are ready.
   * @private
   */
  RasterSource.prototype.allSourcesReady_ = function allSourcesReady_ () {
    var ready = true;
    var source;
    for (var i = 0, ii = this.renderers_.length; i < ii; ++i) {
      source = this.renderers_[i].getLayer().getSource();
      if (source.getState() !== _State_js__WEBPACK_IMPORTED_MODULE_16__["default"].READY) {
        ready = false;
        break;
      }
    }
    return ready;
  };

  /**
   * @inheritDoc
   */
  RasterSource.prototype.getImage = function getImage (extent, resolution, pixelRatio, projection) {
    if (!this.allSourcesReady_()) {
      return null;
    }

    var frameState = this.updateFrameState_(extent, resolution, projection);
    this.requestedFrameState_ = frameState;

    // check if we can't reuse the existing ol/ImageCanvas
    if (this.renderedImageCanvas_) {
      var renderedResolution = this.renderedImageCanvas_.getResolution();
      var renderedExtent = this.renderedImageCanvas_.getExtent();
      if (resolution !== renderedResolution || !Object(_extent_js__WEBPACK_IMPORTED_MODULE_8__["equals"])(extent, renderedExtent)) {
        this.renderedImageCanvas_ = null;
      }
    }

    if (!this.renderedImageCanvas_ || this.getRevision() !== this.renderedRevision_) {
      this.processSources_();
    }

    frameState.tileQueue.loadMoreTiles(16, 16);

    if (frameState.animate) {
      requestAnimationFrame(this.changed.bind(this));
    }

    return this.renderedImageCanvas_;
  };

  /**
   * Start processing source data.
   * @private
   */
  RasterSource.prototype.processSources_ = function processSources_ () {
    var frameState = this.requestedFrameState_;
    var len = this.renderers_.length;
    var imageDatas = new Array(len);
    for (var i = 0; i < len; ++i) {
      var imageData = getImageData(
        this.renderers_[i], frameState, frameState.layerStatesArray[i]);
      if (imageData) {
        imageDatas[i] = imageData;
      } else {
        return;
      }
    }

    var data = {};
    this.dispatchEvent(new RasterSourceEvent(RasterEventType.BEFOREOPERATIONS, frameState, data));
    this.worker_.process(imageDatas, data, this.onWorkerComplete_.bind(this, frameState));
  };

  /**
   * Called when pixel processing is complete.
   * @param {import("../PluggableMap.js").FrameState} frameState The frame state.
   * @param {Error} err Any error during processing.
   * @param {ImageData} output The output image data.
   * @param {Object} data The user data.
   * @private
   */
  RasterSource.prototype.onWorkerComplete_ = function onWorkerComplete_ (frameState, err, output, data) {
    if (err || !output) {
      return;
    }

    // do nothing if extent or resolution changed
    var extent = frameState.extent;
    var resolution = frameState.viewState.resolution;
    if (resolution !== this.requestedFrameState_.viewState.resolution ||
        !Object(_extent_js__WEBPACK_IMPORTED_MODULE_8__["equals"])(extent, this.requestedFrameState_.extent)) {
      return;
    }

    var context;
    if (this.renderedImageCanvas_) {
      context = this.renderedImageCanvas_.getImage().getContext('2d');
    } else {
      var width = Math.round(Object(_extent_js__WEBPACK_IMPORTED_MODULE_8__["getWidth"])(extent) / resolution);
      var height = Math.round(Object(_extent_js__WEBPACK_IMPORTED_MODULE_8__["getHeight"])(extent) / resolution);
      context = Object(_dom_js__WEBPACK_IMPORTED_MODULE_3__["createCanvasContext2D"])(width, height);
      this.renderedImageCanvas_ = new _ImageCanvas_js__WEBPACK_IMPORTED_MODULE_1__["default"](extent, resolution, 1, context.canvas);
    }
    context.putImageData(output, 0, 0);

    this.changed();
    this.renderedRevision_ = this.getRevision();

    this.dispatchEvent(new RasterSourceEvent(RasterEventType.AFTEROPERATIONS, frameState, data));
  };

  /**
   * @override
   */
  RasterSource.prototype.getImageInternal = function getImageInternal () {
    return null; // not implemented
  };

  return RasterSource;
}(_Image_js__WEBPACK_IMPORTED_MODULE_15__["default"]));


/**
 * A reusable canvas context.
 * @type {CanvasRenderingContext2D}
 * @private
 */
var sharedContext = null;


/**
 * Get image data from a renderer.
 * @param {import("../renderer/canvas/Layer.js").default} renderer Layer renderer.
 * @param {import("../PluggableMap.js").FrameState} frameState The frame state.
 * @param {import("../layer/Layer.js").State} layerState The layer state.
 * @return {ImageData} The image data.
 */
function getImageData(renderer, frameState, layerState) {
  if (!renderer.prepareFrame(frameState, layerState)) {
    return null;
  }
  var width = frameState.size[0];
  var height = frameState.size[1];
  if (!sharedContext) {
    sharedContext = Object(_dom_js__WEBPACK_IMPORTED_MODULE_3__["createCanvasContext2D"])(width, height);
  } else {
    var canvas = sharedContext.canvas;
    if (canvas.width !== width || canvas.height !== height) {
      sharedContext = Object(_dom_js__WEBPACK_IMPORTED_MODULE_3__["createCanvasContext2D"])(width, height);
    } else {
      sharedContext.clearRect(0, 0, width, height);
    }
  }
  renderer.composeFrame(frameState, layerState, sharedContext);
  return sharedContext.getImageData(0, 0, width, height);
}


/**
 * Get a list of layer states from a list of renderers.
 * @param {Array<import("../renderer/canvas/Layer.js").default>} renderers Layer renderers.
 * @return {Array<import("../layer/Layer.js").State>} The layer states.
 */
function getLayerStatesArray(renderers) {
  return renderers.map(function(renderer) {
    return renderer.getLayer().getLayerState();
  });
}


/**
 * Create renderers for all sources.
 * @param {Array<import("./Source.js").default|import("../layer/Layer.js").default>} sources The sources.
 * @return {Array<import("../renderer/canvas/Layer.js").default>} Array of layer renderers.
 */
function createRenderers(sources) {
  var len = sources.length;
  var renderers = new Array(len);
  for (var i = 0; i < len; ++i) {
    renderers[i] = createRenderer(sources[i]);
  }
  return renderers;
}


/**
 * Create a renderer for the provided source.
 * @param {import("./Source.js").default|import("../layer/Layer.js").default} layerOrSource The layer or source.
 * @return {import("../renderer/canvas/Layer.js").default} The renderer.
 */
function createRenderer(layerOrSource) {
  var tileSource = /** @type {import("./Tile.js").default} */ (layerOrSource);
  var imageSource = /** @type {import("./Image.js").default} */ (layerOrSource);
  var layer = /** @type {import("../layer/Layer.js").default} */ (layerOrSource);
  var renderer = null;
  if (typeof tileSource.getTile === 'function') {
    renderer = createTileRenderer(tileSource);
  } else if (typeof imageSource.getImage === 'function') {
    renderer = createImageRenderer(imageSource);
  } else if (layer.getType() === _LayerType_js__WEBPACK_IMPORTED_MODULE_9__["default"].TILE) {
    renderer = new _renderer_canvas_TileLayer_js__WEBPACK_IMPORTED_MODULE_14__["default"](/** @type {import("../layer/Tile.js").default} */ (layer));
  } else if (layer.getType() == _LayerType_js__WEBPACK_IMPORTED_MODULE_9__["default"].IMAGE || layer.getType() == _LayerType_js__WEBPACK_IMPORTED_MODULE_9__["default"].VECTOR) {
    renderer = new _renderer_canvas_ImageLayer_js__WEBPACK_IMPORTED_MODULE_13__["default"](/** @type {import("../layer/Image.js").default} */ (layer));
  }
  return renderer;
}


/**
 * Create an image renderer for the provided source.
 * @param {import("./Image.js").default} source The source.
 * @return {import("../renderer/canvas/Layer.js").default} The renderer.
 */
function createImageRenderer(source) {
  var layer = new _layer_Image_js__WEBPACK_IMPORTED_MODULE_10__["default"]({source: source});
  return new _renderer_canvas_ImageLayer_js__WEBPACK_IMPORTED_MODULE_13__["default"](layer);
}


/**
 * Create a tile renderer for the provided source.
 * @param {import("./Tile.js").default} source The source.
 * @return {import("../renderer/canvas/Layer.js").default} The renderer.
 */
function createTileRenderer(source) {
  var layer = new _layer_Tile_js__WEBPACK_IMPORTED_MODULE_11__["default"]({source: source});
  return new _renderer_canvas_TileLayer_js__WEBPACK_IMPORTED_MODULE_14__["default"](layer);
}


/* harmony default export */ __webpack_exports__["default"] = (RasterSource);

//# sourceMappingURL=Raster.js.map

/***/ }),

/***/ "./node_modules/ol/source/Source.js":
/*!******************************************!*\
  !*** ./node_modules/ol/source/Source.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _State_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./State.js */ "./node_modules/ol/source/State.js");
/**
 * @module ol/source/Source
 */






/**
 * A function that returns a string or an array of strings representing source
 * attributions.
 *
 * @typedef {function(import("../PluggableMap.js").FrameState): (string|Array<string>)} Attribution
 */


/**
 * A type that can be used to provide attribution information for data sources.
 *
 * It represents either
 * * a simple string (e.g. `'© Acme Inc.'`)
 * * an array of simple strings (e.g. `['© Acme Inc.', '© Bacme Inc.']`)
 * * a function that returns a string or array of strings (`{@link module:ol/source/Source~Attribution}`)
 *
 * @typedef {string|Array<string>|Attribution} AttributionLike
 */


/**
 * @typedef {Object} Options
 * @property {AttributionLike} [attributions]
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {import("../proj.js").ProjectionLike} projection
 * @property {SourceState} [state='ready']
 * @property {boolean} [wrapX=false]
 */


/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for {@link module:ol/layer/Layer~Layer} sources.
 *
 * A generic `change` event is triggered when the state of the source changes.
 * @abstract
 * @api
 */
var Source = /*@__PURE__*/(function (BaseObject) {
  function Source(options) {

    BaseObject.call(this);

    /**
     * @private
     * @type {import("../proj/Projection.js").default}
     */
    this.projection_ = Object(_proj_js__WEBPACK_IMPORTED_MODULE_2__["get"])(options.projection);

    /**
     * @private
     * @type {?Attribution}
     */
    this.attributions_ = adaptAttributions(options.attributions);

    /**
     * @private
     * @type {boolean}
     */
    this.attributionsCollapsible_ = options.attributionsCollapsible !== undefined ?
      options.attributionsCollapsible : true;

    /**
     * This source is currently loading data. Sources that defer loading to the
     * map's tile queue never set this to `true`.
     * @type {boolean}
     */
    this.loading = false;

    /**
     * @private
     * @type {SourceState}
     */
    this.state_ = options.state !== undefined ?
      options.state : _State_js__WEBPACK_IMPORTED_MODULE_3__["default"].READY;

    /**
     * @private
     * @type {boolean}
     */
    this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;

  }

  if ( BaseObject ) Source.__proto__ = BaseObject;
  Source.prototype = Object.create( BaseObject && BaseObject.prototype );
  Source.prototype.constructor = Source;

  /**
   * Get the attribution function for the source.
   * @return {?Attribution} Attribution function.
   */
  Source.prototype.getAttributions = function getAttributions () {
    return this.attributions_;
  };

  /**
   * @return {boolean} Aattributions are collapsible.
   */
  Source.prototype.getAttributionsCollapsible = function getAttributionsCollapsible () {
    return this.attributionsCollapsible_;
  };

  /**
   * Get the projection of the source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   */
  Source.prototype.getProjection = function getProjection () {
    return this.projection_;
  };

  /**
   * @abstract
   * @return {Array<number>|undefined} Resolutions.
   */
  Source.prototype.getResolutions = function getResolutions () {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Get the state of the source, see {@link module:ol/source/State~State} for possible states.
   * @return {SourceState} State.
   * @api
   */
  Source.prototype.getState = function getState () {
    return this.state_;
  };

  /**
   * @return {boolean|undefined} Wrap X.
   */
  Source.prototype.getWrapX = function getWrapX () {
    return this.wrapX_;
  };

  /**
   * Refreshes the source and finally dispatches a 'change' event.
   * @api
   */
  Source.prototype.refresh = function refresh () {
    this.changed();
  };

  /**
   * Set the attributions of the source.
   * @param {AttributionLike|undefined} attributions Attributions.
   *     Can be passed as `string`, `Array<string>`, `{@link module:ol/source/Source~Attribution}`,
   *     or `undefined`.
   * @api
   */
  Source.prototype.setAttributions = function setAttributions (attributions) {
    this.attributions_ = adaptAttributions(attributions);
    this.changed();
  };

  /**
   * Set the state of the source.
   * @param {SourceState} state State.
   * @protected
   */
  Source.prototype.setState = function setState (state) {
    this.state_ = state;
    this.changed();
  };

  return Source;
}(_Object_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/**
 * Turns the attributions option into an attributions function.
 * @param {AttributionLike|undefined} attributionLike The attribution option.
 * @return {?Attribution} An attribution function (or null).
 */
function adaptAttributions(attributionLike) {
  if (!attributionLike) {
    return null;
  }
  if (Array.isArray(attributionLike)) {
    return function(frameState) {
      return attributionLike;
    };
  }

  if (typeof attributionLike === 'function') {
    return attributionLike;
  }

  return function(frameState) {
    return [attributionLike];
  };
}


/* harmony default export */ __webpack_exports__["default"] = (Source);

//# sourceMappingURL=Source.js.map

/***/ }),

/***/ "./node_modules/ol/source/Stamen.js":
/*!******************************************!*\
  !*** ./node_modules/ol/source/Stamen.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _OSM_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./OSM.js */ "./node_modules/ol/source/OSM.js");
/* harmony import */ var _XYZ_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./XYZ.js */ "./node_modules/ol/source/XYZ.js");
/**
 * @module ol/source/Stamen
 */





/**
 * @const
 * @type {Array<string>}
 */
var ATTRIBUTIONS = [
  'Map tiles by <a href="https://stamen.com/">Stamen Design</a>, ' +
        'under <a href="https://creativecommons.org/licenses/by/3.0/">CC BY' +
        ' 3.0</a>.',
  _OSM_js__WEBPACK_IMPORTED_MODULE_0__["ATTRIBUTION"]
];


/**
 * @type {Object<string, {extension: string, opaque: boolean}>}
 */
var LayerConfig = {
  'terrain': {
    extension: 'jpg',
    opaque: true
  },
  'terrain-background': {
    extension: 'jpg',
    opaque: true
  },
  'terrain-labels': {
    extension: 'png',
    opaque: false
  },
  'terrain-lines': {
    extension: 'png',
    opaque: false
  },
  'toner-background': {
    extension: 'png',
    opaque: true
  },
  'toner': {
    extension: 'png',
    opaque: true
  },
  'toner-hybrid': {
    extension: 'png',
    opaque: false
  },
  'toner-labels': {
    extension: 'png',
    opaque: false
  },
  'toner-lines': {
    extension: 'png',
    opaque: false
  },
  'toner-lite': {
    extension: 'png',
    opaque: true
  },
  'watercolor': {
    extension: 'jpg',
    opaque: true
  }
};


/**
 * @type {Object<string, {minZoom: number, maxZoom: number}>}
 */
var ProviderConfig = {
  'terrain': {
    minZoom: 4,
    maxZoom: 18
  },
  'toner': {
    minZoom: 0,
    maxZoom: 20
  },
  'watercolor': {
    minZoom: 1,
    maxZoom: 16
  }
};


/**
 * @typedef {Object} Options
 * @property {number} [cacheSize=2048] Cache size.
 * @property {string} layer Layer name.
 * @property {number} [minZoom] Minimum zoom.
 * @property {number} [maxZoom] Maximum zoom.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction]
 * Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 */


/**
 * @classdesc
 * Layer source for the Stamen tile server.
 * @api
 */
var Stamen = /*@__PURE__*/(function (XYZ) {
  function Stamen(options) {
    var i = options.layer.indexOf('-');
    var provider = i == -1 ? options.layer : options.layer.slice(0, i);
    var providerConfig = ProviderConfig[provider];

    var layerConfig = LayerConfig[options.layer];

    var url = options.url !== undefined ? options.url :
      'https://stamen-tiles-{a-d}.a.ssl.fastly.net/' + options.layer +
        '/{z}/{x}/{y}.' + layerConfig.extension;

    XYZ.call(this, {
      attributions: ATTRIBUTIONS,
      cacheSize: options.cacheSize,
      crossOrigin: 'anonymous',
      maxZoom: options.maxZoom != undefined ? options.maxZoom : providerConfig.maxZoom,
      minZoom: options.minZoom != undefined ? options.minZoom : providerConfig.minZoom,
      opaque: layerConfig.opaque,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileLoadFunction: options.tileLoadFunction,
      url: url,
      wrapX: options.wrapX
    });

  }

  if ( XYZ ) Stamen.__proto__ = XYZ;
  Stamen.prototype = Object.create( XYZ && XYZ.prototype );
  Stamen.prototype.constructor = Stamen;

  return Stamen;
}(_XYZ_js__WEBPACK_IMPORTED_MODULE_1__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (Stamen);

//# sourceMappingURL=Stamen.js.map

/***/ }),

/***/ "./node_modules/ol/source/State.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/source/State.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/source/State
 */

/**
 * @enum {string}
 * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  UNDEFINED: 'undefined',
  LOADING: 'loading',
  READY: 'ready',
  ERROR: 'error'
});

//# sourceMappingURL=State.js.map

/***/ }),

/***/ "./node_modules/ol/source/Tile.js":
/*!****************************************!*\
  !*** ./node_modules/ol/source/Tile.js ***!
  \****************************************/
/*! exports provided: TileSourceEvent, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TileSourceEvent", function() { return TileSourceEvent; });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _TileCache_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../TileCache.js */ "./node_modules/ol/TileCache.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../size.js */ "./node_modules/ol/size.js");
/* harmony import */ var _Source_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Source.js */ "./node_modules/ol/source/Source.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../tilegrid.js */ "./node_modules/ol/tilegrid.js");
/**
 * @module ol/source/Tile
 */










/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions]
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize]
 * @property {boolean} [opaque]
 * @property {number} [tilePixelRatio]
 * @property {import("../proj.js").ProjectionLike} [projection]
 * @property {import("./State.js").default} [state]
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid]
 * @property {boolean} [wrapX=true]
 * @property {number} [transition]
 * @property {string} [key]
 */


/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for sources providing images divided into a tile grid.
 * @abstract
 * @api
 */
var TileSource = /*@__PURE__*/(function (Source) {
  function TileSource(options) {

    Source.call(this, {
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      projection: options.projection,
      state: options.state,
      wrapX: options.wrapX
    });

    /**
     * @private
     * @type {boolean}
     */
    this.opaque_ = options.opaque !== undefined ? options.opaque : false;

    /**
     * @private
     * @type {number}
     */
    this.tilePixelRatio_ = options.tilePixelRatio !== undefined ?
      options.tilePixelRatio : 1;

    /**
     * @protected
     * @type {import("../tilegrid/TileGrid.js").default}
     */
    this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;

    /**
     * @protected
     * @type {import("../TileCache.js").default}
     */
    this.tileCache = new _TileCache_js__WEBPACK_IMPORTED_MODULE_1__["default"](options.cacheSize);

    /**
     * @protected
     * @type {import("../size.js").Size}
     */
    this.tmpSize = [0, 0];

    /**
     * @private
     * @type {string}
     */
    this.key_ = options.key || '';

    /**
     * @protected
     * @type {import("../Tile.js").Options}
     */
    this.tileOptions = {transition: options.transition};

  }

  if ( Source ) TileSource.__proto__ = Source;
  TileSource.prototype = Object.create( Source && Source.prototype );
  TileSource.prototype.constructor = TileSource;

  /**
   * @return {boolean} Can expire cache.
   */
  TileSource.prototype.canExpireCache = function canExpireCache () {
    return this.tileCache.canExpireCache();
  };

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, import("../TileRange.js").default>} usedTiles Used tiles.
   */
  TileSource.prototype.expireCache = function expireCache (projection, usedTiles) {
    var tileCache = this.getTileCacheForProjection(projection);
    if (tileCache) {
      tileCache.expireCache(usedTiles);
    }
  };

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {number} z Zoom level.
   * @param {import("../TileRange.js").default} tileRange Tile range.
   * @param {function(import("../Tile.js").default):(boolean|void)} callback Called with each
   *     loaded tile.  If the callback returns `false`, the tile will not be
   *     considered loaded.
   * @return {boolean} The tile range is fully covered with loaded tiles.
   */
  TileSource.prototype.forEachLoadedTile = function forEachLoadedTile (projection, z, tileRange, callback) {
    var tileCache = this.getTileCacheForProjection(projection);
    if (!tileCache) {
      return false;
    }

    var covered = true;
    var tile, tileCoordKey, loaded;
    for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
        tileCoordKey = Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_7__["getKeyZXY"])(z, x, y);
        loaded = false;
        if (tileCache.containsKey(tileCoordKey)) {
          tile = /** @type {!import("../Tile.js").default} */ (tileCache.get(tileCoordKey));
          loaded = tile.getState() === _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED;
          if (loaded) {
            loaded = (callback(tile) !== false);
          }
        }
        if (!loaded) {
          covered = false;
        }
      }
    }
    return covered;
  };

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */
  TileSource.prototype.getGutterForProjection = function getGutterForProjection (projection) {
    return 0;
  };

  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   * @protected
   */
  TileSource.prototype.getKey = function getKey () {
    return this.key_;
  };

  /**
   * Set the value to be used as the key for all tiles in the source.
   * @param {string} key The key for tiles.
   * @protected
   */
  TileSource.prototype.setKey = function setKey (key) {
    if (this.key_ !== key) {
      this.key_ = key;
      this.changed();
    }
  };

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {boolean} Opaque.
   */
  TileSource.prototype.getOpaque = function getOpaque (projection) {
    return this.opaque_;
  };

  /**
   * @inheritDoc
   */
  TileSource.prototype.getResolutions = function getResolutions () {
    return this.tileGrid.getResolutions();
  };

  /**
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../Tile.js").default} Tile.
   */
  TileSource.prototype.getTile = function getTile (z, x, y, pixelRatio, projection) {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Return the tile grid of the tile source.
   * @return {import("../tilegrid/TileGrid.js").default} Tile grid.
   * @api
   */
  TileSource.prototype.getTileGrid = function getTileGrid () {
    return this.tileGrid;
  };

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  TileSource.prototype.getTileGridForProjection = function getTileGridForProjection$1 (projection) {
    if (!this.tileGrid) {
      return Object(_tilegrid_js__WEBPACK_IMPORTED_MODULE_8__["getForProjection"])(projection);
    } else {
      return this.tileGrid;
    }
  };

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../TileCache.js").default} Tile cache.
   * @protected
   */
  TileSource.prototype.getTileCacheForProjection = function getTileCacheForProjection (projection) {
    var thisProj = this.getProjection();
    if (thisProj && !Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__["equivalent"])(thisProj, projection)) {
      return null;
    } else {
      return this.tileCache;
    }
  };

  /**
   * Get the tile pixel ratio for this source. Subclasses may override this
   * method, which is meant to return a supported pixel ratio that matches the
   * provided `pixelRatio` as close as possible.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */
  TileSource.prototype.getTilePixelRatio = function getTilePixelRatio (pixelRatio) {
    return this.tilePixelRatio_;
  };

  /**
   * @param {number} z Z.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../size.js").Size} Tile size.
   */
  TileSource.prototype.getTilePixelSize = function getTilePixelSize (z, pixelRatio, projection) {
    var tileGrid = this.getTileGridForProjection(projection);
    var tilePixelRatio = this.getTilePixelRatio(pixelRatio);
    var tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_5__["toSize"])(tileGrid.getTileSize(z), this.tmpSize);
    if (tilePixelRatio == 1) {
      return tileSize;
    } else {
      return Object(_size_js__WEBPACK_IMPORTED_MODULE_5__["scale"])(tileSize, tilePixelRatio, this.tmpSize);
    }
  };

  /**
   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
   * is outside the resolution and extent range of the tile grid, `null` will be
   * returned.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../proj/Projection.js").default=} opt_projection Projection.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
   *     null if no tile URL should be created for the passed `tileCoord`.
   */
  TileSource.prototype.getTileCoordForTileUrlFunction = function getTileCoordForTileUrlFunction (tileCoord, opt_projection) {
    var projection = opt_projection !== undefined ?
      opt_projection : this.getProjection();
    var tileGrid = this.getTileGridForProjection(projection);
    if (this.getWrapX() && projection.isGlobal()) {
      tileCoord = Object(_tilegrid_js__WEBPACK_IMPORTED_MODULE_8__["wrapX"])(tileGrid, tileCoord, projection);
    }
    return Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_7__["withinExtentAndZ"])(tileCoord, tileGrid) ? tileCoord : null;
  };

  /**
   * @inheritDoc
   */
  TileSource.prototype.refresh = function refresh () {
    this.tileCache.clear();
    this.changed();
  };

  /**
   * Marks a tile coord as being used, without triggering a load.
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  TileSource.prototype.useTile = function useTile (z, x, y, projection) {};

  return TileSource;
}(_Source_js__WEBPACK_IMPORTED_MODULE_6__["default"]));


/**
 * @classdesc
 * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this
 * type.
 */
var TileSourceEvent = /*@__PURE__*/(function (Event) {
  function TileSourceEvent(type, tile) {

    Event.call(this, type);

    /**
     * The tile related to the event.
     * @type {import("../Tile.js").default}
     * @api
     */
    this.tile = tile;

  }

  if ( Event ) TileSourceEvent.__proto__ = Event;
  TileSourceEvent.prototype = Object.create( Event && Event.prototype );
  TileSourceEvent.prototype.constructor = TileSourceEvent;

  return TileSourceEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_3__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (TileSource);

//# sourceMappingURL=Tile.js.map

/***/ }),

/***/ "./node_modules/ol/source/TileArcGISRest.js":
/*!**************************************************!*\
  !*** ./node_modules/ol/source/TileArcGISRest.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../size.js */ "./node_modules/ol/size.js");
/* harmony import */ var _TileImage_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./TileImage.js */ "./node_modules/ol/source/TileImage.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");
/* harmony import */ var _uri_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../uri.js */ "./node_modules/ol/uri.js");
/**
 * @module ol/source/TileArcGISRest
 */









/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize=2048] Cache size.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.
 * Note that you must provide a `crossOrigin` value if you are using the WebGL renderer
 * or if you want to access pixel data with the Canvas renderer.  See
 * https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image
 * for more detail.
 * @property {Object<string,*>} [params] ArcGIS Rest parameters. This field is optional. Service defaults will be
 * used for any fields not specified. `FORMAT` is `PNG32` by default. `F` is `IMAGE` by
 * default. `TRANSPARENT` is `true` by default.  `BBOX`, `SIZE`, `BBOXSR`,
 * and `IMAGESR` will be set dynamically. Set `LAYERS` to
 * override the default service layer visibility. See
 * http://resources.arcgis.com/en/help/arcgis-rest-api/index.html#/Export_Map/02r3000000v7000000/
 * for further reference.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid. Base this on the resolutions,
 * tilesize and extent supported by the server.
 * If this is not defined, a default grid will be used: if there is a projection
 * extent, the grid will be based on that; if not, a grid based on a global
 * extent with origin at 0,0 will be used.
 * @property {import("../proj.js").ProjectionLike} projection Projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL.
 * The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {string} [url] ArcGIS Rest service URL for a Map Service or Image Service. The
 * url should include /MapServer or /ImageServer.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number} [transition] Duration of the opacity transition for rendering.  To disable the opacity
 * transition, pass `transition: 0`.
 * @property {Array<string>} urls ArcGIS Rest service urls. Use this instead of `url` when the ArcGIS
 * Service supports multiple urls for export requests.
 */


/**
 * @classdesc
 * Layer source for tile data from ArcGIS Rest services. Map and Image
 * Services are supported.
 *
 * For cached ArcGIS services, better performance is available using the
 * {@link module:ol/source/XYZ~XYZ} data source.
 * @api
 */
var TileArcGISRest = /*@__PURE__*/(function (TileImage) {
  function TileArcGISRest(opt_options) {

    var options = opt_options || /** @type {Options} */ ({});

    TileImage.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      projection: options.projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileGrid: options.tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      tileUrlFunction: tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX !== undefined ? options.wrapX : true,
      transition: options.transition
    });

    /**
     * @private
     * @type {!Object}
     */
    this.params_ = options.params || {};

    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    this.tmpExtent_ = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["createEmpty"])();

    this.setKey(this.getKeyForParams_());
  }

  if ( TileImage ) TileArcGISRest.__proto__ = TileImage;
  TileArcGISRest.prototype = Object.create( TileImage && TileImage.prototype );
  TileArcGISRest.prototype.constructor = TileArcGISRest;

  /**
   * @private
   * @return {string} The key for the current params.
   */
  TileArcGISRest.prototype.getKeyForParams_ = function getKeyForParams_ () {
    var i = 0;
    var res = [];
    for (var key in this.params_) {
      res[i++] = key + '-' + this.params_[key];
    }
    return res.join('/');
  };

  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */
  TileArcGISRest.prototype.getParams = function getParams () {
    return this.params_;
  };

  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../size.js").Size} tileSize Tile size.
   * @param {import("../extent.js").Extent} tileExtent Tile extent.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {Object} params Params.
   * @return {string|undefined} Request URL.
   * @private
   */
  TileArcGISRest.prototype.getRequestUrl_ = function getRequestUrl_ (tileCoord, tileSize, tileExtent, pixelRatio, projection, params) {

    var urls = this.urls;
    if (!urls) {
      return undefined;
    }

    // ArcGIS Server only wants the numeric portion of the projection ID.
    var srid = projection.getCode().split(':').pop();

    params['SIZE'] = tileSize[0] + ',' + tileSize[1];
    params['BBOX'] = tileExtent.join(',');
    params['BBOXSR'] = srid;
    params['IMAGESR'] = srid;
    params['DPI'] = Math.round(
      params['DPI'] ? params['DPI'] * pixelRatio : 90 * pixelRatio
    );

    var url;
    if (urls.length == 1) {
      url = urls[0];
    } else {
      var index = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["modulo"])(Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_5__["hash"])(tileCoord), urls.length);
      url = urls[index];
    }

    var modifiedUrl = url
      .replace(/MapServer\/?$/, 'MapServer/export')
      .replace(/ImageServer\/?$/, 'ImageServer/exportImage');
    return Object(_uri_js__WEBPACK_IMPORTED_MODULE_6__["appendParams"])(modifiedUrl, params);
  };

  /**
   * @inheritDoc
   */
  TileArcGISRest.prototype.getTilePixelRatio = function getTilePixelRatio (pixelRatio) {
    return /** @type {number} */ (pixelRatio);
  };

  /**
   * Update the user-provided params.
   * @param {Object} params Params.
   * @api
   */
  TileArcGISRest.prototype.updateParams = function updateParams (params) {
    Object(_obj_js__WEBPACK_IMPORTED_MODULE_2__["assign"])(this.params_, params);
    this.setKey(this.getKeyForParams_());
  };

  return TileArcGISRest;
}(_TileImage_js__WEBPACK_IMPORTED_MODULE_4__["default"]));

/**
 * @param {import("../tilecoord.js").TileCoord} tileCoord The tile coordinate
 * @param {number} pixelRatio The pixel ratio
 * @param {import("../proj/Projection.js").default} projection The projection
 * @return {string|undefined} The tile URL
 * @this {TileArcGISRest}
 */
function tileUrlFunction(tileCoord, pixelRatio, projection) {

  var tileGrid = this.getTileGrid();
  if (!tileGrid) {
    tileGrid = this.getTileGridForProjection(projection);
  }

  if (tileGrid.getResolutions().length <= tileCoord[0]) {
    return undefined;
  }

  var tileExtent = tileGrid.getTileCoordExtent(
    tileCoord, this.tmpExtent_);
  var tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_3__["toSize"])(
    tileGrid.getTileSize(tileCoord[0]), this.tmpSize);

  if (pixelRatio != 1) {
    tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_3__["scale"])(tileSize, pixelRatio, this.tmpSize);
  }

  // Apply default params and override with user specified values.
  var baseParams = {
    'F': 'image',
    'FORMAT': 'PNG32',
    'TRANSPARENT': true
  };
  Object(_obj_js__WEBPACK_IMPORTED_MODULE_2__["assign"])(baseParams, this.params_);

  return this.getRequestUrl_(tileCoord, tileSize, tileExtent,
    pixelRatio, projection, baseParams);
}


/* harmony default export */ __webpack_exports__["default"] = (TileArcGISRest);

//# sourceMappingURL=TileArcGISRest.js.map

/***/ }),

/***/ "./node_modules/ol/source/TileDebug.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/source/TileDebug.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Tile.js */ "./node_modules/ol/Tile.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../size.js */ "./node_modules/ol/size.js");
/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Tile.js */ "./node_modules/ol/source/Tile.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");
/**
 * @module ol/source/TileDebug
 */









var LabeledTile = /*@__PURE__*/(function (Tile) {
  function LabeledTile(tileCoord, tileSize, text) {

    Tile.call(this, tileCoord, _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED);

    /**
    * @private
    * @type {import("../size.js").Size}
    */
    this.tileSize_ = tileSize;

    /**
    * @private
    * @type {string}
    */
    this.text_ = text;

    /**
    * @private
    * @type {HTMLCanvasElement}
    */
    this.canvas_ = null;

  }

  if ( Tile ) LabeledTile.__proto__ = Tile;
  LabeledTile.prototype = Object.create( Tile && Tile.prototype );
  LabeledTile.prototype.constructor = LabeledTile;

  /**
  * Get the image element for this tile.
  * @return {HTMLCanvasElement} Image.
  */
  LabeledTile.prototype.getImage = function getImage () {
    if (this.canvas_) {
      return this.canvas_;
    } else {
      var tileSize = this.tileSize_;
      var context = Object(_dom_js__WEBPACK_IMPORTED_MODULE_2__["createCanvasContext2D"])(tileSize[0], tileSize[1]);

      context.strokeStyle = 'black';
      context.strokeRect(0.5, 0.5, tileSize[0] + 0.5, tileSize[1] + 0.5);

      context.fillStyle = 'black';
      context.textAlign = 'center';
      context.textBaseline = 'middle';
      context.font = '24px sans-serif';
      context.fillText(this.text_, tileSize[0] / 2, tileSize[1] / 2);

      this.canvas_ = context.canvas;
      return context.canvas;
    }
  };

  /**
  * @override
  */
  LabeledTile.prototype.load = function load () {};

  return LabeledTile;
}(_Tile_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/**
 * @typedef {Object} Options
 * @property {import("../proj.js").ProjectionLike} projection Projection.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 */


/**
 * @classdesc
 * A pseudo tile source, which does not fetch tiles from a server, but renders
 * a grid outline for the tile grid/projection along with the coordinates for
 * each tile. See examples/canvas-tiles for an example.
 *
 * Uses Canvas context2d, so requires Canvas support.
 * @api
 */
var TileDebug = /*@__PURE__*/(function (TileSource) {
  function TileDebug(options) {

    TileSource.call(this, {
      opaque: false,
      projection: options.projection,
      tileGrid: options.tileGrid,
      wrapX: options.wrapX !== undefined ? options.wrapX : true
    });

  }

  if ( TileSource ) TileDebug.__proto__ = TileSource;
  TileDebug.prototype = Object.create( TileSource && TileSource.prototype );
  TileDebug.prototype.constructor = TileDebug;

  /**
  * @inheritDoc
  */
  TileDebug.prototype.getTile = function getTile (z, x, y) {
    var tileCoordKey = Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_5__["getKeyZXY"])(z, x, y);
    if (this.tileCache.containsKey(tileCoordKey)) {
      return /** @type {!LabeledTile} */ (this.tileCache.get(tileCoordKey));
    } else {
      var tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_3__["toSize"])(this.tileGrid.getTileSize(z));
      var tileCoord = [z, x, y];
      var textTileCoord = this.getTileCoordForTileUrlFunction(tileCoord);
      var text = !textTileCoord ? '' :
        this.getTileCoordForTileUrlFunction(textTileCoord).toString();
      var tile = new LabeledTile(tileCoord, tileSize, text);
      this.tileCache.set(tileCoordKey, tile);
      return tile;
    }
  };

  return TileDebug;
}(_Tile_js__WEBPACK_IMPORTED_MODULE_4__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (TileDebug);

//# sourceMappingURL=TileDebug.js.map

/***/ }),

/***/ "./node_modules/ol/source/TileEventType.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/source/TileEventType.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/source/TileEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({

  /**
   * Triggered when a tile starts loading.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
   * @api
   */
  TILELOADSTART: 'tileloadstart',

  /**
   * Triggered when a tile finishes loading, either when its data is loaded,
   * or when loading was aborted because the tile is no longer needed.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadend
   * @api
   */
  TILELOADEND: 'tileloadend',

  /**
   * Triggered if tile loading results in an error.
   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
   * @api
   */
  TILELOADERROR: 'tileloaderror'

});

//# sourceMappingURL=TileEventType.js.map

/***/ }),

/***/ "./node_modules/ol/source/TileImage.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/source/TileImage.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _reproj_common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../reproj/common.js */ "./node_modules/ol/reproj/common.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _ImageTile_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ImageTile.js */ "./node_modules/ol/ImageTile.js");
/* harmony import */ var _TileCache_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../TileCache.js */ "./node_modules/ol/TileCache.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _reproj_Tile_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../reproj/Tile.js */ "./node_modules/ol/reproj/Tile.js");
/* harmony import */ var _UrlTile_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./UrlTile.js */ "./node_modules/ol/source/UrlTile.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../tilegrid.js */ "./node_modules/ol/tilegrid.js");
/**
 * @module ol/source/TileImage
 */













/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize=2048] Cache size.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to
 * access pixel data with the Canvas renderer.  See
 * https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [opaque=true] Whether the layer is opaque.
 * @property {import("../proj.js").ProjectionLike} projection Projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("./State.js").default} [state] Source state.
 * @property {typeof import("../ImageTile.js").default} [tileClass] Class used to instantiate image tiles.
 * Default is {@link module:ol/ImageTile~ImageTile}.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service. For example, if the tile
 * service advertizes 256px by 256px tiles but actually sends 512px
 * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
 * should be set to `2`.
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be
 * used instead of defining each one separately in the `urls` option.
 * @property {Array<string>} [urls] An array of URL templates.
 * @property {boolean} [wrapX] Whether to wrap the world horizontally. The default, is to
 * request out-of-bounds tiles from the server. When set to `false`, only one
 * world will be rendered. When set to `true`, tiles will be requested for one
 * world only, but they will be wrapped horizontally to render multiple worlds.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {string} [key] Optional tile key for proper cache fetching
 */


/**
 * @classdesc
 * Base class for sources providing images divided into a tile grid.
 *
 * @fires import("./Tile.js").TileSourceEvent
 * @api
 */
var TileImage = /*@__PURE__*/(function (UrlTile) {
  function TileImage(options) {

    UrlTile.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      opaque: options.opaque,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tileLoadFunction: options.tileLoadFunction ?
        options.tileLoadFunction : defaultTileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX,
      transition: options.transition,
      key: options.key,
      attributionsCollapsible: options.attributionsCollapsible
    });

    /**
     * @protected
     * @type {?string}
     */
    this.crossOrigin =
        options.crossOrigin !== undefined ? options.crossOrigin : null;

    /**
     * @protected
     * @type {typeof ImageTile}
     */
    this.tileClass = options.tileClass !== undefined ?
      options.tileClass : _ImageTile_js__WEBPACK_IMPORTED_MODULE_2__["default"];

    /**
     * @protected
     * @type {!Object<string, TileCache>}
     */
    this.tileCacheForProjection = {};

    /**
     * @protected
     * @type {!Object<string, import("../tilegrid/TileGrid.js").default>}
     */
    this.tileGridForProjection = {};

    /**
     * @private
     * @type {number|undefined}
     */
    this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;

    /**
     * @private
     * @type {boolean}
     */
    this.renderReprojectionEdges_ = false;
  }

  if ( UrlTile ) TileImage.__proto__ = UrlTile;
  TileImage.prototype = Object.create( UrlTile && UrlTile.prototype );
  TileImage.prototype.constructor = TileImage;

  /**
   * @inheritDoc
   */
  TileImage.prototype.canExpireCache = function canExpireCache () {
    if (!_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"]) {
      return UrlTile.prototype.canExpireCache.call(this);
    }
    if (this.tileCache.canExpireCache()) {
      return true;
    } else {
      for (var key in this.tileCacheForProjection) {
        if (this.tileCacheForProjection[key].canExpireCache()) {
          return true;
        }
      }
    }
    return false;
  };

  /**
   * @inheritDoc
   */
  TileImage.prototype.expireCache = function expireCache (projection, usedTiles) {
    if (!_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"]) {
      UrlTile.prototype.expireCache.call(this, projection, usedTiles);
      return;
    }
    var usedTileCache = this.getTileCacheForProjection(projection);

    this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});
    for (var id in this.tileCacheForProjection) {
      var tileCache = this.tileCacheForProjection[id];
      tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});
    }
  };

  /**
   * @inheritDoc
   */
  TileImage.prototype.getGutterForProjection = function getGutterForProjection (projection) {
    if (_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"] &&
        this.getProjection() && projection && !Object(_proj_js__WEBPACK_IMPORTED_MODULE_7__["equivalent"])(this.getProjection(), projection)) {
      return 0;
    } else {
      return this.getGutter();
    }
  };

  /**
   * @return {number} Gutter.
   */
  TileImage.prototype.getGutter = function getGutter () {
    return 0;
  };

  /**
   * @inheritDoc
   */
  TileImage.prototype.getOpaque = function getOpaque (projection) {
    if (_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"] &&
        this.getProjection() && projection && !Object(_proj_js__WEBPACK_IMPORTED_MODULE_7__["equivalent"])(this.getProjection(), projection)) {
      return false;
    } else {
      return UrlTile.prototype.getOpaque.call(this, projection);
    }
  };

  /**
   * @inheritDoc
   */
  TileImage.prototype.getTileGridForProjection = function getTileGridForProjection$1 (projection) {
    if (!_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"]) {
      return UrlTile.prototype.getTileGridForProjection.call(this, projection);
    }
    var thisProj = this.getProjection();
    if (this.tileGrid && (!thisProj || Object(_proj_js__WEBPACK_IMPORTED_MODULE_7__["equivalent"])(thisProj, projection))) {
      return this.tileGrid;
    } else {
      var projKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_1__["getUid"])(projection);
      if (!(projKey in this.tileGridForProjection)) {
        this.tileGridForProjection[projKey] = Object(_tilegrid_js__WEBPACK_IMPORTED_MODULE_11__["getForProjection"])(projection);
      }
      return (
        /** @type {!import("../tilegrid/TileGrid.js").default} */ (this.tileGridForProjection[projKey])
      );
    }
  };

  /**
   * @inheritDoc
   */
  TileImage.prototype.getTileCacheForProjection = function getTileCacheForProjection (projection) {
    if (!_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"]) {
      return UrlTile.prototype.getTileCacheForProjection.call(this, projection);
    }
    var thisProj = this.getProjection(); if (!thisProj || Object(_proj_js__WEBPACK_IMPORTED_MODULE_7__["equivalent"])(thisProj, projection)) {
      return this.tileCache;
    } else {
      var projKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_1__["getUid"])(projection);
      if (!(projKey in this.tileCacheForProjection)) {
        this.tileCacheForProjection[projKey] = new _TileCache_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.tileCache.highWaterMark);
      }
      return this.tileCacheForProjection[projKey];
    }
  };

  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {string} key The key set on the tile.
   * @return {!import("../Tile.js").default} Tile.
   * @private
   */
  TileImage.prototype.createTile_ = function createTile_ (z, x, y, pixelRatio, projection, key) {
    var tileCoord = [z, x, y];
    var urlTileCoord = this.getTileCoordForTileUrlFunction(
      tileCoord, projection);
    var tileUrl = urlTileCoord ?
      this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : undefined;
    var tile = new this.tileClass(
      tileCoord,
      tileUrl !== undefined ? _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].IDLE : _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].EMPTY,
      tileUrl !== undefined ? tileUrl : '',
      this.crossOrigin,
      this.tileLoadFunction,
      this.tileOptions);
    tile.key = key;
    Object(_events_js__WEBPACK_IMPORTED_MODULE_5__["listen"])(tile, _events_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].CHANGE,
      this.handleTileChange, this);
    return tile;
  };

  /**
   * @inheritDoc
   */
  TileImage.prototype.getTile = function getTile (z, x, y, pixelRatio, projection) {
    var sourceProjection = /** @type {!import("../proj/Projection.js").default} */ (this.getProjection());
    if (!_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"] ||
        !sourceProjection || !projection || Object(_proj_js__WEBPACK_IMPORTED_MODULE_7__["equivalent"])(sourceProjection, projection)) {
      return this.getTileInternal(z, x, y, pixelRatio, sourceProjection || projection);
    } else {
      var cache = this.getTileCacheForProjection(projection);
      var tileCoord = [z, x, y];
      var tile;
      var tileCoordKey = Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_10__["getKey"])(tileCoord);
      if (cache.containsKey(tileCoordKey)) {
        tile = /** @type {!import("../Tile.js").default} */ (cache.get(tileCoordKey));
      }
      var key = this.getKey();
      if (tile && tile.key == key) {
        return tile;
      } else {
        var sourceTileGrid = this.getTileGridForProjection(sourceProjection);
        var targetTileGrid = this.getTileGridForProjection(projection);
        var wrappedTileCoord =
            this.getTileCoordForTileUrlFunction(tileCoord, projection);
        var newTile = new _reproj_Tile_js__WEBPACK_IMPORTED_MODULE_8__["default"](
          sourceProjection, sourceTileGrid,
          projection, targetTileGrid,
          tileCoord, wrappedTileCoord, this.getTilePixelRatio(pixelRatio),
          this.getGutter(),
          function(z, x, y, pixelRatio) {
            return this.getTileInternal(z, x, y, pixelRatio, sourceProjection);
          }.bind(this), this.reprojectionErrorThreshold_,
          this.renderReprojectionEdges_);
        newTile.key = key;

        if (tile) {
          newTile.interimTile = tile;
          newTile.refreshInterimChain();
          cache.replace(tileCoordKey, newTile);
        } else {
          cache.set(tileCoordKey, newTile);
        }
        return newTile;
      }
    }
  };

  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {!import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../Tile.js").default} Tile.
   * @protected
   */
  TileImage.prototype.getTileInternal = function getTileInternal (z, x, y, pixelRatio, projection) {
    var tile = null;
    var tileCoordKey = Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_10__["getKeyZXY"])(z, x, y);
    var key = this.getKey();
    if (!this.tileCache.containsKey(tileCoordKey)) {
      tile = this.createTile_(z, x, y, pixelRatio, projection, key);
      this.tileCache.set(tileCoordKey, tile);
    } else {
      tile = this.tileCache.get(tileCoordKey);
      if (tile.key != key) {
        // The source's params changed. If the tile has an interim tile and if we
        // can use it then we use it. Otherwise we create a new tile.  In both
        // cases we attempt to assign an interim tile to the new tile.
        var interimTile = tile;
        tile = this.createTile_(z, x, y, pixelRatio, projection, key);

        //make the new tile the head of the list,
        if (interimTile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].IDLE) {
          //the old tile hasn't begun loading yet, and is now outdated, so we can simply discard it
          tile.interimTile = interimTile.interimTile;
        } else {
          tile.interimTile = interimTile;
        }
        tile.refreshInterimChain();
        this.tileCache.replace(tileCoordKey, tile);
      }
    }
    return tile;
  };

  /**
   * Sets whether to render reprojection edges or not (usually for debugging).
   * @param {boolean} render Render the edges.
   * @api
   */
  TileImage.prototype.setRenderReprojectionEdges = function setRenderReprojectionEdges (render) {
    if (!_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"] ||
        this.renderReprojectionEdges_ == render) {
      return;
    }
    this.renderReprojectionEdges_ = render;
    for (var id in this.tileCacheForProjection) {
      this.tileCacheForProjection[id].clear();
    }
    this.changed();
  };

  /**
   * Sets the tile grid to use when reprojecting the tiles to the given
   * projection instead of the default tile grid for the projection.
   *
   * This can be useful when the default tile grid cannot be created
   * (e.g. projection has no extent defined) or
   * for optimization reasons (custom tile size, resolutions, ...).
   *
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
   * @api
   */
  TileImage.prototype.setTileGridForProjection = function setTileGridForProjection (projection, tilegrid) {
    if (_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"]) {
      var proj = Object(_proj_js__WEBPACK_IMPORTED_MODULE_7__["get"])(projection);
      if (proj) {
        var projKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_1__["getUid"])(proj);
        if (!(projKey in this.tileGridForProjection)) {
          this.tileGridForProjection[projKey] = tilegrid;
        }
      }
    }
  };

  return TileImage;
}(_UrlTile_js__WEBPACK_IMPORTED_MODULE_9__["default"]));


/**
 * @param {ImageTile} imageTile Image tile.
 * @param {string} src Source.
 */
function defaultTileLoadFunction(imageTile, src) {
  /** @type {HTMLImageElement|HTMLVideoElement} */ (imageTile.getImage()).src = src;
}

/* harmony default export */ __webpack_exports__["default"] = (TileImage);

//# sourceMappingURL=TileImage.js.map

/***/ }),

/***/ "./node_modules/ol/source/TileJSON.js":
/*!********************************************!*\
  !*** ./node_modules/ol/source/TileJSON.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tileurlfunction.js */ "./node_modules/ol/tileurlfunction.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _net_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../net.js */ "./node_modules/ol/net.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _State_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./State.js */ "./node_modules/ol/source/State.js");
/* harmony import */ var _TileImage_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./TileImage.js */ "./node_modules/ol/source/TileImage.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../tilegrid.js */ "./node_modules/ol/tilegrid.js");
/**
 * @module ol/source/TileJSON
 */
// FIXME check order of async callbacks

/**
 * See http://mapbox.com/developers/api/.
 */












/**
 * @typedef {Object} Config
 * @property {string} [name] The name.
 * @property {string} [description] The description.
 * @property {string} [version] The version.
 * @property {string} [attribution] The attribution.
 * @property {string} [template] The template.
 * @property {string} [legend] The legend.
 * @property {string} [scheme] The scheme.
 * @property {Array<string>} tiles The tile URL templates.
 * @property {Array<string>} [grids] Optional grids.
 * @property {number} [minzoom] Minimum zoom level.
 * @property {number} [maxzoom] Maximum zoom level.
 * @property {Array<number>} [bounds] Optional bounds.
 * @property {Array<number>} [center] Optional center.
 */


/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize=2048] Cache size.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to
 * access pixel data with the Canvas renderer.  See
 * https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [jsonp=false] Use JSONP with callback to load the TileJSON.
 * Useful when the server does not support CORS..
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {Config} [tileJSON] TileJSON configuration for this source.
 * If not provided, `url` must be configured.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {string} [url] URL to the TileJSON file. If not provided, `tileJSON` must be configured.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 */


/**
 * @classdesc
 * Layer source for tile data in TileJSON format.
 * @api
 */
var TileJSON = /*@__PURE__*/(function (TileImage) {
  function TileJSON(options) {
    TileImage.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      projection: Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__["get"])('EPSG:3857'),
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      state: _State_js__WEBPACK_IMPORTED_MODULE_5__["default"].LOADING,
      tileLoadFunction: options.tileLoadFunction,
      wrapX: options.wrapX !== undefined ? options.wrapX : true,
      transition: options.transition
    });

    /**
     * @type {Config}
     * @private
     */
    this.tileJSON_ = null;


    if (options.url) {
      if (options.jsonp) {
        Object(_net_js__WEBPACK_IMPORTED_MODULE_3__["jsonp"])(options.url, this.handleTileJSONResponse.bind(this),
          this.handleTileJSONError.bind(this));
      } else {
        var client = new XMLHttpRequest();
        client.addEventListener('load', this.onXHRLoad_.bind(this));
        client.addEventListener('error', this.onXHRError_.bind(this));
        client.open('GET', options.url);
        client.send();
      }
    } else if (options.tileJSON) {
      this.handleTileJSONResponse(options.tileJSON);
    } else {
      Object(_asserts_js__WEBPACK_IMPORTED_MODULE_1__["assert"])(false, 51); // Either `url` or `tileJSON` options must be provided
    }

  }

  if ( TileImage ) TileJSON.__proto__ = TileImage;
  TileJSON.prototype = Object.create( TileImage && TileImage.prototype );
  TileJSON.prototype.constructor = TileJSON;

  /**
   * @private
   * @param {Event} event The load event.
   */
  TileJSON.prototype.onXHRLoad_ = function onXHRLoad_ (event) {
    var client = /** @type {XMLHttpRequest} */ (event.target);
    // status will be 0 for file:// urls
    if (!client.status || client.status >= 200 && client.status < 300) {
      var response;
      try {
        response = /** @type {TileJSON} */(JSON.parse(client.responseText));
      } catch (err) {
        this.handleTileJSONError();
        return;
      }
      this.handleTileJSONResponse(response);
    } else {
      this.handleTileJSONError();
    }
  };

  /**
   * @private
   * @param {Event} event The error event.
   */
  TileJSON.prototype.onXHRError_ = function onXHRError_ (event) {
    this.handleTileJSONError();
  };

  /**
   * @return {Config} The tilejson object.
   * @api
   */
  TileJSON.prototype.getTileJSON = function getTileJSON () {
    return this.tileJSON_;
  };

  /**
   * @protected
   * @param {Config} tileJSON Tile JSON.
   */
  TileJSON.prototype.handleTileJSONResponse = function handleTileJSONResponse (tileJSON) {

    var epsg4326Projection = Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__["get"])('EPSG:4326');

    var sourceProjection = this.getProjection();
    var extent;
    if (tileJSON['bounds'] !== undefined) {
      var transform = Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__["getTransformFromProjections"])(
        epsg4326Projection, sourceProjection);
      extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["applyTransform"])(tileJSON['bounds'], transform);
    }

    var minZoom = tileJSON['minzoom'] || 0;
    var maxZoom = tileJSON['maxzoom'] || 22;
    var tileGrid = Object(_tilegrid_js__WEBPACK_IMPORTED_MODULE_7__["createXYZ"])({
      extent: Object(_tilegrid_js__WEBPACK_IMPORTED_MODULE_7__["extentFromProjection"])(sourceProjection),
      maxZoom: maxZoom,
      minZoom: minZoom
    });
    this.tileGrid = tileGrid;

    this.tileUrlFunction = Object(_tileurlfunction_js__WEBPACK_IMPORTED_MODULE_0__["createFromTemplates"])(tileJSON['tiles'], tileGrid);

    if (tileJSON['attribution'] !== undefined && !this.getAttributions()) {
      var attributionExtent = extent !== undefined ?
        extent : epsg4326Projection.getExtent();

      this.setAttributions(function(frameState) {
        if (Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["intersects"])(attributionExtent, frameState.extent)) {
          return [tileJSON['attribution']];
        }
        return null;
      });

    }
    this.tileJSON_ = tileJSON;
    this.setState(_State_js__WEBPACK_IMPORTED_MODULE_5__["default"].READY);

  };

  /**
   * @protected
   */
  TileJSON.prototype.handleTileJSONError = function handleTileJSONError () {
    this.setState(_State_js__WEBPACK_IMPORTED_MODULE_5__["default"].ERROR);
  };

  return TileJSON;
}(_TileImage_js__WEBPACK_IMPORTED_MODULE_6__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (TileJSON);

//# sourceMappingURL=TileJSON.js.map

/***/ }),

/***/ "./node_modules/ol/source/TileWMS.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/source/TileWMS.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/ol/source/common.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _reproj_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../reproj.js */ "./node_modules/ol/reproj.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../size.js */ "./node_modules/ol/size.js");
/* harmony import */ var _TileImage_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./TileImage.js */ "./node_modules/ol/source/TileImage.js");
/* harmony import */ var _WMSServerType_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./WMSServerType.js */ "./node_modules/ol/source/WMSServerType.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../string.js */ "./node_modules/ol/string.js");
/* harmony import */ var _uri_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../uri.js */ "./node_modules/ol/uri.js");
/**
 * @module ol/source/TileWMS
 */
















/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize=2048] Cache size.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to
 * access pixel data with the Canvas renderer.  See
 * https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {Object<string,*>} params WMS request parameters.
 * At least a `LAYERS` param is required. `STYLES` is
 * `''` by default. `VERSION` is `1.3.0` by default. `WIDTH`, `HEIGHT`, `BBOX`
 * and `CRS` (`SRS` for WMS version < 1.3.0) will be set dynamically.
 * @property {number} [gutter=0]
 * The size in pixels of the gutter around image tiles to ignore. By setting
 * this property to a non-zero value, images will be requested that are wider
 * and taller than the tile size by a value of `2 x gutter`.
 * Using a non-zero value allows artifacts of rendering at tile edges to be
 * ignored. If you control the WMS service it is recommended to address
 * "artifacts at tile edges" issues by properly configuring the WMS service. For
 * example, MapServer has a `tile_map_edge_buffer` configuration parameter for
 * this. See http://mapserver.org/output/tile_mode.html.
 * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting
 * the image from the remote server.
 * @property {import("../proj.js").ProjectionLike} projection Projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {typeof import("../ImageTile.js").default} [tileClass] Class used to instantiate image tiles.
 * Default is {@link module:ol/ImageTile~ImageTile}.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid. Base this on the resolutions,
 * tilesize and extent supported by the server.
 * If this is not defined, a default grid will be used: if there is a projection
 * extent, the grid will be based on that; if not, a grid based on a global
 * extent with origin at 0,0 will be used..
 * @property {import("./WMSServerType.js").default|string} [serverType]
 * The type of the remote WMS server. Currently only used when `hidpi` is
 * `true`.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {string} [url] WMS service URL.
 * @property {Array<string>} [urls] WMS service urls.
 * Use this instead of `url` when the WMS supports multiple urls for GetMap requests.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * When set to `false`, only one world
 * will be rendered. When `true`, tiles will be requested for one world only,
 * but they will be wrapped horizontally to render multiple worlds.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 */


/**
 * @classdesc
 * Layer source for tile data from WMS servers.
 * @api
 */
var TileWMS = /*@__PURE__*/(function (TileImage) {
  function TileWMS(opt_options) {

    var options = opt_options || /** @type {Options} */ ({});

    var params = options.params || {};

    var transparent = 'TRANSPARENT' in params ? params['TRANSPARENT'] : true;

    TileImage.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      opaque: !transparent,
      projection: options.projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileClass: options.tileClass,
      tileGrid: options.tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      tileUrlFunction: tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX !== undefined ? options.wrapX : true,
      transition: options.transition
    });

    /**
     * @private
     * @type {number}
     */
    this.gutter_ = options.gutter !== undefined ? options.gutter : 0;

    /**
     * @private
     * @type {!Object}
     */
    this.params_ = params;

    /**
     * @private
     * @type {boolean}
     */
    this.v13_ = true;

    /**
     * @private
     * @type {import("./WMSServerType.js").default|undefined}
     */
    this.serverType_ = /** @type {import("./WMSServerType.js").default|undefined} */ (options.serverType);

    /**
     * @private
     * @type {boolean}
     */
    this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;

    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    this.tmpExtent_ = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["createEmpty"])();

    this.updateV13_();
    this.setKey(this.getKeyForParams_());

  }

  if ( TileImage ) TileWMS.__proto__ = TileImage;
  TileWMS.prototype = Object.create( TileImage && TileImage.prototype );
  TileWMS.prototype.constructor = TileWMS;

  /**
   * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
   * projection. Return `undefined` if the GetFeatureInfo URL cannot be
   * constructed.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should
   *     be provided. If `QUERY_LAYERS` is not provided then the layers specified
   *     in the `LAYERS` parameter will be used. `VERSION` should not be
   *     specified here.
   * @return {string|undefined} GetFeatureInfo URL.
   * @api
   */
  TileWMS.prototype.getGetFeatureInfoUrl = function getGetFeatureInfoUrl (coordinate, resolution, projection, params) {
    var projectionObj = Object(_proj_js__WEBPACK_IMPORTED_MODULE_5__["get"])(projection);
    var sourceProjectionObj = this.getProjection();

    var tileGrid = this.getTileGrid();
    if (!tileGrid) {
      tileGrid = this.getTileGridForProjection(projectionObj);
    }

    var tileCoord = tileGrid.getTileCoordForCoordAndResolution(coordinate, resolution);

    if (tileGrid.getResolutions().length <= tileCoord[0]) {
      return undefined;
    }

    var tileResolution = tileGrid.getResolution(tileCoord[0]);
    var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);
    var tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_7__["toSize"])(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);


    var gutter = this.gutter_;
    if (gutter !== 0) {
      tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_7__["buffer"])(tileSize, gutter, this.tmpSize);
      tileExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["buffer"])(tileExtent, tileResolution * gutter, tileExtent);
    }

    if (sourceProjectionObj && sourceProjectionObj !== projectionObj) {
      tileResolution = Object(_reproj_js__WEBPACK_IMPORTED_MODULE_6__["calculateSourceResolution"])(sourceProjectionObj, projectionObj, coordinate, tileResolution);
      tileExtent = Object(_proj_js__WEBPACK_IMPORTED_MODULE_5__["transformExtent"])(tileExtent, projectionObj, sourceProjectionObj);
      coordinate = Object(_proj_js__WEBPACK_IMPORTED_MODULE_5__["transform"])(coordinate, projectionObj, sourceProjectionObj);
    }

    var baseParams = {
      'SERVICE': 'WMS',
      'VERSION': _common_js__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_WMS_VERSION"],
      'REQUEST': 'GetFeatureInfo',
      'FORMAT': 'image/png',
      'TRANSPARENT': true,
      'QUERY_LAYERS': this.params_['LAYERS']
    };
    Object(_obj_js__WEBPACK_IMPORTED_MODULE_3__["assign"])(baseParams, this.params_, params);

    var x = Math.floor((coordinate[0] - tileExtent[0]) / tileResolution);
    var y = Math.floor((tileExtent[3] - coordinate[1]) / tileResolution);

    baseParams[this.v13_ ? 'I' : 'X'] = x;
    baseParams[this.v13_ ? 'J' : 'Y'] = y;

    return this.getRequestUrl_(tileCoord, tileSize, tileExtent,
      1, sourceProjectionObj || projectionObj, baseParams);
  };

  /**
   * @inheritDoc
   */
  TileWMS.prototype.getGutter = function getGutter () {
    return this.gutter_;
  };

  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */
  TileWMS.prototype.getParams = function getParams () {
    return this.params_;
  };

  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../size.js").Size} tileSize Tile size.
   * @param {import("../extent.js").Extent} tileExtent Tile extent.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {Object} params Params.
   * @return {string|undefined} Request URL.
   * @private
   */
  TileWMS.prototype.getRequestUrl_ = function getRequestUrl_ (tileCoord, tileSize, tileExtent, pixelRatio, projection, params) {

    var urls = this.urls;
    if (!urls) {
      return undefined;
    }

    params['WIDTH'] = tileSize[0];
    params['HEIGHT'] = tileSize[1];

    params[this.v13_ ? 'CRS' : 'SRS'] = projection.getCode();

    if (!('STYLES' in this.params_)) {
      params['STYLES'] = '';
    }

    if (pixelRatio != 1) {
      switch (this.serverType_) {
        case _WMSServerType_js__WEBPACK_IMPORTED_MODULE_9__["default"].GEOSERVER:
          var dpi = (90 * pixelRatio + 0.5) | 0;
          if ('FORMAT_OPTIONS' in params) {
            params['FORMAT_OPTIONS'] += ';dpi:' + dpi;
          } else {
            params['FORMAT_OPTIONS'] = 'dpi:' + dpi;
          }
          break;
        case _WMSServerType_js__WEBPACK_IMPORTED_MODULE_9__["default"].MAPSERVER:
          params['MAP_RESOLUTION'] = 90 * pixelRatio;
          break;
        case _WMSServerType_js__WEBPACK_IMPORTED_MODULE_9__["default"].CARMENTA_SERVER:
        case _WMSServerType_js__WEBPACK_IMPORTED_MODULE_9__["default"].QGIS:
          params['DPI'] = 90 * pixelRatio;
          break;
        default:
          Object(_asserts_js__WEBPACK_IMPORTED_MODULE_1__["assert"])(false, 52); // Unknown `serverType` configured
          break;
      }
    }

    var axisOrientation = projection.getAxisOrientation();
    var bbox = tileExtent;
    if (this.v13_ && axisOrientation.substr(0, 2) == 'ne') {
      var tmp;
      tmp = tileExtent[0];
      bbox[0] = tileExtent[1];
      bbox[1] = tmp;
      tmp = tileExtent[2];
      bbox[2] = tileExtent[3];
      bbox[3] = tmp;
    }
    params['BBOX'] = bbox.join(',');

    var url;
    if (urls.length == 1) {
      url = urls[0];
    } else {
      var index = Object(_math_js__WEBPACK_IMPORTED_MODULE_4__["modulo"])(Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_10__["hash"])(tileCoord), urls.length);
      url = urls[index];
    }
    return Object(_uri_js__WEBPACK_IMPORTED_MODULE_12__["appendParams"])(url, params);
  };

  /**
   * @inheritDoc
   */
  TileWMS.prototype.getTilePixelRatio = function getTilePixelRatio (pixelRatio) {
    return (!this.hidpi_ || this.serverType_ === undefined) ? 1 :
    /** @type {number} */ (pixelRatio);
  };

  /**
   * @private
   * @return {string} The key for the current params.
   */
  TileWMS.prototype.getKeyForParams_ = function getKeyForParams_ () {
    var i = 0;
    var res = [];
    for (var key in this.params_) {
      res[i++] = key + '-' + this.params_[key];
    }
    return res.join('/');
  };

  /**
   * Update the user-provided params.
   * @param {Object} params Params.
   * @api
   */
  TileWMS.prototype.updateParams = function updateParams (params) {
    Object(_obj_js__WEBPACK_IMPORTED_MODULE_3__["assign"])(this.params_, params);
    this.updateV13_();
    this.setKey(this.getKeyForParams_());
  };

  /**
   * @private
   */
  TileWMS.prototype.updateV13_ = function updateV13_ () {
    var version = this.params_['VERSION'] || _common_js__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_WMS_VERSION"];
    this.v13_ = Object(_string_js__WEBPACK_IMPORTED_MODULE_11__["compareVersions"])(version, '1.3') >= 0;
  };

  return TileWMS;
}(_TileImage_js__WEBPACK_IMPORTED_MODULE_8__["default"]));

/**
 * @param {import("../tilecoord.js").TileCoord} tileCoord The tile coordinate
 * @param {number} pixelRatio The pixel ratio
 * @param {import("../proj/Projection.js").default} projection The projection
 * @return {string|undefined} The tile URL
 * @this {TileWMS}
 */
function tileUrlFunction(tileCoord, pixelRatio, projection) {

  var tileGrid = this.getTileGrid();
  if (!tileGrid) {
    tileGrid = this.getTileGridForProjection(projection);
  }

  if (tileGrid.getResolutions().length <= tileCoord[0]) {
    return undefined;
  }

  if (pixelRatio != 1 && (!this.hidpi_ || this.serverType_ === undefined)) {
    pixelRatio = 1;
  }

  var tileResolution = tileGrid.getResolution(tileCoord[0]);
  var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);
  var tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_7__["toSize"])(
    tileGrid.getTileSize(tileCoord[0]), this.tmpSize);

  var gutter = this.gutter_;
  if (gutter !== 0) {
    tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_7__["buffer"])(tileSize, gutter, this.tmpSize);
    tileExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["buffer"])(tileExtent, tileResolution * gutter, tileExtent);
  }

  if (pixelRatio != 1) {
    tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_7__["scale"])(tileSize, pixelRatio, this.tmpSize);
  }

  var baseParams = {
    'SERVICE': 'WMS',
    'VERSION': _common_js__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_WMS_VERSION"],
    'REQUEST': 'GetMap',
    'FORMAT': 'image/png',
    'TRANSPARENT': true
  };
  Object(_obj_js__WEBPACK_IMPORTED_MODULE_3__["assign"])(baseParams, this.params_);

  return this.getRequestUrl_(tileCoord, tileSize, tileExtent,
    pixelRatio, projection, baseParams);
}


/* harmony default export */ __webpack_exports__["default"] = (TileWMS);

//# sourceMappingURL=TileWMS.js.map

/***/ }),

/***/ "./node_modules/ol/source/UTFGrid.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/source/UTFGrid.js ***!
  \*******************************************/
/*! exports provided: CustomTile, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CustomTile", function() { return CustomTile; });
/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Tile.js */ "./node_modules/ol/Tile.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tileurlfunction.js */ "./node_modules/ol/tileurlfunction.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _net_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../net.js */ "./node_modules/ol/net.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _State_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./State.js */ "./node_modules/ol/source/State.js");
/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Tile.js */ "./node_modules/ol/source/Tile.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../tilegrid.js */ "./node_modules/ol/tilegrid.js");
/**
 * @module ol/source/UTFGrid
 */















/**
 * @typedef {Object} UTFGridJSON
 * @property {Array<string>} grid The grid.
 * @property {Array<string>} keys The keys.
 * @property {Object<string, Object>} [data] Optional data.
 */


var CustomTile = /*@__PURE__*/(function (Tile) {
  function CustomTile(tileCoord, state, src, extent, preemptive, jsonp) {

    Tile.call(this, tileCoord, state);

    /**
     * @private
     * @type {string}
     */
    this.src_ = src;

    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    this.extent_ = extent;

    /**
     * @private
     * @type {boolean}
     */
    this.preemptive_ = preemptive;

    /**
     * @private
     * @type {Array<string>}
     */
    this.grid_ = null;

    /**
     * @private
     * @type {Array<string>}
     */
    this.keys_ = null;

    /**
     * @private
     * @type {Object<string, Object>|undefined}
     */
    this.data_ = null;


    /**
     * @private
     * @type {boolean}
     */
    this.jsonp_ = jsonp;

  }

  if ( Tile ) CustomTile.__proto__ = Tile;
  CustomTile.prototype = Object.create( Tile && Tile.prototype );
  CustomTile.prototype.constructor = CustomTile;

  /**
   * Get the image element for this tile.
   * @return {HTMLImageElement} Image.
   */
  CustomTile.prototype.getImage = function getImage () {
    return null;
  };


  /**
   * Synchronously returns data at given coordinate (if available).
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {*} The data.
   */
  CustomTile.prototype.getData = function getData (coordinate) {
    if (!this.grid_ || !this.keys_) {
      return null;
    }
    var xRelative = (coordinate[0] - this.extent_[0]) /
        (this.extent_[2] - this.extent_[0]);
    var yRelative = (coordinate[1] - this.extent_[1]) /
        (this.extent_[3] - this.extent_[1]);

    var row = this.grid_[Math.floor((1 - yRelative) * this.grid_.length)];

    if (typeof row !== 'string') {
      return null;
    }

    var code = row.charCodeAt(Math.floor(xRelative * row.length));
    if (code >= 93) {
      code--;
    }
    if (code >= 35) {
      code--;
    }
    code -= 32;

    var data = null;
    if (code in this.keys_) {
      var id = this.keys_[code];
      if (this.data_ && id in this.data_) {
        data = this.data_[id];
      } else {
        data = id;
      }
    }
    return data;
  };


  /**
   * Calls the callback (synchronously by default) with the available data
   * for given coordinate (or `null` if not yet loaded).
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(this: T, *)} callback Callback.
   * @param {T=} opt_this The object to use as `this` in the callback.
   * @param {boolean=} opt_request If `true` the callback is always async.
   *                               The tile data is requested if not yet loaded.
   * @template T
   */
  CustomTile.prototype.forDataAtCoordinate = function forDataAtCoordinate (coordinate, callback, opt_this, opt_request) {
    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE && opt_request === true) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_4__["listenOnce"])(this, _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].CHANGE, function(e) {
        callback.call(opt_this, this.getData(coordinate));
      }, this);
      this.loadInternal_();
    } else {
      if (opt_request === true) {
        setTimeout(function() {
          callback.call(opt_this, this.getData(coordinate));
        }.bind(this), 0);
      } else {
        callback.call(opt_this, this.getData(coordinate));
      }
    }
  };


  /**
   * @inheritDoc
   */
  CustomTile.prototype.getKey = function getKey () {
    return this.src_;
  };


  /**
   * @private
   */
  CustomTile.prototype.handleError_ = function handleError_ () {
    this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR;
    this.changed();
  };


  /**
   * @param {!UTFGridJSON} json UTFGrid data.
   * @private
   */
  CustomTile.prototype.handleLoad_ = function handleLoad_ (json) {
    this.grid_ = json['grid'];
    this.keys_ = json['keys'];
    this.data_ = json['data'];

    this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].EMPTY;
    this.changed();
  };


  /**
   * @private
   */
  CustomTile.prototype.loadInternal_ = function loadInternal_ () {
    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING;
      if (this.jsonp_) {
        Object(_net_js__WEBPACK_IMPORTED_MODULE_7__["jsonp"])(this.src_, this.handleLoad_.bind(this),
          this.handleError_.bind(this));
      } else {
        var client = new XMLHttpRequest();
        client.addEventListener('load', this.onXHRLoad_.bind(this));
        client.addEventListener('error', this.onXHRError_.bind(this));
        client.open('GET', this.src_);
        client.send();
      }
    }
  };


  /**
   * @private
   * @param {Event} event The load event.
   */
  CustomTile.prototype.onXHRLoad_ = function onXHRLoad_ (event) {
    var client = /** @type {XMLHttpRequest} */ (event.target);
    // status will be 0 for file:// urls
    if (!client.status || client.status >= 200 && client.status < 300) {
      var response;
      try {
        response = /** @type {!UTFGridJSON} */(JSON.parse(client.responseText));
      } catch (err) {
        this.handleError_();
        return;
      }
      this.handleLoad_(response);
    } else {
      this.handleError_();
    }
  };


  /**
   * @private
   * @param {Event} event The error event.
   */
  CustomTile.prototype.onXHRError_ = function onXHRError_ (event) {
    this.handleError_();
  };


  /**
   * @override
   */
  CustomTile.prototype.load = function load () {
    if (this.preemptive_) {
      this.loadInternal_();
    }
  };

  return CustomTile;
}(_Tile_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/**
 * @typedef {Object} Options
 * @property {boolean} [preemptive=true]
 * If `true` the UTFGrid source loads the tiles based on their "visibility".
 * This improves the speed of response, but increases traffic.
 * Note that if set to `false`, you need to pass `true` as `opt_request`
 * to the `forDataAtCoordinateAndResolution` method otherwise no data
 * will ever be loaded.
 * @property {boolean} [jsonp=false] Use JSONP with callback to load the TileJSON.
 * Useful when the server does not support CORS..
 * @property {import("./TileJSON.js").Config} [tileJSON] TileJSON configuration for this source.
 * If not provided, `url` must be configured.
 * @property {string} [url] TileJSON endpoint that provides the configuration for this source.
 * Request will be made through JSONP. If not provided, `tileJSON` must be configured.
 */


/**
 * @classdesc
 * Layer source for UTFGrid interaction data loaded from TileJSON format.
 * @api
 */
var UTFGrid = /*@__PURE__*/(function (TileSource) {
  function UTFGrid(options) {
    TileSource.call(this, {
      projection: Object(_proj_js__WEBPACK_IMPORTED_MODULE_8__["get"])('EPSG:3857'),
      state: _State_js__WEBPACK_IMPORTED_MODULE_9__["default"].LOADING
    });

    /**
     * @private
     * @type {boolean}
     */
    this.preemptive_ = options.preemptive !== undefined ?
      options.preemptive : true;

    /**
     * @private
     * @type {!import("../Tile.js").UrlFunction}
     */
    this.tileUrlFunction_ = _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_2__["nullTileUrlFunction"];

    /**
     * @private
     * @type {string|undefined}
     */
    this.template_ = undefined;

    /**
     * @private
     * @type {boolean}
     */
    this.jsonp_ = options.jsonp || false;

    if (options.url) {
      if (this.jsonp_) {
        Object(_net_js__WEBPACK_IMPORTED_MODULE_7__["jsonp"])(options.url, this.handleTileJSONResponse.bind(this),
          this.handleTileJSONError.bind(this));
      } else {
        var client = new XMLHttpRequest();
        client.addEventListener('load', this.onXHRLoad_.bind(this));
        client.addEventListener('error', this.onXHRError_.bind(this));
        client.open('GET', options.url);
        client.send();
      }
    } else if (options.tileJSON) {
      this.handleTileJSONResponse(options.tileJSON);
    } else {
      Object(_asserts_js__WEBPACK_IMPORTED_MODULE_3__["assert"])(false, 51); // Either `url` or `tileJSON` options must be provided
    }

  }

  if ( TileSource ) UTFGrid.__proto__ = TileSource;
  UTFGrid.prototype = Object.create( TileSource && TileSource.prototype );
  UTFGrid.prototype.constructor = UTFGrid;


  /**
   * @private
   * @param {Event} event The load event.
   */
  UTFGrid.prototype.onXHRLoad_ = function onXHRLoad_ (event) {
    var client = /** @type {XMLHttpRequest} */ (event.target);
    // status will be 0 for file:// urls
    if (!client.status || client.status >= 200 && client.status < 300) {
      var response;
      try {
        response = /** @type {import("./TileJSON.js").Config} */(JSON.parse(client.responseText));
      } catch (err) {
        this.handleTileJSONError();
        return;
      }
      this.handleTileJSONResponse(response);
    } else {
      this.handleTileJSONError();
    }
  };


  /**
   * @private
   * @param {Event} event The error event.
   */
  UTFGrid.prototype.onXHRError_ = function onXHRError_ (event) {
    this.handleTileJSONError();
  };


  /**
   * Return the template from TileJSON.
   * @return {string|undefined} The template from TileJSON.
   * @api
   */
  UTFGrid.prototype.getTemplate = function getTemplate () {
    return this.template_;
  };


  /**
   * Calls the callback (synchronously by default) with the available data
   * for given coordinate and resolution (or `null` if not yet loaded or
   * in case of an error).
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {function(*)} callback Callback.
   * @param {boolean=} opt_request If `true` the callback is always async.
   *                               The tile data is requested if not yet loaded.
   * @api
   */
  UTFGrid.prototype.forDataAtCoordinateAndResolution = function forDataAtCoordinateAndResolution (
    coordinate, resolution, callback, opt_request) {
    if (this.tileGrid) {
      var tileCoord = this.tileGrid.getTileCoordForCoordAndResolution(
        coordinate, resolution);
      var tile = /** @type {!CustomTile} */(this.getTile(
        tileCoord[0], tileCoord[1], tileCoord[2], 1, this.getProjection()));
      tile.forDataAtCoordinate(coordinate, callback, null, opt_request);
    } else {
      if (opt_request === true) {
        setTimeout(function() {
          callback(null);
        }, 0);
      } else {
        callback(null);
      }
    }
  };


  /**
   * @protected
   */
  UTFGrid.prototype.handleTileJSONError = function handleTileJSONError () {
    this.setState(_State_js__WEBPACK_IMPORTED_MODULE_9__["default"].ERROR);
  };


  /**
   * TODO: very similar to ol/source/TileJSON#handleTileJSONResponse
   * @protected
   * @param {import("./TileJSON.js").Config} tileJSON Tile JSON.
   */
  UTFGrid.prototype.handleTileJSONResponse = function handleTileJSONResponse (tileJSON) {

    var epsg4326Projection = Object(_proj_js__WEBPACK_IMPORTED_MODULE_8__["get"])('EPSG:4326');

    var sourceProjection = this.getProjection();
    var extent;
    if (tileJSON['bounds'] !== undefined) {
      var transform = Object(_proj_js__WEBPACK_IMPORTED_MODULE_8__["getTransformFromProjections"])(
        epsg4326Projection, sourceProjection);
      extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_6__["applyTransform"])(tileJSON['bounds'], transform);
    }

    var minZoom = tileJSON['minzoom'] || 0;
    var maxZoom = tileJSON['maxzoom'] || 22;
    var tileGrid = Object(_tilegrid_js__WEBPACK_IMPORTED_MODULE_12__["createXYZ"])({
      extent: Object(_tilegrid_js__WEBPACK_IMPORTED_MODULE_12__["extentFromProjection"])(sourceProjection),
      maxZoom: maxZoom,
      minZoom: minZoom
    });
    this.tileGrid = tileGrid;

    this.template_ = tileJSON['template'];

    var grids = tileJSON['grids'];
    if (!grids) {
      this.setState(_State_js__WEBPACK_IMPORTED_MODULE_9__["default"].ERROR);
      return;
    }

    this.tileUrlFunction_ = Object(_tileurlfunction_js__WEBPACK_IMPORTED_MODULE_2__["createFromTemplates"])(grids, tileGrid);

    if (tileJSON['attribution'] !== undefined) {
      var attributionExtent = extent !== undefined ?
        extent : epsg4326Projection.getExtent();

      this.setAttributions(function(frameState) {
        if (Object(_extent_js__WEBPACK_IMPORTED_MODULE_6__["intersects"])(attributionExtent, frameState.extent)) {
          return [tileJSON['attribution']];
        }
        return null;
      });
    }

    this.setState(_State_js__WEBPACK_IMPORTED_MODULE_9__["default"].READY);

  };


  /**
   * @inheritDoc
   */
  UTFGrid.prototype.getTile = function getTile (z, x, y, pixelRatio, projection) {
    var tileCoordKey = Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_11__["getKeyZXY"])(z, x, y);
    if (this.tileCache.containsKey(tileCoordKey)) {
      return (
        /** @type {!import("../Tile.js").default} */ (this.tileCache.get(tileCoordKey))
      );
    } else {
      var tileCoord = [z, x, y];
      var urlTileCoord =
          this.getTileCoordForTileUrlFunction(tileCoord, projection);
      var tileUrl = this.tileUrlFunction_(urlTileCoord, pixelRatio, projection);
      var tile = new CustomTile(
        tileCoord,
        tileUrl !== undefined ? _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE : _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].EMPTY,
        tileUrl !== undefined ? tileUrl : '',
        this.tileGrid.getTileCoordExtent(tileCoord),
        this.preemptive_,
        this.jsonp_);
      this.tileCache.set(tileCoordKey, tile);
      return tile;
    }
  };


  /**
   * @inheritDoc
   */
  UTFGrid.prototype.useTile = function useTile (z, x, y) {
    var tileCoordKey = Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_11__["getKeyZXY"])(z, x, y);
    if (this.tileCache.containsKey(tileCoordKey)) {
      this.tileCache.get(tileCoordKey);
    }
  };

  return UTFGrid;
}(_Tile_js__WEBPACK_IMPORTED_MODULE_10__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (UTFGrid);

//# sourceMappingURL=UTFGrid.js.map

/***/ }),

/***/ "./node_modules/ol/source/UrlTile.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/source/UrlTile.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tileurlfunction.js */ "./node_modules/ol/tileurlfunction.js");
/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Tile.js */ "./node_modules/ol/source/Tile.js");
/* harmony import */ var _TileEventType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./TileEventType.js */ "./node_modules/ol/source/TileEventType.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");
/**
 * @module ol/source/UrlTile
 */







/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions]
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize]
 * @property {boolean} [opaque]
 * @property {import("../proj.js").ProjectionLike} [projection]
 * @property {import("./State.js").default} [state]
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid]
 * @property {import("../Tile.js").LoadFunction} tileLoadFunction
 * @property {number} [tilePixelRatio]
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction]
 * @property {string} [url]
 * @property {Array<string>} [urls]
 * @property {boolean} [wrapX=true]
 * @property {number} [transition]
 * @property {string} [key]
 */


/**
 * @classdesc
 * Base class for sources providing tiles divided into a tile grid over http.
 *
 * @fires import("./Tile.js").TileSourceEvent
 */
var UrlTile = /*@__PURE__*/(function (TileSource) {
  function UrlTile(options) {

    TileSource.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      opaque: options.opaque,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tilePixelRatio: options.tilePixelRatio,
      wrapX: options.wrapX,
      transition: options.transition,
      key: options.key,
      attributionsCollapsible: options.attributionsCollapsible
    });

    /**
     * @private
     * @type {boolean}
     */
    this.generateTileUrlFunction_ = !options.tileUrlFunction;

    /**
     * @protected
     * @type {import("../Tile.js").LoadFunction}
     */
    this.tileLoadFunction = options.tileLoadFunction;

    /**
     * @protected
     * @type {import("../Tile.js").UrlFunction}
     */
    this.tileUrlFunction = options.tileUrlFunction ? options.tileUrlFunction.bind(this) : _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_2__["nullTileUrlFunction"];

    /**
     * @protected
     * @type {!Array<string>|null}
     */
    this.urls = null;

    if (options.urls) {
      this.setUrls(options.urls);
    } else if (options.url) {
      this.setUrl(options.url);
    }

    if (options.tileUrlFunction) {
      this.setTileUrlFunction(options.tileUrlFunction, this.key_);
    }

    /**
     * @private
     * @type {!Object<string, boolean>}
     */
    this.tileLoadingKeys_ = {};

  }

  if ( TileSource ) UrlTile.__proto__ = TileSource;
  UrlTile.prototype = Object.create( TileSource && TileSource.prototype );
  UrlTile.prototype.constructor = UrlTile;

  /**
   * Return the tile load function of the source.
   * @return {import("../Tile.js").LoadFunction} TileLoadFunction
   * @api
   */
  UrlTile.prototype.getTileLoadFunction = function getTileLoadFunction () {
    return this.tileLoadFunction;
  };

  /**
   * Return the tile URL function of the source.
   * @return {import("../Tile.js").UrlFunction} TileUrlFunction
   * @api
   */
  UrlTile.prototype.getTileUrlFunction = function getTileUrlFunction () {
    return this.tileUrlFunction;
  };

  /**
   * Return the URLs used for this source.
   * When a tileUrlFunction is used instead of url or urls,
   * null will be returned.
   * @return {!Array<string>|null} URLs.
   * @api
   */
  UrlTile.prototype.getUrls = function getUrls () {
    return this.urls;
  };

  /**
   * Handle tile change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */
  UrlTile.prototype.handleTileChange = function handleTileChange (event) {
    var tile = /** @type {import("../Tile.js").default} */ (event.target);
    var uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(tile);
    var tileState = tile.getState();
    var type;
    if (tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING) {
      this.tileLoadingKeys_[uid] = true;
      type = _TileEventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].TILELOADSTART;
    } else if (uid in this.tileLoadingKeys_) {
      delete this.tileLoadingKeys_[uid];
      type = tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR ? _TileEventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].TILELOADERROR :
        (tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED || tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ABORT) ?
          _TileEventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].TILELOADEND : undefined;
    }
    if (type != undefined) {
      this.dispatchEvent(new _Tile_js__WEBPACK_IMPORTED_MODULE_3__["TileSourceEvent"](type, tile));
    }
  };

  /**
   * Set the tile load function of the source.
   * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @api
   */
  UrlTile.prototype.setTileLoadFunction = function setTileLoadFunction (tileLoadFunction) {
    this.tileCache.clear();
    this.tileLoadFunction = tileLoadFunction;
    this.changed();
  };

  /**
   * Set the tile URL function of the source.
   * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
   * @param {string=} key Optional new tile key for the source.
   * @api
   */
  UrlTile.prototype.setTileUrlFunction = function setTileUrlFunction (tileUrlFunction, key) {
    this.tileUrlFunction = tileUrlFunction;
    this.tileCache.pruneExceptNewestZ();
    if (typeof key !== 'undefined') {
      this.setKey(key);
    } else {
      this.changed();
    }
  };

  /**
   * Set the URL to use for requests.
   * @param {string} url URL.
   * @api
   */
  UrlTile.prototype.setUrl = function setUrl (url) {
    var urls = this.urls = Object(_tileurlfunction_js__WEBPACK_IMPORTED_MODULE_2__["expandUrl"])(url);
    this.setUrls(urls);
  };

  /**
   * Set the URLs to use for requests.
   * @param {Array<string>} urls URLs.
   * @api
   */
  UrlTile.prototype.setUrls = function setUrls (urls) {
    this.urls = urls;
    var key = urls.join('\n');
    if (this.generateTileUrlFunction_) {
      this.setTileUrlFunction(Object(_tileurlfunction_js__WEBPACK_IMPORTED_MODULE_2__["createFromTemplates"])(urls, this.tileGrid), key);
    } else {
      this.setKey(key);
    }
  };

  /**
   * @inheritDoc
   */
  UrlTile.prototype.useTile = function useTile (z, x, y) {
    var tileCoordKey = Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_5__["getKeyZXY"])(z, x, y);
    if (this.tileCache.containsKey(tileCoordKey)) {
      this.tileCache.get(tileCoordKey);
    }
  };

  return UrlTile;
}(_Tile_js__WEBPACK_IMPORTED_MODULE_3__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (UrlTile);

//# sourceMappingURL=UrlTile.js.map

/***/ }),

/***/ "./node_modules/ol/source/Vector.js":
/*!******************************************!*\
  !*** ./node_modules/ol/source/Vector.js ***!
  \******************************************/
/*! exports provided: VectorSourceEvent, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VectorSourceEvent", function() { return VectorSourceEvent; });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Collection.js */ "./node_modules/ol/Collection.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../CollectionEventType.js */ "./node_modules/ol/CollectionEventType.js");
/* harmony import */ var _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ObjectEventType.js */ "./node_modules/ol/ObjectEventType.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _featureloader_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../featureloader.js */ "./node_modules/ol/featureloader.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _loadingstrategy_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../loadingstrategy.js */ "./node_modules/ol/loadingstrategy.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _Source_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Source.js */ "./node_modules/ol/source/Source.js");
/* harmony import */ var _State_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./State.js */ "./node_modules/ol/source/State.js");
/* harmony import */ var _VectorEventType_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./VectorEventType.js */ "./node_modules/ol/source/VectorEventType.js");
/* harmony import */ var _structs_RBush_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../structs/RBush.js */ "./node_modules/ol/structs/RBush.js");
/**
 * @module ol/source/Vector
 */




















/**
 * A function that takes an {@link module:ol/extent~Extent} and a resolution as arguments, and
 * returns an array of {@link module:ol/extent~Extent} with the extents to load. Usually this
 * is one of the standard {@link module:ol/loadingstrategy} strategies.
 *
 * @typedef {function(import("../extent.js").Extent, number): Array<import("../extent.js").Extent>} LoadingStrategy
 * @api
 */


/**
 * @classdesc
 * Events emitted by {@link module:ol/source/Vector} instances are instances of this
 * type.
 */
var VectorSourceEvent = /*@__PURE__*/(function (Event) {
  function VectorSourceEvent(type, opt_feature) {

    Event.call(this, type);

    /**
     * The feature being added or removed.
     * @type {import("../Feature.js").default|undefined}
     * @api
     */
    this.feature = opt_feature;

  }

  if ( Event ) VectorSourceEvent.__proto__ = Event;
  VectorSourceEvent.prototype = Object.create( Event && Event.prototype );
  VectorSourceEvent.prototype.constructor = VectorSourceEvent;

  return VectorSourceEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_7__["default"]));


/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {Array<import("../Feature.js").default>|Collection<import("../Feature.js").default>} [features]
 * Features. If provided as {@link module:ol/Collection}, the features in the source
 * and the collection will stay in sync.
 * @property {import("../format/Feature.js").default} [format] The feature format used by the XHR
 * feature loader when `url` is set. Required if `url` is set, otherwise ignored.
 * @property {import("../featureloader.js").FeatureLoader} [loader]
 * The loader function used to load features, from a remote source for example.
 * If this is not set and `url` is set, the source will create and use an XHR
 * feature loader.
 *
 * Example:
 *
 * ```js
 * import {Vector} from 'ol/source';
 * import {GeoJSON} from 'ol/format';
 * import {bbox} from 'ol/loadingstrategy';
 *
 * var vectorSource = new Vector({
 *   format: new GeoJSON(),
 *   loader: function(extent, resolution, projection) {
 *      var proj = projection.getCode();
 *      var url = 'https://ahocevar.com/geoserver/wfs?service=WFS&' +
 *          'version=1.1.0&request=GetFeature&typename=osm:water_areas&' +
 *          'outputFormat=application/json&srsname=' + proj + '&' +
 *          'bbox=' + extent.join(',') + ',' + proj;
 *      var xhr = new XMLHttpRequest();
 *      xhr.open('GET', url);
 *      var onError = function() {
 *        vectorSource.removeLoadedExtent(extent);
 *      }
 *      xhr.onerror = onError;
 *      xhr.onload = function() {
 *        if (xhr.status == 200) {
 *          vectorSource.addFeatures(
 *              vectorSource.getFormat().readFeatures(xhr.responseText));
 *        } else {
 *          onError();
 *        }
 *      }
 *      xhr.send();
 *    },
 *    strategy: bbox
 *  });
 * ```
 * @property {boolean} [overlaps=true] This source may have overlapping geometries.
 * Setting this to `false` (e.g. for sources with polygons that represent administrative
 * boundaries or TopoJSON sources) allows the renderer to optimise fill and
 * stroke operations.
 * @property {LoadingStrategy} [strategy] The loading strategy to use.
 * By default an {@link module:ol/loadingstrategy~all}
 * strategy is used, a one-off strategy which loads all features at once.
 * @property {string|import("../featureloader.js").FeatureUrlFunction} [url]
 * Setting this option instructs the source to load features using an XHR loader
 * (see {@link module:ol/featureloader~xhr}). Use a `string` and an
 * {@link module:ol/loadingstrategy~all} for a one-off download of all features from
 * the given URL. Use a {@link module:ol/featureloader~FeatureUrlFunction} to generate the url with
 * other loading strategies.
 * Requires `format` to be set as well.
 * When default XHR feature loader is provided, the features will
 * be transformed from the data projection to the view projection
 * during parsing. If your remote data source does not advertise its projection
 * properly, this transformation will be incorrect. For some formats, the
 * default projection (usually EPSG:4326) can be overridden by setting the
 * dataProjection constructor option on the format.
 * Note that if a source contains non-feature data, such as a GeoJSON geometry
 * or a KML NetworkLink, these will be ignored. Use a custom loader to load these.
 * @property {boolean} [useSpatialIndex=true]
 * By default, an RTree is used as spatial index. When features are removed and
 * added frequently, and the total number of features is low, setting this to
 * `false` may improve performance.
 *
 * Note that
 * {@link module:ol/source/Vector~VectorSource#getFeaturesInExtent},
 * {@link module:ol/source/Vector~VectorSource#getClosestFeatureToCoordinate} and
 * {@link module:ol/source/Vector~VectorSource#getExtent} cannot be used when `useSpatialIndex` is
 * set to `false`, and {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent} will loop
 * through all features.
 *
 * When set to `false`, the features will be maintained in an
 * {@link module:ol/Collection}, which can be retrieved through
 * {@link module:ol/source/Vector~VectorSource#getFeaturesCollection}.
 * @property {boolean} [wrapX=true] Wrap the world horizontally. For vector editing across the
 * -180° and 180° meridians to work properly, this should be set to `false`. The
 * resulting geometry coordinates will then exceed the world bounds.
 */


/**
 * @classdesc
 * Provides a source of features for vector layers. Vector features provided
 * by this source are suitable for editing. See {@link module:ol/source/VectorTile~VectorTile} for
 * vector data that is optimized for rendering.
 *
 * @fires ol/source/Vector.VectorSourceEvent
 * @api
 */
var VectorSource = /*@__PURE__*/(function (Source) {
  function VectorSource(opt_options) {

    var options = opt_options || {};

    Source.call(this, {
      attributions: options.attributions,
      projection: undefined,
      state: _State_js__WEBPACK_IMPORTED_MODULE_15__["default"].READY,
      wrapX: options.wrapX !== undefined ? options.wrapX : true
    });

    /**
     * @private
     * @type {import("../featureloader.js").FeatureLoader}
     */
    this.loader_ = _functions_js__WEBPACK_IMPORTED_MODULE_11__["VOID"];

    /**
     * @private
     * @type {import("../format/Feature.js").default|undefined}
     */
    this.format_ = options.format;

    /**
     * @private
     * @type {boolean}
     */
    this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;

    /**
     * @private
     * @type {string|import("../featureloader.js").FeatureUrlFunction|undefined}
     */
    this.url_ = options.url;

    if (options.loader !== undefined) {
      this.loader_ = options.loader;
    } else if (this.url_ !== undefined) {
      Object(_asserts_js__WEBPACK_IMPORTED_MODULE_5__["assert"])(this.format_, 7); // `format` must be set when `url` is set
      // create a XHR feature loader for "url" and "format"
      this.loader_ = Object(_featureloader_js__WEBPACK_IMPORTED_MODULE_10__["xhr"])(this.url_, /** @type {import("../format/Feature.js").default} */ (this.format_));
    }

    /**
     * @private
     * @type {LoadingStrategy}
     */
    this.strategy_ = options.strategy !== undefined ? options.strategy : _loadingstrategy_js__WEBPACK_IMPORTED_MODULE_12__["all"];

    var useSpatialIndex =
        options.useSpatialIndex !== undefined ? options.useSpatialIndex : true;

    /**
     * @private
     * @type {RBush<import("../Feature.js").default>}
     */
    this.featuresRtree_ = useSpatialIndex ? new _structs_RBush_js__WEBPACK_IMPORTED_MODULE_17__["default"]() : null;

    /**
     * @private
     * @type {RBush<{extent: import("../extent.js").Extent}>}
     */
    this.loadedExtentsRtree_ = new _structs_RBush_js__WEBPACK_IMPORTED_MODULE_17__["default"]();

    /**
     * @private
     * @type {!Object<string, import("../Feature.js").default>}
     */
    this.nullGeometryFeatures_ = {};

    /**
     * A lookup of features by id (the return from feature.getId()).
     * @private
     * @type {!Object<string, import("../Feature.js").default>}
     */
    this.idIndex_ = {};

    /**
     * A lookup of features without id (keyed by getUid(feature)).
     * @private
     * @type {!Object<string, import("../Feature.js").default>}
     */
    this.undefIdIndex_ = {};

    /**
     * @private
     * @type {Object<string, Array<import("../events.js").EventsKey>>}
     */
    this.featureChangeKeys_ = {};

    /**
     * @private
     * @type {Collection<import("../Feature.js").default>}
     */
    this.featuresCollection_ = null;

    var collection, features;
    if (Array.isArray(options.features)) {
      features = options.features;
    } else if (options.features) {
      collection = options.features;
      features = collection.getArray();
    }
    if (!useSpatialIndex && collection === undefined) {
      collection = new _Collection_js__WEBPACK_IMPORTED_MODULE_1__["default"](features);
    }
    if (features !== undefined) {
      this.addFeaturesInternal(features);
    }
    if (collection !== undefined) {
      this.bindFeaturesCollection_(collection);
    }

  }

  if ( Source ) VectorSource.__proto__ = Source;
  VectorSource.prototype = Object.create( Source && Source.prototype );
  VectorSource.prototype.constructor = VectorSource;

  /**
   * Add a single feature to the source.  If you want to add a batch of features
   * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
   * instead. A feature will not be added to the source if feature with
   * the same id is already there. The reason for this behavior is to avoid
   * feature duplication when using bbox or tile loading strategies.
   * @param {import("../Feature.js").default} feature Feature to add.
   * @api
   */
  VectorSource.prototype.addFeature = function addFeature (feature) {
    this.addFeatureInternal(feature);
    this.changed();
  };


  /**
   * Add a feature without firing a `change` event.
   * @param {import("../Feature.js").default} feature Feature.
   * @protected
   */
  VectorSource.prototype.addFeatureInternal = function addFeatureInternal (feature) {
    var featureKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature);

    if (!this.addToIndex_(featureKey, feature)) {
      return;
    }

    this.setupChangeEvents_(featureKey, feature);

    var geometry = feature.getGeometry();
    if (geometry) {
      var extent = geometry.getExtent();
      if (this.featuresRtree_) {
        this.featuresRtree_.insert(extent, feature);
      }
    } else {
      this.nullGeometryFeatures_[featureKey] = feature;
    }

    this.dispatchEvent(
      new VectorSourceEvent(_VectorEventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].ADDFEATURE, feature));
  };


  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {import("../Feature.js").default} feature The feature.
   * @private
   */
  VectorSource.prototype.setupChangeEvents_ = function setupChangeEvents_ (featureKey, feature) {
    this.featureChangeKeys_[featureKey] = [
      Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(feature, _events_EventType_js__WEBPACK_IMPORTED_MODULE_8__["default"].CHANGE,
        this.handleFeatureChange_, this),
      Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(feature, _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].PROPERTYCHANGE,
        this.handleFeatureChange_, this)
    ];
  };


  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {import("../Feature.js").default} feature The feature.
   * @return {boolean} The feature is "valid", in the sense that it is also a
   *     candidate for insertion into the Rtree.
   * @private
   */
  VectorSource.prototype.addToIndex_ = function addToIndex_ (featureKey, feature) {
    var valid = true;
    var id = feature.getId();
    if (id !== undefined) {
      if (!(id.toString() in this.idIndex_)) {
        this.idIndex_[id.toString()] = feature;
      } else {
        valid = false;
      }
    } else {
      Object(_asserts_js__WEBPACK_IMPORTED_MODULE_5__["assert"])(!(featureKey in this.undefIdIndex_),
        30); // The passed `feature` was already added to the source
      this.undefIdIndex_[featureKey] = feature;
    }
    return valid;
  };


  /**
   * Add a batch of features to the source.
   * @param {Array<import("../Feature.js").default>} features Features to add.
   * @api
   */
  VectorSource.prototype.addFeatures = function addFeatures (features) {
    this.addFeaturesInternal(features);
    this.changed();
  };


  /**
   * Add features without firing a `change` event.
   * @param {Array<import("../Feature.js").default>} features Features.
   * @protected
   */
  VectorSource.prototype.addFeaturesInternal = function addFeaturesInternal (features) {
    var extents = [];
    var newFeatures = [];
    var geometryFeatures = [];

    for (var i = 0, length = features.length; i < length; i++) {
      var feature = features[i];
      var featureKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature);
      if (this.addToIndex_(featureKey, feature)) {
        newFeatures.push(feature);
      }
    }

    for (var i$1 = 0, length$1 = newFeatures.length; i$1 < length$1; i$1++) {
      var feature$1 = newFeatures[i$1];
      var featureKey$1 = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature$1);
      this.setupChangeEvents_(featureKey$1, feature$1);

      var geometry = feature$1.getGeometry();
      if (geometry) {
        var extent = geometry.getExtent();
        extents.push(extent);
        geometryFeatures.push(feature$1);
      } else {
        this.nullGeometryFeatures_[featureKey$1] = feature$1;
      }
    }
    if (this.featuresRtree_) {
      this.featuresRtree_.load(extents, geometryFeatures);
    }

    for (var i$2 = 0, length$2 = newFeatures.length; i$2 < length$2; i$2++) {
      this.dispatchEvent(new VectorSourceEvent(_VectorEventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].ADDFEATURE, newFeatures[i$2]));
    }
  };


  /**
   * @param {!Collection<import("../Feature.js").default>} collection Collection.
   * @private
   */
  VectorSource.prototype.bindFeaturesCollection_ = function bindFeaturesCollection_ (collection) {
    var modifyingCollection = false;
    Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(this, _VectorEventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].ADDFEATURE,
      /**
       * @param {VectorSourceEvent} evt The vector source event
       */
      function(evt) {
        if (!modifyingCollection) {
          modifyingCollection = true;
          collection.push(evt.feature);
          modifyingCollection = false;
        }
      });
    Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(this, _VectorEventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].REMOVEFEATURE,
      /**
       * @param {VectorSourceEvent} evt The vector source event
       */
      function(evt) {
        if (!modifyingCollection) {
          modifyingCollection = true;
          collection.remove(evt.feature);
          modifyingCollection = false;
        }
      });
    Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(collection, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].ADD,
      /**
       * @param {import("../Collection.js").CollectionEvent} evt The collection event
       */
      function(evt) {
        if (!modifyingCollection) {
          modifyingCollection = true;
          this.addFeature(/** @type {import("../Feature.js").default} */ (evt.element));
          modifyingCollection = false;
        }
      }, this);
    Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(collection, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].REMOVE,
      /**
       * @param {import("../Collection.js").CollectionEvent} evt The collection event
       */
      function(evt) {
        if (!modifyingCollection) {
          modifyingCollection = true;
          this.removeFeature(/** @type {import("../Feature.js").default} */ (evt.element));
          modifyingCollection = false;
        }
      }, this);
    this.featuresCollection_ = collection;
  };


  /**
   * Remove all features from the source.
   * @param {boolean=} opt_fast Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#removefeature} events.
   * @api
   */
  VectorSource.prototype.clear = function clear (opt_fast) {
    if (opt_fast) {
      for (var featureId in this.featureChangeKeys_) {
        var keys = this.featureChangeKeys_[featureId];
        keys.forEach(_events_js__WEBPACK_IMPORTED_MODULE_6__["unlistenByKey"]);
      }
      if (!this.featuresCollection_) {
        this.featureChangeKeys_ = {};
        this.idIndex_ = {};
        this.undefIdIndex_ = {};
      }
    } else {
      if (this.featuresRtree_) {
        this.featuresRtree_.forEach(this.removeFeatureInternal, this);
        for (var id in this.nullGeometryFeatures_) {
          this.removeFeatureInternal(this.nullGeometryFeatures_[id]);
        }
      }
    }
    if (this.featuresCollection_) {
      this.featuresCollection_.clear();
    }

    if (this.featuresRtree_) {
      this.featuresRtree_.clear();
    }
    this.loadedExtentsRtree_.clear();
    this.nullGeometryFeatures_ = {};

    var clearEvent = new VectorSourceEvent(_VectorEventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].CLEAR);
    this.dispatchEvent(clearEvent);
    this.changed();
  };


  /**
   * Iterate through all features on the source, calling the provided callback
   * with each one.  If the callback returns any "truthy" value, iteration will
   * stop and the function will return the same value.
   * Note: this function only iterate through the feature that have a defined geometry.
   *
   * @param {function(import("../Feature.js").default): T} callback Called with each feature
   *     on the source.  Return a truthy value to stop iteration.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  VectorSource.prototype.forEachFeature = function forEachFeature (callback) {
    if (this.featuresRtree_) {
      return this.featuresRtree_.forEach(callback);
    } else if (this.featuresCollection_) {
      this.featuresCollection_.forEach(callback);
    }
  };


  /**
   * Iterate through all features whose geometries contain the provided
   * coordinate, calling the callback with each feature.  If the callback returns
   * a "truthy" value, iteration will stop and the function will return the same
   * value.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(import("../Feature.js").default): T} callback Called with each feature
   *     whose goemetry contains the provided coordinate.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   */
  VectorSource.prototype.forEachFeatureAtCoordinateDirect = function forEachFeatureAtCoordinateDirect (coordinate, callback) {
    var extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];
    return this.forEachFeatureInExtent(extent, function(feature) {
      var geometry = feature.getGeometry();
      if (geometry.intersectsCoordinate(coordinate)) {
        return callback(feature);
      } else {
        return undefined;
      }
    });
  };


  /**
   * Iterate through all features whose bounding box intersects the provided
   * extent (note that the feature's geometry may not intersect the extent),
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you are interested in features whose geometry intersects an extent, call
   * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
   *
   * When `useSpatialIndex` is set to false, this method will loop through all
   * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(import("../Feature.js").default): T} callback Called with each feature
   *     whose bounding box intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  VectorSource.prototype.forEachFeatureInExtent = function forEachFeatureInExtent (extent, callback) {
    if (this.featuresRtree_) {
      return this.featuresRtree_.forEachInExtent(extent, callback);
    } else if (this.featuresCollection_) {
      this.featuresCollection_.forEach(callback);
    }
  };


  /**
   * Iterate through all features whose geometry intersects the provided extent,
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you only want to test for bounding box intersection, call the
   * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(import("../Feature.js").default): T} callback Called with each feature
   *     whose geometry intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  VectorSource.prototype.forEachFeatureIntersectingExtent = function forEachFeatureIntersectingExtent (extent, callback) {
    return this.forEachFeatureInExtent(extent,
      /**
       * @param {import("../Feature.js").default} feature Feature.
       * @return {T|undefined} The return value from the last call to the callback.
       */
      function(feature) {
        var geometry = feature.getGeometry();
        if (geometry.intersectsExtent(extent)) {
          var result = callback(feature);
          if (result) {
            return result;
          }
        }
      });
  };


  /**
   * Get the features collection associated with this source. Will be `null`
   * unless the source was configured with `useSpatialIndex` set to `false`, or
   * with an {@link module:ol/Collection} as `features`.
   * @return {Collection<import("../Feature.js").default>} The collection of features.
   * @api
   */
  VectorSource.prototype.getFeaturesCollection = function getFeaturesCollection () {
    return this.featuresCollection_;
  };


  /**
   * Get all features on the source in random order.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */
  VectorSource.prototype.getFeatures = function getFeatures () {
    var features;
    if (this.featuresCollection_) {
      features = this.featuresCollection_.getArray();
    } else if (this.featuresRtree_) {
      features = this.featuresRtree_.getAll();
      if (!Object(_obj_js__WEBPACK_IMPORTED_MODULE_13__["isEmpty"])(this.nullGeometryFeatures_)) {
        Object(_array_js__WEBPACK_IMPORTED_MODULE_4__["extend"])(features, Object(_obj_js__WEBPACK_IMPORTED_MODULE_13__["getValues"])(this.nullGeometryFeatures_));
      }
    }
    return (
      /** @type {Array<import("../Feature.js").default>} */ (features)
    );
  };


  /**
   * Get all features whose geometry intersects the provided coordinate.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */
  VectorSource.prototype.getFeaturesAtCoordinate = function getFeaturesAtCoordinate (coordinate) {
    var features = [];
    this.forEachFeatureAtCoordinateDirect(coordinate, function(feature) {
      features.push(feature);
    });
    return features;
  };


  /**
   * Get all features in the provided extent.  Note that this returns an array of
   * all features intersecting the given extent in random order (so it may include
   * features whose geometries do not intersect the extent).
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */
  VectorSource.prototype.getFeaturesInExtent = function getFeaturesInExtent (extent) {
    return this.featuresRtree_.getInExtent(extent);
  };


  /**
   * Get the closest feature to the provided coordinate.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(import("../Feature.js").default):boolean=} opt_filter Feature filter function.
   *     The filter function will receive one argument, the {@link module:ol/Feature feature}
   *     and it should return a boolean value. By default, no filtering is made.
   * @return {import("../Feature.js").default} Closest feature.
   * @api
   */
  VectorSource.prototype.getClosestFeatureToCoordinate = function getClosestFeatureToCoordinate (coordinate, opt_filter) {
    // Find the closest feature using branch and bound.  We start searching an
    // infinite extent, and find the distance from the first feature found.  This
    // becomes the closest feature.  We then compute a smaller extent which any
    // closer feature must intersect.  We continue searching with this smaller
    // extent, trying to find a closer feature.  Every time we find a closer
    // feature, we update the extent being searched so that any even closer
    // feature must intersect it.  We continue until we run out of features.
    var x = coordinate[0];
    var y = coordinate[1];
    var closestFeature = null;
    var closestPoint = [NaN, NaN];
    var minSquaredDistance = Infinity;
    var extent = [-Infinity, -Infinity, Infinity, Infinity];
    var filter = opt_filter ? opt_filter : _functions_js__WEBPACK_IMPORTED_MODULE_11__["TRUE"];
    this.featuresRtree_.forEachInExtent(extent,
      /**
       * @param {import("../Feature.js").default} feature Feature.
       */
      function(feature) {
        if (filter(feature)) {
          var geometry = feature.getGeometry();
          var previousMinSquaredDistance = minSquaredDistance;
          minSquaredDistance = geometry.closestPointXY(
            x, y, closestPoint, minSquaredDistance);
          if (minSquaredDistance < previousMinSquaredDistance) {
            closestFeature = feature;
            // This is sneaky.  Reduce the extent that it is currently being
            // searched while the R-Tree traversal using this same extent object
            // is still in progress.  This is safe because the new extent is
            // strictly contained by the old extent.
            var minDistance = Math.sqrt(minSquaredDistance);
            extent[0] = x - minDistance;
            extent[1] = y - minDistance;
            extent[2] = x + minDistance;
            extent[3] = y + minDistance;
          }
        }
      });
    return closestFeature;
  };


  /**
   * Get the extent of the features currently in the source.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../extent.js").Extent=} opt_extent Destination extent. If provided, no new extent
   *     will be created. Instead, that extent's coordinates will be overwritten.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  VectorSource.prototype.getExtent = function getExtent (opt_extent) {
    return this.featuresRtree_.getExtent(opt_extent);
  };


  /**
   * Get a feature by its identifier (the value returned by feature.getId()).
   * Note that the index treats string and numeric identifiers as the same.  So
   * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
   *
   * @param {string|number} id Feature identifier.
   * @return {import("../Feature.js").default} The feature (or `null` if not found).
   * @api
   */
  VectorSource.prototype.getFeatureById = function getFeatureById (id) {
    var feature = this.idIndex_[id.toString()];
    return feature !== undefined ? feature : null;
  };


  /**
   * Get the format associated with this source.
   *
   * @return {import("../format/Feature.js").default|undefined} The feature format.
   * @api
   */
  VectorSource.prototype.getFormat = function getFormat () {
    return this.format_;
  };


  /**
   * @return {boolean} The source can have overlapping geometries.
   */
  VectorSource.prototype.getOverlaps = function getOverlaps () {
    return this.overlaps_;
  };


  /**
   * Get the url associated with this source.
   *
   * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
   * @api
   */
  VectorSource.prototype.getUrl = function getUrl () {
    return this.url_;
  };


  /**
   * @param {Event} event Event.
   * @private
   */
  VectorSource.prototype.handleFeatureChange_ = function handleFeatureChange_ (event) {
    var feature = /** @type {import("../Feature.js").default} */ (event.target);
    var featureKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature);
    var geometry = feature.getGeometry();
    if (!geometry) {
      if (!(featureKey in this.nullGeometryFeatures_)) {
        if (this.featuresRtree_) {
          this.featuresRtree_.remove(feature);
        }
        this.nullGeometryFeatures_[featureKey] = feature;
      }
    } else {
      var extent = geometry.getExtent();
      if (featureKey in this.nullGeometryFeatures_) {
        delete this.nullGeometryFeatures_[featureKey];
        if (this.featuresRtree_) {
          this.featuresRtree_.insert(extent, feature);
        }
      } else {
        if (this.featuresRtree_) {
          this.featuresRtree_.update(extent, feature);
        }
      }
    }
    var id = feature.getId();
    if (id !== undefined) {
      var sid = id.toString();
      if (featureKey in this.undefIdIndex_) {
        delete this.undefIdIndex_[featureKey];
        this.idIndex_[sid] = feature;
      } else {
        if (this.idIndex_[sid] !== feature) {
          this.removeFromIdIndex_(feature);
          this.idIndex_[sid] = feature;
        }
      }
    } else {
      if (!(featureKey in this.undefIdIndex_)) {
        this.removeFromIdIndex_(feature);
        this.undefIdIndex_[featureKey] = feature;
      }
    }
    this.changed();
    this.dispatchEvent(new VectorSourceEvent(
      _VectorEventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].CHANGEFEATURE, feature));
  };

  /**
   * Returns true if the feature is contained within the source.
   * @param {import("../Feature.js").default} feature Feature.
   * @return {boolean} Has feature.
   * @api
   */
  VectorSource.prototype.hasFeature = function hasFeature (feature) {
    var id = feature.getId();
    if (id !== undefined) {
      return id in this.idIndex_;
    } else {
      return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature) in this.undefIdIndex_;
    }
  };

  /**
   * @return {boolean} Is empty.
   */
  VectorSource.prototype.isEmpty = function isEmpty$1 () {
    return this.featuresRtree_.isEmpty() && Object(_obj_js__WEBPACK_IMPORTED_MODULE_13__["isEmpty"])(this.nullGeometryFeatures_);
  };


  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  VectorSource.prototype.loadFeatures = function loadFeatures (extent, resolution, projection) {
    var this$1 = this;

    var loadedExtentsRtree = this.loadedExtentsRtree_;
    var extentsToLoad = this.strategy_(extent, resolution);
    this.loading = false;
    var loop = function ( i, ii ) {
      var extentToLoad = extentsToLoad[i];
      var alreadyLoaded = loadedExtentsRtree.forEachInExtent(extentToLoad,
        /**
         * @param {{extent: import("../extent.js").Extent}} object Object.
         * @return {boolean} Contains.
         */
        function(object) {
          return Object(_extent_js__WEBPACK_IMPORTED_MODULE_9__["containsExtent"])(object.extent, extentToLoad);
        });
      if (!alreadyLoaded) {
        this$1.loader_.call(this$1, extentToLoad, resolution, projection);
        loadedExtentsRtree.insert(extentToLoad, {extent: extentToLoad.slice()});
        this$1.loading = this$1.loader_ !== _functions_js__WEBPACK_IMPORTED_MODULE_11__["VOID"];
      }
    };

    for (var i = 0, ii = extentsToLoad.length; i < ii; ++i) loop( i, ii );
  };


  /**
   * Remove an extent from the list of loaded extents.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  VectorSource.prototype.removeLoadedExtent = function removeLoadedExtent (extent) {
    var loadedExtentsRtree = this.loadedExtentsRtree_;
    var obj;
    loadedExtentsRtree.forEachInExtent(extent, function(object) {
      if (Object(_extent_js__WEBPACK_IMPORTED_MODULE_9__["equals"])(object.extent, extent)) {
        obj = object;
        return true;
      }
    });
    if (obj) {
      loadedExtentsRtree.remove(obj);
    }
  };


  /**
   * Remove a single feature from the source.  If you want to remove all features
   * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
   * instead.
   * @param {import("../Feature.js").default} feature Feature to remove.
   * @api
   */
  VectorSource.prototype.removeFeature = function removeFeature (feature) {
    var featureKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature);
    if (featureKey in this.nullGeometryFeatures_) {
      delete this.nullGeometryFeatures_[featureKey];
    } else {
      if (this.featuresRtree_) {
        this.featuresRtree_.remove(feature);
      }
    }
    this.removeFeatureInternal(feature);
    this.changed();
  };


  /**
   * Remove feature without firing a `change` event.
   * @param {import("../Feature.js").default} feature Feature.
   * @protected
   */
  VectorSource.prototype.removeFeatureInternal = function removeFeatureInternal (feature) {
    var featureKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature);
    this.featureChangeKeys_[featureKey].forEach(_events_js__WEBPACK_IMPORTED_MODULE_6__["unlistenByKey"]);
    delete this.featureChangeKeys_[featureKey];
    var id = feature.getId();
    if (id !== undefined) {
      delete this.idIndex_[id.toString()];
    } else {
      delete this.undefIdIndex_[featureKey];
    }
    this.dispatchEvent(new VectorSourceEvent(
      _VectorEventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].REMOVEFEATURE, feature));
  };


  /**
   * Remove a feature from the id index.  Called internally when the feature id
   * may have changed.
   * @param {import("../Feature.js").default} feature The feature.
   * @return {boolean} Removed the feature from the index.
   * @private
   */
  VectorSource.prototype.removeFromIdIndex_ = function removeFromIdIndex_ (feature) {
    var removed = false;
    for (var id in this.idIndex_) {
      if (this.idIndex_[id] === feature) {
        delete this.idIndex_[id];
        removed = true;
        break;
      }
    }
    return removed;
  };


  /**
   * Set the new loader of the source. The next loadFeatures call will use the
   * new loader.
   * @param {import("../featureloader.js").FeatureLoader} loader The loader to set.
   * @api
   */
  VectorSource.prototype.setLoader = function setLoader (loader) {
    this.loader_ = loader;
  };

  return VectorSource;
}(_Source_js__WEBPACK_IMPORTED_MODULE_14__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (VectorSource);

//# sourceMappingURL=Vector.js.map

/***/ }),

/***/ "./node_modules/ol/source/VectorEventType.js":
/*!***************************************************!*\
  !*** ./node_modules/ol/source/VectorEventType.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/source/VectorEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  /**
   * Triggered when a feature is added to the source.
   * @event ol/source/Vector.VectorSourceEvent#addfeature
   * @api
   */
  ADDFEATURE: 'addfeature',

  /**
   * Triggered when a feature is updated.
   * @event ol/source/Vector.VectorSourceEvent#changefeature
   * @api
   */
  CHANGEFEATURE: 'changefeature',

  /**
   * Triggered when the clear method is called on the source.
   * @event ol/source/Vector.VectorSourceEvent#clear
   * @api
   */
  CLEAR: 'clear',

  /**
   * Triggered when a feature is removed from the source.
   * See {@link module:ol/source/Vector#clear source.clear()} for exceptions.
   * @event ol/source/Vector.VectorSourceEvent#removefeature
   * @api
   */
  REMOVEFEATURE: 'removefeature'
});

//# sourceMappingURL=VectorEventType.js.map

/***/ }),

/***/ "./node_modules/ol/source/VectorTile.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/source/VectorTile.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _VectorImageTile_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../VectorImageTile.js */ "./node_modules/ol/VectorImageTile.js");
/* harmony import */ var _VectorTile_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../VectorTile.js */ "./node_modules/ol/VectorTile.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../size.js */ "./node_modules/ol/size.js");
/* harmony import */ var _UrlTile_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./UrlTile.js */ "./node_modules/ol/source/UrlTile.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../tilegrid.js */ "./node_modules/ol/tilegrid.js");
/**
 * @module ol/source/VectorTile
 */









/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize=128] Cache size.
 * @property {import("../extent.js").Extent} [extent]
 * @property {import("../format/Feature.js").default} [format] Feature format for tiles. Used and required by the default.
 * @property {boolean} [overlaps=true] This source may have overlapping geometries. Setting this
 * to `false` (e.g. for sources with polygons that represent administrative
 * boundaries or TopoJSON sources) allows the renderer to optimise fill and
 * stroke operations.
 * @property {import("../proj.js").ProjectionLike} projection Projection.
 * @property {import("./State.js").default} [state] Source state.
 * @property {typeof import("../VectorTile.js").default} [tileClass] Class used to instantiate image tiles.
 * Default is {@link module:ol/VectorTile}.
 * @property {number} [maxZoom=22] Optional max zoom level.
 * @property {number} [minZoom] Optional min zoom level.
 * @property {number|import("../size.js").Size} [tileSize=512] Optional tile size.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction]
 * Optional function to load a tile given a URL. Could look like this:
 * ```js
 * function(tile, url) {
 *   tile.setLoader(function() {
 *     var data = // ... fetch data
 *     var format = tile.getFormat();
 *     tile.setProjection(format.readProjection(data));
 *     tile.setFeatures(format.readFeatures(data, {
 *       // featureProjection is not required for ol/format/MVT
 *       featureProjection: map.getView().getProjection()
 *     }));
 *     // the line below is only required for ol/format/MVT
 *     tile.setExtent(format.getLastExtent());
 *   }
 * });
 * ```
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be
 * used instead of defining each one separately in the `urls` option.
 * @property {number} [transition] A duration for tile opacity
 * transitions in milliseconds. A duration of 0 disables the opacity transition.
 * @property {Array<string>} [urls] An array of URL templates.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * When set to `false`, only one world
 * will be rendered. When set to `true`, tiles will be wrapped horizontally to
 * render multiple worlds.
 */


/**
 * @classdesc
 * Class for layer sources providing vector data divided into a tile grid, to be
 * used with {@link module:ol/layer/VectorTile~VectorTile}. Although this source receives tiles
 * with vector features from the server, it is not meant for feature editing.
 * Features are optimized for rendering, their geometries are clipped at or near
 * tile boundaries and simplified for a view resolution. See
 * {@link module:ol/source/Vector} for vector sources that are suitable for feature
 * editing.
 *
 * @fires import("./Tile.js").TileSourceEvent
 * @api
 */
var VectorTile = /*@__PURE__*/(function (UrlTile) {
  function VectorTile(options) {
    var projection = options.projection || 'EPSG:3857';

    var extent = options.extent || Object(_tilegrid_js__WEBPACK_IMPORTED_MODULE_6__["extentFromProjection"])(projection);

    var tileGrid = options.tileGrid || Object(_tilegrid_js__WEBPACK_IMPORTED_MODULE_6__["createXYZ"])({
      extent: extent,
      maxZoom: options.maxZoom || 22,
      minZoom: options.minZoom,
      tileSize: options.tileSize || 512
    });

    UrlTile.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize !== undefined ? options.cacheSize : 128,
      opaque: false,
      projection: projection,
      state: options.state,
      tileGrid: tileGrid,
      tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : _VectorImageTile_js__WEBPACK_IMPORTED_MODULE_1__["defaultLoadFunction"],
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX === undefined ? true : options.wrapX,
      transition: options.transition
    });

    /**
     * @private
     * @type {import("../format/Feature.js").default}
     */
    this.format_ = options.format ? options.format : null;

    /**
       * @private
       * @type {Object<string, Tile>}
       */
    this.sourceTiles_ = {};

    /**
     * @private
     * @type {boolean}
     */
    this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;

    /**
     * @protected
     * @type {typeof import("../VectorTile.js").default}
     */
    this.tileClass = options.tileClass ? options.tileClass : _VectorTile_js__WEBPACK_IMPORTED_MODULE_2__["default"];

    /**
     * @private
     * @type {Object<string, import("../tilegrid/TileGrid.js").default>}
     */
    this.tileGrids_ = {};

  }

  if ( UrlTile ) VectorTile.__proto__ = UrlTile;
  VectorTile.prototype = Object.create( UrlTile && UrlTile.prototype );
  VectorTile.prototype.constructor = VectorTile;

  /**
   * @return {boolean} The source can have overlapping geometries.
   */
  VectorTile.prototype.getOverlaps = function getOverlaps () {
    return this.overlaps_;
  };

  /**
   * clear {@link module:ol/TileCache~TileCache} and delete all source tiles
   * @api
   */
  VectorTile.prototype.clear = function clear () {
    this.tileCache.clear();
    this.sourceTiles_ = {};
  };

  /**
   * @inheritDoc
   */
  VectorTile.prototype.getTile = function getTile (z, x, y, pixelRatio, projection) {
    var tileCoordKey = Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_5__["getKeyZXY"])(z, x, y);
    if (this.tileCache.containsKey(tileCoordKey)) {
      return (
        /** @type {!import("../Tile.js").default} */ (this.tileCache.get(tileCoordKey))
      );
    } else {
      var tileCoord = [z, x, y];
      var urlTileCoord = this.getTileCoordForTileUrlFunction(
        tileCoord, projection);
      var tile = new _VectorImageTile_js__WEBPACK_IMPORTED_MODULE_1__["default"](
        tileCoord,
        urlTileCoord !== null ? _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].IDLE : _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].EMPTY,
        this.getRevision(),
        this.format_, this.tileLoadFunction, urlTileCoord, this.tileUrlFunction,
        this.tileGrid, this.getTileGridForProjection(projection),
        this.sourceTiles_, pixelRatio, projection, this.tileClass,
        this.handleTileChange.bind(this), tileCoord[0]);

      this.tileCache.set(tileCoordKey, tile);
      return tile;
    }
  };


  /**
   * @inheritDoc
   */
  VectorTile.prototype.getTileGridForProjection = function getTileGridForProjection (projection) {
    var code = projection.getCode();
    var tileGrid = this.tileGrids_[code];
    if (!tileGrid) {
      // A tile grid that matches the tile size of the source tile grid is more
      // likely to have 1:1 relationships between source tiles and rendered tiles.
      var sourceTileGrid = this.tileGrid;
      tileGrid = this.tileGrids_[code] = Object(_tilegrid_js__WEBPACK_IMPORTED_MODULE_6__["createForProjection"])(projection, undefined,
        sourceTileGrid ? sourceTileGrid.getTileSize(sourceTileGrid.getMinZoom()) : undefined);
    }
    return tileGrid;
  };


  /**
   * @inheritDoc
   */
  VectorTile.prototype.getTilePixelRatio = function getTilePixelRatio (pixelRatio) {
    return pixelRatio;
  };


  /**
   * @inheritDoc
   */
  VectorTile.prototype.getTilePixelSize = function getTilePixelSize (z, pixelRatio, projection) {
    var tileGrid = this.getTileGridForProjection(projection);
    var tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_3__["toSize"])(tileGrid.getTileSize(z), this.tmpSize);
    return [Math.round(tileSize[0] * pixelRatio), Math.round(tileSize[1] * pixelRatio)];
  };

  return VectorTile;
}(_UrlTile_js__WEBPACK_IMPORTED_MODULE_4__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (VectorTile);

//# sourceMappingURL=VectorTile.js.map

/***/ }),

/***/ "./node_modules/ol/source/WMSServerType.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/source/WMSServerType.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/source/WMSServerType
 */

/**
 * Available server types: `'carmentaserver'`, `'geoserver'`, `'mapserver'`,
 *     `'qgis'`. These are servers that have vendor parameters beyond the WMS
 *     specification that OpenLayers can make use of.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  CARMENTA_SERVER: 'carmentaserver',
  GEOSERVER: 'geoserver',
  MAPSERVER: 'mapserver',
  QGIS: 'qgis'
});

//# sourceMappingURL=WMSServerType.js.map

/***/ }),

/***/ "./node_modules/ol/source/WMTS.js":
/*!****************************************!*\
  !*** ./node_modules/ol/source/WMTS.js ***!
  \****************************************/
/*! exports provided: default, optionsFromCapabilities */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "optionsFromCapabilities", function() { return optionsFromCapabilities; });
/* harmony import */ var _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tileurlfunction.js */ "./node_modules/ol/tileurlfunction.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _TileImage_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./TileImage.js */ "./node_modules/ol/source/TileImage.js");
/* harmony import */ var _WMTSRequestEncoding_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./WMTSRequestEncoding.js */ "./node_modules/ol/source/WMTSRequestEncoding.js");
/* harmony import */ var _tilegrid_WMTS_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../tilegrid/WMTS.js */ "./node_modules/ol/tilegrid/WMTS.js");
/* harmony import */ var _uri_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../uri.js */ "./node_modules/ol/uri.js");
/**
 * @module ol/source/WMTS
 */











/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize=2048] Cache size.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to
 * access pixel data with the Canvas renderer.  See
 * https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {import("../tilegrid/WMTS.js").default} tileGrid Tile grid.
 * @property {import("../proj.js").ProjectionLike} projection Projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("./WMTSRequestEncoding.js").default|string} [requestEncoding='KVP'] Request encoding.
 * @property {string} layer Layer name as advertised in the WMTS capabilities.
 * @property {string} style Style name as advertised in the WMTS capabilities.
 * @property {typeof import("../ImageTile.js").default} [tileClass]  Class used to instantiate image tiles. Default is {@link module:ol/ImageTile~ImageTile}.
 * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service.
 * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px
 * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
 * should be set to `2`.
 * @property {string} [format='image/jpeg'] Image format. Only used when `requestEncoding` is `'KVP'`.
 * @property {string} [version='1.0.0'] WMTS version.
 * @property {string} matrixSet Matrix set.
 * @property {!Object} [dimensions] Additional "dimensions" for tile requests.
 * This is an object with properties named like the advertised WMTS dimensions.
 * @property {string} [url]  A URL for the service.
 * For the RESTful request encoding, this is a URL
 * template.  For KVP encoding, it is normal URL. A `{?-?}` template pattern,
 * for example `subdomain{a-f}.domain.com`, may be used instead of defining
 * each one separately in the `urls` option.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {Array<string>} [urls] An array of URLs.
 * Requests will be distributed among the URLs in this array.
 * @property {boolean} [wrapX=false] Whether to wrap the world horizontally.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 */


/**
 * @classdesc
 * Layer source for tile data from WMTS servers.
 * @api
 */
var WMTS = /*@__PURE__*/(function (TileImage) {
  function WMTS(options) {

    // TODO: add support for TileMatrixLimits

    var requestEncoding = options.requestEncoding !== undefined ?
      /** @type {import("./WMTSRequestEncoding.js").default} */ (options.requestEncoding) :
      _WMTSRequestEncoding_js__WEBPACK_IMPORTED_MODULE_6__["default"].KVP;

    // FIXME: should we create a default tileGrid?
    // we could issue a getCapabilities xhr to retrieve missing configuration
    var tileGrid = options.tileGrid;

    var urls = options.urls;
    if (urls === undefined && options.url !== undefined) {
      urls = Object(_tileurlfunction_js__WEBPACK_IMPORTED_MODULE_0__["expandUrl"])(options.url);
    }

    TileImage.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      projection: options.projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileClass: options.tileClass,
      tileGrid: tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_0__["nullTileUrlFunction"],
      urls: urls,
      wrapX: options.wrapX !== undefined ? options.wrapX : false,
      transition: options.transition
    });

    /**
     * @private
     * @type {string}
     */
    this.version_ = options.version !== undefined ? options.version : '1.0.0';

    /**
     * @private
     * @type {string}
     */
    this.format_ = options.format !== undefined ? options.format : 'image/jpeg';

    /**
     * @private
     * @type {!Object}
     */
    this.dimensions_ = options.dimensions !== undefined ? options.dimensions : {};

    /**
     * @private
     * @type {string}
     */
    this.layer_ = options.layer;

    /**
     * @private
     * @type {string}
     */
    this.matrixSet_ = options.matrixSet;

    /**
     * @private
     * @type {string}
     */
    this.style_ = options.style;

    // FIXME: should we guess this requestEncoding from options.url(s)
    //        structure? that would mean KVP only if a template is not provided.

    /**
     * @private
     * @type {import("./WMTSRequestEncoding.js").default}
     */
    this.requestEncoding_ = requestEncoding;

    this.setKey(this.getKeyForDimensions_());

    if (urls && urls.length > 0) {
      this.tileUrlFunction = Object(_tileurlfunction_js__WEBPACK_IMPORTED_MODULE_0__["createFromTileUrlFunctions"])(urls.map(createFromWMTSTemplate.bind(this)));
    }

  }

  if ( TileImage ) WMTS.__proto__ = TileImage;
  WMTS.prototype = Object.create( TileImage && TileImage.prototype );
  WMTS.prototype.constructor = WMTS;

  /**
   * Set the URLs to use for requests.
   * URLs may contain OCG conform URL Template Variables: {TileMatrix}, {TileRow}, {TileCol}.
   * @override
   */
  WMTS.prototype.setUrls = function setUrls (urls) {
    this.urls = urls;
    var key = urls.join('\n');
    this.setTileUrlFunction(Object(_tileurlfunction_js__WEBPACK_IMPORTED_MODULE_0__["createFromTileUrlFunctions"])(urls.map(createFromWMTSTemplate.bind(this))), key);
  };

  /**
   * Get the dimensions, i.e. those passed to the constructor through the
   * "dimensions" option, and possibly updated using the updateDimensions
   * method.
   * @return {!Object} Dimensions.
   * @api
   */
  WMTS.prototype.getDimensions = function getDimensions () {
    return this.dimensions_;
  };


  /**
   * Return the image format of the WMTS source.
   * @return {string} Format.
   * @api
   */
  WMTS.prototype.getFormat = function getFormat () {
    return this.format_;
  };


  /**
   * Return the layer of the WMTS source.
   * @return {string} Layer.
   * @api
   */
  WMTS.prototype.getLayer = function getLayer () {
    return this.layer_;
  };


  /**
   * Return the matrix set of the WMTS source.
   * @return {string} MatrixSet.
   * @api
   */
  WMTS.prototype.getMatrixSet = function getMatrixSet () {
    return this.matrixSet_;
  };


  /**
   * Return the request encoding, either "KVP" or "REST".
   * @return {import("./WMTSRequestEncoding.js").default} Request encoding.
   * @api
   */
  WMTS.prototype.getRequestEncoding = function getRequestEncoding () {
    return this.requestEncoding_;
  };


  /**
   * Return the style of the WMTS source.
   * @return {string} Style.
   * @api
   */
  WMTS.prototype.getStyle = function getStyle () {
    return this.style_;
  };


  /**
   * Return the version of the WMTS source.
   * @return {string} Version.
   * @api
   */
  WMTS.prototype.getVersion = function getVersion () {
    return this.version_;
  };


  /**
   * @private
   * @return {string} The key for the current dimensions.
   */
  WMTS.prototype.getKeyForDimensions_ = function getKeyForDimensions_ () {
    var i = 0;
    var res = [];
    for (var key in this.dimensions_) {
      res[i++] = key + '-' + this.dimensions_[key];
    }
    return res.join('/');
  };


  /**
   * Update the dimensions.
   * @param {Object} dimensions Dimensions.
   * @api
   */
  WMTS.prototype.updateDimensions = function updateDimensions (dimensions) {
    Object(_obj_js__WEBPACK_IMPORTED_MODULE_3__["assign"])(this.dimensions_, dimensions);
    this.setKey(this.getKeyForDimensions_());
  };

  return WMTS;
}(_TileImage_js__WEBPACK_IMPORTED_MODULE_5__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (WMTS);

/**
 * Generate source options from a capabilities object.
 * @param {Object} wmtsCap An object representing the capabilities document.
 * @param {!Object} config Configuration properties for the layer.  Defaults for
 *                  the layer will apply if not provided.
 *
 * Required config properties:
 *  - layer - {string} The layer identifier.
 *
 * Optional config properties:
 *  - matrixSet - {string} The matrix set identifier, required if there is
 *       more than one matrix set in the layer capabilities.
 *  - projection - {string} The desired CRS when no matrixSet is specified.
 *       eg: "EPSG:3857". If the desired projection is not available,
 *       an error is thrown.
 *  - requestEncoding - {string} url encoding format for the layer. Default is
 *       the first tile url format found in the GetCapabilities response.
 *  - style - {string} The name of the style
 *  - format - {string} Image format for the layer. Default is the first
 *       format returned in the GetCapabilities response.
 *  - crossOrigin - {string|null|undefined} Cross origin. Default is `undefined`.
 * @return {?Options} WMTS source options object or `null` if the layer was not found.
 * @api
 */
function optionsFromCapabilities(wmtsCap, config) {
  var layers = wmtsCap['Contents']['Layer'];
  var l = Object(_array_js__WEBPACK_IMPORTED_MODULE_1__["find"])(layers, function(elt, index, array) {
    return elt['Identifier'] == config['layer'];
  });
  if (l === null) {
    return null;
  }
  var tileMatrixSets = wmtsCap['Contents']['TileMatrixSet'];
  var idx;
  if (l['TileMatrixSetLink'].length > 1) {
    if ('projection' in config) {
      idx = Object(_array_js__WEBPACK_IMPORTED_MODULE_1__["findIndex"])(l['TileMatrixSetLink'],
        function(elt, index, array) {
          var tileMatrixSet = Object(_array_js__WEBPACK_IMPORTED_MODULE_1__["find"])(tileMatrixSets, function(el) {
            return el['Identifier'] == elt['TileMatrixSet'];
          });
          var supportedCRS = tileMatrixSet['SupportedCRS'];
          var proj1 = Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__["get"])(supportedCRS.replace(/urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, '$1:$3')) ||
                Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__["get"])(supportedCRS);
          var proj2 = Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__["get"])(config['projection']);
          if (proj1 && proj2) {
            return Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__["equivalent"])(proj1, proj2);
          } else {
            return supportedCRS == config['projection'];
          }
        });
    } else {
      idx = Object(_array_js__WEBPACK_IMPORTED_MODULE_1__["findIndex"])(l['TileMatrixSetLink'],
        function(elt, index, array) {
          return elt['TileMatrixSet'] == config['matrixSet'];
        });
    }
  } else {
    idx = 0;
  }
  if (idx < 0) {
    idx = 0;
  }
  var matrixSet = /** @type {string} */
    (l['TileMatrixSetLink'][idx]['TileMatrixSet']);
  var matrixLimits = /** @type {Array<Object>} */
    (l['TileMatrixSetLink'][idx]['TileMatrixSetLimits']);

  var format = /** @type {string} */ (l['Format'][0]);
  if ('format' in config) {
    format = config['format'];
  }
  idx = Object(_array_js__WEBPACK_IMPORTED_MODULE_1__["findIndex"])(l['Style'], function(elt, index, array) {
    if ('style' in config) {
      return elt['Title'] == config['style'];
    } else {
      return elt['isDefault'];
    }
  });
  if (idx < 0) {
    idx = 0;
  }
  var style = /** @type {string} */ (l['Style'][idx]['Identifier']);

  var dimensions = {};
  if ('Dimension' in l) {
    l['Dimension'].forEach(function(elt, index, array) {
      var key = elt['Identifier'];
      var value = elt['Default'];
      if (value === undefined) {
        value = elt['Value'][0];
      }
      dimensions[key] = value;
    });
  }

  var matrixSets = wmtsCap['Contents']['TileMatrixSet'];
  var matrixSetObj = Object(_array_js__WEBPACK_IMPORTED_MODULE_1__["find"])(matrixSets, function(elt, index, array) {
    return elt['Identifier'] == matrixSet;
  });

  var projection;
  var code = matrixSetObj['SupportedCRS'];
  if (code) {
    projection = Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__["get"])(code.replace(/urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, '$1:$3')) ||
        Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__["get"])(code);
  }
  if ('projection' in config) {
    var projConfig = Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__["get"])(config['projection']);
    if (projConfig) {
      if (!projection || Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__["equivalent"])(projConfig, projection)) {
        projection = projConfig;
      }
    }
  }

  var wgs84BoundingBox = l['WGS84BoundingBox'];
  var extent, wrapX;
  if (wgs84BoundingBox !== undefined) {
    var wgs84ProjectionExtent = Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__["get"])('EPSG:4326').getExtent();
    wrapX = (wgs84BoundingBox[0] == wgs84ProjectionExtent[0] &&
        wgs84BoundingBox[2] == wgs84ProjectionExtent[2]);
    extent = Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__["transformExtent"])(
      wgs84BoundingBox, 'EPSG:4326', projection);
    var projectionExtent = projection.getExtent();
    if (projectionExtent) {
      // If possible, do a sanity check on the extent - it should never be
      // bigger than the validity extent of the projection of a matrix set.
      if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["containsExtent"])(projectionExtent, extent)) {
        extent = undefined;
      }
    }
  }

  var tileGrid = Object(_tilegrid_WMTS_js__WEBPACK_IMPORTED_MODULE_7__["createFromCapabilitiesMatrixSet"])(matrixSetObj, extent, matrixLimits);

  /** @type {!Array<string>} */
  var urls = [];
  var requestEncoding = config['requestEncoding'];
  requestEncoding = requestEncoding !== undefined ? requestEncoding : '';

  if ('OperationsMetadata' in wmtsCap && 'GetTile' in wmtsCap['OperationsMetadata']) {
    var gets = wmtsCap['OperationsMetadata']['GetTile']['DCP']['HTTP']['Get'];

    for (var i = 0, ii = gets.length; i < ii; ++i) {
      if (gets[i]['Constraint']) {
        var constraint = Object(_array_js__WEBPACK_IMPORTED_MODULE_1__["find"])(gets[i]['Constraint'], function(element) {
          return element['name'] == 'GetEncoding';
        });
        var encodings = constraint['AllowedValues']['Value'];

        if (requestEncoding === '') {
          // requestEncoding not provided, use the first encoding from the list
          requestEncoding = encodings[0];
        }
        if (requestEncoding === _WMTSRequestEncoding_js__WEBPACK_IMPORTED_MODULE_6__["default"].KVP) {
          if (Object(_array_js__WEBPACK_IMPORTED_MODULE_1__["includes"])(encodings, _WMTSRequestEncoding_js__WEBPACK_IMPORTED_MODULE_6__["default"].KVP)) {
            urls.push(/** @type {string} */ (gets[i]['href']));
          }
        } else {
          break;
        }
      } else if (gets[i]['href']) {
        requestEncoding = _WMTSRequestEncoding_js__WEBPACK_IMPORTED_MODULE_6__["default"].KVP;
        urls.push(/** @type {string} */ (gets[i]['href']));
      }
    }
  }
  if (urls.length === 0) {
    requestEncoding = _WMTSRequestEncoding_js__WEBPACK_IMPORTED_MODULE_6__["default"].REST;
    l['ResourceURL'].forEach(function(element) {
      if (element['resourceType'] === 'tile') {
        format = element['format'];
        urls.push(/** @type {string} */ (element['template']));
      }
    });
  }

  return {
    urls: urls,
    layer: config['layer'],
    matrixSet: matrixSet,
    format: format,
    projection: projection,
    requestEncoding: requestEncoding,
    tileGrid: tileGrid,
    style: style,
    dimensions: dimensions,
    wrapX: wrapX,
    crossOrigin: config['crossOrigin']
  };
}

/**
 * @param {string} template Template.
 * @return {import("../Tile.js").UrlFunction} Tile URL function.
 * @this {WMTS}
 */
function createFromWMTSTemplate(template) {
  var requestEncoding = this.requestEncoding_;

  // context property names are lower case to allow for a case insensitive
  // replacement as some services use different naming conventions
  var context = {
    'layer': this.layer_,
    'style': this.style_,
    'tilematrixset': this.matrixSet_
  };

  if (requestEncoding == _WMTSRequestEncoding_js__WEBPACK_IMPORTED_MODULE_6__["default"].KVP) {
    Object(_obj_js__WEBPACK_IMPORTED_MODULE_3__["assign"])(context, {
      'Service': 'WMTS',
      'Request': 'GetTile',
      'Version': this.version_,
      'Format': this.format_
    });
  }

  // TODO: we may want to create our own appendParams function so that params
  // order conforms to wmts spec guidance, and so that we can avoid to escape
  // special template params

  template = (requestEncoding == _WMTSRequestEncoding_js__WEBPACK_IMPORTED_MODULE_6__["default"].KVP) ?
    Object(_uri_js__WEBPACK_IMPORTED_MODULE_8__["appendParams"])(template, context) :
    template.replace(/\{(\w+?)\}/g, function(m, p) {
      return (p.toLowerCase() in context) ? context[p.toLowerCase()] : m;
    });

  var tileGrid = /** @type {import("../tilegrid/WMTS.js").default} */ (
    this.tileGrid);
  var dimensions = this.dimensions_;

  return (
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return undefined;
      } else {
        var localContext = {
          'TileMatrix': tileGrid.getMatrixId(tileCoord[0]),
          'TileCol': tileCoord[1],
          'TileRow': -tileCoord[2] - 1
        };
        Object(_obj_js__WEBPACK_IMPORTED_MODULE_3__["assign"])(localContext, dimensions);
        var url = template;
        if (requestEncoding == _WMTSRequestEncoding_js__WEBPACK_IMPORTED_MODULE_6__["default"].KVP) {
          url = Object(_uri_js__WEBPACK_IMPORTED_MODULE_8__["appendParams"])(url, localContext);
        } else {
          url = url.replace(/\{(\w+?)\}/g, function(m, p) {
            return localContext[p];
          });
        }
        return url;
      }
    }
  );
}

//# sourceMappingURL=WMTS.js.map

/***/ }),

/***/ "./node_modules/ol/source/WMTSRequestEncoding.js":
/*!*******************************************************!*\
  !*** ./node_modules/ol/source/WMTSRequestEncoding.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/source/WMTSRequestEncoding
 */

/**
 * Request encoding. One of 'KVP', 'REST'.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  KVP: 'KVP', // see spec §8
  REST: 'REST' // see spec §10
});

//# sourceMappingURL=WMTSRequestEncoding.js.map

/***/ }),

/***/ "./node_modules/ol/source/XYZ.js":
/*!***************************************!*\
  !*** ./node_modules/ol/source/XYZ.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _TileImage_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TileImage.js */ "./node_modules/ol/source/TileImage.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tilegrid.js */ "./node_modules/ol/tilegrid.js");
/**
 * @module ol/source/XYZ
 */




/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize=2048] Cache size.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to
 * access pixel data with the Canvas renderer.  See
 * https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [opaque=true] Whether the layer is opaque.
 * @property {import("../proj.js").ProjectionLike} [projection='EPSG:3857'] Projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {number} [maxZoom=18] Optional max zoom level.
 * @property {number} [minZoom=0] Optional min zoom level.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service.
 * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px
 * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
 * should be set to `2`.
 * @property {number|import("../size.js").Size} [tileSize=[256, 256]] The tile size used by the tile service.
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Optional function to get
 * tile URL given a tile coordinate and the projection.
 * Required if url or urls are not provided.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`,
 * and `{z}` placeholders. A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`,
 * may be used instead of defining each one separately in the `urls` option.
 * @property {Array<string>} [urls] An array of URL templates.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 */


/**
 * @classdesc
 * Layer source for tile data with URLs in a set XYZ format that are
 * defined in a URL template. By default, this follows the widely-used
 * Google grid where `x` 0 and `y` 0 are in the top left. Grids like
 * TMS where `x` 0 and `y` 0 are in the bottom left can be used by
 * using the `{-y}` placeholder in the URL template, so long as the
 * source does not have a custom tile grid. In this case,
 * {@link module:ol/source/TileImage} can be used with a `tileUrlFunction`
 * such as:
 *
 *  tileUrlFunction: function(coordinate) {
 *    return 'http://mapserver.com/' + coordinate[0] + '/' +
 *        coordinate[1] + '/' + coordinate[2] + '.png';
 *    }
 *
 * @api
 */
var XYZ = /*@__PURE__*/(function (TileImage) {
  function XYZ(opt_options) {
    var options = opt_options || {};
    var projection = options.projection !== undefined ?
      options.projection : 'EPSG:3857';

    var tileGrid = options.tileGrid !== undefined ? options.tileGrid :
      Object(_tilegrid_js__WEBPACK_IMPORTED_MODULE_1__["createXYZ"])({
        extent: Object(_tilegrid_js__WEBPACK_IMPORTED_MODULE_1__["extentFromProjection"])(projection),
        maxZoom: options.maxZoom,
        minZoom: options.minZoom,
        tileSize: options.tileSize
      });

    TileImage.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      opaque: options.opaque,
      projection: projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileGrid: tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX !== undefined ? options.wrapX : true,
      transition: options.transition,
      attributionsCollapsible: options.attributionsCollapsible
    });

  }

  if ( TileImage ) XYZ.__proto__ = TileImage;
  XYZ.prototype = Object.create( TileImage && TileImage.prototype );
  XYZ.prototype.constructor = XYZ;

  return XYZ;
}(_TileImage_js__WEBPACK_IMPORTED_MODULE_0__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (XYZ);

//# sourceMappingURL=XYZ.js.map

/***/ }),

/***/ "./node_modules/ol/source/Zoomify.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/source/Zoomify.js ***!
  \*******************************************/
/*! exports provided: CustomTile, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CustomTile", function() { return CustomTile; });
/* harmony import */ var _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tilegrid/common.js */ "./node_modules/ol/tilegrid/common.js");
/* harmony import */ var _ImageTile_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ImageTile.js */ "./node_modules/ol/ImageTile.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../tileurlfunction.js */ "./node_modules/ol/tileurlfunction.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../size.js */ "./node_modules/ol/size.js");
/* harmony import */ var _TileImage_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./TileImage.js */ "./node_modules/ol/source/TileImage.js");
/* harmony import */ var _tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../tilegrid/TileGrid.js */ "./node_modules/ol/tilegrid/TileGrid.js");
/**
 * @module ol/source/Zoomify
 */













/**
 * @enum {string}
 */
var TierSizeCalculation = {
  DEFAULT: 'default',
  TRUNCATED: 'truncated'
};


var CustomTile = /*@__PURE__*/(function (ImageTile) {
  function CustomTile(tileGrid, tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options) {

    ImageTile.call(this, tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options);

    /**
     * @private
     * @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement}
     */
    this.zoomifyImage_ = null;

    /**
     * @private
     * @type {import("../size.js").Size}
     */
    this.tileSize_ = Object(_size_js__WEBPACK_IMPORTED_MODULE_7__["toSize"])(tileGrid.getTileSize(tileCoord[0]));

  }

  if ( ImageTile ) CustomTile.__proto__ = ImageTile;
  CustomTile.prototype = Object.create( ImageTile && ImageTile.prototype );
  CustomTile.prototype.constructor = CustomTile;

  /**
   * @inheritDoc
   */
  CustomTile.prototype.getImage = function getImage () {
    if (this.zoomifyImage_) {
      return this.zoomifyImage_;
    }
    var image = ImageTile.prototype.getImage.call(this);
    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
      var tileSize = this.tileSize_;
      if (image.width == tileSize[0] && image.height == tileSize[1]) {
        this.zoomifyImage_ = image;
        return image;
      } else {
        var context = Object(_dom_js__WEBPACK_IMPORTED_MODULE_5__["createCanvasContext2D"])(tileSize[0], tileSize[1]);
        context.drawImage(image, 0, 0);
        this.zoomifyImage_ = context.canvas;
        return context.canvas;
      }
    } else {
      return image;
    }
  };

  return CustomTile;
}(_ImageTile_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize=2048] Cache size.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to
 * access pixel data with the Canvas renderer.  See
 * https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {string} [url] URL template or base URL of the Zoomify service.
 * A base URL is the fixed part
 * of the URL, excluding the tile group, z, x, and y folder structure, e.g.
 * `http://my.zoomify.info/IMAGE.TIF/`. A URL template must include
 * `{TileGroup}`, `{x}`, `{y}`, and `{z}` placeholders, e.g.
 * `http://my.zoomify.info/IMAGE.TIF/{TileGroup}/{z}-{x}-{y}.jpg`.
 * Internet Imaging Protocol (IIP) with JTL extension can be also used with
 * `{tileIndex}` and `{z}` placeholders, e.g.
 * `http://my.zoomify.info?FIF=IMAGE.TIF&JTL={z},{tileIndex}`.
 * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be
 * used instead of defining each one separately in the `urls` option.
 * @property {string} [tierSizeCalculation] Tier size calculation method: `default` or `truncated`.
 * @property {import("../size.js").Size} [size] Size of the image.
 * @property {import("../extent.js").Extent} [extent] Extent for the TileGrid that is created.
 * Default sets the TileGrid in the
 * fourth quadrant, meaning extent is `[0, -height, width, 0]`. To change the
 * extent to the first quadrant (the default for OpenLayers 2) set the extent
 * as `[0, 0, width, height]`.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {number} [tileSize=256] Tile size. Same tile size is used for all zoom levels.
 */


/**
 * @classdesc
 * Layer source for tile data in Zoomify format (both Zoomify and Internet
 * Imaging Protocol are supported).
 * @api
 */
var Zoomify = /*@__PURE__*/(function (TileImage) {
  function Zoomify(opt_options) {

    var options = opt_options || {};

    var size = options.size;
    var tierSizeCalculation = options.tierSizeCalculation !== undefined ?
      options.tierSizeCalculation :
      TierSizeCalculation.DEFAULT;

    var imageWidth = size[0];
    var imageHeight = size[1];
    var extent = options.extent || [0, -size[1], size[0], 0];
    var tierSizeInTiles = [];
    var tileSize = options.tileSize || _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_TILE_SIZE"];
    var tileSizeForTierSizeCalculation = tileSize;

    switch (tierSizeCalculation) {
      case TierSizeCalculation.DEFAULT:
        while (imageWidth > tileSizeForTierSizeCalculation || imageHeight > tileSizeForTierSizeCalculation) {
          tierSizeInTiles.push([
            Math.ceil(imageWidth / tileSizeForTierSizeCalculation),
            Math.ceil(imageHeight / tileSizeForTierSizeCalculation)
          ]);
          tileSizeForTierSizeCalculation += tileSizeForTierSizeCalculation;
        }
        break;
      case TierSizeCalculation.TRUNCATED:
        var width = imageWidth;
        var height = imageHeight;
        while (width > tileSizeForTierSizeCalculation || height > tileSizeForTierSizeCalculation) {
          tierSizeInTiles.push([
            Math.ceil(width / tileSizeForTierSizeCalculation),
            Math.ceil(height / tileSizeForTierSizeCalculation)
          ]);
          width >>= 1;
          height >>= 1;
        }
        break;
      default:
        Object(_asserts_js__WEBPACK_IMPORTED_MODULE_4__["assert"])(false, 53); // Unknown `tierSizeCalculation` configured
        break;
    }

    tierSizeInTiles.push([1, 1]);
    tierSizeInTiles.reverse();

    var resolutions = [1];
    var tileCountUpToTier = [0];
    for (var i = 1, ii = tierSizeInTiles.length; i < ii; i++) {
      resolutions.push(1 << i);
      tileCountUpToTier.push(
        tierSizeInTiles[i - 1][0] * tierSizeInTiles[i - 1][1] +
          tileCountUpToTier[i - 1]
      );
    }
    resolutions.reverse();

    var tileGrid = new _tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_9__["default"]({
      tileSize: tileSize,
      extent: extent,
      origin: Object(_extent_js__WEBPACK_IMPORTED_MODULE_6__["getTopLeft"])(extent),
      resolutions: resolutions
    });

    var url = options.url;
    if (url && url.indexOf('{TileGroup}') == -1 && url.indexOf('{tileIndex}') == -1) {
      url += '{TileGroup}/{z}-{x}-{y}.jpg';
    }
    var urls = Object(_tileurlfunction_js__WEBPACK_IMPORTED_MODULE_3__["expandUrl"])(url);

    /**
     * @param {string} template Template.
     * @return {import("../Tile.js").UrlFunction} Tile URL function.
     */
    function createFromTemplate(template) {

      return (
        /**
         * @param {import("../tilecoord.js").TileCoord} tileCoord Tile Coordinate.
         * @param {number} pixelRatio Pixel ratio.
         * @param {import("../proj/Projection.js").default} projection Projection.
         * @return {string|undefined} Tile URL.
         */
        function(tileCoord, pixelRatio, projection) {
          if (!tileCoord) {
            return undefined;
          } else {
            var tileCoordZ = tileCoord[0];
            var tileCoordX = tileCoord[1];
            var tileCoordY = -tileCoord[2] - 1;
            var tileIndex =
                tileCoordX +
                tileCoordY * tierSizeInTiles[tileCoordZ][0];
            var tileSize = tileGrid.getTileSize(tileCoordZ);
            var tileWidth = Array.isArray(tileSize) ? tileSize[0] : tileSize;
            var tileGroup = ((tileIndex + tileCountUpToTier[tileCoordZ]) / tileWidth) | 0;
            var localContext = {
              'z': tileCoordZ,
              'x': tileCoordX,
              'y': tileCoordY,
              'tileIndex': tileIndex,
              'TileGroup': 'TileGroup' + tileGroup
            };
            return template.replace(/\{(\w+?)\}/g, function(m, p) {
              return localContext[p];
            });
          }
        }
      );
    }

    var tileUrlFunction = Object(_tileurlfunction_js__WEBPACK_IMPORTED_MODULE_3__["createFromTileUrlFunctions"])(urls.map(createFromTemplate));

    var ZoomifyTileClass = CustomTile.bind(null, tileGrid);

    TileImage.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      projection: options.projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileClass: ZoomifyTileClass,
      tileGrid: tileGrid,
      tileUrlFunction: tileUrlFunction,
      transition: options.transition
    });

  }

  if ( TileImage ) Zoomify.__proto__ = TileImage;
  Zoomify.prototype = Object.create( TileImage && TileImage.prototype );
  Zoomify.prototype.constructor = Zoomify;

  return Zoomify;
}(_TileImage_js__WEBPACK_IMPORTED_MODULE_8__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (Zoomify);

//# sourceMappingURL=Zoomify.js.map

/***/ }),

/***/ "./node_modules/ol/source/common.js":
/*!******************************************!*\
  !*** ./node_modules/ol/source/common.js ***!
  \******************************************/
/*! exports provided: DEFAULT_WMS_VERSION */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_WMS_VERSION", function() { return DEFAULT_WMS_VERSION; });
/**
 * @module ol/source/common
 */

/**
 * Default WMS version.
 * @type {string}
 */
var DEFAULT_WMS_VERSION = '1.3.0';

//# sourceMappingURL=common.js.map

/***/ }),

/***/ "./node_modules/ol/sphere.js":
/*!***********************************!*\
  !*** ./node_modules/ol/sphere.js ***!
  \***********************************/
/*! exports provided: DEFAULT_RADIUS, getDistance, getLength, getArea, offset */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_RADIUS", function() { return DEFAULT_RADIUS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDistance", function() { return getDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLength", function() { return getLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getArea", function() { return getArea; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "offset", function() { return offset; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/**
 * @license
 * Latitude/longitude spherical geodesy formulae taken from
 * http://www.movable-type.co.uk/scripts/latlong.html
 * Licensed under CC-BY-3.0.
 */

/**
 * @module ol/sphere
 */




/**
 * Object literal with options for the {@link getLength} or {@link getArea}
 * functions.
 * @typedef {Object} SphereMetricOptions
 * @property {import("./proj.js").ProjectionLike} [projection='EPSG:3857']
 * Projection of the  geometry.  By default, the geometry is assumed to be in
 * Web Mercator.
 * @property {number} [radius=6371008.8] Sphere radius.  By default, the radius of the
 * earth is used (Clarke 1866 Authalic Sphere).
 */


/**
 * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.
 * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius
 * @type {number}
 */
var DEFAULT_RADIUS = 6371008.8;


/**
 * Get the great circle distance (in meters) between two geographic coordinates.
 * @param {Array} c1 Starting coordinate.
 * @param {Array} c2 Ending coordinate.
 * @param {number=} opt_radius The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {number} The great circle distance between the points (in meters).
 * @api
 */
function getDistance(c1, c2, opt_radius) {
  var radius = opt_radius || DEFAULT_RADIUS;
  var lat1 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toRadians"])(c1[1]);
  var lat2 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toRadians"])(c2[1]);
  var deltaLatBy2 = (lat2 - lat1) / 2;
  var deltaLonBy2 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toRadians"])(c2[0] - c1[0]) / 2;
  var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) +
      Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) *
      Math.cos(lat1) * Math.cos(lat2);
  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}


/**
 * Get the cumulative great circle length of linestring coordinates (geographic).
 * @param {Array} coordinates Linestring coordinates.
 * @param {number} radius The sphere radius to use.
 * @return {number} The length (in meters).
 */
function getLengthInternal(coordinates, radius) {
  var length = 0;
  for (var i = 0, ii = coordinates.length; i < ii - 1; ++i) {
    length += getDistance(coordinates[i], coordinates[i + 1], radius);
  }
  return length;
}


/**
 * Get the spherical length of a geometry.  This length is the sum of the
 * great circle distances between coordinates.  For polygons, the length is
 * the sum of all rings.  For points, the length is zero.  For multi-part
 * geometries, the length is the sum of the length of each part.
 * @param {import("./geom/Geometry.js").default} geometry A geometry.
 * @param {SphereMetricOptions=} opt_options Options for the
 * length calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 * You can change this by providing a `projection` option.
 * @return {number} The spherical length (in meters).
 * @api
 */
function getLength(geometry, opt_options) {
  var options = opt_options || {};
  var radius = options.radius || DEFAULT_RADIUS;
  var projection = options.projection || 'EPSG:3857';
  var type = geometry.getType();
  if (type !== _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].GEOMETRY_COLLECTION) {
    geometry = geometry.clone().transform(projection, 'EPSG:4326');
  }
  var length = 0;
  var coordinates, coords, i, ii, j, jj;
  switch (type) {
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINT:
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POINT: {
      break;
    }
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRING:
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINEAR_RING: {
      coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ (geometry).getCoordinates();
      length = getLengthInternal(coordinates, radius);
      break;
    }
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_LINE_STRING:
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POLYGON: {
      coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ (geometry).getCoordinates();
      for (i = 0, ii = coordinates.length; i < ii; ++i) {
        length += getLengthInternal(coordinates[i], radius);
      }
      break;
    }
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POLYGON: {
      coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ (geometry).getCoordinates();
      for (i = 0, ii = coordinates.length; i < ii; ++i) {
        coords = coordinates[i];
        for (j = 0, jj = coords.length; j < jj; ++j) {
          length += getLengthInternal(coords[j], radius);
        }
      }
      break;
    }
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].GEOMETRY_COLLECTION: {
      var geometries = /** @type {import("./geom/GeometryCollection.js").default} */ (geometry).getGeometries();
      for (i = 0, ii = geometries.length; i < ii; ++i) {
        length += getLength(geometries[i], opt_options);
      }
      break;
    }
    default: {
      throw new Error('Unsupported geometry type: ' + type);
    }
  }
  return length;
}


/**
 * Returns the spherical area for a list of coordinates.
 *
 * [Reference](https://trs-new.jpl.nasa.gov/handle/2014/40409)
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 * Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 * Laboratory, Pasadena, CA, June 2007
 *
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates List of coordinates of a linear
 * ring. If the ring is oriented clockwise, the area will be positive,
 * otherwise it will be negative.
 * @param {number} radius The sphere radius.
 * @return {number} Area (in square meters).
 */
function getAreaInternal(coordinates, radius) {
  var area = 0;
  var len = coordinates.length;
  var x1 = coordinates[len - 1][0];
  var y1 = coordinates[len - 1][1];
  for (var i = 0; i < len; i++) {
    var x2 = coordinates[i][0];
    var y2 = coordinates[i][1];
    area += Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toRadians"])(x2 - x1) *
        (2 + Math.sin(Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toRadians"])(y1)) +
        Math.sin(Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toRadians"])(y2)));
    x1 = x2;
    y1 = y2;
  }
  return area * radius * radius / 2.0;
}


/**
 * Get the spherical area of a geometry.  This is the area (in meters) assuming
 * that polygon edges are segments of great circles on a sphere.
 * @param {import("./geom/Geometry.js").default} geometry A geometry.
 * @param {SphereMetricOptions=} opt_options Options for the area
 *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 *     You can change this by providing a `projection` option.
 * @return {number} The spherical area (in square meters).
 * @api
 */
function getArea(geometry, opt_options) {
  var options = opt_options || {};
  var radius = options.radius || DEFAULT_RADIUS;
  var projection = options.projection || 'EPSG:3857';
  var type = geometry.getType();
  if (type !== _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].GEOMETRY_COLLECTION) {
    geometry = geometry.clone().transform(projection, 'EPSG:4326');
  }
  var area = 0;
  var coordinates, coords, i, ii, j, jj;
  switch (type) {
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINT:
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POINT:
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRING:
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_LINE_STRING:
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINEAR_RING: {
      break;
    }
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POLYGON: {
      coordinates = /** @type {import("./geom/Polygon.js").default} */ (geometry).getCoordinates();
      area = Math.abs(getAreaInternal(coordinates[0], radius));
      for (i = 1, ii = coordinates.length; i < ii; ++i) {
        area -= Math.abs(getAreaInternal(coordinates[i], radius));
      }
      break;
    }
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POLYGON: {
      coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ (geometry).getCoordinates();
      for (i = 0, ii = coordinates.length; i < ii; ++i) {
        coords = coordinates[i];
        area += Math.abs(getAreaInternal(coords[0], radius));
        for (j = 1, jj = coords.length; j < jj; ++j) {
          area -= Math.abs(getAreaInternal(coords[j], radius));
        }
      }
      break;
    }
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].GEOMETRY_COLLECTION: {
      var geometries = /** @type {import("./geom/GeometryCollection.js").default} */ (geometry).getGeometries();
      for (i = 0, ii = geometries.length; i < ii; ++i) {
        area += getArea(geometries[i], opt_options);
      }
      break;
    }
    default: {
      throw new Error('Unsupported geometry type: ' + type);
    }
  }
  return area;
}


/**
 * Returns the coordinate at the given distance and bearing from `c1`.
 *
 * @param {import("./coordinate.js").Coordinate} c1 The origin point (`[lon, lat]` in degrees).
 * @param {number} distance The great-circle distance between the origin
 *     point and the target point.
 * @param {number} bearing The bearing (in radians).
 * @param {number=} opt_radius The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {import("./coordinate.js").Coordinate} The target point.
 */
function offset(c1, distance, bearing, opt_radius) {
  var radius = opt_radius || DEFAULT_RADIUS;
  var lat1 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toRadians"])(c1[1]);
  var lon1 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toRadians"])(c1[0]);
  var dByR = distance / radius;
  var lat = Math.asin(
    Math.sin(lat1) * Math.cos(dByR) +
      Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));
  var lon = lon1 + Math.atan2(
    Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1),
    Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));
  return [Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toDegrees"])(lon), Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toDegrees"])(lat)];
}

//# sourceMappingURL=sphere.js.map

/***/ }),

/***/ "./node_modules/ol/string.js":
/*!***********************************!*\
  !*** ./node_modules/ol/string.js ***!
  \***********************************/
/*! exports provided: padNumber, compareVersions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "padNumber", function() { return padNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compareVersions", function() { return compareVersions; });
/**
 * @module ol/string
 */

/**
 * @param {number} number Number to be formatted
 * @param {number} width The desired width
 * @param {number=} opt_precision Precision of the output string (i.e. number of decimal places)
 * @returns {string} Formatted string
 */
function padNumber(number, width, opt_precision) {
  var numberString = opt_precision !== undefined ? number.toFixed(opt_precision) : '' + number;
  var decimal = numberString.indexOf('.');
  decimal = decimal === -1 ? numberString.length : decimal;
  return decimal > width ? numberString : new Array(1 + width - decimal).join('0') + numberString;
}


/**
 * Adapted from https://github.com/omichelsen/compare-versions/blob/master/index.js
 * @param {string|number} v1 First version
 * @param {string|number} v2 Second version
 * @returns {number} Value
 */
function compareVersions(v1, v2) {
  var s1 = ('' + v1).split('.');
  var s2 = ('' + v2).split('.');

  for (var i = 0; i < Math.max(s1.length, s2.length); i++) {
    var n1 = parseInt(s1[i] || '0', 10);
    var n2 = parseInt(s2[i] || '0', 10);

    if (n1 > n2) {
      return 1;
    }
    if (n2 > n1) {
      return -1;
    }
  }

  return 0;
}

//# sourceMappingURL=string.js.map

/***/ }),

/***/ "./node_modules/ol/structs/LRUCache.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/structs/LRUCache.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/Target.js */ "./node_modules/ol/events/Target.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/**
 * @module ol/structs/LRUCache
 */






/**
 * @typedef {Object} Entry
 * @property {string} key_
 * @property {Object} newer
 * @property {Object} older
 * @property {*} value_
 */


/**
 * @classdesc
 * Implements a Least-Recently-Used cache where the keys do not conflict with
 * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring
 * items from the cache is the responsibility of the user.
 *
 * @fires import("../events/Event.js").Event
 * @template T
 */
var LRUCache = /*@__PURE__*/(function (EventTarget) {
  function LRUCache(opt_highWaterMark) {

    EventTarget.call(this);

    /**
     * @type {number}
     */
    this.highWaterMark = opt_highWaterMark !== undefined ? opt_highWaterMark : 2048;

    /**
     * @private
     * @type {number}
     */
    this.count_ = 0;

    /**
     * @private
     * @type {!Object<string, Entry>}
     */
    this.entries_ = {};

    /**
     * @private
     * @type {?Entry}
     */
    this.oldest_ = null;

    /**
     * @private
     * @type {?Entry}
     */
    this.newest_ = null;

  }

  if ( EventTarget ) LRUCache.__proto__ = EventTarget;
  LRUCache.prototype = Object.create( EventTarget && EventTarget.prototype );
  LRUCache.prototype.constructor = LRUCache;


  /**
   * @return {boolean} Can expire cache.
   */
  LRUCache.prototype.canExpireCache = function canExpireCache () {
    return this.getCount() > this.highWaterMark;
  };


  /**
   * FIXME empty description for jsdoc
   */
  LRUCache.prototype.clear = function clear () {
    this.count_ = 0;
    this.entries_ = {};
    this.oldest_ = null;
    this.newest_ = null;
    this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CLEAR);
  };


  /**
   * @param {string} key Key.
   * @return {boolean} Contains key.
   */
  LRUCache.prototype.containsKey = function containsKey (key) {
    return this.entries_.hasOwnProperty(key);
  };


  /**
   * @param {function(this: S, T, string, LRUCache): ?} f The function
   *     to call for every entry from the oldest to the newer. This function takes
   *     3 arguments (the entry value, the entry key and the LRUCache object).
   *     The return value is ignored.
   * @param {S=} opt_this The object to use as `this` in `f`.
   * @template S
   */
  LRUCache.prototype.forEach = function forEach (f, opt_this) {
    var entry = this.oldest_;
    while (entry) {
      f.call(opt_this, entry.value_, entry.key_, this);
      entry = entry.newer;
    }
  };


  /**
   * @param {string} key Key.
   * @return {T} Value.
   */
  LRUCache.prototype.get = function get (key) {
    var entry = this.entries_[key];
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(entry !== undefined,
      15); // Tried to get a value for a key that does not exist in the cache
    if (entry === this.newest_) {
      return entry.value_;
    } else if (entry === this.oldest_) {
      this.oldest_ = /** @type {Entry} */ (this.oldest_.newer);
      this.oldest_.older = null;
    } else {
      entry.newer.older = entry.older;
      entry.older.newer = entry.newer;
    }
    entry.newer = null;
    entry.older = this.newest_;
    this.newest_.newer = entry;
    this.newest_ = entry;
    return entry.value_;
  };


  /**
   * Remove an entry from the cache.
   * @param {string} key The entry key.
   * @return {T} The removed entry.
   */
  LRUCache.prototype.remove = function remove (key) {
    var entry = this.entries_[key];
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache
    if (entry === this.newest_) {
      this.newest_ = /** @type {Entry} */ (entry.older);
      if (this.newest_) {
        this.newest_.newer = null;
      }
    } else if (entry === this.oldest_) {
      this.oldest_ = /** @type {Entry} */ (entry.newer);
      if (this.oldest_) {
        this.oldest_.older = null;
      }
    } else {
      entry.newer.older = entry.older;
      entry.older.newer = entry.newer;
    }
    delete this.entries_[key];
    --this.count_;
    return entry.value_;
  };


  /**
   * @return {number} Count.
   */
  LRUCache.prototype.getCount = function getCount () {
    return this.count_;
  };


  /**
   * @return {Array<string>} Keys.
   */
  LRUCache.prototype.getKeys = function getKeys () {
    var keys = new Array(this.count_);
    var i = 0;
    var entry;
    for (entry = this.newest_; entry; entry = entry.older) {
      keys[i++] = entry.key_;
    }
    return keys;
  };


  /**
   * @return {Array<T>} Values.
   */
  LRUCache.prototype.getValues = function getValues () {
    var values = new Array(this.count_);
    var i = 0;
    var entry;
    for (entry = this.newest_; entry; entry = entry.older) {
      values[i++] = entry.value_;
    }
    return values;
  };


  /**
   * @return {T} Last value.
   */
  LRUCache.prototype.peekLast = function peekLast () {
    return this.oldest_.value_;
  };


  /**
   * @return {string} Last key.
   */
  LRUCache.prototype.peekLastKey = function peekLastKey () {
    return this.oldest_.key_;
  };


  /**
   * Get the key of the newest item in the cache.  Throws if the cache is empty.
   * @return {string} The newest key.
   */
  LRUCache.prototype.peekFirstKey = function peekFirstKey () {
    return this.newest_.key_;
  };


  /**
   * @return {T} value Value.
   */
  LRUCache.prototype.pop = function pop () {
    var entry = this.oldest_;
    delete this.entries_[entry.key_];
    if (entry.newer) {
      entry.newer.older = null;
    }
    this.oldest_ = /** @type {Entry} */ (entry.newer);
    if (!this.oldest_) {
      this.newest_ = null;
    }
    --this.count_;
    return entry.value_;
  };


  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  LRUCache.prototype.replace = function replace (key, value) {
    this.get(key); // update `newest_`
    this.entries_[key].value_ = value;
  };


  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  LRUCache.prototype.set = function set (key, value) {
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(!(key in this.entries_),
      16); // Tried to set a value for a key that is used already
    var entry = /** @type {Entry} */ ({
      key_: key,
      newer: null,
      older: this.newest_,
      value_: value
    });
    if (!this.newest_) {
      this.oldest_ = entry;
    } else {
      this.newest_.newer = entry;
    }
    this.newest_ = entry;
    this.entries_[key] = entry;
    ++this.count_;
  };


  /**
   * Set a maximum number of entries for the cache.
   * @param {number} size Cache size.
   * @api
   */
  LRUCache.prototype.setSize = function setSize (size) {
    this.highWaterMark = size;
  };


  /**
   * Prune the cache.
   */
  LRUCache.prototype.prune = function prune () {
    while (this.canExpireCache()) {
      this.pop();
    }
  };

  return LRUCache;
}(_events_Target_js__WEBPACK_IMPORTED_MODULE_1__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (LRUCache);

//# sourceMappingURL=LRUCache.js.map

/***/ }),

/***/ "./node_modules/ol/structs/PriorityQueue.js":
/*!**************************************************!*\
  !*** ./node_modules/ol/structs/PriorityQueue.js ***!
  \**************************************************/
/*! exports provided: DROP, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DROP", function() { return DROP; });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/structs/PriorityQueue
 */




/**
 * @type {number}
 */
var DROP = Infinity;


/**
 * @classdesc
 * Priority queue.
 *
 * The implementation is inspired from the Closure Library's Heap class and
 * Python's heapq module.
 *
 * See http://closure-library.googlecode.com/svn/docs/closure_goog_structs_heap.js.source.html
 * and http://hg.python.org/cpython/file/2.7/Lib/heapq.py.
 *
 * @template T
 */
var PriorityQueue = function PriorityQueue(priorityFunction, keyFunction) {

  /**
   * @type {function(T): number}
   * @private
   */
  this.priorityFunction_ = priorityFunction;

  /**
   * @type {function(T): string}
   * @private
   */
  this.keyFunction_ = keyFunction;

  /**
   * @type {Array<T>}
   * @private
   */
  this.elements_ = [];

  /**
   * @type {Array<number>}
   * @private
   */
  this.priorities_ = [];

  /**
   * @type {!Object<string, boolean>}
   * @private
   */
  this.queuedElements_ = {};

};

/**
 * FIXME empty description for jsdoc
 */
PriorityQueue.prototype.clear = function clear$1 () {
  this.elements_.length = 0;
  this.priorities_.length = 0;
  Object(_obj_js__WEBPACK_IMPORTED_MODULE_1__["clear"])(this.queuedElements_);
};


/**
 * Remove and return the highest-priority element. O(log N).
 * @return {T} Element.
 */
PriorityQueue.prototype.dequeue = function dequeue () {
  var elements = this.elements_;
  var priorities = this.priorities_;
  var element = elements[0];
  if (elements.length == 1) {
    elements.length = 0;
    priorities.length = 0;
  } else {
    elements[0] = elements.pop();
    priorities[0] = priorities.pop();
    this.siftUp_(0);
  }
  var elementKey = this.keyFunction_(element);
  delete this.queuedElements_[elementKey];
  return element;
};


/**
 * Enqueue an element. O(log N).
 * @param {T} element Element.
 * @return {boolean} The element was added to the queue.
 */
PriorityQueue.prototype.enqueue = function enqueue (element) {
  Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(!(this.keyFunction_(element) in this.queuedElements_),
    31); // Tried to enqueue an `element` that was already added to the queue
  var priority = this.priorityFunction_(element);
  if (priority != DROP) {
    this.elements_.push(element);
    this.priorities_.push(priority);
    this.queuedElements_[this.keyFunction_(element)] = true;
    this.siftDown_(0, this.elements_.length - 1);
    return true;
  }
  return false;
};


/**
 * @return {number} Count.
 */
PriorityQueue.prototype.getCount = function getCount () {
  return this.elements_.length;
};


/**
 * Gets the index of the left child of the node at the given index.
 * @param {number} index The index of the node to get the left child for.
 * @return {number} The index of the left child.
 * @private
 */
PriorityQueue.prototype.getLeftChildIndex_ = function getLeftChildIndex_ (index) {
  return index * 2 + 1;
};


/**
 * Gets the index of the right child of the node at the given index.
 * @param {number} index The index of the node to get the right child for.
 * @return {number} The index of the right child.
 * @private
 */
PriorityQueue.prototype.getRightChildIndex_ = function getRightChildIndex_ (index) {
  return index * 2 + 2;
};


/**
 * Gets the index of the parent of the node at the given index.
 * @param {number} index The index of the node to get the parent for.
 * @return {number} The index of the parent.
 * @private
 */
PriorityQueue.prototype.getParentIndex_ = function getParentIndex_ (index) {
  return (index - 1) >> 1;
};


/**
 * Make this a heap. O(N).
 * @private
 */
PriorityQueue.prototype.heapify_ = function heapify_ () {
  var i;
  for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {
    this.siftUp_(i);
  }
};


/**
 * @return {boolean} Is empty.
 */
PriorityQueue.prototype.isEmpty = function isEmpty () {
  return this.elements_.length === 0;
};


/**
 * @param {string} key Key.
 * @return {boolean} Is key queued.
 */
PriorityQueue.prototype.isKeyQueued = function isKeyQueued (key) {
  return key in this.queuedElements_;
};


/**
 * @param {T} element Element.
 * @return {boolean} Is queued.
 */
PriorityQueue.prototype.isQueued = function isQueued (element) {
  return this.isKeyQueued(this.keyFunction_(element));
};


/**
 * @param {number} index The index of the node to move down.
 * @private
 */
PriorityQueue.prototype.siftUp_ = function siftUp_ (index) {
  var elements = this.elements_;
  var priorities = this.priorities_;
  var count = elements.length;
  var element = elements[index];
  var priority = priorities[index];
  var startIndex = index;

  while (index < (count >> 1)) {
    var lIndex = this.getLeftChildIndex_(index);
    var rIndex = this.getRightChildIndex_(index);

    var smallerChildIndex = rIndex < count &&
        priorities[rIndex] < priorities[lIndex] ?
      rIndex : lIndex;

    elements[index] = elements[smallerChildIndex];
    priorities[index] = priorities[smallerChildIndex];
    index = smallerChildIndex;
  }

  elements[index] = element;
  priorities[index] = priority;
  this.siftDown_(startIndex, index);
};


/**
 * @param {number} startIndex The index of the root.
 * @param {number} index The index of the node to move up.
 * @private
 */
PriorityQueue.prototype.siftDown_ = function siftDown_ (startIndex, index) {
  var elements = this.elements_;
  var priorities = this.priorities_;
  var element = elements[index];
  var priority = priorities[index];

  while (index > startIndex) {
    var parentIndex = this.getParentIndex_(index);
    if (priorities[parentIndex] > priority) {
      elements[index] = elements[parentIndex];
      priorities[index] = priorities[parentIndex];
      index = parentIndex;
    } else {
      break;
    }
  }
  elements[index] = element;
  priorities[index] = priority;
};


/**
 * FIXME empty description for jsdoc
 */
PriorityQueue.prototype.reprioritize = function reprioritize () {
  var priorityFunction = this.priorityFunction_;
  var elements = this.elements_;
  var priorities = this.priorities_;
  var index = 0;
  var n = elements.length;
  var element, i, priority;
  for (i = 0; i < n; ++i) {
    element = elements[i];
    priority = priorityFunction(element);
    if (priority == DROP) {
      delete this.queuedElements_[this.keyFunction_(element)];
    } else {
      priorities[index] = priority;
      elements[index++] = element;
    }
  }
  elements.length = index;
  priorities.length = index;
  this.heapify_();
};


/* harmony default export */ __webpack_exports__["default"] = (PriorityQueue);

//# sourceMappingURL=PriorityQueue.js.map

/***/ }),

/***/ "./node_modules/ol/structs/RBush.js":
/*!******************************************!*\
  !*** ./node_modules/ol/structs/RBush.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rbush */ "./node_modules/ol/node_modules/rbush/index.js");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(rbush__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/structs/RBush
 */





/**
 * @typedef {Object} Entry
 * @property {number} minX
 * @property {number} minY
 * @property {number} maxX
 * @property {number} maxY
 * @property {Object} [value]
 */

/**
 * @classdesc
 * Wrapper around the RBush by Vladimir Agafonkin.
 * See https://github.com/mourner/rbush.
 *
 * @template T
 */
var RBush = function RBush(opt_maxEntries) {

  /**
   * @private
   */
  this.rbush_ = rbush__WEBPACK_IMPORTED_MODULE_1___default()(opt_maxEntries, undefined);

  /**
   * A mapping between the objects added to this rbush wrapper
   * and the objects that are actually added to the internal rbush.
   * @private
   * @type {Object<string, Entry>}
   */
  this.items_ = {};

};

/**
 * Insert a value into the RBush.
 * @param {import("../extent.js").Extent} extent Extent.
 * @param {T} value Value.
 */
RBush.prototype.insert = function insert (extent, value) {
  /** @type {Entry} */
  var item = {
    minX: extent[0],
    minY: extent[1],
    maxX: extent[2],
    maxY: extent[3],
    value: value
  };

  this.rbush_.insert(item);
  this.items_[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(value)] = item;
};


/**
 * Bulk-insert values into the RBush.
 * @param {Array<import("../extent.js").Extent>} extents Extents.
 * @param {Array<T>} values Values.
 */
RBush.prototype.load = function load (extents, values) {
  var items = new Array(values.length);
  for (var i = 0, l = values.length; i < l; i++) {
    var extent = extents[i];
    var value = values[i];

    /** @type {Entry} */
    var item = {
      minX: extent[0],
      minY: extent[1],
      maxX: extent[2],
      maxY: extent[3],
      value: value
    };
    items[i] = item;
    this.items_[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(value)] = item;
  }
  this.rbush_.load(items);
};


/**
 * Remove a value from the RBush.
 * @param {T} value Value.
 * @return {boolean} Removed.
 */
RBush.prototype.remove = function remove (value) {
  var uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(value);

  // get the object in which the value was wrapped when adding to the
  // internal rbush. then use that object to do the removal.
  var item = this.items_[uid];
  delete this.items_[uid];
  return this.rbush_.remove(item) !== null;
};


/**
 * Update the extent of a value in the RBush.
 * @param {import("../extent.js").Extent} extent Extent.
 * @param {T} value Value.
 */
RBush.prototype.update = function update (extent, value) {
  var item = this.items_[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(value)];
  var bbox = [item.minX, item.minY, item.maxX, item.maxY];
  if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["equals"])(bbox, extent)) {
    this.remove(value);
    this.insert(extent, value);
  }
};


/**
 * Return all values in the RBush.
 * @return {Array<T>} All.
 */
RBush.prototype.getAll = function getAll () {
  var items = this.rbush_.all();
  return items.map(function(item) {
    return item.value;
  });
};


/**
 * Return all values in the given extent.
 * @param {import("../extent.js").Extent} extent Extent.
 * @return {Array<T>} All in extent.
 */
RBush.prototype.getInExtent = function getInExtent (extent) {
  /** @type {Entry} */
  var bbox = {
    minX: extent[0],
    minY: extent[1],
    maxX: extent[2],
    maxY: extent[3]
  };
  var items = this.rbush_.search(bbox);
  return items.map(function(item) {
    return item.value;
  });
};


/**
 * Calls a callback function with each value in the tree.
 * If the callback returns a truthy value, this value is returned without
 * checking the rest of the tree.
 * @param {function(this: S, T): *} callback Callback.
 * @param {S=} opt_this The object to use as `this` in `callback`.
 * @return {*} Callback return value.
 * @template S
 */
RBush.prototype.forEach = function forEach (callback, opt_this) {
  return this.forEach_(this.getAll(), callback, opt_this);
};


/**
 * Calls a callback function with each value in the provided extent.
 * @param {import("../extent.js").Extent} extent Extent.
 * @param {function(this: S, T): *} callback Callback.
 * @param {S=} opt_this The object to use as `this` in `callback`.
 * @return {*} Callback return value.
 * @template S
 */
RBush.prototype.forEachInExtent = function forEachInExtent (extent, callback, opt_this) {
  return this.forEach_(this.getInExtent(extent), callback, opt_this);
};


/**
 * @param {Array<T>} values Values.
 * @param {function(this: S, T): *} callback Callback.
 * @param {S=} opt_this The object to use as `this` in `callback`.
 * @private
 * @return {*} Callback return value.
 * @template S
 */
RBush.prototype.forEach_ = function forEach_ (values, callback, opt_this) {
  var result;
  for (var i = 0, l = values.length; i < l; i++) {
    result = callback.call(opt_this, values[i]);
    if (result) {
      return result;
    }
  }
  return result;
};


/**
 * @return {boolean} Is empty.
 */
RBush.prototype.isEmpty = function isEmpty$1 () {
  return Object(_obj_js__WEBPACK_IMPORTED_MODULE_3__["isEmpty"])(this.items_);
};


/**
 * Remove all values from the RBush.
 */
RBush.prototype.clear = function clear () {
  this.rbush_.clear();
  this.items_ = {};
};


/**
 * @param {import("../extent.js").Extent=} opt_extent Extent.
 * @return {import("../extent.js").Extent} Extent.
 */
RBush.prototype.getExtent = function getExtent (opt_extent) {
  var data = this.rbush_.toJSON();
  return Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["createOrUpdate"])(data.minX, data.minY, data.maxX, data.maxY, opt_extent);
};


/**
 * @param {RBush} rbush R-Tree.
 */
RBush.prototype.concat = function concat (rbush) {
  this.rbush_.load(rbush.rbush_.all());
  for (var i in rbush.items_) {
    this.items_[i] = rbush.items_[i];
  }
};


/* harmony default export */ __webpack_exports__["default"] = (RBush);

//# sourceMappingURL=RBush.js.map

/***/ }),

/***/ "./node_modules/ol/style/Circle.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/style/Circle.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _RegularShape_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RegularShape.js */ "./node_modules/ol/style/RegularShape.js");
/**
 * @module ol/style/Circle
 */




/**
 * @typedef {Object} Options
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {number} radius Circle radius.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {import("./AtlasManager.js").default} [atlasManager] The atlas manager to use for this circle.
 * When using WebGL it is recommended to use an atlas manager to avoid texture switching. If an atlas manager is given,
 * the circle is added to an atlas. By default no atlas manager is used.
 */


/**
 * @classdesc
 * Set circle style for vector features.
 * @api
 */
var CircleStyle = /*@__PURE__*/(function (RegularShape) {
  function CircleStyle(opt_options) {

    var options = opt_options || /** @type {Options} */ ({});

    RegularShape.call(this, {
      points: Infinity,
      fill: options.fill,
      radius: options.radius,
      stroke: options.stroke,
      atlasManager: options.atlasManager
    });

  }

  if ( RegularShape ) CircleStyle.__proto__ = RegularShape;
  CircleStyle.prototype = Object.create( RegularShape && RegularShape.prototype );
  CircleStyle.prototype.constructor = CircleStyle;

  /**
  * Clones the style.  If an atlasmanager was provided to the original style it will be used in the cloned style, too.
  * @return {CircleStyle} The cloned style.
  * @override
  * @api
  */
  CircleStyle.prototype.clone = function clone () {
    var style = new CircleStyle({
      fill: this.getFill() ? this.getFill().clone() : undefined,
      stroke: this.getStroke() ? this.getStroke().clone() : undefined,
      radius: this.getRadius(),
      atlasManager: this.atlasManager_
    });
    style.setOpacity(this.getOpacity());
    style.setScale(this.getScale());
    return style;
  };

  /**
  * Set the circle radius.
  *
  * @param {number} radius Circle radius.
  * @api
  */
  CircleStyle.prototype.setRadius = function setRadius (radius) {
    this.radius_ = radius;
    this.render_(this.atlasManager_);
  };

  return CircleStyle;
}(_RegularShape_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (CircleStyle);

//# sourceMappingURL=Circle.js.map

/***/ }),

/***/ "./node_modules/ol/style/Fill.js":
/*!***************************************!*\
  !*** ./node_modules/ol/style/Fill.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../color.js */ "./node_modules/ol/color.js");
/**
 * @module ol/style/Fill
 */




/**
 * @typedef {Object} Options
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [color] A color, gradient or pattern.
 * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
 * Default null; if null, the Canvas/renderer default black will be used.
 */


/**
 * @classdesc
 * Set fill style for vector features.
 * @api
 */
var Fill = function Fill(opt_options) {

  var options = opt_options || {};

  /**
   * @private
   * @type {import("../color.js").Color|import("../colorlike.js").ColorLike}
   */
  this.color_ = options.color !== undefined ? options.color : null;

  /**
   * @private
   * @type {string|undefined}
   */
  this.checksum_ = undefined;
};

/**
 * Clones the style. The color is not cloned if it is an {@link module:ol/colorlike~ColorLike}.
 * @return {Fill} The cloned style.
 * @api
 */
Fill.prototype.clone = function clone () {
  var color = this.getColor();
  return new Fill({
    color: Array.isArray(color) ? color.slice() : color || undefined
  });
};

/**
 * Get the fill color.
 * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
 * @api
 */
Fill.prototype.getColor = function getColor () {
  return this.color_;
};

/**
 * Set the color.
 *
 * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
 * @api
 */
Fill.prototype.setColor = function setColor (color) {
  this.color_ = color;
  this.checksum_ = undefined;
};

/**
 * @return {string} The checksum.
 */
Fill.prototype.getChecksum = function getChecksum () {
  if (this.checksum_ === undefined) {
    var color = this.color_;
    if (color) {
      if (Array.isArray(color) || typeof color == 'string') {
        this.checksum_ = 'f' + Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["asString"])(/** @type {import("../color.js").Color|string} */ (color));
      } else {
        this.checksum_ = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(this.color_);
      }
    } else {
      this.checksum_ = 'f-';
    }
  }

  return this.checksum_;
};

/* harmony default export */ __webpack_exports__["default"] = (Fill);

//# sourceMappingURL=Fill.js.map

/***/ }),

/***/ "./node_modules/ol/style/Icon.js":
/*!***************************************!*\
  !*** ./node_modules/ol/style/Icon.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ImageState.js */ "./node_modules/ol/ImageState.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../color.js */ "./node_modules/ol/color.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _IconAnchorUnits_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./IconAnchorUnits.js */ "./node_modules/ol/style/IconAnchorUnits.js");
/* harmony import */ var _IconImage_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./IconImage.js */ "./node_modules/ol/style/IconImage.js");
/* harmony import */ var _IconOrigin_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./IconOrigin.js */ "./node_modules/ol/style/IconOrigin.js");
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Image.js */ "./node_modules/ol/style/Image.js");
/**
 * @module ol/style/Icon
 */












/**
 * @typedef {Object} Options
 * @property {Array<number>} [anchor=[0.5, 0.5]] Anchor. Default value is the icon center.
 * @property {import("./IconOrigin.js").default} [anchorOrigin] Origin of the anchor: `bottom-left`, `bottom-right`,
 * `top-left` or `top-right`. Default is `top-left`.
 * @property {import("./IconAnchorUnits.js").default} [anchorXUnits] Units in which the anchor x value is
 * specified. A value of `'fraction'` indicates the x value is a fraction of the icon. A value of `'pixels'` indicates
 * the x value in pixels. Default is `'fraction'`.
 * @property {import("./IconAnchorUnits.js").default} [anchorYUnits] Units in which the anchor y value is
 * specified. A value of `'fraction'` indicates the y value is a fraction of the icon. A value of `'pixels'` indicates
 * the y value in pixels. Default is `'fraction'`.
 * @property {import("../color.js").Color|string} [color] Color to tint the icon. If not specified,
 * the icon will be left as is.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images. Note that you must provide a
 * `crossOrigin` value if you are using the WebGL renderer or if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {HTMLImageElement|HTMLCanvasElement} [img] Image object for the icon. If the `src` option is not provided then the
 * provided image must already be loaded. And in that case, it is required
 * to provide the size of the image, with the `imgSize` option.
 * @property {Array<number>} [offset=[0, 0]] Offset, which, together with the size and the offset origin, define the
 * sub-rectangle to use from the original icon image.
 * @property {import("./IconOrigin.js").default} [offsetOrigin] Origin of the offset: `bottom-left`, `bottom-right`,
 * `top-left` or `top-right`. Default is `top-left`.
 * @property {number} [opacity=1] Opacity of the icon.
 * @property {number} [scale=1] Scale.
 * @property {boolean} [rotateWithView=false] Whether to rotate the icon with the view.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {import("../size.js").Size} [size] Icon size in pixel. Can be used together with `offset` to define the
 * sub-rectangle to use from the origin (sprite) icon image.
 * @property {import("../size.js").Size} [imgSize] Image size in pixels. Only required if `img` is set and `src` is not, and
 * for SVG images in Internet Explorer 11. The provided `imgSize` needs to match the actual size of the image.
 * @property {string} [src] Image source URI.
 */


/**
 * @classdesc
 * Set icon style for vector features.
 * @api
 */
var Icon = /*@__PURE__*/(function (ImageStyle) {
  function Icon(opt_options) {
    var options = opt_options || {};

    /**
     * @type {number}
     */
    var opacity = options.opacity !== undefined ? options.opacity : 1;

    /**
     * @type {number}
     */
    var rotation = options.rotation !== undefined ? options.rotation : 0;

    /**
     * @type {number}
     */
    var scale = options.scale !== undefined ? options.scale : 1;

    /**
     * @type {boolean}
     */
    var rotateWithView = options.rotateWithView !== undefined ?
      options.rotateWithView : false;

    ImageStyle.call(this, {
      opacity: opacity,
      rotation: rotation,
      scale: scale,
      rotateWithView: rotateWithView
    });

    /**
     * @private
     * @type {Array<number>}
     */
    this.anchor_ = options.anchor !== undefined ? options.anchor : [0.5, 0.5];

    /**
     * @private
     * @type {Array<number>}
     */
    this.normalizedAnchor_ = null;

    /**
     * @private
     * @type {import("./IconOrigin.js").default}
     */
    this.anchorOrigin_ = options.anchorOrigin !== undefined ?
      options.anchorOrigin : _IconOrigin_js__WEBPACK_IMPORTED_MODULE_8__["default"].TOP_LEFT;

    /**
     * @private
     * @type {import("./IconAnchorUnits.js").default}
     */
    this.anchorXUnits_ = options.anchorXUnits !== undefined ?
      options.anchorXUnits : _IconAnchorUnits_js__WEBPACK_IMPORTED_MODULE_6__["default"].FRACTION;

    /**
     * @private
     * @type {import("./IconAnchorUnits.js").default}
     */
    this.anchorYUnits_ = options.anchorYUnits !== undefined ?
      options.anchorYUnits : _IconAnchorUnits_js__WEBPACK_IMPORTED_MODULE_6__["default"].FRACTION;

    /**
     * @private
     * @type {?string}
     */
    this.crossOrigin_ =
        options.crossOrigin !== undefined ? options.crossOrigin : null;

    /**
     * @type {HTMLImageElement|HTMLCanvasElement}
     */
    var image = options.img !== undefined ? options.img : null;

    /**
     * @type {import("../size.js").Size}
     */
    var imgSize = options.imgSize !== undefined ? options.imgSize : null;

    /**
     * @type {string|undefined}
     */
    var src = options.src;

    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_2__["assert"])(!(src !== undefined && image),
      4); // `image` and `src` cannot be provided at the same time
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_2__["assert"])(!image || (image && imgSize),
      5); // `imgSize` must be set when `image` is provided

    if ((src === undefined || src.length === 0) && image) {
      src = /** @type {HTMLImageElement} */ (image).src || Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(image);
    }
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_2__["assert"])(src !== undefined && src.length > 0,
      6); // A defined and non-empty `src` or `image` must be provided

    /**
     * @type {import("../ImageState.js").default}
     */
    var imageState = options.src !== undefined ?
      _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE : _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;

    /**
     * @private
     * @type {import("../color.js").Color}
     */
    this.color_ = options.color !== undefined ? Object(_color_js__WEBPACK_IMPORTED_MODULE_3__["asArray"])(options.color) : null;

    /**
     * @private
     * @type {import("./IconImage.js").default}
     */
    this.iconImage_ = Object(_IconImage_js__WEBPACK_IMPORTED_MODULE_7__["get"])(
      image, /** @type {string} */ (src), imgSize, this.crossOrigin_, imageState, this.color_);

    /**
     * @private
     * @type {Array<number>}
     */
    this.offset_ = options.offset !== undefined ? options.offset : [0, 0];

    /**
     * @private
     * @type {import("./IconOrigin.js").default}
     */
    this.offsetOrigin_ = options.offsetOrigin !== undefined ?
      options.offsetOrigin : _IconOrigin_js__WEBPACK_IMPORTED_MODULE_8__["default"].TOP_LEFT;

    /**
     * @private
     * @type {Array<number>}
     */
    this.origin_ = null;

    /**
     * @private
     * @type {import("../size.js").Size}
     */
    this.size_ = options.size !== undefined ? options.size : null;

  }

  if ( ImageStyle ) Icon.__proto__ = ImageStyle;
  Icon.prototype = Object.create( ImageStyle && ImageStyle.prototype );
  Icon.prototype.constructor = Icon;

  /**
   * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
   * @return {Icon} The cloned style.
   * @api
   */
  Icon.prototype.clone = function clone () {
    return new Icon({
      anchor: this.anchor_.slice(),
      anchorOrigin: this.anchorOrigin_,
      anchorXUnits: this.anchorXUnits_,
      anchorYUnits: this.anchorYUnits_,
      crossOrigin: this.crossOrigin_,
      color: (this.color_ && this.color_.slice) ? this.color_.slice() : this.color_ || undefined,
      src: this.getSrc(),
      offset: this.offset_.slice(),
      offsetOrigin: this.offsetOrigin_,
      size: this.size_ !== null ? this.size_.slice() : undefined,
      opacity: this.getOpacity(),
      scale: this.getScale(),
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView()
    });
  };

  /**
   * @inheritDoc
   * @api
   */
  Icon.prototype.getAnchor = function getAnchor () {
    if (this.normalizedAnchor_) {
      return this.normalizedAnchor_;
    }
    var anchor = this.anchor_;
    var size = this.getSize();
    if (this.anchorXUnits_ == _IconAnchorUnits_js__WEBPACK_IMPORTED_MODULE_6__["default"].FRACTION ||
        this.anchorYUnits_ == _IconAnchorUnits_js__WEBPACK_IMPORTED_MODULE_6__["default"].FRACTION) {
      if (!size) {
        return null;
      }
      anchor = this.anchor_.slice();
      if (this.anchorXUnits_ == _IconAnchorUnits_js__WEBPACK_IMPORTED_MODULE_6__["default"].FRACTION) {
        anchor[0] *= size[0];
      }
      if (this.anchorYUnits_ == _IconAnchorUnits_js__WEBPACK_IMPORTED_MODULE_6__["default"].FRACTION) {
        anchor[1] *= size[1];
      }
    }

    if (this.anchorOrigin_ != _IconOrigin_js__WEBPACK_IMPORTED_MODULE_8__["default"].TOP_LEFT) {
      if (!size) {
        return null;
      }
      if (anchor === this.anchor_) {
        anchor = this.anchor_.slice();
      }
      if (this.anchorOrigin_ == _IconOrigin_js__WEBPACK_IMPORTED_MODULE_8__["default"].TOP_RIGHT ||
          this.anchorOrigin_ == _IconOrigin_js__WEBPACK_IMPORTED_MODULE_8__["default"].BOTTOM_RIGHT) {
        anchor[0] = -anchor[0] + size[0];
      }
      if (this.anchorOrigin_ == _IconOrigin_js__WEBPACK_IMPORTED_MODULE_8__["default"].BOTTOM_LEFT ||
          this.anchorOrigin_ == _IconOrigin_js__WEBPACK_IMPORTED_MODULE_8__["default"].BOTTOM_RIGHT) {
        anchor[1] = -anchor[1] + size[1];
      }
    }
    this.normalizedAnchor_ = anchor;
    return this.normalizedAnchor_;
  };

  /**
   * Set the anchor point. The anchor determines the center point for the
   * symbolizer.
   *
   * @param {Array<number>} anchor Anchor.
   * @api
   */
  Icon.prototype.setAnchor = function setAnchor (anchor) {
    this.anchor_ = anchor;
    this.normalizedAnchor_ = null;
  };

  /**
   * Get the icon color.
   * @return {import("../color.js").Color} Color.
   * @api
   */
  Icon.prototype.getColor = function getColor () {
    return this.color_;
  };

  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement} Image or Canvas element.
   * @override
   * @api
   */
  Icon.prototype.getImage = function getImage (pixelRatio) {
    return this.iconImage_.getImage(pixelRatio);
  };

  /**
   * @override
   */
  Icon.prototype.getImageSize = function getImageSize () {
    return this.iconImage_.getSize();
  };

  /**
   * @override
   */
  Icon.prototype.getHitDetectionImageSize = function getHitDetectionImageSize () {
    return this.getImageSize();
  };

  /**
   * @override
   */
  Icon.prototype.getImageState = function getImageState () {
    return this.iconImage_.getImageState();
  };

  /**
   * @override
   */
  Icon.prototype.getHitDetectionImage = function getHitDetectionImage (pixelRatio) {
    return this.iconImage_.getHitDetectionImage(pixelRatio);
  };

  /**
   * @inheritDoc
   * @api
   */
  Icon.prototype.getOrigin = function getOrigin () {
    if (this.origin_) {
      return this.origin_;
    }
    var offset = this.offset_;

    if (this.offsetOrigin_ != _IconOrigin_js__WEBPACK_IMPORTED_MODULE_8__["default"].TOP_LEFT) {
      var size = this.getSize();
      var iconImageSize = this.iconImage_.getSize();
      if (!size || !iconImageSize) {
        return null;
      }
      offset = offset.slice();
      if (this.offsetOrigin_ == _IconOrigin_js__WEBPACK_IMPORTED_MODULE_8__["default"].TOP_RIGHT ||
          this.offsetOrigin_ == _IconOrigin_js__WEBPACK_IMPORTED_MODULE_8__["default"].BOTTOM_RIGHT) {
        offset[0] = iconImageSize[0] - size[0] - offset[0];
      }
      if (this.offsetOrigin_ == _IconOrigin_js__WEBPACK_IMPORTED_MODULE_8__["default"].BOTTOM_LEFT ||
          this.offsetOrigin_ == _IconOrigin_js__WEBPACK_IMPORTED_MODULE_8__["default"].BOTTOM_RIGHT) {
        offset[1] = iconImageSize[1] - size[1] - offset[1];
      }
    }
    this.origin_ = offset;
    return this.origin_;
  };

  /**
   * Get the image URL.
   * @return {string|undefined} Image src.
   * @api
   */
  Icon.prototype.getSrc = function getSrc () {
    return this.iconImage_.getSrc();
  };

  /**
   * @inheritDoc
   * @api
   */
  Icon.prototype.getSize = function getSize () {
    return !this.size_ ? this.iconImage_.getSize() : this.size_;
  };

  /**
   * @override
   */
  Icon.prototype.listenImageChange = function listenImageChange (listener, thisArg) {
    return Object(_events_js__WEBPACK_IMPORTED_MODULE_4__["listen"])(this.iconImage_, _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].CHANGE,
      listener, thisArg);
  };

  /**
   * Load not yet loaded URI.
   * When rendering a feature with an icon style, the vector renderer will
   * automatically call this method. However, you might want to call this
   * method yourself for preloading or other purposes.
   * @override
   * @api
   */
  Icon.prototype.load = function load () {
    this.iconImage_.load();
  };

  /**
   * @override
   */
  Icon.prototype.unlistenImageChange = function unlistenImageChange (listener, thisArg) {
    Object(_events_js__WEBPACK_IMPORTED_MODULE_4__["unlisten"])(this.iconImage_, _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].CHANGE,
      listener, thisArg);
  };

  return Icon;
}(_Image_js__WEBPACK_IMPORTED_MODULE_9__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (Icon);

//# sourceMappingURL=Icon.js.map

/***/ }),

/***/ "./node_modules/ol/style/IconAnchorUnits.js":
/*!**************************************************!*\
  !*** ./node_modules/ol/style/IconAnchorUnits.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/style/IconAnchorUnits
 */

/**
 * Icon anchor units. One of 'fraction', 'pixels'.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  FRACTION: 'fraction',
  PIXELS: 'pixels'
});

//# sourceMappingURL=IconAnchorUnits.js.map

/***/ }),

/***/ "./node_modules/ol/style/IconImage.js":
/*!********************************************!*\
  !*** ./node_modules/ol/style/IconImage.js ***!
  \********************************************/
/*! exports provided: get, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/Target.js */ "./node_modules/ol/events/Target.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ImageState.js */ "./node_modules/ol/ImageState.js");
/* harmony import */ var _IconImageCache_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./IconImageCache.js */ "./node_modules/ol/style/IconImageCache.js");
/**
 * @module ol/style/IconImage
 */








var IconImage = /*@__PURE__*/(function (EventTarget) {
  function IconImage(image, src, size, crossOrigin, imageState, color) {

    EventTarget.call(this);

    /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement}
     */
    this.hitDetectionImage_ = null;

    /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement}
     */
    this.image_ = !image ? new Image() : image;

    if (crossOrigin !== null) {
      /** @type {HTMLImageElement} */ (this.image_).crossOrigin = crossOrigin;
    }

    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    this.canvas_ = color ?
      /** @type {HTMLCanvasElement} */ (document.createElement('canvas')) :
      null;

    /**
     * @private
     * @type {import("../color.js").Color}
     */
    this.color_ = color;

    /**
     * @private
     * @type {Array<import("../events.js").EventsKey>}
     */
    this.imageListenerKeys_ = null;

    /**
     * @private
     * @type {import("../ImageState.js").default}
     */
    this.imageState_ = imageState;

    /**
     * @private
     * @type {import("../size.js").Size}
     */
    this.size_ = size;

    /**
     * @private
     * @type {string|undefined}
     */
    this.src_ = src;

    /**
     * @private
     * @type {boolean|undefined}
     */
    this.tainted_;

  }

  if ( EventTarget ) IconImage.__proto__ = EventTarget;
  IconImage.prototype = Object.create( EventTarget && EventTarget.prototype );
  IconImage.prototype.constructor = IconImage;

  /**
   * @private
   * @return {boolean} The image canvas is tainted.
   */
  IconImage.prototype.isTainted_ = function isTainted_ () {
    if (this.tainted_ === undefined && this.imageState_ === _ImageState_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOADED) {
      this.tainted_ = false;
      var context = Object(_dom_js__WEBPACK_IMPORTED_MODULE_0__["createCanvasContext2D"])(1, 1);
      try {
        context.drawImage(this.image_, 0, 0);
        context.getImageData(0, 0, 1, 1);
      } catch (e) {
        this.tainted_ = true;
      }
    }
    return this.tainted_ === true;
  };

  /**
   * @private
   */
  IconImage.prototype.dispatchChangeEvent_ = function dispatchChangeEvent_ () {
    this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].CHANGE);
  };

  /**
   * @private
   */
  IconImage.prototype.handleImageError_ = function handleImageError_ () {
    this.imageState_ = _ImageState_js__WEBPACK_IMPORTED_MODULE_4__["default"].ERROR;
    this.unlistenImage_();
    this.dispatchChangeEvent_();
  };

  /**
   * @private
   */
  IconImage.prototype.handleImageLoad_ = function handleImageLoad_ () {
    this.imageState_ = _ImageState_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOADED;
    if (this.size_) {
      this.image_.width = this.size_[0];
      this.image_.height = this.size_[1];
    }
    this.size_ = [this.image_.width, this.image_.height];
    this.unlistenImage_();
    this.replaceColor_();
    this.dispatchChangeEvent_();
  };

  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement} Image or Canvas element.
   */
  IconImage.prototype.getImage = function getImage (pixelRatio) {
    return this.canvas_ ? this.canvas_ : this.image_;
  };

  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  IconImage.prototype.getImageState = function getImageState () {
    return this.imageState_;
  };

  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement} Image element.
   */
  IconImage.prototype.getHitDetectionImage = function getHitDetectionImage (pixelRatio) {
    if (!this.hitDetectionImage_) {
      if (this.isTainted_()) {
        var width = this.size_[0];
        var height = this.size_[1];
        var context = Object(_dom_js__WEBPACK_IMPORTED_MODULE_0__["createCanvasContext2D"])(width, height);
        context.fillRect(0, 0, width, height);
        this.hitDetectionImage_ = context.canvas;
      } else {
        this.hitDetectionImage_ = this.image_;
      }
    }
    return this.hitDetectionImage_;
  };

  /**
   * @return {import("../size.js").Size} Image size.
   */
  IconImage.prototype.getSize = function getSize () {
    return this.size_;
  };

  /**
   * @return {string|undefined} Image src.
   */
  IconImage.prototype.getSrc = function getSrc () {
    return this.src_;
  };

  /**
   * Load not yet loaded URI.
   */
  IconImage.prototype.load = function load () {
    if (this.imageState_ == _ImageState_js__WEBPACK_IMPORTED_MODULE_4__["default"].IDLE) {
      this.imageState_ = _ImageState_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOADING;
      this.imageListenerKeys_ = [
        Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["listenOnce"])(this.image_, _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].ERROR,
          this.handleImageError_, this),
        Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["listenOnce"])(this.image_, _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOAD,
          this.handleImageLoad_, this)
      ];
      try {
        /** @type {HTMLImageElement} */ (this.image_).src = this.src_;
      } catch (e) {
        this.handleImageError_();
      }
    }
  };

  /**
   * @private
   */
  IconImage.prototype.replaceColor_ = function replaceColor_ () {
    if (!this.color_ || this.isTainted_()) {
      return;
    }

    this.canvas_.width = this.image_.width;
    this.canvas_.height = this.image_.height;

    var ctx = this.canvas_.getContext('2d');
    ctx.drawImage(this.image_, 0, 0);

    var imgData = ctx.getImageData(0, 0, this.image_.width, this.image_.height);
    var data = imgData.data;
    var r = this.color_[0] / 255.0;
    var g = this.color_[1] / 255.0;
    var b = this.color_[2] / 255.0;

    for (var i = 0, ii = data.length; i < ii; i += 4) {
      data[i] *= r;
      data[i + 1] *= g;
      data[i + 2] *= b;
    }
    ctx.putImageData(imgData, 0, 0);
  };

  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */
  IconImage.prototype.unlistenImage_ = function unlistenImage_ () {
    this.imageListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_1__["unlistenByKey"]);
    this.imageListenerKeys_ = null;
  };

  return IconImage;
}(_events_Target_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/**
 * @param {HTMLImageElement|HTMLCanvasElement} image Image.
 * @param {string} src Src.
 * @param {import("../size.js").Size} size Size.
 * @param {?string} crossOrigin Cross origin.
 * @param {import("../ImageState.js").default} imageState Image state.
 * @param {import("../color.js").Color} color Color.
 * @return {IconImage} Icon image.
 */
function get(image, src, size, crossOrigin, imageState, color) {
  var iconImage = _IconImageCache_js__WEBPACK_IMPORTED_MODULE_5__["shared"].get(src, crossOrigin, color);
  if (!iconImage) {
    iconImage = new IconImage(image, src, size, crossOrigin, imageState, color);
    _IconImageCache_js__WEBPACK_IMPORTED_MODULE_5__["shared"].set(src, crossOrigin, color, iconImage);
  }
  return iconImage;
}


/* harmony default export */ __webpack_exports__["default"] = (IconImage);

//# sourceMappingURL=IconImage.js.map

/***/ }),

/***/ "./node_modules/ol/style/IconImageCache.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/style/IconImageCache.js ***!
  \*************************************************/
/*! exports provided: default, shared */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shared", function() { return shared; });
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../color.js */ "./node_modules/ol/color.js");
/**
 * @module ol/style/IconImageCache
 */


/**
 * @classdesc
 * Singleton class. Available through {@link module:ol/style/IconImageCache~shared}.
 */
var IconImageCache = function IconImageCache() {

  /**
  * @type {!Object<string, import("./IconImage.js").default>}
  * @private
  */
  this.cache_ = {};

  /**
  * @type {number}
  * @private
  */
  this.cacheSize_ = 0;

  /**
  * @type {number}
  * @private
  */
  this.maxCacheSize_ = 32;
};

/**
* FIXME empty description for jsdoc
*/
IconImageCache.prototype.clear = function clear () {
  this.cache_ = {};
  this.cacheSize_ = 0;
};

/**
* FIXME empty description for jsdoc
*/
IconImageCache.prototype.expire = function expire () {
  if (this.cacheSize_ > this.maxCacheSize_) {
    var i = 0;
    for (var key in this.cache_) {
      var iconImage = this.cache_[key];
      if ((i++ & 3) === 0 && !iconImage.hasListener()) {
        delete this.cache_[key];
        --this.cacheSize_;
      }
    }
  }
};

/**
* @param {string} src Src.
* @param {?string} crossOrigin Cross origin.
* @param {import("../color.js").Color} color Color.
* @return {import("./IconImage.js").default} Icon image.
*/
IconImageCache.prototype.get = function get (src, crossOrigin, color) {
  var key = getKey(src, crossOrigin, color);
  return key in this.cache_ ? this.cache_[key] : null;
};

/**
* @param {string} src Src.
* @param {?string} crossOrigin Cross origin.
* @param {import("../color.js").Color} color Color.
* @param {import("./IconImage.js").default} iconImage Icon image.
*/
IconImageCache.prototype.set = function set (src, crossOrigin, color, iconImage) {
  var key = getKey(src, crossOrigin, color);
  this.cache_[key] = iconImage;
  ++this.cacheSize_;
};

/**
* Set the cache size of the icon cache. Default is `32`. Change this value when
* your map uses more than 32 different icon images and you are not caching icon
* styles on the application level.
* @param {number} maxCacheSize Cache max size.
* @api
*/
IconImageCache.prototype.setSize = function setSize (maxCacheSize) {
  this.maxCacheSize_ = maxCacheSize;
  this.expire();
};


/**
 * @param {string} src Src.
 * @param {?string} crossOrigin Cross origin.
 * @param {import("../color.js").Color} color Color.
 * @return {string} Cache key.
 */
function getKey(src, crossOrigin, color) {
  var colorString = color ? Object(_color_js__WEBPACK_IMPORTED_MODULE_0__["asString"])(color) : 'null';
  return crossOrigin + ':' + src + ':' + colorString;
}


/* harmony default export */ __webpack_exports__["default"] = (IconImageCache);


/**
 * The {@link module:ol/style/IconImageCache~IconImageCache} for
 * {@link module:ol/style/Icon~Icon} images.
 * @api
 */
var shared = new IconImageCache();

//# sourceMappingURL=IconImageCache.js.map

/***/ }),

/***/ "./node_modules/ol/style/IconOrigin.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/style/IconOrigin.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/style/IconOrigin
 */

/**
 * Icon origin. One of 'bottom-left', 'bottom-right', 'top-left', 'top-right'.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  BOTTOM_LEFT: 'bottom-left',
  BOTTOM_RIGHT: 'bottom-right',
  TOP_LEFT: 'top-left',
  TOP_RIGHT: 'top-right'
});

//# sourceMappingURL=IconOrigin.js.map

/***/ }),

/***/ "./node_modules/ol/style/Image.js":
/*!****************************************!*\
  !*** ./node_modules/ol/style/Image.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/**
 * @module ol/style/Image
 */



/**
 * @typedef {Object} Options
 * @property {number} opacity
 * @property {boolean} rotateWithView
 * @property {number} rotation
 * @property {number} scale
 */


/**
 * @classdesc
 * A base class used for creating subclasses and not instantiated in
 * apps. Base class for {@link module:ol/style/Icon~Icon}, {@link module:ol/style/Circle~CircleStyle} and
 * {@link module:ol/style/RegularShape~RegularShape}.
 * @abstract
 * @api
 */
var ImageStyle = function ImageStyle(options) {

  /**
   * @private
   * @type {number}
   */
  this.opacity_ = options.opacity;

  /**
   * @private
   * @type {boolean}
   */
  this.rotateWithView_ = options.rotateWithView;

  /**
   * @private
   * @type {number}
   */
  this.rotation_ = options.rotation;

  /**
   * @private
   * @type {number}
   */
  this.scale_ = options.scale;

};

/**
 * Clones the style.
 * @return {ImageStyle} The cloned style.
 * @api
 */
ImageStyle.prototype.clone = function clone () {
  return new ImageStyle({
    opacity: this.getOpacity(),
    scale: this.getScale(),
    rotation: this.getRotation(),
    rotateWithView: this.getRotateWithView()
  });
};

/**
 * Get the symbolizer opacity.
 * @return {number} Opacity.
 * @api
 */
ImageStyle.prototype.getOpacity = function getOpacity () {
  return this.opacity_;
};

/**
 * Determine whether the symbolizer rotates with the map.
 * @return {boolean} Rotate with map.
 * @api
 */
ImageStyle.prototype.getRotateWithView = function getRotateWithView () {
  return this.rotateWithView_;
};

/**
 * Get the symoblizer rotation.
 * @return {number} Rotation.
 * @api
 */
ImageStyle.prototype.getRotation = function getRotation () {
  return this.rotation_;
};

/**
 * Get the symbolizer scale.
 * @return {number} Scale.
 * @api
 */
ImageStyle.prototype.getScale = function getScale () {
  return this.scale_;
};

/**
 * This method is deprecated and always returns false.
 * @return {boolean} false.
 * @deprecated
 * @api
 */
ImageStyle.prototype.getSnapToPixel = function getSnapToPixel () {
  return false;
};

/**
 * Get the anchor point in pixels. The anchor determines the center point for the
 * symbolizer.
 * @abstract
 * @return {Array<number>} Anchor.
 */
ImageStyle.prototype.getAnchor = function getAnchor () {
  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
};

/**
 * Get the image element for the symbolizer.
 * @abstract
 * @param {number} pixelRatio Pixel ratio.
 * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
 */
ImageStyle.prototype.getImage = function getImage (pixelRatio) {
  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
};

/**
 * @abstract
 * @param {number} pixelRatio Pixel ratio.
 * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
 */
ImageStyle.prototype.getHitDetectionImage = function getHitDetectionImage (pixelRatio) {
  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
};

/**
 * @abstract
 * @return {import("../ImageState.js").default} Image state.
 */
ImageStyle.prototype.getImageState = function getImageState () {
  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
};

/**
 * @abstract
 * @return {import("../size.js").Size} Image size.
 */
ImageStyle.prototype.getImageSize = function getImageSize () {
  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
};

/**
 * @abstract
 * @return {import("../size.js").Size} Size of the hit-detection image.
 */
ImageStyle.prototype.getHitDetectionImageSize = function getHitDetectionImageSize () {
  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
};

/**
 * Get the origin of the symbolizer.
 * @abstract
 * @return {Array<number>} Origin.
 */
ImageStyle.prototype.getOrigin = function getOrigin () {
  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
};

/**
 * Get the size of the symbolizer (in pixels).
 * @abstract
 * @return {import("../size.js").Size} Size.
 */
ImageStyle.prototype.getSize = function getSize () {
  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
};

/**
 * Set the opacity.
 *
 * @param {number} opacity Opacity.
 * @api
 */
ImageStyle.prototype.setOpacity = function setOpacity (opacity) {
  this.opacity_ = opacity;
};

/**
 * Set whether to rotate the style with the view.
 *
 * @param {boolean} rotateWithView Rotate with map.
 * @api
 */
ImageStyle.prototype.setRotateWithView = function setRotateWithView (rotateWithView) {
  this.rotateWithView_ = rotateWithView;
};

/**
 * Set the rotation.
 *
 * @param {number} rotation Rotation.
 * @api
 */
ImageStyle.prototype.setRotation = function setRotation (rotation) {
  this.rotation_ = rotation;
};
/**
 * Set the scale.
 *
 * @param {number} scale Scale.
 * @api
 */
ImageStyle.prototype.setScale = function setScale (scale) {
  this.scale_ = scale;
};

/**
 * This method is deprecated and does nothing.
 * @param {boolean} snapToPixel Snap to pixel?
 * @deprecated
 * @api
 */
ImageStyle.prototype.setSnapToPixel = function setSnapToPixel (snapToPixel) {};

/**
 * @abstract
 * @param {function(this: T, import("../events/Event.js").default)} listener Listener function.
 * @param {T} thisArg Value to use as `this` when executing `listener`.
 * @return {import("../events.js").EventsKey|undefined} Listener key.
 * @template T
 */
ImageStyle.prototype.listenImageChange = function listenImageChange (listener, thisArg) {
  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
};

/**
 * Load not yet loaded URI.
 * @abstract
 */
ImageStyle.prototype.load = function load () {
  Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
};

/**
 * @abstract
 * @param {function(this: T, import("../events/Event.js").default)} listener Listener function.
 * @param {T} thisArg Value to use as `this` when executing `listener`.
 * @template T
 */
ImageStyle.prototype.unlistenImageChange = function unlistenImageChange (listener, thisArg) {
  Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
};

/* harmony default export */ __webpack_exports__["default"] = (ImageStyle);

//# sourceMappingURL=Image.js.map

/***/ }),

/***/ "./node_modules/ol/style/RegularShape.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/style/RegularShape.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../color.js */ "./node_modules/ol/color.js");
/* harmony import */ var _colorlike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../colorlike.js */ "./node_modules/ol/colorlike.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ImageState.js */ "./node_modules/ol/ImageState.js");
/* harmony import */ var _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../render/canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Image.js */ "./node_modules/ol/style/Image.js");
/**
 * @module ol/style/RegularShape
 */










/**
 * Specify radius for regular polygons, or radius1 and radius2 for stars.
 * @typedef {Object} Options
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {number} points Number of points for stars and regular polygons. In case of a polygon, the number of points
 * is the number of sides.
 * @property {number} [radius] Radius of a regular polygon.
 * @property {number} [radius1] Outer radius of a star.
 * @property {number} [radius2] Inner radius of a star.
 * @property {number} [angle=0] Shape's angle in radians. A value of 0 will have one of the shape's point facing up.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view.
 * @property {import("./AtlasManager.js").default} [atlasManager] The atlas manager to use for this symbol. When
 * using WebGL it is recommended to use an atlas manager to avoid texture switching. If an atlas manager is given, the
 * symbol is added to an atlas. By default no atlas manager is used.
 */


/**
 * @typedef {Object} RenderOptions
 * @property {import("../colorlike.js").ColorLike} [strokeStyle]
 * @property {number} strokeWidth
 * @property {number} size
 * @property {string} lineCap
 * @property {Array<number>} lineDash
 * @property {number} lineDashOffset
 * @property {string} lineJoin
 * @property {number} miterLimit
 */


/**
 * @classdesc
 * Set regular shape style for vector features. The resulting shape will be
 * a regular polygon when `radius` is provided, or a star when `radius1` and
 * `radius2` are provided.
 * @api
 */
var RegularShape = /*@__PURE__*/(function (ImageStyle) {
  function RegularShape(options) {
    /**
     * @type {boolean}
     */
    var rotateWithView = options.rotateWithView !== undefined ?
      options.rotateWithView : false;

    ImageStyle.call(this, {
      opacity: 1,
      rotateWithView: rotateWithView,
      rotation: options.rotation !== undefined ? options.rotation : 0,
      scale: 1
    });

    /**
     * @private
     * @type {Array<string|number>}
     */
    this.checksums_ = null;

    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    this.canvas_ = null;

    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    this.hitDetectionCanvas_ = null;

    /**
     * @private
     * @type {import("./Fill.js").default}
     */
    this.fill_ = options.fill !== undefined ? options.fill : null;

    /**
     * @private
     * @type {Array<number>}
     */
    this.origin_ = [0, 0];

    /**
     * @private
     * @type {number}
     */
    this.points_ = options.points;

    /**
     * @protected
     * @type {number}
     */
    this.radius_ = /** @type {number} */ (options.radius !== undefined ?
      options.radius : options.radius1);

    /**
     * @private
     * @type {number|undefined}
     */
    this.radius2_ = options.radius2;

    /**
     * @private
     * @type {number}
     */
    this.angle_ = options.angle !== undefined ? options.angle : 0;

    /**
     * @private
     * @type {import("./Stroke.js").default}
     */
    this.stroke_ = options.stroke !== undefined ? options.stroke : null;

    /**
     * @private
     * @type {Array<number>}
     */
    this.anchor_ = null;

    /**
     * @private
     * @type {import("../size.js").Size}
     */
    this.size_ = null;

    /**
     * @private
     * @type {import("../size.js").Size}
     */
    this.imageSize_ = null;

    /**
     * @private
     * @type {import("../size.js").Size}
     */
    this.hitDetectionImageSize_ = null;

    /**
     * @protected
     * @type {import("./AtlasManager.js").default|undefined}
     */
    this.atlasManager_ = options.atlasManager;

    this.render_(this.atlasManager_);

  }

  if ( ImageStyle ) RegularShape.__proto__ = ImageStyle;
  RegularShape.prototype = Object.create( ImageStyle && ImageStyle.prototype );
  RegularShape.prototype.constructor = RegularShape;

  /**
   * Clones the style. If an atlasmanager was provided to the original style it will be used in the cloned style, too.
   * @return {RegularShape} The cloned style.
   * @api
   */
  RegularShape.prototype.clone = function clone () {
    var style = new RegularShape({
      fill: this.getFill() ? this.getFill().clone() : undefined,
      points: this.getPoints(),
      radius: this.getRadius(),
      radius2: this.getRadius2(),
      angle: this.getAngle(),
      stroke: this.getStroke() ? this.getStroke().clone() : undefined,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      atlasManager: this.atlasManager_
    });
    style.setOpacity(this.getOpacity());
    style.setScale(this.getScale());
    return style;
  };

  /**
   * @inheritDoc
   * @api
   */
  RegularShape.prototype.getAnchor = function getAnchor () {
    return this.anchor_;
  };

  /**
   * Get the angle used in generating the shape.
   * @return {number} Shape's rotation in radians.
   * @api
   */
  RegularShape.prototype.getAngle = function getAngle () {
    return this.angle_;
  };

  /**
   * Get the fill style for the shape.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */
  RegularShape.prototype.getFill = function getFill () {
    return this.fill_;
  };

  /**
   * @inheritDoc
   */
  RegularShape.prototype.getHitDetectionImage = function getHitDetectionImage (pixelRatio) {
    return this.hitDetectionCanvas_;
  };

  /**
   * @inheritDoc
   * @api
   */
  RegularShape.prototype.getImage = function getImage (pixelRatio) {
    return this.canvas_;
  };

  /**
   * @inheritDoc
   */
  RegularShape.prototype.getImageSize = function getImageSize () {
    return this.imageSize_;
  };

  /**
   * @inheritDoc
   */
  RegularShape.prototype.getHitDetectionImageSize = function getHitDetectionImageSize () {
    return this.hitDetectionImageSize_;
  };

  /**
   * @inheritDoc
   */
  RegularShape.prototype.getImageState = function getImageState () {
    return _ImageState_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOADED;
  };

  /**
   * @inheritDoc
   * @api
   */
  RegularShape.prototype.getOrigin = function getOrigin () {
    return this.origin_;
  };

  /**
   * Get the number of points for generating the shape.
   * @return {number} Number of points for stars and regular polygons.
   * @api
   */
  RegularShape.prototype.getPoints = function getPoints () {
    return this.points_;
  };

  /**
   * Get the (primary) radius for the shape.
   * @return {number} Radius.
   * @api
   */
  RegularShape.prototype.getRadius = function getRadius () {
    return this.radius_;
  };

  /**
   * Get the secondary radius for the shape.
   * @return {number|undefined} Radius2.
   * @api
   */
  RegularShape.prototype.getRadius2 = function getRadius2 () {
    return this.radius2_;
  };

  /**
   * @inheritDoc
   * @api
   */
  RegularShape.prototype.getSize = function getSize () {
    return this.size_;
  };

  /**
   * Get the stroke style for the shape.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */
  RegularShape.prototype.getStroke = function getStroke () {
    return this.stroke_;
  };

  /**
   * @inheritDoc
   */
  RegularShape.prototype.listenImageChange = function listenImageChange (listener, thisArg) {
    return undefined;
  };

  /**
   * @inheritDoc
   */
  RegularShape.prototype.load = function load () {};

  /**
   * @inheritDoc
   */
  RegularShape.prototype.unlistenImageChange = function unlistenImageChange (listener, thisArg) {};

  /**
   * @protected
   * @param {import("./AtlasManager.js").default|undefined} atlasManager An atlas manager.
   */
  RegularShape.prototype.render_ = function render_ (atlasManager) {
    var imageSize;
    var lineCap = '';
    var lineJoin = '';
    var miterLimit = 0;
    var lineDash = null;
    var lineDashOffset = 0;
    var strokeStyle;
    var strokeWidth = 0;

    if (this.stroke_) {
      strokeStyle = this.stroke_.getColor();
      if (strokeStyle === null) {
        strokeStyle = _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["defaultStrokeStyle"];
      }
      strokeStyle = Object(_colorlike_js__WEBPACK_IMPORTED_MODULE_1__["asColorLike"])(strokeStyle);
      strokeWidth = this.stroke_.getWidth();
      if (strokeWidth === undefined) {
        strokeWidth = _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["defaultLineWidth"];
      }
      lineDash = this.stroke_.getLineDash();
      lineDashOffset = this.stroke_.getLineDashOffset();
      if (!_has_js__WEBPACK_IMPORTED_MODULE_3__["CANVAS_LINE_DASH"]) {
        lineDash = null;
        lineDashOffset = 0;
      }
      lineJoin = this.stroke_.getLineJoin();
      if (lineJoin === undefined) {
        lineJoin = _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["defaultLineJoin"];
      }
      lineCap = this.stroke_.getLineCap();
      if (lineCap === undefined) {
        lineCap = _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["defaultLineCap"];
      }
      miterLimit = this.stroke_.getMiterLimit();
      if (miterLimit === undefined) {
        miterLimit = _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["defaultMiterLimit"];
      }
    }

    var size = 2 * (this.radius_ + strokeWidth) + 1;

    /** @type {RenderOptions} */
    var renderOptions = {
      strokeStyle: strokeStyle,
      strokeWidth: strokeWidth,
      size: size,
      lineCap: lineCap,
      lineDash: lineDash,
      lineDashOffset: lineDashOffset,
      lineJoin: lineJoin,
      miterLimit: miterLimit
    };

    if (atlasManager === undefined) {
      // no atlas manager is used, create a new canvas
      var context = Object(_dom_js__WEBPACK_IMPORTED_MODULE_2__["createCanvasContext2D"])(size, size);
      this.canvas_ = context.canvas;

      // canvas.width and height are rounded to the closest integer
      size = this.canvas_.width;
      imageSize = size;

      this.draw_(renderOptions, context, 0, 0);

      this.createHitDetectionCanvas_(renderOptions);
    } else {
      // an atlas manager is used, add the symbol to an atlas
      size = Math.round(size);

      var hasCustomHitDetectionImage = !this.fill_;
      var renderHitDetectionCallback;
      if (hasCustomHitDetectionImage) {
        // render the hit-detection image into a separate atlas image
        renderHitDetectionCallback =
            this.drawHitDetectionCanvas_.bind(this, renderOptions);
      }

      var id = this.getChecksum();
      var info = atlasManager.add(
        id, size, size, this.draw_.bind(this, renderOptions),
        renderHitDetectionCallback);

      this.canvas_ = info.image;
      this.origin_ = [info.offsetX, info.offsetY];
      imageSize = info.image.width;

      if (hasCustomHitDetectionImage) {
        this.hitDetectionCanvas_ = info.hitImage;
        this.hitDetectionImageSize_ =
            [info.hitImage.width, info.hitImage.height];
      } else {
        this.hitDetectionCanvas_ = this.canvas_;
        this.hitDetectionImageSize_ = [imageSize, imageSize];
      }
    }

    this.anchor_ = [size / 2, size / 2];
    this.size_ = [size, size];
    this.imageSize_ = [imageSize, imageSize];
  };

  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The rendering context.
   * @param {number} x The origin for the symbol (x).
   * @param {number} y The origin for the symbol (y).
   */
  RegularShape.prototype.draw_ = function draw_ (renderOptions, context, x, y) {
    var i, angle0, radiusC;
    // reset transform
    context.setTransform(1, 0, 0, 1, 0, 0);

    // then move to (x, y)
    context.translate(x, y);

    context.beginPath();

    var points = this.points_;
    if (points === Infinity) {
      context.arc(
        renderOptions.size / 2, renderOptions.size / 2,
        this.radius_, 0, 2 * Math.PI, true);
    } else {
      var radius2 = (this.radius2_ !== undefined) ? this.radius2_
        : this.radius_;
      if (radius2 !== this.radius_) {
        points = 2 * points;
      }
      for (i = 0; i <= points; i++) {
        angle0 = i * 2 * Math.PI / points - Math.PI / 2 + this.angle_;
        radiusC = i % 2 === 0 ? this.radius_ : radius2;
        context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0),
          renderOptions.size / 2 + radiusC * Math.sin(angle0));
      }
    }


    if (this.fill_) {
      var color = this.fill_.getColor();
      if (color === null) {
        color = _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["defaultFillStyle"];
      }
      context.fillStyle = Object(_colorlike_js__WEBPACK_IMPORTED_MODULE_1__["asColorLike"])(color);
      context.fill();
    }
    if (this.stroke_) {
      context.strokeStyle = renderOptions.strokeStyle;
      context.lineWidth = renderOptions.strokeWidth;
      if (renderOptions.lineDash) {
        context.setLineDash(renderOptions.lineDash);
        context.lineDashOffset = renderOptions.lineDashOffset;
      }
      context.lineCap = /** @type {CanvasLineCap} */ (renderOptions.lineCap);
      context.lineJoin = /** @type {CanvasLineJoin} */ (renderOptions.lineJoin);
      context.miterLimit = renderOptions.miterLimit;
      context.stroke();
    }
    context.closePath();
  };

  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   */
  RegularShape.prototype.createHitDetectionCanvas_ = function createHitDetectionCanvas_ (renderOptions) {
    this.hitDetectionImageSize_ = [renderOptions.size, renderOptions.size];
    if (this.fill_) {
      this.hitDetectionCanvas_ = this.canvas_;
      return;
    }

    // if no fill style is set, create an extra hit-detection image with a
    // default fill style
    var context = Object(_dom_js__WEBPACK_IMPORTED_MODULE_2__["createCanvasContext2D"])(renderOptions.size, renderOptions.size);
    this.hitDetectionCanvas_ = context.canvas;

    this.drawHitDetectionCanvas_(renderOptions, context, 0, 0);
  };

  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The context.
   * @param {number} x The origin for the symbol (x).
   * @param {number} y The origin for the symbol (y).
   */
  RegularShape.prototype.drawHitDetectionCanvas_ = function drawHitDetectionCanvas_ (renderOptions, context, x, y) {
    // reset transform
    context.setTransform(1, 0, 0, 1, 0, 0);

    // then move to (x, y)
    context.translate(x, y);

    context.beginPath();

    var points = this.points_;
    if (points === Infinity) {
      context.arc(
        renderOptions.size / 2, renderOptions.size / 2,
        this.radius_, 0, 2 * Math.PI, true);
    } else {
      var radius2 = (this.radius2_ !== undefined) ? this.radius2_
        : this.radius_;
      if (radius2 !== this.radius_) {
        points = 2 * points;
      }
      var i, radiusC, angle0;
      for (i = 0; i <= points; i++) {
        angle0 = i * 2 * Math.PI / points - Math.PI / 2 + this.angle_;
        radiusC = i % 2 === 0 ? this.radius_ : radius2;
        context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0),
          renderOptions.size / 2 + radiusC * Math.sin(angle0));
      }
    }

    context.fillStyle = Object(_color_js__WEBPACK_IMPORTED_MODULE_0__["asString"])(_render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["defaultFillStyle"]);
    context.fill();
    if (this.stroke_) {
      context.strokeStyle = renderOptions.strokeStyle;
      context.lineWidth = renderOptions.strokeWidth;
      if (renderOptions.lineDash) {
        context.setLineDash(renderOptions.lineDash);
        context.lineDashOffset = renderOptions.lineDashOffset;
      }
      context.stroke();
    }
    context.closePath();
  };

  /**
   * @return {string} The checksum.
   */
  RegularShape.prototype.getChecksum = function getChecksum () {
    var strokeChecksum = this.stroke_ ?
      this.stroke_.getChecksum() : '-';
    var fillChecksum = this.fill_ ?
      this.fill_.getChecksum() : '-';

    var recalculate = !this.checksums_ ||
        (strokeChecksum != this.checksums_[1] ||
        fillChecksum != this.checksums_[2] ||
        this.radius_ != this.checksums_[3] ||
        this.radius2_ != this.checksums_[4] ||
        this.angle_ != this.checksums_[5] ||
        this.points_ != this.checksums_[6]);

    if (recalculate) {
      var checksum = 'r' + strokeChecksum + fillChecksum +
          (this.radius_ !== undefined ? this.radius_.toString() : '-') +
          (this.radius2_ !== undefined ? this.radius2_.toString() : '-') +
          (this.angle_ !== undefined ? this.angle_.toString() : '-') +
          (this.points_ !== undefined ? this.points_.toString() : '-');
      this.checksums_ = [checksum, strokeChecksum, fillChecksum,
        this.radius_, this.radius2_, this.angle_, this.points_];
    }

    return /** @type {string} */ (this.checksums_[0]);
  };

  return RegularShape;
}(_Image_js__WEBPACK_IMPORTED_MODULE_6__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (RegularShape);

//# sourceMappingURL=RegularShape.js.map

/***/ }),

/***/ "./node_modules/ol/style/Stroke.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/style/Stroke.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/**
 * @module ol/style/Stroke
 */



/**
 * @typedef {Object} Options
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [color] A color, gradient or pattern.
 * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
 * Default null; if null, the Canvas/renderer default black will be used.
 * @property {string} [lineCap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {string} [lineJoin='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {Array<number>} [lineDash] Line dash pattern. Default is `undefined` (no dash).
 * Please note that Internet Explorer 10 and lower do not support the `setLineDash` method on
 * the `CanvasRenderingContext2D` and therefore this option will have no visual effect in these browsers.
 * @property {number} [lineDashOffset=0] Line dash offset.
 * @property {number} [miterLimit=10] Miter limit.
 * @property {number} [width] Width.
 */


/**
 * @classdesc
 * Set stroke style for vector features.
 * Note that the defaults given are the Canvas defaults, which will be used if
 * option is not defined. The `get` functions return whatever was entered in
 * the options; they will not return the default.
 * @api
 */
var Stroke = function Stroke(opt_options) {

  var options = opt_options || {};

  /**
   * @private
   * @type {import("../color.js").Color|import("../colorlike.js").ColorLike}
   */
  this.color_ = options.color !== undefined ? options.color : null;

  /**
   * @private
   * @type {string|undefined}
   */
  this.lineCap_ = options.lineCap;

  /**
   * @private
   * @type {Array<number>}
   */
  this.lineDash_ = options.lineDash !== undefined ? options.lineDash : null;

  /**
   * @private
   * @type {number|undefined}
   */
  this.lineDashOffset_ = options.lineDashOffset;

  /**
   * @private
   * @type {string|undefined}
   */
  this.lineJoin_ = options.lineJoin;

  /**
   * @private
   * @type {number|undefined}
   */
  this.miterLimit_ = options.miterLimit;

  /**
   * @private
   * @type {number|undefined}
   */
  this.width_ = options.width;

  /**
   * @private
   * @type {string|undefined}
   */
  this.checksum_ = undefined;
};

/**
 * Clones the style.
 * @return {Stroke} The cloned style.
 * @api
 */
Stroke.prototype.clone = function clone () {
  var color = this.getColor();
  return new Stroke({
    color: Array.isArray(color) ? color.slice() : color || undefined,
    lineCap: this.getLineCap(),
    lineDash: this.getLineDash() ? this.getLineDash().slice() : undefined,
    lineDashOffset: this.getLineDashOffset(),
    lineJoin: this.getLineJoin(),
    miterLimit: this.getMiterLimit(),
    width: this.getWidth()
  });
};

/**
 * Get the stroke color.
 * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
 * @api
 */
Stroke.prototype.getColor = function getColor () {
  return this.color_;
};

/**
 * Get the line cap type for the stroke.
 * @return {string|undefined} Line cap.
 * @api
 */
Stroke.prototype.getLineCap = function getLineCap () {
  return this.lineCap_;
};

/**
 * Get the line dash style for the stroke.
 * @return {Array<number>} Line dash.
 * @api
 */
Stroke.prototype.getLineDash = function getLineDash () {
  return this.lineDash_;
};

/**
 * Get the line dash offset for the stroke.
 * @return {number|undefined} Line dash offset.
 * @api
 */
Stroke.prototype.getLineDashOffset = function getLineDashOffset () {
  return this.lineDashOffset_;
};

/**
 * Get the line join type for the stroke.
 * @return {string|undefined} Line join.
 * @api
 */
Stroke.prototype.getLineJoin = function getLineJoin () {
  return this.lineJoin_;
};

/**
 * Get the miter limit for the stroke.
 * @return {number|undefined} Miter limit.
 * @api
 */
Stroke.prototype.getMiterLimit = function getMiterLimit () {
  return this.miterLimit_;
};

/**
 * Get the stroke width.
 * @return {number|undefined} Width.
 * @api
 */
Stroke.prototype.getWidth = function getWidth () {
  return this.width_;
};

/**
 * Set the color.
 *
 * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
 * @api
 */
Stroke.prototype.setColor = function setColor (color) {
  this.color_ = color;
  this.checksum_ = undefined;
};

/**
 * Set the line cap.
 *
 * @param {string|undefined} lineCap Line cap.
 * @api
 */
Stroke.prototype.setLineCap = function setLineCap (lineCap) {
  this.lineCap_ = lineCap;
  this.checksum_ = undefined;
};

/**
 * Set the line dash.
 *
 * Please note that Internet Explorer 10 and lower [do not support][mdn] the
 * `setLineDash` method on the `CanvasRenderingContext2D` and therefore this
 * property will have no visual effect in these browsers.
 *
 * [mdn]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility
 *
 * @param {Array<number>} lineDash Line dash.
 * @api
 */
Stroke.prototype.setLineDash = function setLineDash (lineDash) {
  this.lineDash_ = lineDash;
  this.checksum_ = undefined;
};

/**
 * Set the line dash offset.
 *
 * @param {number|undefined} lineDashOffset Line dash offset.
 * @api
 */
Stroke.prototype.setLineDashOffset = function setLineDashOffset (lineDashOffset) {
  this.lineDashOffset_ = lineDashOffset;
  this.checksum_ = undefined;
};

/**
 * Set the line join.
 *
 * @param {string|undefined} lineJoin Line join.
 * @api
 */
Stroke.prototype.setLineJoin = function setLineJoin (lineJoin) {
  this.lineJoin_ = lineJoin;
  this.checksum_ = undefined;
};

/**
 * Set the miter limit.
 *
 * @param {number|undefined} miterLimit Miter limit.
 * @api
 */
Stroke.prototype.setMiterLimit = function setMiterLimit (miterLimit) {
  this.miterLimit_ = miterLimit;
  this.checksum_ = undefined;
};

/**
 * Set the width.
 *
 * @param {number|undefined} width Width.
 * @api
 */
Stroke.prototype.setWidth = function setWidth (width) {
  this.width_ = width;
  this.checksum_ = undefined;
};

/**
 * @return {string} The checksum.
 */
Stroke.prototype.getChecksum = function getChecksum () {
  if (this.checksum_ === undefined) {
    this.checksum_ = 's';
    if (this.color_) {
      if (typeof this.color_ === 'string') {
        this.checksum_ += this.color_;
      } else {
        this.checksum_ += Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(this.color_);
      }
    } else {
      this.checksum_ += '-';
    }
    this.checksum_ += ',' +
        (this.lineCap_ !== undefined ?
          this.lineCap_.toString() : '-') + ',' +
        (this.lineDash_ ?
          this.lineDash_.toString() : '-') + ',' +
        (this.lineDashOffset_ !== undefined ?
          this.lineDashOffset_ : '-') + ',' +
        (this.lineJoin_ !== undefined ?
          this.lineJoin_ : '-') + ',' +
        (this.miterLimit_ !== undefined ?
          this.miterLimit_.toString() : '-') + ',' +
        (this.width_ !== undefined ?
          this.width_.toString() : '-');
  }

  return this.checksum_;
};

/* harmony default export */ __webpack_exports__["default"] = (Stroke);

//# sourceMappingURL=Stroke.js.map

/***/ }),

/***/ "./node_modules/ol/style/Style.js":
/*!****************************************!*\
  !*** ./node_modules/ol/style/Style.js ***!
  \****************************************/
/*! exports provided: toFunction, createDefaultStyle, createEditingStyle, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toFunction", function() { return toFunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createDefaultStyle", function() { return createDefaultStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createEditingStyle", function() { return createEditingStyle; });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _Circle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Circle.js */ "./node_modules/ol/style/Circle.js");
/* harmony import */ var _Fill_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Fill.js */ "./node_modules/ol/style/Fill.js");
/* harmony import */ var _Stroke_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Stroke.js */ "./node_modules/ol/style/Stroke.js");
/**
 * @module ol/style/Style
 */

/**
 * Feature styles.
 *
 * If no style is defined, the following default style is used:
 * ```js
 *  import {Fill, Stroke, Circle, Style} from 'ol/style';
 *
 *  var fill = new Fill({
 *    color: 'rgba(255,255,255,0.4)'
 *  });
 *  var stroke = new Stroke({
 *    color: '#3399CC',
 *    width: 1.25
 *  });
 *  var styles = [
 *    new Style({
 *      image: new Circle({
 *        fill: fill,
 *        stroke: stroke,
 *        radius: 5
 *      }),
 *      fill: fill,
 *      stroke: stroke
 *    })
 *  ];
 * ```
 *
 * A separate editing style has the following defaults:
 * ```js
 *  import {Fill, Stroke, Circle, Style} from 'ol/style';
 *  import GeometryType from 'ol/geom/GeometryType';
 *
 *  var white = [255, 255, 255, 1];
 *  var blue = [0, 153, 255, 1];
 *  var width = 3;
 *  styles[GeometryType.POLYGON] = [
 *    new Style({
 *      fill: new Fill({
 *        color: [255, 255, 255, 0.5]
 *      })
 *    })
 *  ];
 *  styles[GeometryType.MULTI_POLYGON] =
 *      styles[GeometryType.POLYGON];
 *  styles[GeometryType.LINE_STRING] = [
 *    new Style({
 *      stroke: new Stroke({
 *        color: white,
 *        width: width + 2
 *      })
 *    }),
 *    new Style({
 *      stroke: new Stroke({
 *        color: blue,
 *        width: width
 *      })
 *    })
 *  ];
 *  styles[GeometryType.MULTI_LINE_STRING] =
 *      styles[GeometryType.LINE_STRING];
 *  styles[GeometryType.POINT] = [
 *    new Style({
 *      image: new Circle({
 *        radius: width * 2,
 *        fill: new Fill({
 *          color: blue
 *        }),
 *        stroke: new Stroke({
 *          color: white,
 *          width: width / 2
 *        })
 *      }),
 *      zIndex: Infinity
 *    })
 *  ];
 *  styles[GeometryType.MULTI_POINT] =
 *      styles[GeometryType.POINT];
 *  styles[GeometryType.GEOMETRY_COLLECTION] =
 *      styles[GeometryType.POLYGON].concat(
 *          styles[GeometryType.LINE_STRING],
 *          styles[GeometryType.POINT]
 *      );
 * ```
 */







/**
 * A function that takes an {@link module:ol/Feature} and a `{number}`
 * representing the view's resolution. The function should return a
 * {@link module:ol/style/Style} or an array of them. This way e.g. a
 * vector layer can be styled.
 *
 * @typedef {function(import("../Feature.js").FeatureLike, number):(Style|Array<Style>)} StyleFunction
 */

/**
 * A {@link Style}, an array of {@link Style}, or a {@link StyleFunction}.
 * @typedef {Style|Array<Style>|StyleFunction} StyleLike
 */

/**
 * A function that takes an {@link module:ol/Feature} as argument and returns an
 * {@link module:ol/geom/Geometry} that will be rendered and styled for the feature.
 *
 * @typedef {function(import("../Feature.js").FeatureLike):
 *     (import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined)} GeometryFunction
 */


/**
 * Custom renderer function. Takes two arguments:
 *
 * 1. The pixel coordinates of the geometry in GeoJSON notation.
 * 2. The {@link module:ol/render~State} of the layer renderer.
 *
 * @typedef {function((import("../coordinate.js").Coordinate|Array<import("../coordinate.js").Coordinate>|Array<Array<import("../coordinate.js").Coordinate>>),import("../render.js").State)}
 * RenderFunction
 */


/**
 * @typedef {Object} Options
 * @property {string|import("../geom/Geometry.js").default|GeometryFunction} [geometry] Feature property or geometry
 * or function returning a geometry to render for this style.
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {import("./Image.js").default} [image] Image style.
 * @property {RenderFunction} [renderer] Custom renderer. When configured, `fill`, `stroke` and `image` will be
 * ignored, and the provided function will be called with each render frame for each geometry.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {import("./Text.js").default} [text] Text style.
 * @property {number} [zIndex] Z index.
 */

/**
 * @classdesc
 * Container for vector feature rendering styles. Any changes made to the style
 * or its children through `set*()` methods will not take effect until the
 * feature or layer that uses the style is re-rendered.
 * @api
 */
var Style = function Style(opt_options) {

  var options = opt_options || {};

  /**
   * @private
   * @type {string|import("../geom/Geometry.js").default|GeometryFunction}
   */
  this.geometry_ = null;

  /**
   * @private
   * @type {!GeometryFunction}
   */
  this.geometryFunction_ = defaultGeometryFunction;

  if (options.geometry !== undefined) {
    this.setGeometry(options.geometry);
  }

  /**
   * @private
   * @type {import("./Fill.js").default}
   */
  this.fill_ = options.fill !== undefined ? options.fill : null;

  /**
     * @private
     * @type {import("./Image.js").default}
     */
  this.image_ = options.image !== undefined ? options.image : null;

  /**
   * @private
   * @type {RenderFunction|null}
   */
  this.renderer_ = options.renderer !== undefined ? options.renderer : null;

  /**
   * @private
   * @type {import("./Stroke.js").default}
   */
  this.stroke_ = options.stroke !== undefined ? options.stroke : null;

  /**
   * @private
   * @type {import("./Text.js").default}
   */
  this.text_ = options.text !== undefined ? options.text : null;

  /**
   * @private
   * @type {number|undefined}
   */
  this.zIndex_ = options.zIndex;

};

/**
 * Clones the style.
 * @return {Style} The cloned style.
 * @api
 */
Style.prototype.clone = function clone () {
  var geometry = this.getGeometry();
  if (geometry && typeof geometry === 'object') {
    geometry = /** @type {import("../geom/Geometry.js").default} */ (geometry).clone();
  }
  return new Style({
    geometry: geometry,
    fill: this.getFill() ? this.getFill().clone() : undefined,
    image: this.getImage() ? this.getImage().clone() : undefined,
    stroke: this.getStroke() ? this.getStroke().clone() : undefined,
    text: this.getText() ? this.getText().clone() : undefined,
    zIndex: this.getZIndex()
  });
};

/**
 * Get the custom renderer function that was configured with
 * {@link #setRenderer} or the `renderer` constructor option.
 * @return {RenderFunction|null} Custom renderer function.
 * @api
 */
Style.prototype.getRenderer = function getRenderer () {
  return this.renderer_;
};

/**
 * Sets a custom renderer function for this style. When set, `fill`, `stroke`
 * and `image` options of the style will be ignored.
 * @param {RenderFunction|null} renderer Custom renderer function.
 * @api
 */
Style.prototype.setRenderer = function setRenderer (renderer) {
  this.renderer_ = renderer;
};

/**
 * Get the geometry to be rendered.
 * @return {string|import("../geom/Geometry.js").default|GeometryFunction}
 * Feature property or geometry or function that returns the geometry that will
 * be rendered with this style.
 * @api
 */
Style.prototype.getGeometry = function getGeometry () {
  return this.geometry_;
};

/**
 * Get the function used to generate a geometry for rendering.
 * @return {!GeometryFunction} Function that is called with a feature
 * and returns the geometry to render instead of the feature's geometry.
 * @api
 */
Style.prototype.getGeometryFunction = function getGeometryFunction () {
  return this.geometryFunction_;
};

/**
 * Get the fill style.
 * @return {import("./Fill.js").default} Fill style.
 * @api
 */
Style.prototype.getFill = function getFill () {
  return this.fill_;
};

/**
 * Set the fill style.
 * @param {import("./Fill.js").default} fill Fill style.
 * @api
 */
Style.prototype.setFill = function setFill (fill) {
  this.fill_ = fill;
};

/**
 * Get the image style.
 * @return {import("./Image.js").default} Image style.
 * @api
 */
Style.prototype.getImage = function getImage () {
  return this.image_;
};

/**
 * Set the image style.
 * @param {import("./Image.js").default} image Image style.
 * @api
 */
Style.prototype.setImage = function setImage (image) {
  this.image_ = image;
};

/**
 * Get the stroke style.
 * @return {import("./Stroke.js").default} Stroke style.
 * @api
 */
Style.prototype.getStroke = function getStroke () {
  return this.stroke_;
};

/**
 * Set the stroke style.
 * @param {import("./Stroke.js").default} stroke Stroke style.
 * @api
 */
Style.prototype.setStroke = function setStroke (stroke) {
  this.stroke_ = stroke;
};

/**
 * Get the text style.
 * @return {import("./Text.js").default} Text style.
 * @api
 */
Style.prototype.getText = function getText () {
  return this.text_;
};

/**
 * Set the text style.
 * @param {import("./Text.js").default} text Text style.
 * @api
 */
Style.prototype.setText = function setText (text) {
  this.text_ = text;
};

/**
 * Get the z-index for the style.
 * @return {number|undefined} ZIndex.
 * @api
 */
Style.prototype.getZIndex = function getZIndex () {
  return this.zIndex_;
};

/**
 * Set a geometry that is rendered instead of the feature's geometry.
 *
 * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry
 *   Feature property or geometry or function returning a geometry to render
 *   for this style.
 * @api
 */
Style.prototype.setGeometry = function setGeometry (geometry) {
  if (typeof geometry === 'function') {
    this.geometryFunction_ = geometry;
  } else if (typeof geometry === 'string') {
    this.geometryFunction_ = function(feature) {
      return (
        /** @type {import("../geom/Geometry.js").default} */ (feature.get(geometry))
      );
    };
  } else if (!geometry) {
    this.geometryFunction_ = defaultGeometryFunction;
  } else if (geometry !== undefined) {
    this.geometryFunction_ = function() {
      return (
        /** @type {import("../geom/Geometry.js").default} */ (geometry)
      );
    };
  }
  this.geometry_ = geometry;
};

/**
 * Set the z-index.
 *
 * @param {number|undefined} zIndex ZIndex.
 * @api
 */
Style.prototype.setZIndex = function setZIndex (zIndex) {
  this.zIndex_ = zIndex;
};


/**
 * Convert the provided object into a style function.  Functions passed through
 * unchanged.  Arrays of Style or single style objects wrapped in a
 * new style function.
 * @param {StyleFunction|Array<Style>|Style} obj
 *     A style function, a single style, or an array of styles.
 * @return {StyleFunction} A style function.
 */
function toFunction(obj) {
  var styleFunction;

  if (typeof obj === 'function') {
    styleFunction = obj;
  } else {
    /**
     * @type {Array<Style>}
     */
    var styles;
    if (Array.isArray(obj)) {
      styles = obj;
    } else {
      Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(typeof /** @type {?} */ (obj).getZIndex === 'function',
        41); // Expected an `Style` or an array of `Style`
      var style = /** @type {Style} */ (obj);
      styles = [style];
    }
    styleFunction = function() {
      return styles;
    };
  }
  return styleFunction;
}


/**
 * @type {Array<Style>}
 */
var defaultStyles = null;


/**
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {number} resolution Resolution.
 * @return {Array<Style>} Style.
 */
function createDefaultStyle(feature, resolution) {
  // We don't use an immediately-invoked function
  // and a closure so we don't get an error at script evaluation time in
  // browsers that do not support Canvas. (import("./Circle.js").CircleStyle does
  // canvas.getContext('2d') at construction time, which will cause an.error
  // in such browsers.)
  if (!defaultStyles) {
    var fill = new _Fill_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
      color: 'rgba(255,255,255,0.4)'
    });
    var stroke = new _Stroke_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
      color: '#3399CC',
      width: 1.25
    });
    defaultStyles = [
      new Style({
        image: new _Circle_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
          fill: fill,
          stroke: stroke,
          radius: 5
        }),
        fill: fill,
        stroke: stroke
      })
    ];
  }
  return defaultStyles;
}


/**
 * Default styles for editing features.
 * @return {Object<import("../geom/GeometryType.js").default, Array<Style>>} Styles
 */
function createEditingStyle() {
  /** @type {Object<import("../geom/GeometryType.js").default, Array<Style>>} */
  var styles = {};
  var white = [255, 255, 255, 1];
  var blue = [0, 153, 255, 1];
  var width = 3;
  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POLYGON] = [
    new Style({
      fill: new _Fill_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
        color: [255, 255, 255, 0.5]
      })
    })
  ];
  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POLYGON] =
      styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POLYGON];

  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRING] = [
    new Style({
      stroke: new _Stroke_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
        color: white,
        width: width + 2
      })
    }),
    new Style({
      stroke: new _Stroke_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
        color: blue,
        width: width
      })
    })
  ];
  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_LINE_STRING] =
      styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRING];

  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CIRCLE] =
      styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POLYGON].concat(
        styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRING]
      );


  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINT] = [
    new Style({
      image: new _Circle_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
        radius: width * 2,
        fill: new _Fill_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
          color: blue
        }),
        stroke: new _Stroke_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
          color: white,
          width: width / 2
        })
      }),
      zIndex: Infinity
    })
  ];
  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POINT] =
      styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINT];

  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].GEOMETRY_COLLECTION] =
      styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POLYGON].concat(
        styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRING],
        styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINT]
      );

  return styles;
}


/**
 * Function that is called with a feature and returns its default geometry.
 * @param {import("../Feature.js").FeatureLike} feature Feature to get the geometry for.
 * @return {import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined} Geometry to render.
 */
function defaultGeometryFunction(feature) {
  return feature.getGeometry();
}

/* harmony default export */ __webpack_exports__["default"] = (Style);

//# sourceMappingURL=Style.js.map

/***/ }),

/***/ "./node_modules/ol/tilecoord.js":
/*!**************************************!*\
  !*** ./node_modules/ol/tilecoord.js ***!
  \**************************************/
/*! exports provided: createOrUpdate, getKeyZXY, getKey, fromKey, hash, quadKey, withinExtentAndZ */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdate", function() { return createOrUpdate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getKeyZXY", function() { return getKeyZXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getKey", function() { return getKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromKey", function() { return fromKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hash", function() { return hash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quadKey", function() { return quadKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "withinExtentAndZ", function() { return withinExtentAndZ; });
/**
 * @module ol/tilecoord
 */


/**
 * An array of three numbers representing the location of a tile in a tile
 * grid. The order is `z`, `x`, and `y`. `z` is the zoom level.
 * @typedef {Array<number>} TileCoord
 * @api
 */


/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {TileCoord=} opt_tileCoord Tile coordinate.
 * @return {TileCoord} Tile coordinate.
 */
function createOrUpdate(z, x, y, opt_tileCoord) {
  if (opt_tileCoord !== undefined) {
    opt_tileCoord[0] = z;
    opt_tileCoord[1] = x;
    opt_tileCoord[2] = y;
    return opt_tileCoord;
  } else {
    return [z, x, y];
  }
}


/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {string} Key.
 */
function getKeyZXY(z, x, y) {
  return z + '/' + x + '/' + y;
}


/**
 * Get the key for a tile coord.
 * @param {TileCoord} tileCoord The tile coord.
 * @return {string} Key.
 */
function getKey(tileCoord) {
  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
}


/**
 * Get a tile coord given a key.
 * @param {string} key The tile coord key.
 * @return {TileCoord} The tile coord.
 */
function fromKey(key) {
  return key.split('/').map(Number);
}


/**
 * @param {TileCoord} tileCoord Tile coord.
 * @return {number} Hash.
 */
function hash(tileCoord) {
  return (tileCoord[1] << tileCoord[0]) + tileCoord[2];
}


/**
 * @param {TileCoord} tileCoord Tile coord.
 * @return {string} Quad key.
 */
function quadKey(tileCoord) {
  var z = tileCoord[0];
  var digits = new Array(z);
  var mask = 1 << (z - 1);
  var i, charCode;
  for (i = 0; i < z; ++i) {
    // 48 is charCode for 0 - '0'.charCodeAt(0)
    charCode = 48;
    if (tileCoord[1] & mask) {
      charCode += 1;
    }
    if (tileCoord[2] & mask) {
      charCode += 2;
    }
    digits[i] = String.fromCharCode(charCode);
    mask >>= 1;
  }
  return digits.join('');
}


/**
 * @param {TileCoord} tileCoord Tile coordinate.
 * @param {!import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {boolean} Tile coordinate is within extent and zoom level range.
 */
function withinExtentAndZ(tileCoord, tileGrid) {
  var z = tileCoord[0];
  var x = tileCoord[1];
  var y = tileCoord[2];

  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {
    return false;
  }
  var extent = tileGrid.getExtent();
  var tileRange;
  if (!extent) {
    tileRange = tileGrid.getFullTileRange(z);
  } else {
    tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
  }
  if (!tileRange) {
    return true;
  } else {
    return tileRange.containsXY(x, y);
  }
}

//# sourceMappingURL=tilecoord.js.map

/***/ }),

/***/ "./node_modules/ol/tilegrid.js":
/*!*************************************!*\
  !*** ./node_modules/ol/tilegrid.js ***!
  \*************************************/
/*! exports provided: getForProjection, wrapX, createForExtent, createXYZ, createForProjection, extentFromProjection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getForProjection", function() { return getForProjection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wrapX", function() { return wrapX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createForExtent", function() { return createForExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createXYZ", function() { return createXYZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createForProjection", function() { return createForProjection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extentFromProjection", function() { return extentFromProjection; });
/* harmony import */ var _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tilegrid/common.js */ "./node_modules/ol/tilegrid/common.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./size.js */ "./node_modules/ol/size.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _extent_Corner_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./extent/Corner.js */ "./node_modules/ol/extent/Corner.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _proj_Units_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./proj/Units.js */ "./node_modules/ol/proj/Units.js");
/* harmony import */ var _tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./tilegrid/TileGrid.js */ "./node_modules/ol/tilegrid/TileGrid.js");
/**
 * @module ol/tilegrid
 */









/**
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {!TileGrid} Default tile grid for the
 * passed projection.
 */
function getForProjection(projection) {
  var tileGrid = projection.getDefaultTileGrid();
  if (!tileGrid) {
    tileGrid = createForProjection(projection);
    projection.setDefaultTileGrid(tileGrid);
  }
  return tileGrid;
}


/**
 * @param {TileGrid} tileGrid Tile grid.
 * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {import("./tilecoord.js").TileCoord} Tile coordinate.
 */
function wrapX(tileGrid, tileCoord, projection) {
  var z = tileCoord[0];
  var center = tileGrid.getTileCoordCenter(tileCoord);
  var projectionExtent = extentFromProjection(projection);
  if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["containsCoordinate"])(projectionExtent, center)) {
    var worldWidth = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["getWidth"])(projectionExtent);
    var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);
    center[0] += worldWidth * worldsAway;
    return tileGrid.getTileCoordForCoordAndZ(center, z);
  } else {
    return tileCoord;
  }
}


/**
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number=} opt_maxZoom Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size=} opt_tileSize Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {Corner=} opt_corner Extent corner (default is `'top-left'`).
 * @return {!TileGrid} TileGrid instance.
 */
function createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner) {
  var corner = opt_corner !== undefined ? opt_corner : _extent_Corner_js__WEBPACK_IMPORTED_MODULE_3__["default"].TOP_LEFT;

  var resolutions = resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize);

  return new _tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_6__["default"]({
    extent: extent,
    origin: Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["getCorner"])(extent, corner),
    resolutions: resolutions,
    tileSize: opt_tileSize
  });
}


/**
 * @typedef {Object} XYZOptions
 * @property {import("./extent.js").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the
 * top-left corner of the extent. The zero level of the grid is defined by the resolution at which one tile fits in the
 * provided extent. If not provided, the extent of the EPSG:3857 projection is used.
 * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels
 * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.
 * @property {number} [minZoom=0] Minimum zoom.
 * @property {number|import("./size.js").Size} [tileSize=[256, 256]] Tile size in pixels.
 */


/**
 * Creates a tile grid with a standard XYZ tiling scheme.
 * @param {XYZOptions=} opt_options Tile grid options.
 * @return {!TileGrid} Tile grid instance.
 * @api
 */
function createXYZ(opt_options) {
  /** @type {XYZOptions} */
  var xyzOptions = opt_options || {};

  var extent = xyzOptions.extent || Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__["get"])('EPSG:3857').getExtent();

  /** @type {import("./tilegrid/TileGrid.js").Options} */
  var gridOptions = {
    extent: extent,
    minZoom: xyzOptions.minZoom,
    tileSize: xyzOptions.tileSize,
    resolutions: resolutionsFromExtent(
      extent,
      xyzOptions.maxZoom,
      xyzOptions.tileSize
    )
  };
  return new _tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_6__["default"](gridOptions);
}


/**
 * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number=} opt_maxZoom Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size=} opt_tileSize Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @return {!Array<number>} Resolutions array.
 */
function resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize) {
  var maxZoom = opt_maxZoom !== undefined ?
    opt_maxZoom : _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_MAX_ZOOM"];

  var height = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["getHeight"])(extent);
  var width = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["getWidth"])(extent);

  var tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_1__["toSize"])(opt_tileSize !== undefined ?
    opt_tileSize : _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_TILE_SIZE"]);
  var maxResolution = Math.max(
    width / tileSize[0], height / tileSize[1]);

  var length = maxZoom + 1;
  var resolutions = new Array(length);
  for (var z = 0; z < length; ++z) {
    resolutions[z] = maxResolution / Math.pow(2, z);
  }
  return resolutions;
}


/**
 * @param {import("./proj.js").ProjectionLike} projection Projection.
 * @param {number=} opt_maxZoom Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size=} opt_tileSize Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {Corner=} opt_corner Extent corner (default is `'top-left'`).
 * @return {!TileGrid} TileGrid instance.
 */
function createForProjection(projection, opt_maxZoom, opt_tileSize, opt_corner) {
  var extent = extentFromProjection(projection);
  return createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner);
}


/**
 * Generate a tile grid extent from a projection.  If the projection has an
 * extent, it is used.  If not, a global extent is assumed.
 * @param {import("./proj.js").ProjectionLike} projection Projection.
 * @return {import("./extent.js").Extent} Extent.
 */
function extentFromProjection(projection) {
  projection = Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__["get"])(projection);
  var extent = projection.getExtent();
  if (!extent) {
    var half = 180 * _proj_js__WEBPACK_IMPORTED_MODULE_4__["METERS_PER_UNIT"][_proj_Units_js__WEBPACK_IMPORTED_MODULE_5__["default"].DEGREES] / projection.getMetersPerUnit();
    extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["createOrUpdate"])(-half, -half, half, half);
  }
  return extent;
}

//# sourceMappingURL=tilegrid.js.map

/***/ }),

/***/ "./node_modules/ol/tilegrid/TileGrid.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/tilegrid/TileGrid.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/ol/tilegrid/common.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _TileRange_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../TileRange.js */ "./node_modules/ol/TileRange.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../size.js */ "./node_modules/ol/size.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");
/**
 * @module ol/tilegrid/TileGrid
 */










/**
 * @private
 * @type {import("../tilecoord.js").TileCoord}
 */
var tmpTileCoord = [0, 0, 0];


/**
 * @typedef {Object} Options
 * @property {import("../extent.js").Extent} [extent] Extent for the tile grid. No tiles outside this
 * extent will be requested by {@link module:ol/source/Tile} sources. When no `origin` or
 * `origins` are configured, the `origin` will be set to the top-left corner of the extent.
 * @property {number} [minZoom=0] Minimum zoom.
 * @property {import("../coordinate.js").Coordinate} [origin] The tile grid origin, i.e. where the `x`
 * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and upwards. If not
 * specified, `extent` or `origins` must be provided.
 * @property {Array<import("../coordinate.js").Coordinate>} [origins] Tile grid origins, i.e. where
 * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length
 * should match the length of the `resolutions` array, i.e. each resolution can have a different
 * origin. Tile coordinates increase left to right and upwards. If not specified, `extent` or
 * `origin` must be provided.
 * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs
 * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions
 * array will have a length of `maxZoom + 1`.
 * @property {Array<import("../size.js").Size>} [sizes] Sizes.
 * @property {number|import("../size.js").Size} [tileSize] Tile size.
 * Default is `[256, 256]`.
 * @property {Array<import("../size.js").Size>} [tileSizes] Tile sizes. If given, the array length
 * should match the length of the `resolutions` array, i.e. each resolution can have a different
 * tile size.
 */


/**
 * @classdesc
 * Base class for setting the grid pattern for sources accessing tiled-image
 * servers.
 * @api
 */
var TileGrid = function TileGrid(options) {

  /**
   * @protected
   * @type {number}
   */
  this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;

  /**
   * @private
   * @type {!Array<number>}
   */
  this.resolutions_ = options.resolutions;
  Object(_asserts_js__WEBPACK_IMPORTED_MODULE_1__["assert"])(Object(_array_js__WEBPACK_IMPORTED_MODULE_3__["isSorted"])(this.resolutions_, function(a, b) {
    return b - a;
  }, true), 17); // `resolutions` must be sorted in descending order


  // check if we've got a consistent zoom factor and origin
  var zoomFactor;
  if (!options.origins) {
    for (var i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {
      if (!zoomFactor) {
        zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];
      } else {
        if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {
          zoomFactor = undefined;
          break;
        }
      }
    }
  }


  /**
   * @private
   * @type {number|undefined}
   */
  this.zoomFactor_ = zoomFactor;


  /**
   * @protected
   * @type {number}
   */
  this.maxZoom = this.resolutions_.length - 1;

  /**
   * @private
   * @type {import("../coordinate.js").Coordinate}
   */
  this.origin_ = options.origin !== undefined ? options.origin : null;

  /**
   * @private
   * @type {Array<import("../coordinate.js").Coordinate>}
   */
  this.origins_ = null;
  if (options.origins !== undefined) {
    this.origins_ = options.origins;
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_1__["assert"])(this.origins_.length == this.resolutions_.length,
      20); // Number of `origins` and `resolutions` must be equal
  }

  var extent = options.extent;

  if (extent !== undefined &&
      !this.origin_ && !this.origins_) {
    this.origin_ = Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["getTopLeft"])(extent);
  }

  Object(_asserts_js__WEBPACK_IMPORTED_MODULE_1__["assert"])(
    (!this.origin_ && this.origins_) || (this.origin_ && !this.origins_),
    18); // Either `origin` or `origins` must be configured, never both

  /**
   * @private
   * @type {Array<number|import("../size.js").Size>}
   */
  this.tileSizes_ = null;
  if (options.tileSizes !== undefined) {
    this.tileSizes_ = options.tileSizes;
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_1__["assert"])(this.tileSizes_.length == this.resolutions_.length,
      19); // Number of `tileSizes` and `resolutions` must be equal
  }

  /**
   * @private
   * @type {number|import("../size.js").Size}
   */
  this.tileSize_ = options.tileSize !== undefined ?
    options.tileSize :
    !this.tileSizes_ ? _common_js__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_TILE_SIZE"] : null;
  Object(_asserts_js__WEBPACK_IMPORTED_MODULE_1__["assert"])(
    (!this.tileSize_ && this.tileSizes_) ||
      (this.tileSize_ && !this.tileSizes_),
    22); // Either `tileSize` or `tileSizes` must be configured, never both

  /**
   * @private
   * @type {import("../extent.js").Extent}
   */
  this.extent_ = extent !== undefined ? extent : null;


  /**
   * @private
   * @type {Array<import("../TileRange.js").default>}
   */
  this.fullTileRanges_ = null;

  /**
   * @private
   * @type {import("../size.js").Size}
   */
  this.tmpSize_ = [0, 0];

  if (options.sizes !== undefined) {
    this.fullTileRanges_ = options.sizes.map(function(size, z) {
      var tileRange = new _TileRange_js__WEBPACK_IMPORTED_MODULE_2__["default"](
        Math.min(0, size[0]), Math.max(size[0] - 1, -1),
        Math.min(0, size[1]), Math.max(size[1] - 1, -1));
      return tileRange;
    }, this);
  } else if (extent) {
    this.calculateTileRanges_(extent);
  }

};

/**
 * Call a function with each tile coordinate for a given extent and zoom level.
 *
 * @param {import("../extent.js").Extent} extent Extent.
 * @param {number} zoom Integer zoom level.
 * @param {function(import("../tilecoord.js").TileCoord)} callback Function called with each tile coordinate.
 * @api
 */
TileGrid.prototype.forEachTileCoord = function forEachTileCoord (extent, zoom, callback) {
  var tileRange = this.getTileRangeForExtentAndZ(extent, zoom);
  for (var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {
    for (var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {
      callback([zoom, i, j]);
    }
  }
};

/**
 * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @param {function(this: T, number, import("../TileRange.js").default): boolean} callback Callback.
 * @param {T=} opt_this The object to use as `this` in `callback`.
 * @param {import("../TileRange.js").default=} opt_tileRange Temporary import("../TileRange.js").default object.
 * @param {import("../extent.js").Extent=} opt_extent Temporary import("../extent.js").Extent object.
 * @return {boolean} Callback succeeded.
 * @template T
 */
TileGrid.prototype.forEachTileCoordParentTileRange = function forEachTileCoordParentTileRange (tileCoord, callback, opt_this, opt_tileRange, opt_extent) {
  var tileRange, x, y;
  var tileCoordExtent = null;
  var z = tileCoord[0] - 1;
  if (this.zoomFactor_ === 2) {
    x = tileCoord[1];
    y = tileCoord[2];
  } else {
    tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
  }
  while (z >= this.minZoom) {
    if (this.zoomFactor_ === 2) {
      x = Math.floor(x / 2);
      y = Math.floor(y / 2);
      tileRange = Object(_TileRange_js__WEBPACK_IMPORTED_MODULE_2__["createOrUpdate"])(x, x, y, y, opt_tileRange);
    } else {
      tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);
    }
    if (callback.call(opt_this, z, tileRange)) {
      return true;
    }
    --z;
  }
  return false;
};

/**
 * Get the extent for this tile grid, if it was configured.
 * @return {import("../extent.js").Extent} Extent.
 */
TileGrid.prototype.getExtent = function getExtent () {
  return this.extent_;
};

/**
 * Get the maximum zoom level for the grid.
 * @return {number} Max zoom.
 * @api
 */
TileGrid.prototype.getMaxZoom = function getMaxZoom () {
  return this.maxZoom;
};

/**
 * Get the minimum zoom level for the grid.
 * @return {number} Min zoom.
 * @api
 */
TileGrid.prototype.getMinZoom = function getMinZoom () {
  return this.minZoom;
};

/**
 * Get the origin for the grid at the given zoom level.
 * @param {number} z Integer zoom level.
 * @return {import("../coordinate.js").Coordinate} Origin.
 * @api
 */
TileGrid.prototype.getOrigin = function getOrigin (z) {
  if (this.origin_) {
    return this.origin_;
  } else {
    return this.origins_[z];
  }
};

/**
 * Get the resolution for the given zoom level.
 * @param {number} z Integer zoom level.
 * @return {number} Resolution.
 * @api
 */
TileGrid.prototype.getResolution = function getResolution (z) {
  return this.resolutions_[z];
};

/**
 * Get the list of resolutions for the tile grid.
 * @return {Array<number>} Resolutions.
 * @api
 */
TileGrid.prototype.getResolutions = function getResolutions () {
  return this.resolutions_;
};

/**
 * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @param {import("../TileRange.js").default=} opt_tileRange Temporary import("../TileRange.js").default object.
 * @param {import("../extent.js").Extent=} opt_extent Temporary import("../extent.js").Extent object.
 * @return {import("../TileRange.js").default} Tile range.
 */
TileGrid.prototype.getTileCoordChildTileRange = function getTileCoordChildTileRange (tileCoord, opt_tileRange, opt_extent) {
  if (tileCoord[0] < this.maxZoom) {
    if (this.zoomFactor_ === 2) {
      var minX = tileCoord[1] * 2;
      var minY = tileCoord[2] * 2;
      return Object(_TileRange_js__WEBPACK_IMPORTED_MODULE_2__["createOrUpdate"])(minX, minX + 1, minY, minY + 1, opt_tileRange);
    }
    var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
    return this.getTileRangeForExtentAndZ(
      tileCoordExtent, tileCoord[0] + 1, opt_tileRange);
  }
  return null;
};

/**
 * Get the extent for a tile range.
 * @param {number} z Integer zoom level.
 * @param {import("../TileRange.js").default} tileRange Tile range.
 * @param {import("../extent.js").Extent=} opt_extent Temporary import("../extent.js").Extent object.
 * @return {import("../extent.js").Extent} Extent.
 */
TileGrid.prototype.getTileRangeExtent = function getTileRangeExtent (z, tileRange, opt_extent) {
  var origin = this.getOrigin(z);
  var resolution = this.getResolution(z);
  var tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_6__["toSize"])(this.getTileSize(z), this.tmpSize_);
  var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;
  var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;
  var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;
  var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;
  return Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["createOrUpdate"])(minX, minY, maxX, maxY, opt_extent);
};

/**
 * Get a tile range for the given extent and integer zoom level.
 * @param {import("../extent.js").Extent} extent Extent.
 * @param {number} z Integer zoom level.
 * @param {import("../TileRange.js").default=} opt_tileRange Temporary tile range object.
 * @return {import("../TileRange.js").default} Tile range.
 */
TileGrid.prototype.getTileRangeForExtentAndZ = function getTileRangeForExtentAndZ (extent, z, opt_tileRange) {
  var tileCoord = tmpTileCoord;
  this.getTileCoordForXYAndZ_(extent[0], extent[1], z, false, tileCoord);
  var minX = tileCoord[1];
  var minY = tileCoord[2];
  this.getTileCoordForXYAndZ_(extent[2], extent[3], z, true, tileCoord);
  return Object(_TileRange_js__WEBPACK_IMPORTED_MODULE_2__["createOrUpdate"])(minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);
};

/**
 * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @return {import("../coordinate.js").Coordinate} Tile center.
 */
TileGrid.prototype.getTileCoordCenter = function getTileCoordCenter (tileCoord) {
  var origin = this.getOrigin(tileCoord[0]);
  var resolution = this.getResolution(tileCoord[0]);
  var tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_6__["toSize"])(this.getTileSize(tileCoord[0]), this.tmpSize_);
  return [
    origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,
    origin[1] + (tileCoord[2] + 0.5) * tileSize[1] * resolution
  ];
};

/**
 * Get the extent of a tile coordinate.
 *
 * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @param {import("../extent.js").Extent=} opt_extent Temporary extent object.
 * @return {import("../extent.js").Extent} Extent.
 * @api
 */
TileGrid.prototype.getTileCoordExtent = function getTileCoordExtent (tileCoord, opt_extent) {
  var origin = this.getOrigin(tileCoord[0]);
  var resolution = this.getResolution(tileCoord[0]);
  var tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_6__["toSize"])(this.getTileSize(tileCoord[0]), this.tmpSize_);
  var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
  var minY = origin[1] + tileCoord[2] * tileSize[1] * resolution;
  var maxX = minX + tileSize[0] * resolution;
  var maxY = minY + tileSize[1] * resolution;
  return Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["createOrUpdate"])(minX, minY, maxX, maxY, opt_extent);
};

/**
 * Get the tile coordinate for the given map coordinate and resolution.This
 * method considers that coordinates that intersect tile boundaries should be
 * assigned the higher tile coordinate.
 *
 * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
 * @param {number} resolution Resolution.
 * @param {import("../tilecoord.js").TileCoord=} opt_tileCoord Destination import("../tilecoord.js").TileCoord object.
 * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
 * @api
 */
TileGrid.prototype.getTileCoordForCoordAndResolution = function getTileCoordForCoordAndResolution (coordinate, resolution, opt_tileCoord) {
  return this.getTileCoordForXYAndResolution_(
    coordinate[0], coordinate[1], resolution, false, opt_tileCoord);
};

/**
 * Note that this method should not be called for resolutions that correspond
 * to an integer zoom level.Instead call the `getTileCoordForXYAndZ_` method.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} resolution Resolution (for a non-integer zoom level).
 * @param {boolean} reverseIntersectionPolicy Instead of letting edge
 *   intersections go to the higher tile coordinate, let edge intersections
 *   go to the lower tile coordinate.
 * @param {import("../tilecoord.js").TileCoord=} opt_tileCoord Temporary import("../tilecoord.js").TileCoord object.
 * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
 * @private
 */
TileGrid.prototype.getTileCoordForXYAndResolution_ = function getTileCoordForXYAndResolution_ (x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {
  var z = this.getZForResolution(resolution);
  var scale = resolution / this.getResolution(z);
  var origin = this.getOrigin(z);
  var tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_6__["toSize"])(this.getTileSize(z), this.tmpSize_);

  var adjustX = reverseIntersectionPolicy ? 0.5 : 0;
  var adjustY = reverseIntersectionPolicy ? 0 : 0.5;
  var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);
  var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);
  var tileCoordX = scale * xFromOrigin / tileSize[0];
  var tileCoordY = scale * yFromOrigin / tileSize[1];

  if (reverseIntersectionPolicy) {
    tileCoordX = Math.ceil(tileCoordX) - 1;
    tileCoordY = Math.ceil(tileCoordY) - 1;
  } else {
    tileCoordX = Math.floor(tileCoordX);
    tileCoordY = Math.floor(tileCoordY);
  }

  return Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_7__["createOrUpdate"])(z, tileCoordX, tileCoordY, opt_tileCoord);
};

/**
 * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
 * they should have separate implementations.This method is for integer zoom
 * levels.The other method should only be called for resolutions corresponding
 * to non-integer zoom levels.
 * @param {number} x Map x coordinate.
 * @param {number} y Map y coordinate.
 * @param {number} z Integer zoom level.
 * @param {boolean} reverseIntersectionPolicy Instead of letting edge
 *   intersections go to the higher tile coordinate, let edge intersections
 *   go to the lower tile coordinate.
 * @param {import("../tilecoord.js").TileCoord=} opt_tileCoord Temporary import("../tilecoord.js").TileCoord object.
 * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
 * @private
 */
TileGrid.prototype.getTileCoordForXYAndZ_ = function getTileCoordForXYAndZ_ (x, y, z, reverseIntersectionPolicy, opt_tileCoord) {
  var origin = this.getOrigin(z);
  var resolution = this.getResolution(z);
  var tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_6__["toSize"])(this.getTileSize(z), this.tmpSize_);

  var adjustX = reverseIntersectionPolicy ? 0.5 : 0;
  var adjustY = reverseIntersectionPolicy ? 0 : 0.5;
  var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);
  var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);
  var tileCoordX = xFromOrigin / tileSize[0];
  var tileCoordY = yFromOrigin / tileSize[1];

  if (reverseIntersectionPolicy) {
    tileCoordX = Math.ceil(tileCoordX) - 1;
    tileCoordY = Math.ceil(tileCoordY) - 1;
  } else {
    tileCoordX = Math.floor(tileCoordX);
    tileCoordY = Math.floor(tileCoordY);
  }

  return Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_7__["createOrUpdate"])(z, tileCoordX, tileCoordY, opt_tileCoord);
};

/**
 * Get a tile coordinate given a map coordinate and zoom level.
 * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
 * @param {number} z Zoom level.
 * @param {import("../tilecoord.js").TileCoord=} opt_tileCoord Destination import("../tilecoord.js").TileCoord object.
 * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
 * @api
 */
TileGrid.prototype.getTileCoordForCoordAndZ = function getTileCoordForCoordAndZ (coordinate, z, opt_tileCoord) {
  return this.getTileCoordForXYAndZ_(
    coordinate[0], coordinate[1], z, false, opt_tileCoord);
};

/**
 * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @return {number} Tile resolution.
 */
TileGrid.prototype.getTileCoordResolution = function getTileCoordResolution (tileCoord) {
  return this.resolutions_[tileCoord[0]];
};

/**
 * Get the tile size for a zoom level. The type of the return value matches the
 * `tileSize` or `tileSizes` that the tile grid was configured with. To always
 * get an `import("../size.js").Size`, run the result through `import("../size.js").Size.toSize()`.
 * @param {number} z Z.
 * @return {number|import("../size.js").Size} Tile size.
 * @api
 */
TileGrid.prototype.getTileSize = function getTileSize (z) {
  if (this.tileSize_) {
    return this.tileSize_;
  } else {
    return this.tileSizes_[z];
  }
};

/**
 * @param {number} z Zoom level.
 * @return {import("../TileRange.js").default} Extent tile range for the specified zoom level.
 */
TileGrid.prototype.getFullTileRange = function getFullTileRange (z) {
  if (!this.fullTileRanges_) {
    return null;
  } else {
    return this.fullTileRanges_[z];
  }
};

/**
 * @param {number} resolution Resolution.
 * @param {number=} opt_direction If 0, the nearest resolution will be used.
 *   If 1, the nearest lower resolution will be used. If -1, the nearest
 *   higher resolution will be used. Default is 0.
 * @return {number} Z.
 * @api
 */
TileGrid.prototype.getZForResolution = function getZForResolution (resolution, opt_direction) {
  var z = Object(_array_js__WEBPACK_IMPORTED_MODULE_3__["linearFindNearest"])(this.resolutions_, resolution, opt_direction || 0);
  return Object(_math_js__WEBPACK_IMPORTED_MODULE_5__["clamp"])(z, this.minZoom, this.maxZoom);
};

/**
 * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
 * @private
 */
TileGrid.prototype.calculateTileRanges_ = function calculateTileRanges_ (extent) {
  var length = this.resolutions_.length;
  var fullTileRanges = new Array(length);
  for (var z = this.minZoom; z < length; ++z) {
    fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);
  }
  this.fullTileRanges_ = fullTileRanges;
};


/* harmony default export */ __webpack_exports__["default"] = (TileGrid);

//# sourceMappingURL=TileGrid.js.map

/***/ }),

/***/ "./node_modules/ol/tilegrid/WMTS.js":
/*!******************************************!*\
  !*** ./node_modules/ol/tilegrid/WMTS.js ***!
  \******************************************/
/*! exports provided: default, createFromCapabilitiesMatrixSet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createFromCapabilitiesMatrixSet", function() { return createFromCapabilitiesMatrixSet; });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _TileGrid_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TileGrid.js */ "./node_modules/ol/tilegrid/TileGrid.js");
/**
 * @module ol/tilegrid/WMTS
 */






/**
 * @typedef {Object} Options
 * @property {import("../extent.js").Extent} [extent] Extent for the tile grid. No tiles
 * outside this extent will be requested by {@link module:ol/source/Tile} sources.
 * When no `origin` or `origins` are configured, the `origin` will be set to the
 * top-left corner of the extent.
 * @property {import("../coordinate.js").Coordinate} [origin] The tile grid origin, i.e.
 * where the `x` and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left
 * to right and upwards. If not specified, `extent` or `origins` must be provided.
 * @property {Array<import("../coordinate.js").Coordinate>} [origins] Tile grid origins,
 * i.e. where the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If
 * given, the array length should match the length of the `resolutions` array, i.e.
 * each resolution can have a different origin. Tile coordinates increase left to
 * right and upwards. If not specified, `extent` or `origin` must be provided.
 * @property {!Array<number>} resolutions Resolutions. The array index of each
 * resolution needs to match the zoom level. This means that even if a `minZoom`
 * is configured, the resolutions array will have a length of `maxZoom + 1`
 * @property {!Array<string>} matrixIds matrix IDs. The length of this array needs
 * to match the length of the `resolutions` array.
 * @property {Array<import("../size.js").Size>} [sizes] Number of tile rows and columns
 * of the grid for each zoom level. The values here are the `TileMatrixWidth` and
 * `TileMatrixHeight` advertised in the GetCapabilities response of the WMTS, and
 * define the grid's extent together with the `origin`.
 * An `extent` can be configured in addition, and will further limit the extent for
 * which tile requests are made by sources. Note that when the top-left corner of
 * the `extent` is used as `origin` or `origins`, then the `y` value must be
 * negative because OpenLayers tile coordinates increase upwards.
 * @property {number|import("../size.js").Size} [tileSize] Tile size.
 * @property {Array<import("../size.js").Size>} [tileSizes] Tile sizes. The length of
 * this array needs to match the length of the `resolutions` array.
 * @property {Array<number>} [widths] Number of tile columns that cover the grid's
 * extent for each zoom level. Only required when used with a source that has `wrapX`
 * set to `true`, and only when the grid's origin differs from the one of the
 * projection's extent. The array length has to match the length of the `resolutions`
 * array, i.e. each resolution will have a matching entry here.
 */


/**
 * @classdesc
 * Set the grid pattern for sources accessing WMTS tiled-image servers.
 * @api
 */
var WMTSTileGrid = /*@__PURE__*/(function (TileGrid) {
  function WMTSTileGrid(options) {
    TileGrid.call(this, {
      extent: options.extent,
      origin: options.origin,
      origins: options.origins,
      resolutions: options.resolutions,
      tileSize: options.tileSize,
      tileSizes: options.tileSizes,
      sizes: options.sizes
    });

    /**
     * @private
     * @type {!Array<string>}
     */
    this.matrixIds_ = options.matrixIds;
  }

  if ( TileGrid ) WMTSTileGrid.__proto__ = TileGrid;
  WMTSTileGrid.prototype = Object.create( TileGrid && TileGrid.prototype );
  WMTSTileGrid.prototype.constructor = WMTSTileGrid;

  /**
   * @param {number} z Z.
   * @return {string} MatrixId..
   */
  WMTSTileGrid.prototype.getMatrixId = function getMatrixId (z) {
    return this.matrixIds_[z];
  };

  /**
   * Get the list of matrix identifiers.
   * @return {Array<string>} MatrixIds.
   * @api
   */
  WMTSTileGrid.prototype.getMatrixIds = function getMatrixIds () {
    return this.matrixIds_;
  };

  return WMTSTileGrid;
}(_TileGrid_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (WMTSTileGrid);

/**
 * Create a tile grid from a WMTS capabilities matrix set and an
 * optional TileMatrixSetLimits.
 * @param {Object} matrixSet An object representing a matrixSet in the
 *     capabilities document.
 * @param {import("../extent.js").Extent=} opt_extent An optional extent to restrict the tile
 *     ranges the server provides.
 * @param {Array<Object>=} opt_matrixLimits An optional object representing
 *     the available matrices for tileGrid.
 * @return {WMTSTileGrid} WMTS tileGrid instance.
 * @api
 */
function createFromCapabilitiesMatrixSet(matrixSet, opt_extent, opt_matrixLimits) {

  /** @type {!Array<number>} */
  var resolutions = [];
  /** @type {!Array<string>} */
  var matrixIds = [];
  /** @type {!Array<import("../coordinate.js").Coordinate>} */
  var origins = [];
  /** @type {!Array<import("../size.js").Size>} */
  var tileSizes = [];
  /** @type {!Array<import("../size.js").Size>} */
  var sizes = [];

  var matrixLimits = opt_matrixLimits !== undefined ? opt_matrixLimits : [];

  var supportedCRSPropName = 'SupportedCRS';
  var matrixIdsPropName = 'TileMatrix';
  var identifierPropName = 'Identifier';
  var scaleDenominatorPropName = 'ScaleDenominator';
  var topLeftCornerPropName = 'TopLeftCorner';
  var tileWidthPropName = 'TileWidth';
  var tileHeightPropName = 'TileHeight';

  var code = matrixSet[supportedCRSPropName];
  var projection = Object(_proj_js__WEBPACK_IMPORTED_MODULE_1__["get"])(code.replace(/urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, '$1:$3')) ||
      Object(_proj_js__WEBPACK_IMPORTED_MODULE_1__["get"])(code);
  var metersPerUnit = projection.getMetersPerUnit();
  // swap origin x and y coordinates if axis orientation is lat/long
  var switchOriginXY = projection.getAxisOrientation().substr(0, 2) == 'ne';

  matrixSet[matrixIdsPropName].sort(function(a, b) {
    return b[scaleDenominatorPropName] - a[scaleDenominatorPropName];
  });

  matrixSet[matrixIdsPropName].forEach(function(elt) {

    var matrixAvailable;
    // use of matrixLimits to filter TileMatrices from GetCapabilities
    // TileMatrixSet from unavailable matrix levels.
    if (matrixLimits.length > 0) {
      matrixAvailable = Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["find"])(matrixLimits, function(elt_ml) {
        if (elt[identifierPropName] == elt_ml[matrixIdsPropName]) {
          return true;
        }
        // Fallback for tileMatrix identifiers that don't get prefixed
        // by their tileMatrixSet identifiers.
        if (elt[identifierPropName].indexOf(':') === -1) {
          return matrixSet[identifierPropName] + ':' + elt[identifierPropName] === elt_ml[matrixIdsPropName];
        }
        return false;
      });
    } else {
      matrixAvailable = true;
    }

    if (matrixAvailable) {
      matrixIds.push(elt[identifierPropName]);
      var resolution = elt[scaleDenominatorPropName] * 0.28E-3 / metersPerUnit;
      var tileWidth = elt[tileWidthPropName];
      var tileHeight = elt[tileHeightPropName];
      if (switchOriginXY) {
        origins.push([elt[topLeftCornerPropName][1],
          elt[topLeftCornerPropName][0]]);
      } else {
        origins.push(elt[topLeftCornerPropName]);
      }
      resolutions.push(resolution);
      tileSizes.push(tileWidth == tileHeight ?
        tileWidth : [tileWidth, tileHeight]);
      // top-left origin, so height is negative
      sizes.push([elt['MatrixWidth'], -elt['MatrixHeight']]);
    }
  });

  return new WMTSTileGrid({
    extent: opt_extent,
    origins: origins,
    resolutions: resolutions,
    matrixIds: matrixIds,
    tileSizes: tileSizes,
    sizes: sizes
  });
}

//# sourceMappingURL=WMTS.js.map

/***/ }),

/***/ "./node_modules/ol/tilegrid/common.js":
/*!********************************************!*\
  !*** ./node_modules/ol/tilegrid/common.js ***!
  \********************************************/
/*! exports provided: DEFAULT_MAX_ZOOM, DEFAULT_TILE_SIZE */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_MAX_ZOOM", function() { return DEFAULT_MAX_ZOOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_TILE_SIZE", function() { return DEFAULT_TILE_SIZE; });
/**
 * @module ol/tilegrid/common
 */

/**
 * Default maximum zoom for default tile grids.
 * @type {number}
 */
var DEFAULT_MAX_ZOOM = 42;

/**
 * Default tile size.
 * @type {number}
 */
var DEFAULT_TILE_SIZE = 256;

//# sourceMappingURL=common.js.map

/***/ }),

/***/ "./node_modules/ol/tileurlfunction.js":
/*!********************************************!*\
  !*** ./node_modules/ol/tileurlfunction.js ***!
  \********************************************/
/*! exports provided: createFromTemplate, createFromTemplates, createFromTileUrlFunctions, nullTileUrlFunction, expandUrl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createFromTemplate", function() { return createFromTemplate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createFromTemplates", function() { return createFromTemplates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createFromTileUrlFunctions", function() { return createFromTileUrlFunctions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nullTileUrlFunction", function() { return nullTileUrlFunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expandUrl", function() { return expandUrl; });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tilecoord.js */ "./node_modules/ol/tilecoord.js");
/**
 * @module ol/tileurlfunction
 */





/**
 * @param {string} template Template.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */
function createFromTemplate(template, tileGrid) {
  var zRegEx = /\{z\}/g;
  var xRegEx = /\{x\}/g;
  var yRegEx = /\{y\}/g;
  var dashYRegEx = /\{-y\}/g;
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return undefined;
      } else {
        return template.replace(zRegEx, tileCoord[0].toString())
          .replace(xRegEx, tileCoord[1].toString())
          .replace(yRegEx, function() {
            var y = -tileCoord[2] - 1;
            return y.toString();
          })
          .replace(dashYRegEx, function() {
            var z = tileCoord[0];
            var range = tileGrid.getFullTileRange(z);
            Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(range, 55); // The {-y} placeholder requires a tile grid with extent
            var y = range.getHeight() + tileCoord[2];
            return y.toString();
          });
      }
    }
  );
}


/**
 * @param {Array<string>} templates Templates.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */
function createFromTemplates(templates, tileGrid) {
  var len = templates.length;
  var tileUrlFunctions = new Array(len);
  for (var i = 0; i < len; ++i) {
    tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);
  }
  return createFromTileUrlFunctions(tileUrlFunctions);
}


/**
 * @param {Array<import("./Tile.js").UrlFunction>} tileUrlFunctions Tile URL Functions.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */
function createFromTileUrlFunctions(tileUrlFunctions) {
  if (tileUrlFunctions.length === 1) {
    return tileUrlFunctions[0];
  }
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return undefined;
      } else {
        var h = Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_2__["hash"])(tileCoord);
        var index = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["modulo"])(h, tileUrlFunctions.length);
        return tileUrlFunctions[index](tileCoord, pixelRatio, projection);
      }
    }
  );
}


/**
 * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @param {number} pixelRatio Pixel ratio.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {string|undefined} Tile URL.
 */
function nullTileUrlFunction(tileCoord, pixelRatio, projection) {
  return undefined;
}


/**
 * @param {string} url URL.
 * @return {Array<string>} Array of urls.
 */
function expandUrl(url) {
  var urls = [];
  var match = /\{([a-z])-([a-z])\}/.exec(url);
  if (match) {
    // char range
    var startCharCode = match[1].charCodeAt(0);
    var stopCharCode = match[2].charCodeAt(0);
    var charCode;
    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
      urls.push(url.replace(match[0], String.fromCharCode(charCode)));
    }
    return urls;
  }
  match = match = /\{(\d+)-(\d+)\}/.exec(url);
  if (match) {
    // number range
    var stop = parseInt(match[2], 10);
    for (var i = parseInt(match[1], 10); i <= stop; i++) {
      urls.push(url.replace(match[0], i.toString()));
    }
    return urls;
  }
  urls.push(url);
  return urls;
}

//# sourceMappingURL=tileurlfunction.js.map

/***/ }),

/***/ "./node_modules/ol/transform.js":
/*!**************************************!*\
  !*** ./node_modules/ol/transform.js ***!
  \**************************************/
/*! exports provided: create, reset, multiply, set, setFromArray, apply, rotate, scale, translate, compose, invert, determinant */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reset", function() { return reset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setFromArray", function() { return setFromArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "apply", function() { return apply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compose", function() { return compose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/**
 * @module ol/transform
 */



/**
 * An array representing an affine 2d transformation for use with
 * {@link module:ol/transform} functions. The array has 6 elements.
 * @typedef {!Array<number>} Transform
 */


/**
 * Collection of affine 2d transformation functions. The functions work on an
 * array of 6 elements. The element order is compatible with the [SVGMatrix
 * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is
 * a subset (elements a to f) of a 3×3 matrix:
 * ```
 * [ a c e ]
 * [ b d f ]
 * [ 0 0 1 ]
 * ```
 */


/**
 * @private
 * @type {Transform}
 */
var tmp_ = new Array(6);


/**
 * Create an identity transform.
 * @return {!Transform} Identity transform.
 */
function create() {
  return [1, 0, 0, 1, 0, 0];
}


/**
 * Resets the given transform to an identity transform.
 * @param {!Transform} transform Transform.
 * @return {!Transform} Transform.
 */
function reset(transform) {
  return set(transform, 1, 0, 0, 1, 0, 0);
}


/**
 * Multiply the underlying matrices of two transforms and return the result in
 * the first transform.
 * @param {!Transform} transform1 Transform parameters of matrix 1.
 * @param {!Transform} transform2 Transform parameters of matrix 2.
 * @return {!Transform} transform1 multiplied with transform2.
 */
function multiply(transform1, transform2) {
  var a1 = transform1[0];
  var b1 = transform1[1];
  var c1 = transform1[2];
  var d1 = transform1[3];
  var e1 = transform1[4];
  var f1 = transform1[5];
  var a2 = transform2[0];
  var b2 = transform2[1];
  var c2 = transform2[2];
  var d2 = transform2[3];
  var e2 = transform2[4];
  var f2 = transform2[5];

  transform1[0] = a1 * a2 + c1 * b2;
  transform1[1] = b1 * a2 + d1 * b2;
  transform1[2] = a1 * c2 + c1 * d2;
  transform1[3] = b1 * c2 + d1 * d2;
  transform1[4] = a1 * e2 + c1 * f2 + e1;
  transform1[5] = b1 * e2 + d1 * f2 + f1;

  return transform1;
}

/**
 * Set the transform components a-f on a given transform.
 * @param {!Transform} transform Transform.
 * @param {number} a The a component of the transform.
 * @param {number} b The b component of the transform.
 * @param {number} c The c component of the transform.
 * @param {number} d The d component of the transform.
 * @param {number} e The e component of the transform.
 * @param {number} f The f component of the transform.
 * @return {!Transform} Matrix with transform applied.
 */
function set(transform, a, b, c, d, e, f) {
  transform[0] = a;
  transform[1] = b;
  transform[2] = c;
  transform[3] = d;
  transform[4] = e;
  transform[5] = f;
  return transform;
}


/**
 * Set transform on one matrix from another matrix.
 * @param {!Transform} transform1 Matrix to set transform to.
 * @param {!Transform} transform2 Matrix to set transform from.
 * @return {!Transform} transform1 with transform from transform2 applied.
 */
function setFromArray(transform1, transform2) {
  transform1[0] = transform2[0];
  transform1[1] = transform2[1];
  transform1[2] = transform2[2];
  transform1[3] = transform2[3];
  transform1[4] = transform2[4];
  transform1[5] = transform2[5];
  return transform1;
}


/**
 * Transforms the given coordinate with the given transform returning the
 * resulting, transformed coordinate. The coordinate will be modified in-place.
 *
 * @param {Transform} transform The transformation.
 * @param {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} coordinate The coordinate to transform.
 * @return {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} return coordinate so that operations can be
 *     chained together.
 */
function apply(transform, coordinate) {
  var x = coordinate[0];
  var y = coordinate[1];
  coordinate[0] = transform[0] * x + transform[2] * y + transform[4];
  coordinate[1] = transform[1] * x + transform[3] * y + transform[5];
  return coordinate;
}


/**
 * Applies rotation to the given transform.
 * @param {!Transform} transform Transform.
 * @param {number} angle Angle in radians.
 * @return {!Transform} The rotated transform.
 */
function rotate(transform, angle) {
  var cos = Math.cos(angle);
  var sin = Math.sin(angle);
  return multiply(transform, set(tmp_, cos, sin, -sin, cos, 0, 0));
}


/**
 * Applies scale to a given transform.
 * @param {!Transform} transform Transform.
 * @param {number} x Scale factor x.
 * @param {number} y Scale factor y.
 * @return {!Transform} The scaled transform.
 */
function scale(transform, x, y) {
  return multiply(transform, set(tmp_, x, 0, 0, y, 0, 0));
}


/**
 * Applies translation to the given transform.
 * @param {!Transform} transform Transform.
 * @param {number} dx Translation x.
 * @param {number} dy Translation y.
 * @return {!Transform} The translated transform.
 */
function translate(transform, dx, dy) {
  return multiply(transform, set(tmp_, 1, 0, 0, 1, dx, dy));
}


/**
 * Creates a composite transform given an initial translation, scale, rotation, and
 * final translation (in that order only, not commutative).
 * @param {!Transform} transform The transform (will be modified in place).
 * @param {number} dx1 Initial translation x.
 * @param {number} dy1 Initial translation y.
 * @param {number} sx Scale factor x.
 * @param {number} sy Scale factor y.
 * @param {number} angle Rotation (in counter-clockwise radians).
 * @param {number} dx2 Final translation x.
 * @param {number} dy2 Final translation y.
 * @return {!Transform} The composite transform.
 */
function compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {
  var sin = Math.sin(angle);
  var cos = Math.cos(angle);
  transform[0] = sx * cos;
  transform[1] = sy * sin;
  transform[2] = -sx * sin;
  transform[3] = sy * cos;
  transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
  transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
  return transform;
}


/**
 * Invert the given transform.
 * @param {!Transform} transform Transform.
 * @return {!Transform} Inverse of the transform.
 */
function invert(transform) {
  var det = determinant(transform);
  Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(det !== 0, 32); // Transformation matrix cannot be inverted

  var a = transform[0];
  var b = transform[1];
  var c = transform[2];
  var d = transform[3];
  var e = transform[4];
  var f = transform[5];

  transform[0] = d / det;
  transform[1] = -b / det;
  transform[2] = -c / det;
  transform[3] = a / det;
  transform[4] = (c * f - d * e) / det;
  transform[5] = -(a * f - b * e) / det;

  return transform;
}


/**
 * Returns the determinant of the given matrix.
 * @param {!Transform} mat Matrix.
 * @return {number} Determinant.
 */
function determinant(mat) {
  return mat[0] * mat[3] - mat[1] * mat[2];
}

//# sourceMappingURL=transform.js.map

/***/ }),

/***/ "./node_modules/ol/uri.js":
/*!********************************!*\
  !*** ./node_modules/ol/uri.js ***!
  \********************************/
/*! exports provided: appendParams */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "appendParams", function() { return appendParams; });
/**
 * @module ol/uri
 */


/**
 * Appends query parameters to a URI.
 *
 * @param {string} uri The original URI, which may already have query data.
 * @param {!Object} params An object where keys are URI-encoded parameter keys,
 *     and the values are arbitrary types or arrays.
 * @return {string} The new URI.
 */
function appendParams(uri, params) {
  var keyParams = [];
  // Skip any null or undefined parameter values
  Object.keys(params).forEach(function(k) {
    if (params[k] !== null && params[k] !== undefined) {
      keyParams.push(k + '=' + encodeURIComponent(params[k]));
    }
  });
  var qs = keyParams.join('&');
  // remove any trailing ? or &
  uri = uri.replace(/[?&]$/, '');
  // append ? or & depending on whether uri has existing parameters
  uri = uri.indexOf('?') === -1 ? uri + '?' : uri + '&';
  return uri + qs;
}

//# sourceMappingURL=uri.js.map

/***/ }),

/***/ "./node_modules/ol/util.js":
/*!*********************************!*\
  !*** ./node_modules/ol/util.js ***!
  \*********************************/
/*! exports provided: abstract, inherits, getUid, VERSION */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "abstract", function() { return abstract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inherits", function() { return inherits; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getUid", function() { return getUid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return VERSION; });
/**
 * @module ol/util
 */

/**
 * @return {?} Any return.
 */
function abstract() {
  return /** @type {?} */ ((function() {
    throw new Error('Unimplemented abstract method.');
  })());
}

/**
 * Inherit the prototype methods from one constructor into another.
 *
 * Usage:
 *
 *     function ParentClass(a, b) { }
 *     ParentClass.prototype.foo = function(a) { }
 *
 *     function ChildClass(a, b, c) {
 *       // Call parent constructor
 *       ParentClass.call(this, a, b);
 *     }
 *     inherits(ChildClass, ParentClass);
 *
 *     var child = new ChildClass('a', 'b', 'see');
 *     child.foo(); // This works.
 *
 * @param {!Function} childCtor Child constructor.
 * @param {!Function} parentCtor Parent constructor.
 * @function module:ol.inherits
 * @deprecated
 * @api
 */
function inherits(childCtor, parentCtor) {
  childCtor.prototype = Object.create(parentCtor.prototype);
  childCtor.prototype.constructor = childCtor;
}

/**
 * Counter for getUid.
 * @type {number}
 * @private
 */
var uidCounter_ = 0;

/**
 * Gets a unique ID for an object. This mutates the object so that further calls
 * with the same object as a parameter returns the same value. Unique IDs are generated
 * as a strictly increasing sequence. Adapted from goog.getUid.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {string} The unique ID for the object.
 * @function module:ol.getUid
 * @api
 */
function getUid(obj) {
  return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
}

/**
 * OpenLayers version.
 * @type {string}
 */
var VERSION = '5.3.1';

//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/ol/webgl.js":
/*!**********************************!*\
  !*** ./node_modules/ol/webgl.js ***!
  \**********************************/
/*! exports provided: ONE, SRC_ALPHA, COLOR_ATTACHMENT0, COLOR_BUFFER_BIT, TRIANGLES, TRIANGLE_STRIP, ONE_MINUS_SRC_ALPHA, ARRAY_BUFFER, ELEMENT_ARRAY_BUFFER, STREAM_DRAW, STATIC_DRAW, DYNAMIC_DRAW, CULL_FACE, BLEND, STENCIL_TEST, DEPTH_TEST, SCISSOR_TEST, UNSIGNED_BYTE, UNSIGNED_SHORT, UNSIGNED_INT, FLOAT, RGBA, FRAGMENT_SHADER, VERTEX_SHADER, LINK_STATUS, LINEAR, TEXTURE_MAG_FILTER, TEXTURE_MIN_FILTER, TEXTURE_WRAP_S, TEXTURE_WRAP_T, TEXTURE_2D, TEXTURE0, CLAMP_TO_EDGE, COMPILE_STATUS, FRAMEBUFFER, getContext, DEBUG, HAS, MAX_TEXTURE_SIZE, EXTENSIONS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ONE", function() { return ONE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRC_ALPHA", function() { return SRC_ALPHA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COLOR_ATTACHMENT0", function() { return COLOR_ATTACHMENT0; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COLOR_BUFFER_BIT", function() { return COLOR_BUFFER_BIT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TRIANGLES", function() { return TRIANGLES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TRIANGLE_STRIP", function() { return TRIANGLE_STRIP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ONE_MINUS_SRC_ALPHA", function() { return ONE_MINUS_SRC_ALPHA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ARRAY_BUFFER", function() { return ARRAY_BUFFER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ELEMENT_ARRAY_BUFFER", function() { return ELEMENT_ARRAY_BUFFER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STREAM_DRAW", function() { return STREAM_DRAW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STATIC_DRAW", function() { return STATIC_DRAW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DYNAMIC_DRAW", function() { return DYNAMIC_DRAW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CULL_FACE", function() { return CULL_FACE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BLEND", function() { return BLEND; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STENCIL_TEST", function() { return STENCIL_TEST; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEPTH_TEST", function() { return DEPTH_TEST; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SCISSOR_TEST", function() { return SCISSOR_TEST; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNSIGNED_BYTE", function() { return UNSIGNED_BYTE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNSIGNED_SHORT", function() { return UNSIGNED_SHORT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNSIGNED_INT", function() { return UNSIGNED_INT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FLOAT", function() { return FLOAT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA", function() { return RGBA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FRAGMENT_SHADER", function() { return FRAGMENT_SHADER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERTEX_SHADER", function() { return VERTEX_SHADER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LINK_STATUS", function() { return LINK_STATUS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LINEAR", function() { return LINEAR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXTURE_MAG_FILTER", function() { return TEXTURE_MAG_FILTER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXTURE_MIN_FILTER", function() { return TEXTURE_MIN_FILTER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXTURE_WRAP_S", function() { return TEXTURE_WRAP_S; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXTURE_WRAP_T", function() { return TEXTURE_WRAP_T; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXTURE_2D", function() { return TEXTURE_2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXTURE0", function() { return TEXTURE0; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLAMP_TO_EDGE", function() { return CLAMP_TO_EDGE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COMPILE_STATUS", function() { return COMPILE_STATUS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FRAMEBUFFER", function() { return FRAMEBUFFER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getContext", function() { return getContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEBUG", function() { return DEBUG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HAS", function() { return HAS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAX_TEXTURE_SIZE", function() { return MAX_TEXTURE_SIZE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EXTENSIONS", function() { return EXTENSIONS; });
/**
 * @module ol/webgl
 */


/**
 * Constants taken from goog.webgl
 */


/**
 * @const
 * @type {number}
 */
var ONE = 1;


/**
 * @const
 * @type {number}
 */
var SRC_ALPHA = 0x0302;


/**
 * @const
 * @type {number}
 */
var COLOR_ATTACHMENT0 = 0x8CE0;


/**
 * @const
 * @type {number}
 */
var COLOR_BUFFER_BIT = 0x00004000;


/**
 * @const
 * @type {number}
 */
var TRIANGLES = 0x0004;


/**
 * @const
 * @type {number}
 */
var TRIANGLE_STRIP = 0x0005;


/**
 * @const
 * @type {number}
 */
var ONE_MINUS_SRC_ALPHA = 0x0303;


/**
 * @const
 * @type {number}
 */
var ARRAY_BUFFER = 0x8892;


/**
 * @const
 * @type {number}
 */
var ELEMENT_ARRAY_BUFFER = 0x8893;


/**
 * @const
 * @type {number}
 */
var STREAM_DRAW = 0x88E0;


/**
 * @const
 * @type {number}
 */
var STATIC_DRAW = 0x88E4;


/**
 * @const
 * @type {number}
 */
var DYNAMIC_DRAW = 0x88E8;


/**
 * @const
 * @type {number}
 */
var CULL_FACE = 0x0B44;


/**
 * @const
 * @type {number}
 */
var BLEND = 0x0BE2;


/**
 * @const
 * @type {number}
 */
var STENCIL_TEST = 0x0B90;


/**
 * @const
 * @type {number}
 */
var DEPTH_TEST = 0x0B71;


/**
 * @const
 * @type {number}
 */
var SCISSOR_TEST = 0x0C11;


/**
 * @const
 * @type {number}
 */
var UNSIGNED_BYTE = 0x1401;


/**
 * @const
 * @type {number}
 */
var UNSIGNED_SHORT = 0x1403;


/**
 * @const
 * @type {number}
 */
var UNSIGNED_INT = 0x1405;


/**
 * @const
 * @type {number}
 */
var FLOAT = 0x1406;


/**
 * @const
 * @type {number}
 */
var RGBA = 0x1908;


/**
 * @const
 * @type {number}
 */
var FRAGMENT_SHADER = 0x8B30;


/**
 * @const
 * @type {number}
 */
var VERTEX_SHADER = 0x8B31;


/**
 * @const
 * @type {number}
 */
var LINK_STATUS = 0x8B82;


/**
 * @const
 * @type {number}
 */
var LINEAR = 0x2601;


/**
 * @const
 * @type {number}
 */
var TEXTURE_MAG_FILTER = 0x2800;


/**
 * @const
 * @type {number}
 */
var TEXTURE_MIN_FILTER = 0x2801;


/**
 * @const
 * @type {number}
 */
var TEXTURE_WRAP_S = 0x2802;


/**
 * @const
 * @type {number}
 */
var TEXTURE_WRAP_T = 0x2803;


/**
 * @const
 * @type {number}
 */
var TEXTURE_2D = 0x0DE1;


/**
 * @const
 * @type {number}
 */
var TEXTURE0 = 0x84C0;


/**
 * @const
 * @type {number}
 */
var CLAMP_TO_EDGE = 0x812F;


/**
 * @const
 * @type {number}
 */
var COMPILE_STATUS = 0x8B81;


/**
 * @const
 * @type {number}
 */
var FRAMEBUFFER = 0x8D40;


/** end of goog.webgl constants
 */


/**
 * @const
 * @type {Array<string>}
 */
var CONTEXT_IDS = [
  'experimental-webgl',
  'webgl',
  'webkit-3d',
  'moz-webgl'
];


/**
 * @param {HTMLCanvasElement} canvas Canvas.
 * @param {Object=} opt_attributes Attributes.
 * @return {WebGLRenderingContext} WebGL rendering context.
 */
function getContext(canvas, opt_attributes) {
  var ii = CONTEXT_IDS.length;
  for (var i = 0; i < ii; ++i) {
    try {
      var context = canvas.getContext(CONTEXT_IDS[i], opt_attributes);
      if (context) {
        return /** @type {!WebGLRenderingContext} */ (context);
      }
    } catch (e) {
      // pass
    }
  }
  return null;
}


/**
 * Include debuggable shader sources.  Default is `true`. This should be set to
 * `false` for production builds.
 * @type {boolean}
 */
var DEBUG = true;


/**
 * The maximum supported WebGL texture size in pixels. If WebGL is not
 * supported, the value is set to `undefined`.
 * @type {number|undefined}
 */
var MAX_TEXTURE_SIZE; // value is set below


/**
 * List of supported WebGL extensions.
 * @type {Array<string>}
 */
var EXTENSIONS; // value is set below


/**
 * True if both OpenLayers and browser support WebGL.
 * @type {boolean}
 * @api
 */
var HAS = false;

//TODO Remove side effects
if (typeof window !== 'undefined' && 'WebGLRenderingContext' in window) {
  try {
    var canvas = /** @type {HTMLCanvasElement} */ (document.createElement('canvas'));
    var gl = getContext(canvas, {failIfMajorPerformanceCaveat: true});
    if (gl) {
      HAS = true;
      MAX_TEXTURE_SIZE = /** @type {number} */ (gl.getParameter(gl.MAX_TEXTURE_SIZE));
      EXTENSIONS = gl.getSupportedExtensions();
    }
  } catch (e) {
    // pass
  }
}



//# sourceMappingURL=webgl.js.map

/***/ }),

/***/ "./node_modules/pixelworks/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/pixelworks/lib/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Processor = __webpack_require__(/*! ./processor */ "./node_modules/pixelworks/lib/processor.js");

exports.Processor = Processor;


/***/ }),

/***/ "./node_modules/pixelworks/lib/processor.js":
/*!**************************************************!*\
  !*** ./node_modules/pixelworks/lib/processor.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var newImageData = __webpack_require__(/*! ./util */ "./node_modules/pixelworks/lib/util.js").newImageData;

/**
 * Create a function for running operations.  This function is serialized for
 * use in a worker.
 * @param {function(Array, Object):*} operation The operation.
 * @return {function(Object):ArrayBuffer} A function that takes an object with
 * buffers, meta, imageOps, width, and height properties and returns an array
 * buffer.
 */
function createMinion(operation) {
  var workerHasImageData = true;
  try {
    new ImageData(10, 10);
  } catch (_) {
    workerHasImageData = false;
  }

  function newWorkerImageData(data, width, height) {
    if (workerHasImageData) {
      return new ImageData(data, width, height);
    } else {
      return {data: data, width: width, height: height};
    }
  }

  return function(data) {
    // bracket notation for minification support
    var buffers = data['buffers'];
    var meta = data['meta'];
    var imageOps = data['imageOps'];
    var width = data['width'];
    var height = data['height'];

    var numBuffers = buffers.length;
    var numBytes = buffers[0].byteLength;
    var output, b;

    if (imageOps) {
      var images = new Array(numBuffers);
      for (b = 0; b < numBuffers; ++b) {
        images[b] = newWorkerImageData(
            new Uint8ClampedArray(buffers[b]), width, height);
      }
      output = operation(images, meta).data;
    } else {
      output = new Uint8ClampedArray(numBytes);
      var arrays = new Array(numBuffers);
      var pixels = new Array(numBuffers);
      for (b = 0; b < numBuffers; ++b) {
        arrays[b] = new Uint8ClampedArray(buffers[b]);
        pixels[b] = [0, 0, 0, 0];
      }
      for (var i = 0; i < numBytes; i += 4) {
        for (var j = 0; j < numBuffers; ++j) {
          var array = arrays[j];
          pixels[j][0] = array[i];
          pixels[j][1] = array[i + 1];
          pixels[j][2] = array[i + 2];
          pixels[j][3] = array[i + 3];
        }
        var pixel = operation(pixels, meta);
        output[i] = pixel[0];
        output[i + 1] = pixel[1];
        output[i + 2] = pixel[2];
        output[i + 3] = pixel[3];
      }
    }
    return output.buffer;
  };
}

/**
 * Create a worker for running operations.
 * @param {Object} config Configuration.
 * @param {function(MessageEvent)} onMessage Called with a message event.
 * @return {Worker} The worker.
 */
function createWorker(config, onMessage) {
  var lib = Object.keys(config.lib || {}).map(function(name) {
    return 'var ' + name + ' = ' + config.lib[name].toString() + ';';
  });

  var lines = lib.concat([
    'var __minion__ = (' + createMinion.toString() + ')(', config.operation.toString(), ');',
    'self.addEventListener("message", function(event) {',
    '  var buffer = __minion__(event.data);',
    '  self.postMessage({buffer: buffer, meta: event.data.meta}, [buffer]);',
    '});'
  ]);

  var blob = new Blob(lines, {type: 'text/javascript'});
  var source = URL.createObjectURL(blob);
  var worker = new Worker(source);
  worker.addEventListener('message', onMessage);
  return worker;
}

/**
 * Create a faux worker for running operations.
 * @param {Object} config Configuration.
 * @param {function(MessageEvent)} onMessage Called with a message event.
 * @return {Object} The faux worker.
 */
function createFauxWorker(config, onMessage) {
  var minion = createMinion(config.operation);
  return {
    postMessage: function(data) {
      setTimeout(function() {
        onMessage({'data': {'buffer': minion(data), 'meta': data['meta']}});
      }, 0);
    }
  };
}

/**
 * A processor runs pixel or image operations in workers.
 * @param {Object} config Configuration.
 */
function Processor(config) {
  this._imageOps = !!config.imageOps;
  var threads;
  if (config.threads === 0) {
    threads = 0;
  } else if (this._imageOps) {
    threads = 1;
  } else {
    threads = config.threads || 1;
  }
  var workers = [];
  if (threads) {
    for (var i = 0; i < threads; ++i) {
      workers[i] = createWorker(config, this._onWorkerMessage.bind(this, i));
    }
  } else {
    workers[0] = createFauxWorker(config, this._onWorkerMessage.bind(this, 0));
  }
  this._workers = workers;
  this._queue = [];
  this._maxQueueLength = config.queue || Infinity;
  this._running = 0;
  this._dataLookup = {};
  this._job = null;
}

/**
 * Run operation on input data.
 * @param {Array.<Array|ImageData>} inputs Array of pixels or image data
 *     (depending on the operation type).
 * @param {Object} meta A user data object.  This is passed to all operations
 *     and must be serializable.
 * @param {function(Error, ImageData, Object)} callback Called when work
 *     completes.  The first argument is any error.  The second is the ImageData
 *     generated by operations.  The third is the user data object.
 */
Processor.prototype.process = function(inputs, meta, callback) {
  this._enqueue({
    inputs: inputs,
    meta: meta,
    callback: callback
  });
  this._dispatch();
};

/**
 * Stop responding to any completed work and destroy the processor.
 */
Processor.prototype.destroy = function() {
  for (var key in this) {
    this[key] = null;
  }
  this._destroyed = true;
};

/**
 * Add a job to the queue.
 * @param {Object} job The job.
 */
Processor.prototype._enqueue = function(job) {
  this._queue.push(job);
  while (this._queue.length > this._maxQueueLength) {
    this._queue.shift().callback(null, null);
  }
};

/**
 * Dispatch a job.
 */
Processor.prototype._dispatch = function() {
  if (this._running === 0 && this._queue.length > 0) {
    var job = this._job = this._queue.shift();
    var width = job.inputs[0].width;
    var height = job.inputs[0].height;
    var buffers = job.inputs.map(function(input) {
      return input.data.buffer;
    });
    var threads = this._workers.length;
    this._running = threads;
    if (threads === 1) {
      this._workers[0].postMessage({
        'buffers': buffers,
        'meta': job.meta,
        'imageOps': this._imageOps,
        'width': width,
        'height': height
      }, buffers);
    } else {
      var length = job.inputs[0].data.length;
      var segmentLength = 4 * Math.ceil(length / 4 / threads);
      for (var i = 0; i < threads; ++i) {
        var offset = i * segmentLength;
        var slices = [];
        for (var j = 0, jj = buffers.length; j < jj; ++j) {
          slices.push(buffers[i].slice(offset, offset + segmentLength));
        }
        this._workers[i].postMessage({
          'buffers': slices,
          'meta': job.meta,
          'imageOps': this._imageOps,
          'width': width,
          'height': height
        }, slices);
      }
    }
  }
};

/**
 * Handle messages from the worker.
 * @param {number} index The worker index.
 * @param {MessageEvent} event The message event.
 */
Processor.prototype._onWorkerMessage = function(index, event) {
  if (this._destroyed) {
    return;
  }
  this._dataLookup[index] = event.data;
  --this._running;
  if (this._running === 0) {
    this._resolveJob();
  }
};

/**
 * Resolve a job.  If there are no more worker threads, the processor callback
 * will be called.
 */
Processor.prototype._resolveJob = function() {
  var job = this._job;
  var threads = this._workers.length;
  var data, meta;
  if (threads === 1) {
    data = new Uint8ClampedArray(this._dataLookup[0]['buffer']);
    meta = this._dataLookup[0]['meta'];
  } else {
    var length = job.inputs[0].data.length;
    data = new Uint8ClampedArray(length);
    meta = new Array(length);
    var segmentLength = 4 * Math.ceil(length / 4 / threads);
    for (var i = 0; i < threads; ++i) {
      var buffer = this._dataLookup[i]['buffer'];
      var offset = i * segmentLength;
      data.set(new Uint8ClampedArray(buffer), offset);
      meta[i] = this._dataLookup[i]['meta'];
    }
  }
  this._job = null;
  this._dataLookup = {};
  job.callback(null,
      newImageData(data, job.inputs[0].width, job.inputs[0].height), meta);
  this._dispatch();
};

module.exports = Processor;


/***/ }),

/***/ "./node_modules/pixelworks/lib/util.js":
/*!*********************************************!*\
  !*** ./node_modules/pixelworks/lib/util.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var hasImageData = true;
try {
  new ImageData(10, 10);
} catch (_) {
  hasImageData = false;
}

var context = document.createElement('canvas').getContext('2d');

function newImageData(data, width, height) {
  if (hasImageData) {
    return new ImageData(data, width, height);
  } else {
    var imageData = context.createImageData(width, height);
    imageData.data.set(data);
    return imageData;
  }
}

exports.newImageData = newImageData;


/***/ }),

/***/ "./node_modules/quickselect/quickselect.js":
/*!*************************************************!*\
  !*** ./node_modules/quickselect/quickselect.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function (global, factory) {
	 true ? module.exports = factory() :
	undefined;
}(this, (function () { 'use strict';

function quickselect(arr, k, left, right, compare) {
    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);
}

function quickselectStep(arr, k, left, right, compare) {

    while (right > left) {
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            quickselectStep(arr, k, newLeft, newRight, compare);
        }

        var t = arr[k];
        var i = left;
        var j = right;

        swap(arr, left, k);
        if (compare(arr[right], t) > 0) swap(arr, left, right);

        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (compare(arr[i], t) < 0) i++;
            while (compare(arr[j], t) > 0) j--;
        }

        if (compare(arr[left], t) === 0) swap(arr, left, j);
        else {
            j++;
            swap(arr, j, right);
        }

        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
    }
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}

return quickselect;

})));


/***/ })

/******/ });
//# sourceMappingURL=c4g-maps.js.map
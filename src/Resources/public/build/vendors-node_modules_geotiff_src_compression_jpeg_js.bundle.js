"use strict";
(self["webpackChunkmapsbundle"] = self["webpackChunkmapsbundle"] || []).push([["vendors-node_modules_geotiff_src_compression_jpeg_js"],{

/***/ "./node_modules/geotiff/src/compression/basedecoder.js":
/*!*************************************************************!*\
  !*** ./node_modules/geotiff/src/compression/basedecoder.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BaseDecoder)
/* harmony export */ });
/* harmony import */ var _predictor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../predictor */ "./node_modules/geotiff/src/predictor.js");


class BaseDecoder {
  async decode(fileDirectory, buffer) {
    const decoded = await this.decodeBlock(buffer);
    const predictor = fileDirectory.Predictor || 1;
    if (predictor !== 1) {
      const isTiled = !fileDirectory.StripOffsets;
      const tileWidth = isTiled ? fileDirectory.TileWidth : fileDirectory.ImageWidth;
      const tileHeight = isTiled ? fileDirectory.TileLength : (
        fileDirectory.RowsPerStrip || fileDirectory.ImageLength
      );
      return (0,_predictor__WEBPACK_IMPORTED_MODULE_0__.applyPredictor)(
        decoded, predictor, tileWidth, tileHeight, fileDirectory.BitsPerSample,
        fileDirectory.PlanarConfiguration,
      );
    }
    return decoded;
  }
}


/***/ }),

/***/ "./node_modules/geotiff/src/compression/jpeg.js":
/*!******************************************************!*\
  !*** ./node_modules/geotiff/src/compression/jpeg.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ JpegDecoder)
/* harmony export */ });
/* harmony import */ var _basedecoder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basedecoder */ "./node_modules/geotiff/src/compression/basedecoder.js");


/* -*- tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/*
   Copyright 2011 notmasteryet
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
       http://www.apache.org/licenses/LICENSE-2.0
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

// - The JPEG specification can be found in the ITU CCITT Recommendation T.81
//   (www.w3.org/Graphics/JPEG/itu-t81.pdf)
// - The JFIF specification can be found in the JPEG File Interchange Format
//   (www.w3.org/Graphics/JPEG/jfif3.pdf)
// - The Adobe Application-Specific JPEG markers in the Supporting the DCT Filters
//   in PostScript Level 2, Technical Note #5116
//   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)

const dctZigZag = new Int32Array([
  0,
  1, 8,
  16, 9, 2,
  3, 10, 17, 24,
  32, 25, 18, 11, 4,
  5, 12, 19, 26, 33, 40,
  48, 41, 34, 27, 20, 13, 6,
  7, 14, 21, 28, 35, 42, 49, 56,
  57, 50, 43, 36, 29, 22, 15,
  23, 30, 37, 44, 51, 58,
  59, 52, 45, 38, 31,
  39, 46, 53, 60,
  61, 54, 47,
  55, 62,
  63,
]);

const dctCos1 = 4017; // cos(pi/16)
const dctSin1 = 799; // sin(pi/16)
const dctCos3 = 3406; // cos(3*pi/16)
const dctSin3 = 2276; // sin(3*pi/16)
const dctCos6 = 1567; // cos(6*pi/16)
const dctSin6 = 3784; // sin(6*pi/16)
const dctSqrt2 = 5793; // sqrt(2)
const dctSqrt1d2 = 2896;// sqrt(2) / 2

function buildHuffmanTable(codeLengths, values) {
  let k = 0;
  const code = [];
  let length = 16;
  while (length > 0 && !codeLengths[length - 1]) {
    --length;
  }
  code.push({ children: [], index: 0 });

  let p = code[0];
  let q;
  for (let i = 0; i < length; i++) {
    for (let j = 0; j < codeLengths[i]; j++) {
      p = code.pop();
      p.children[p.index] = values[k];
      while (p.index > 0) {
        p = code.pop();
      }
      p.index++;
      code.push(p);
      while (code.length <= i) {
        code.push(q = { children: [], index: 0 });
        p.children[p.index] = q.children;
        p = q;
      }
      k++;
    }
    if (i + 1 < length) {
      // p here points to last code
      code.push(q = { children: [], index: 0 });
      p.children[p.index] = q.children;
      p = q;
    }
  }
  return code[0].children;
}

function decodeScan(data, initialOffset,
  frame, components, resetInterval,
  spectralStart, spectralEnd,
  successivePrev, successive) {
  const { mcusPerLine, progressive } = frame;

  const startOffset = initialOffset;
  let offset = initialOffset;
  let bitsData = 0;
  let bitsCount = 0;
  function readBit() {
    if (bitsCount > 0) {
      bitsCount--;
      return (bitsData >> bitsCount) & 1;
    }
    bitsData = data[offset++];
    if (bitsData === 0xFF) {
      const nextByte = data[offset++];
      if (nextByte) {
        throw new Error(`unexpected marker: ${((bitsData << 8) | nextByte).toString(16)}`);
      }
      // unstuff 0
    }
    bitsCount = 7;
    return bitsData >>> 7;
  }
  function decodeHuffman(tree) {
    let node = tree;
    let bit;
    while ((bit = readBit()) !== null) { // eslint-disable-line no-cond-assign
      node = node[bit];
      if (typeof node === 'number') {
        return node;
      }
      if (typeof node !== 'object') {
        throw new Error('invalid huffman sequence');
      }
    }
    return null;
  }
  function receive(initialLength) {
    let length = initialLength;
    let n = 0;
    while (length > 0) {
      const bit = readBit();
      if (bit === null) {
        return undefined;
      }
      n = (n << 1) | bit;
      --length;
    }
    return n;
  }
  function receiveAndExtend(length) {
    const n = receive(length);
    if (n >= 1 << (length - 1)) {
      return n;
    }
    return n + (-1 << length) + 1;
  }
  function decodeBaseline(component, zz) {
    const t = decodeHuffman(component.huffmanTableDC);
    const diff = t === 0 ? 0 : receiveAndExtend(t);
    component.pred += diff;
    zz[0] = component.pred;
    let k = 1;
    while (k < 64) {
      const rs = decodeHuffman(component.huffmanTableAC);
      const s = rs & 15;
      const r = rs >> 4;
      if (s === 0) {
        if (r < 15) {
          break;
        }
        k += 16;
      } else {
        k += r;
        const z = dctZigZag[k];
        zz[z] = receiveAndExtend(s);
        k++;
      }
    }
  }
  function decodeDCFirst(component, zz) {
    const t = decodeHuffman(component.huffmanTableDC);
    const diff = t === 0 ? 0 : (receiveAndExtend(t) << successive);
    component.pred += diff;
    zz[0] = component.pred;
  }
  function decodeDCSuccessive(component, zz) {
    zz[0] |= readBit() << successive;
  }
  let eobrun = 0;
  function decodeACFirst(component, zz) {
    if (eobrun > 0) {
      eobrun--;
      return;
    }
    let k = spectralStart;
    const e = spectralEnd;
    while (k <= e) {
      const rs = decodeHuffman(component.huffmanTableAC);
      const s = rs & 15;
      const r = rs >> 4;
      if (s === 0) {
        if (r < 15) {
          eobrun = receive(r) + (1 << r) - 1;
          break;
        }
        k += 16;
      } else {
        k += r;
        const z = dctZigZag[k];
        zz[z] = receiveAndExtend(s) * (1 << successive);
        k++;
      }
    }
  }
  let successiveACState = 0;
  let successiveACNextValue;
  function decodeACSuccessive(component, zz) {
    let k = spectralStart;
    const e = spectralEnd;
    let r = 0;
    while (k <= e) {
      const z = dctZigZag[k];
      const direction = zz[z] < 0 ? -1 : 1;
      switch (successiveACState) {
        case 0: { // initial state
          const rs = decodeHuffman(component.huffmanTableAC);
          const s = rs & 15;
          r = rs >> 4;
          if (s === 0) {
            if (r < 15) {
              eobrun = receive(r) + (1 << r);
              successiveACState = 4;
            } else {
              r = 16;
              successiveACState = 1;
            }
          } else {
            if (s !== 1) {
              throw new Error('invalid ACn encoding');
            }
            successiveACNextValue = receiveAndExtend(s);
            successiveACState = r ? 2 : 3;
          }
          continue; // eslint-disable-line no-continue
        }
        case 1: // skipping r zero items
        case 2:
          if (zz[z]) {
            zz[z] += (readBit() << successive) * direction;
          } else {
            r--;
            if (r === 0) {
              successiveACState = successiveACState === 2 ? 3 : 0;
            }
          }
          break;
        case 3: // set value for a zero item
          if (zz[z]) {
            zz[z] += (readBit() << successive) * direction;
          } else {
            zz[z] = successiveACNextValue << successive;
            successiveACState = 0;
          }
          break;
        case 4: // eob
          if (zz[z]) {
            zz[z] += (readBit() << successive) * direction;
          }
          break;
        default:
          break;
      }
      k++;
    }
    if (successiveACState === 4) {
      eobrun--;
      if (eobrun === 0) {
        successiveACState = 0;
      }
    }
  }
  function decodeMcu(component, decodeFunction, mcu, row, col) {
    const mcuRow = (mcu / mcusPerLine) | 0;
    const mcuCol = mcu % mcusPerLine;
    const blockRow = (mcuRow * component.v) + row;
    const blockCol = (mcuCol * component.h) + col;
    decodeFunction(component, component.blocks[blockRow][blockCol]);
  }
  function decodeBlock(component, decodeFunction, mcu) {
    const blockRow = (mcu / component.blocksPerLine) | 0;
    const blockCol = mcu % component.blocksPerLine;
    decodeFunction(component, component.blocks[blockRow][blockCol]);
  }

  const componentsLength = components.length;
  let component;
  let i;
  let j;
  let k;
  let n;
  let decodeFn;
  if (progressive) {
    if (spectralStart === 0) {
      decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
    } else {
      decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
    }
  } else {
    decodeFn = decodeBaseline;
  }

  let mcu = 0;
  let marker;
  let mcuExpected;
  if (componentsLength === 1) {
    mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
  } else {
    mcuExpected = mcusPerLine * frame.mcusPerColumn;
  }

  const usedResetInterval = resetInterval || mcuExpected;

  while (mcu < mcuExpected) {
    // reset interval stuff
    for (i = 0; i < componentsLength; i++) {
      components[i].pred = 0;
    }
    eobrun = 0;

    if (componentsLength === 1) {
      component = components[0];
      for (n = 0; n < usedResetInterval; n++) {
        decodeBlock(component, decodeFn, mcu);
        mcu++;
      }
    } else {
      for (n = 0; n < usedResetInterval; n++) {
        for (i = 0; i < componentsLength; i++) {
          component = components[i];
          const { h, v } = component;
          for (j = 0; j < v; j++) {
            for (k = 0; k < h; k++) {
              decodeMcu(component, decodeFn, mcu, j, k);
            }
          }
        }
        mcu++;

        // If we've reached our expected MCU's, stop decoding
        if (mcu === mcuExpected) {
          break;
        }
      }
    }

    // find marker
    bitsCount = 0;
    marker = (data[offset] << 8) | data[offset + 1];
    if (marker < 0xFF00) {
      throw new Error('marker was not found');
    }

    if (marker >= 0xFFD0 && marker <= 0xFFD7) { // RSTx
      offset += 2;
    } else {
      break;
    }
  }

  return offset - startOffset;
}

function buildComponentData(frame, component) {
  const lines = [];
  const { blocksPerLine, blocksPerColumn } = component;
  const samplesPerLine = blocksPerLine << 3;
  const R = new Int32Array(64);
  const r = new Uint8Array(64);

  // A port of poppler's IDCT method which in turn is taken from:
  //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,
  //   "Practical Fast 1-D DCT Algorithms with 11 Multiplications",
  //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,
  //   988-991.
  function quantizeAndInverse(zz, dataOut, dataIn) {
    const qt = component.quantizationTable;
    let v0;
    let v1;
    let v2;
    let v3;
    let v4;
    let v5;
    let v6;
    let v7;
    let t;
    const p = dataIn;
    let i;

    // dequant
    for (i = 0; i < 64; i++) {
      p[i] = zz[i] * qt[i];
    }

    // inverse DCT on rows
    for (i = 0; i < 8; ++i) {
      const row = 8 * i;

      // check for all-zero AC coefficients
      if (p[1 + row] === 0 && p[2 + row] === 0 && p[3 + row] === 0
        && p[4 + row] === 0 && p[5 + row] === 0 && p[6 + row] === 0
        && p[7 + row] === 0) {
        t = ((dctSqrt2 * p[0 + row]) + 512) >> 10;
        p[0 + row] = t;
        p[1 + row] = t;
        p[2 + row] = t;
        p[3 + row] = t;
        p[4 + row] = t;
        p[5 + row] = t;
        p[6 + row] = t;
        p[7 + row] = t;
        continue; // eslint-disable-line no-continue
      }

      // stage 4
      v0 = ((dctSqrt2 * p[0 + row]) + 128) >> 8;
      v1 = ((dctSqrt2 * p[4 + row]) + 128) >> 8;
      v2 = p[2 + row];
      v3 = p[6 + row];
      v4 = ((dctSqrt1d2 * (p[1 + row] - p[7 + row])) + 128) >> 8;
      v7 = ((dctSqrt1d2 * (p[1 + row] + p[7 + row])) + 128) >> 8;
      v5 = p[3 + row] << 4;
      v6 = p[5 + row] << 4;

      // stage 3
      t = (v0 - v1 + 1) >> 1;
      v0 = (v0 + v1 + 1) >> 1;
      v1 = t;
      t = ((v2 * dctSin6) + (v3 * dctCos6) + 128) >> 8;
      v2 = ((v2 * dctCos6) - (v3 * dctSin6) + 128) >> 8;
      v3 = t;
      t = (v4 - v6 + 1) >> 1;
      v4 = (v4 + v6 + 1) >> 1;
      v6 = t;
      t = (v7 + v5 + 1) >> 1;
      v5 = (v7 - v5 + 1) >> 1;
      v7 = t;

      // stage 2
      t = (v0 - v3 + 1) >> 1;
      v0 = (v0 + v3 + 1) >> 1;
      v3 = t;
      t = (v1 - v2 + 1) >> 1;
      v1 = (v1 + v2 + 1) >> 1;
      v2 = t;
      t = ((v4 * dctSin3) + (v7 * dctCos3) + 2048) >> 12;
      v4 = ((v4 * dctCos3) - (v7 * dctSin3) + 2048) >> 12;
      v7 = t;
      t = ((v5 * dctSin1) + (v6 * dctCos1) + 2048) >> 12;
      v5 = ((v5 * dctCos1) - (v6 * dctSin1) + 2048) >> 12;
      v6 = t;

      // stage 1
      p[0 + row] = v0 + v7;
      p[7 + row] = v0 - v7;
      p[1 + row] = v1 + v6;
      p[6 + row] = v1 - v6;
      p[2 + row] = v2 + v5;
      p[5 + row] = v2 - v5;
      p[3 + row] = v3 + v4;
      p[4 + row] = v3 - v4;
    }

    // inverse DCT on columns
    for (i = 0; i < 8; ++i) {
      const col = i;

      // check for all-zero AC coefficients
      if (p[(1 * 8) + col] === 0 && p[(2 * 8) + col] === 0 && p[(3 * 8) + col] === 0
        && p[(4 * 8) + col] === 0 && p[(5 * 8) + col] === 0 && p[(6 * 8) + col] === 0
        && p[(7 * 8) + col] === 0) {
        t = ((dctSqrt2 * dataIn[i + 0]) + 8192) >> 14;
        p[(0 * 8) + col] = t;
        p[(1 * 8) + col] = t;
        p[(2 * 8) + col] = t;
        p[(3 * 8) + col] = t;
        p[(4 * 8) + col] = t;
        p[(5 * 8) + col] = t;
        p[(6 * 8) + col] = t;
        p[(7 * 8) + col] = t;
        continue; // eslint-disable-line no-continue
      }

      // stage 4
      v0 = ((dctSqrt2 * p[(0 * 8) + col]) + 2048) >> 12;
      v1 = ((dctSqrt2 * p[(4 * 8) + col]) + 2048) >> 12;
      v2 = p[(2 * 8) + col];
      v3 = p[(6 * 8) + col];
      v4 = ((dctSqrt1d2 * (p[(1 * 8) + col] - p[(7 * 8) + col])) + 2048) >> 12;
      v7 = ((dctSqrt1d2 * (p[(1 * 8) + col] + p[(7 * 8) + col])) + 2048) >> 12;
      v5 = p[(3 * 8) + col];
      v6 = p[(5 * 8) + col];

      // stage 3
      t = (v0 - v1 + 1) >> 1;
      v0 = (v0 + v1 + 1) >> 1;
      v1 = t;
      t = ((v2 * dctSin6) + (v3 * dctCos6) + 2048) >> 12;
      v2 = ((v2 * dctCos6) - (v3 * dctSin6) + 2048) >> 12;
      v3 = t;
      t = (v4 - v6 + 1) >> 1;
      v4 = (v4 + v6 + 1) >> 1;
      v6 = t;
      t = (v7 + v5 + 1) >> 1;
      v5 = (v7 - v5 + 1) >> 1;
      v7 = t;

      // stage 2
      t = (v0 - v3 + 1) >> 1;
      v0 = (v0 + v3 + 1) >> 1;
      v3 = t;
      t = (v1 - v2 + 1) >> 1;
      v1 = (v1 + v2 + 1) >> 1;
      v2 = t;
      t = ((v4 * dctSin3) + (v7 * dctCos3) + 2048) >> 12;
      v4 = ((v4 * dctCos3) - (v7 * dctSin3) + 2048) >> 12;
      v7 = t;
      t = ((v5 * dctSin1) + (v6 * dctCos1) + 2048) >> 12;
      v5 = ((v5 * dctCos1) - (v6 * dctSin1) + 2048) >> 12;
      v6 = t;

      // stage 1
      p[(0 * 8) + col] = v0 + v7;
      p[(7 * 8) + col] = v0 - v7;
      p[(1 * 8) + col] = v1 + v6;
      p[(6 * 8) + col] = v1 - v6;
      p[(2 * 8) + col] = v2 + v5;
      p[(5 * 8) + col] = v2 - v5;
      p[(3 * 8) + col] = v3 + v4;
      p[(4 * 8) + col] = v3 - v4;
    }

    // convert to 8-bit integers
    for (i = 0; i < 64; ++i) {
      const sample = 128 + ((p[i] + 8) >> 4);
      if (sample < 0) {
        dataOut[i] = 0;
      } else if (sample > 0XFF) {
        dataOut[i] = 0xFF;
      } else {
        dataOut[i] = sample;
      }
    }
  }

  for (let blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
    const scanLine = blockRow << 3;
    for (let i = 0; i < 8; i++) {
      lines.push(new Uint8Array(samplesPerLine));
    }
    for (let blockCol = 0; blockCol < blocksPerLine; blockCol++) {
      quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);

      let offset = 0;
      const sample = blockCol << 3;
      for (let j = 0; j < 8; j++) {
        const line = lines[scanLine + j];
        for (let i = 0; i < 8; i++) {
          line[sample + i] = r[offset++];
        }
      }
    }
  }
  return lines;
}

class JpegStreamReader {
  constructor() {
    this.jfif = null;
    this.adobe = null;

    this.quantizationTables = [];
    this.huffmanTablesAC = [];
    this.huffmanTablesDC = [];
    this.resetFrames();
  }

  resetFrames() {
    this.frames = [];
  }

  parse(data) {
    let offset = 0;
    // const { length } = data;
    function readUint16() {
      const value = (data[offset] << 8) | data[offset + 1];
      offset += 2;
      return value;
    }
    function readDataBlock() {
      const length = readUint16();
      const array = data.subarray(offset, offset + length - 2);
      offset += array.length;
      return array;
    }
    function prepareComponents(frame) {
      let maxH = 0;
      let maxV = 0;
      let component;
      let componentId;
      for (componentId in frame.components) {
        if (frame.components.hasOwnProperty(componentId)) {
          component = frame.components[componentId];
          if (maxH < component.h) {
            maxH = component.h;
          }
          if (maxV < component.v) {
            maxV = component.v;
          }
        }
      }
      const mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / maxH);
      const mcusPerColumn = Math.ceil(frame.scanLines / 8 / maxV);
      for (componentId in frame.components) {
        if (frame.components.hasOwnProperty(componentId)) {
          component = frame.components[componentId];
          const blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / maxH);
          const blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines / 8) * component.v / maxV);
          const blocksPerLineForMcu = mcusPerLine * component.h;
          const blocksPerColumnForMcu = mcusPerColumn * component.v;
          const blocks = [];
          for (let i = 0; i < blocksPerColumnForMcu; i++) {
            const row = [];
            for (let j = 0; j < blocksPerLineForMcu; j++) {
              row.push(new Int32Array(64));
            }
            blocks.push(row);
          }
          component.blocksPerLine = blocksPerLine;
          component.blocksPerColumn = blocksPerColumn;
          component.blocks = blocks;
        }
      }
      frame.maxH = maxH;
      frame.maxV = maxV;
      frame.mcusPerLine = mcusPerLine;
      frame.mcusPerColumn = mcusPerColumn;
    }

    let fileMarker = readUint16();
    if (fileMarker !== 0xFFD8) { // SOI (Start of Image)
      throw new Error('SOI not found');
    }

    fileMarker = readUint16();
    while (fileMarker !== 0xFFD9) { // EOI (End of image)
      switch (fileMarker) {
        case 0xFF00: break;
        case 0xFFE0: // APP0 (Application Specific)
        case 0xFFE1: // APP1
        case 0xFFE2: // APP2
        case 0xFFE3: // APP3
        case 0xFFE4: // APP4
        case 0xFFE5: // APP5
        case 0xFFE6: // APP6
        case 0xFFE7: // APP7
        case 0xFFE8: // APP8
        case 0xFFE9: // APP9
        case 0xFFEA: // APP10
        case 0xFFEB: // APP11
        case 0xFFEC: // APP12
        case 0xFFED: // APP13
        case 0xFFEE: // APP14
        case 0xFFEF: // APP15
        case 0xFFFE: { // COM (Comment)
          const appData = readDataBlock();

          if (fileMarker === 0xFFE0) {
            if (appData[0] === 0x4A && appData[1] === 0x46 && appData[2] === 0x49
              && appData[3] === 0x46 && appData[4] === 0) { // 'JFIF\x00'
              this.jfif = {
                version: { major: appData[5], minor: appData[6] },
                densityUnits: appData[7],
                xDensity: (appData[8] << 8) | appData[9],
                yDensity: (appData[10] << 8) | appData[11],
                thumbWidth: appData[12],
                thumbHeight: appData[13],
                thumbData: appData.subarray(14, 14 + (3 * appData[12] * appData[13])),
              };
            }
          }
          // TODO APP1 - Exif
          if (fileMarker === 0xFFEE) {
            if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6F
              && appData[3] === 0x62 && appData[4] === 0x65 && appData[5] === 0) { // 'Adobe\x00'
              this.adobe = {
                version: appData[6],
                flags0: (appData[7] << 8) | appData[8],
                flags1: (appData[9] << 8) | appData[10],
                transformCode: appData[11],
              };
            }
          }
          break;
        }

        case 0xFFDB: { // DQT (Define Quantization Tables)
          const quantizationTablesLength = readUint16();
          const quantizationTablesEnd = quantizationTablesLength + offset - 2;
          while (offset < quantizationTablesEnd) {
            const quantizationTableSpec = data[offset++];
            const tableData = new Int32Array(64);
            if ((quantizationTableSpec >> 4) === 0) { // 8 bit values
              for (let j = 0; j < 64; j++) {
                const z = dctZigZag[j];
                tableData[z] = data[offset++];
              }
            } else if ((quantizationTableSpec >> 4) === 1) { // 16 bit
              for (let j = 0; j < 64; j++) {
                const z = dctZigZag[j];
                tableData[z] = readUint16();
              }
            } else {
              throw new Error('DQT: invalid table spec');
            }
            this.quantizationTables[quantizationTableSpec & 15] = tableData;
          }
          break;
        }

        case 0xFFC0: // SOF0 (Start of Frame, Baseline DCT)
        case 0xFFC1: // SOF1 (Start of Frame, Extended DCT)
        case 0xFFC2: { // SOF2 (Start of Frame, Progressive DCT)
          readUint16(); // skip data length
          const frame = {
            extended: (fileMarker === 0xFFC1),
            progressive: (fileMarker === 0xFFC2),
            precision: data[offset++],
            scanLines: readUint16(),
            samplesPerLine: readUint16(),
            components: {},
            componentsOrder: [],
          };

          const componentsCount = data[offset++];
          let componentId;
          // let maxH = 0;
          // let maxV = 0;
          for (let i = 0; i < componentsCount; i++) {
            componentId = data[offset];
            const h = data[offset + 1] >> 4;
            const v = data[offset + 1] & 15;
            const qId = data[offset + 2];
            frame.componentsOrder.push(componentId);
            frame.components[componentId] = {
              h,
              v,
              quantizationIdx: qId,
            };
            offset += 3;
          }
          prepareComponents(frame);
          this.frames.push(frame);
          break;
        }

        case 0xFFC4: { // DHT (Define Huffman Tables)
          const huffmanLength = readUint16();
          for (let i = 2; i < huffmanLength;) {
            const huffmanTableSpec = data[offset++];
            const codeLengths = new Uint8Array(16);
            let codeLengthSum = 0;
            for (let j = 0; j < 16; j++, offset++) {
              codeLengths[j] = data[offset];
              codeLengthSum += codeLengths[j];
            }
            const huffmanValues = new Uint8Array(codeLengthSum);
            for (let j = 0; j < codeLengthSum; j++, offset++) {
              huffmanValues[j] = data[offset];
            }
            i += 17 + codeLengthSum;

            if ((huffmanTableSpec >> 4) === 0) {
              this.huffmanTablesDC[huffmanTableSpec & 15] = buildHuffmanTable(
                codeLengths, huffmanValues,
              );
            } else {
              this.huffmanTablesAC[huffmanTableSpec & 15] = buildHuffmanTable(
                codeLengths, huffmanValues,
              );
            }
          }
          break;
        }

        case 0xFFDD: // DRI (Define Restart Interval)
          readUint16(); // skip data length
          this.resetInterval = readUint16();
          break;

        case 0xFFDA: { // SOS (Start of Scan)
          readUint16(); // skip length
          const selectorsCount = data[offset++];
          const components = [];
          const frame = this.frames[0];
          for (let i = 0; i < selectorsCount; i++) {
            const component = frame.components[data[offset++]];
            const tableSpec = data[offset++];
            component.huffmanTableDC = this.huffmanTablesDC[tableSpec >> 4];
            component.huffmanTableAC = this.huffmanTablesAC[tableSpec & 15];
            components.push(component);
          }
          const spectralStart = data[offset++];
          const spectralEnd = data[offset++];
          const successiveApproximation = data[offset++];
          const processed = decodeScan(data, offset,
            frame, components, this.resetInterval,
            spectralStart, spectralEnd,
            successiveApproximation >> 4, successiveApproximation & 15);
          offset += processed;
          break;
        }

        case 0xFFFF: // Fill bytes
          if (data[offset] !== 0xFF) { // Avoid skipping a valid marker.
            offset--;
          }
          break;

        default:
          if (data[offset - 3] === 0xFF
            && data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {
            // could be incorrect encoding -- last 0xFF byte of the previous
            // block was eaten by the encoder
            offset -= 3;
            break;
          }
          throw new Error(`unknown JPEG marker ${fileMarker.toString(16)}`);
      }
      fileMarker = readUint16();
    }
  }

  getResult() {
    const { frames } = this;
    if (this.frames.length === 0) {
      throw new Error('no frames were decoded');
    } else if (this.frames.length > 1) {
      console.warn('more than one frame is not supported');
    }

    // set each frame's components quantization table
    for (let i = 0; i < this.frames.length; i++) {
      const cp = this.frames[i].components;
      for (const j of Object.keys(cp)) {
        cp[j].quantizationTable = this.quantizationTables[cp[j].quantizationIdx];
        delete cp[j].quantizationIdx;
      }
    }

    const frame = frames[0];
    const { components, componentsOrder } = frame;
    const outComponents = [];
    const width = frame.samplesPerLine;
    const height = frame.scanLines;

    for (let i = 0; i < componentsOrder.length; i++) {
      const component = components[componentsOrder[i]];
      outComponents.push({
        lines: buildComponentData(frame, component),
        scaleX: component.h / frame.maxH,
        scaleY: component.v / frame.maxV,
      });
    }

    const out = new Uint8Array(width * height * outComponents.length);
    let oi = 0;
    for (let y = 0; y < height; ++y) {
      for (let x = 0; x < width; ++x) {
        for (let i = 0; i < outComponents.length; ++i) {
          const component = outComponents[i];
          out[oi] = component.lines[0 | y * component.scaleY][0 | x * component.scaleX];
          ++oi;
        }
      }
    }
    return out;
  }
}

class JpegDecoder extends _basedecoder__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(fileDirectory) {
    super();
    this.reader = new JpegStreamReader();
    if (fileDirectory.JPEGTables) {
      this.reader.parse(fileDirectory.JPEGTables);
    }
  }

  decodeBlock(buffer) {
    this.reader.resetFrames();
    this.reader.parse(new Uint8Array(buffer));
    return this.reader.getResult().buffer;
  }
}


/***/ }),

/***/ "./node_modules/geotiff/src/predictor.js":
/*!***********************************************!*\
  !*** ./node_modules/geotiff/src/predictor.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "applyPredictor": () => (/* binding */ applyPredictor)
/* harmony export */ });
function decodeRowAcc(row, stride) {
  let length = row.length - stride;
  let offset = 0;
  do {
    for (let i = stride; i > 0; i--) {
      row[offset + stride] += row[offset];
      offset++;
    }

    length -= stride;
  } while (length > 0);
}

function decodeRowFloatingPoint(row, stride, bytesPerSample) {
  let index = 0;
  let count = row.length;
  const wc = count / bytesPerSample;

  while (count > stride) {
    for (let i = stride; i > 0; --i) {
      row[index + stride] += row[index];
      ++index;
    }
    count -= stride;
  }

  const copy = row.slice();
  for (let i = 0; i < wc; ++i) {
    for (let b = 0; b < bytesPerSample; ++b) {
      row[(bytesPerSample * i) + b] = copy[((bytesPerSample - b - 1) * wc) + i];
    }
  }
}

function applyPredictor(block, predictor, width, height, bitsPerSample,
  planarConfiguration) {
  if (!predictor || predictor === 1) {
    return block;
  }

  for (let i = 0; i < bitsPerSample.length; ++i) {
    if (bitsPerSample[i] % 8 !== 0) {
      throw new Error('When decoding with predictor, only multiple of 8 bits are supported.');
    }
    if (bitsPerSample[i] !== bitsPerSample[0]) {
      throw new Error('When decoding with predictor, all samples must have the same size.');
    }
  }

  const bytesPerSample = bitsPerSample[0] / 8;
  const stride = planarConfiguration === 2 ? 1 : bitsPerSample.length;

  for (let i = 0; i < height; ++i) {
    // Last strip will be truncated if height % stripHeight != 0
    if (i * stride * width * bytesPerSample >= block.byteLength) {
      break;
    }
    let row;
    if (predictor === 2) { // horizontal prediction
      switch (bitsPerSample[0]) {
        case 8:
          row = new Uint8Array(
            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,
          );
          break;
        case 16:
          row = new Uint16Array(
            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 2,
          );
          break;
        case 32:
          row = new Uint32Array(
            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 4,
          );
          break;
        default:
          throw new Error(`Predictor 2 not allowed with ${bitsPerSample[0]} bits per sample.`);
      }
      decodeRowAcc(row, stride, bytesPerSample);
    } else if (predictor === 3) { // horizontal floating point
      row = new Uint8Array(
        block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,
      );
      decodeRowFloatingPoint(row, stride, bytesPerSample);
    }
  }
  return block;
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfZ2VvdGlmZl9zcmNfY29tcHJlc3Npb25fanBlZ19qcy5idW5kbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBOEM7O0FBRS9CO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwwREFBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ25Cd0M7O0FBRXhDLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEIscUJBQXFCO0FBQ3JCLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0Qix1QkFBdUI7QUFDdkIsd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0JBQXdCOztBQUV0QztBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUIsb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwyQkFBMkI7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDBDQUEwQztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ2g0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUIsb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsa0JBQWtCO0FBQzVFO0FBQ0E7QUFDQSxNQUFNLDRCQUE0QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFwc2J1bmRsZS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL3NyYy9jb21wcmVzc2lvbi9iYXNlZGVjb2Rlci5qcyIsIndlYnBhY2s6Ly9tYXBzYnVuZGxlLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvc3JjL2NvbXByZXNzaW9uL2pwZWcuanMiLCJ3ZWJwYWNrOi8vbWFwc2J1bmRsZS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL3NyYy9wcmVkaWN0b3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXBwbHlQcmVkaWN0b3IgfSBmcm9tICcuLi9wcmVkaWN0b3InO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlRGVjb2RlciB7XG4gIGFzeW5jIGRlY29kZShmaWxlRGlyZWN0b3J5LCBidWZmZXIpIHtcbiAgICBjb25zdCBkZWNvZGVkID0gYXdhaXQgdGhpcy5kZWNvZGVCbG9jayhidWZmZXIpO1xuICAgIGNvbnN0IHByZWRpY3RvciA9IGZpbGVEaXJlY3RvcnkuUHJlZGljdG9yIHx8IDE7XG4gICAgaWYgKHByZWRpY3RvciAhPT0gMSkge1xuICAgICAgY29uc3QgaXNUaWxlZCA9ICFmaWxlRGlyZWN0b3J5LlN0cmlwT2Zmc2V0cztcbiAgICAgIGNvbnN0IHRpbGVXaWR0aCA9IGlzVGlsZWQgPyBmaWxlRGlyZWN0b3J5LlRpbGVXaWR0aCA6IGZpbGVEaXJlY3RvcnkuSW1hZ2VXaWR0aDtcbiAgICAgIGNvbnN0IHRpbGVIZWlnaHQgPSBpc1RpbGVkID8gZmlsZURpcmVjdG9yeS5UaWxlTGVuZ3RoIDogKFxuICAgICAgICBmaWxlRGlyZWN0b3J5LlJvd3NQZXJTdHJpcCB8fCBmaWxlRGlyZWN0b3J5LkltYWdlTGVuZ3RoXG4gICAgICApO1xuICAgICAgcmV0dXJuIGFwcGx5UHJlZGljdG9yKFxuICAgICAgICBkZWNvZGVkLCBwcmVkaWN0b3IsIHRpbGVXaWR0aCwgdGlsZUhlaWdodCwgZmlsZURpcmVjdG9yeS5CaXRzUGVyU2FtcGxlLFxuICAgICAgICBmaWxlRGlyZWN0b3J5LlBsYW5hckNvbmZpZ3VyYXRpb24sXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZGVjb2RlZDtcbiAgfVxufVxuIiwiaW1wb3J0IEJhc2VEZWNvZGVyIGZyb20gJy4vYmFzZWRlY29kZXInO1xuXG4vKiAtKi0gdGFiLXdpZHRoOiAyOyBpbmRlbnQtdGFicy1tb2RlOiBuaWw7IGMtYmFzaWMtb2Zmc2V0OiAyIC0qLSAvXG4vKiB2aW06IHNldCBzaGlmdHdpZHRoPTIgdGFic3RvcD0yIGF1dG9pbmRlbnQgY2luZGVudCBleHBhbmR0YWI6ICovXG4vKlxuICAgQ29weXJpZ2h0IDIwMTEgbm90bWFzdGVyeWV0XG4gICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuLy8gLSBUaGUgSlBFRyBzcGVjaWZpY2F0aW9uIGNhbiBiZSBmb3VuZCBpbiB0aGUgSVRVIENDSVRUIFJlY29tbWVuZGF0aW9uIFQuODFcbi8vICAgKHd3dy53My5vcmcvR3JhcGhpY3MvSlBFRy9pdHUtdDgxLnBkZilcbi8vIC0gVGhlIEpGSUYgc3BlY2lmaWNhdGlvbiBjYW4gYmUgZm91bmQgaW4gdGhlIEpQRUcgRmlsZSBJbnRlcmNoYW5nZSBGb3JtYXRcbi8vICAgKHd3dy53My5vcmcvR3JhcGhpY3MvSlBFRy9qZmlmMy5wZGYpXG4vLyAtIFRoZSBBZG9iZSBBcHBsaWNhdGlvbi1TcGVjaWZpYyBKUEVHIG1hcmtlcnMgaW4gdGhlIFN1cHBvcnRpbmcgdGhlIERDVCBGaWx0ZXJzXG4vLyAgIGluIFBvc3RTY3JpcHQgTGV2ZWwgMiwgVGVjaG5pY2FsIE5vdGUgIzUxMTZcbi8vICAgKHBhcnRuZXJzLmFkb2JlLmNvbS9wdWJsaWMvZGV2ZWxvcGVyL2VuL3BzL3Nkay81MTE2LkRDVF9GaWx0ZXIucGRmKVxuXG5jb25zdCBkY3RaaWdaYWcgPSBuZXcgSW50MzJBcnJheShbXG4gIDAsXG4gIDEsIDgsXG4gIDE2LCA5LCAyLFxuICAzLCAxMCwgMTcsIDI0LFxuICAzMiwgMjUsIDE4LCAxMSwgNCxcbiAgNSwgMTIsIDE5LCAyNiwgMzMsIDQwLFxuICA0OCwgNDEsIDM0LCAyNywgMjAsIDEzLCA2LFxuICA3LCAxNCwgMjEsIDI4LCAzNSwgNDIsIDQ5LCA1NixcbiAgNTcsIDUwLCA0MywgMzYsIDI5LCAyMiwgMTUsXG4gIDIzLCAzMCwgMzcsIDQ0LCA1MSwgNTgsXG4gIDU5LCA1MiwgNDUsIDM4LCAzMSxcbiAgMzksIDQ2LCA1MywgNjAsXG4gIDYxLCA1NCwgNDcsXG4gIDU1LCA2MixcbiAgNjMsXG5dKTtcblxuY29uc3QgZGN0Q29zMSA9IDQwMTc7IC8vIGNvcyhwaS8xNilcbmNvbnN0IGRjdFNpbjEgPSA3OTk7IC8vIHNpbihwaS8xNilcbmNvbnN0IGRjdENvczMgPSAzNDA2OyAvLyBjb3MoMypwaS8xNilcbmNvbnN0IGRjdFNpbjMgPSAyMjc2OyAvLyBzaW4oMypwaS8xNilcbmNvbnN0IGRjdENvczYgPSAxNTY3OyAvLyBjb3MoNipwaS8xNilcbmNvbnN0IGRjdFNpbjYgPSAzNzg0OyAvLyBzaW4oNipwaS8xNilcbmNvbnN0IGRjdFNxcnQyID0gNTc5MzsgLy8gc3FydCgyKVxuY29uc3QgZGN0U3FydDFkMiA9IDI4OTY7Ly8gc3FydCgyKSAvIDJcblxuZnVuY3Rpb24gYnVpbGRIdWZmbWFuVGFibGUoY29kZUxlbmd0aHMsIHZhbHVlcykge1xuICBsZXQgayA9IDA7XG4gIGNvbnN0IGNvZGUgPSBbXTtcbiAgbGV0IGxlbmd0aCA9IDE2O1xuICB3aGlsZSAobGVuZ3RoID4gMCAmJiAhY29kZUxlbmd0aHNbbGVuZ3RoIC0gMV0pIHtcbiAgICAtLWxlbmd0aDtcbiAgfVxuICBjb2RlLnB1c2goeyBjaGlsZHJlbjogW10sIGluZGV4OiAwIH0pO1xuXG4gIGxldCBwID0gY29kZVswXTtcbiAgbGV0IHE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvZGVMZW5ndGhzW2ldOyBqKyspIHtcbiAgICAgIHAgPSBjb2RlLnBvcCgpO1xuICAgICAgcC5jaGlsZHJlbltwLmluZGV4XSA9IHZhbHVlc1trXTtcbiAgICAgIHdoaWxlIChwLmluZGV4ID4gMCkge1xuICAgICAgICBwID0gY29kZS5wb3AoKTtcbiAgICAgIH1cbiAgICAgIHAuaW5kZXgrKztcbiAgICAgIGNvZGUucHVzaChwKTtcbiAgICAgIHdoaWxlIChjb2RlLmxlbmd0aCA8PSBpKSB7XG4gICAgICAgIGNvZGUucHVzaChxID0geyBjaGlsZHJlbjogW10sIGluZGV4OiAwIH0pO1xuICAgICAgICBwLmNoaWxkcmVuW3AuaW5kZXhdID0gcS5jaGlsZHJlbjtcbiAgICAgICAgcCA9IHE7XG4gICAgICB9XG4gICAgICBrKys7XG4gICAgfVxuICAgIGlmIChpICsgMSA8IGxlbmd0aCkge1xuICAgICAgLy8gcCBoZXJlIHBvaW50cyB0byBsYXN0IGNvZGVcbiAgICAgIGNvZGUucHVzaChxID0geyBjaGlsZHJlbjogW10sIGluZGV4OiAwIH0pO1xuICAgICAgcC5jaGlsZHJlbltwLmluZGV4XSA9IHEuY2hpbGRyZW47XG4gICAgICBwID0gcTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvZGVbMF0uY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIGRlY29kZVNjYW4oZGF0YSwgaW5pdGlhbE9mZnNldCxcbiAgZnJhbWUsIGNvbXBvbmVudHMsIHJlc2V0SW50ZXJ2YWwsXG4gIHNwZWN0cmFsU3RhcnQsIHNwZWN0cmFsRW5kLFxuICBzdWNjZXNzaXZlUHJldiwgc3VjY2Vzc2l2ZSkge1xuICBjb25zdCB7IG1jdXNQZXJMaW5lLCBwcm9ncmVzc2l2ZSB9ID0gZnJhbWU7XG5cbiAgY29uc3Qgc3RhcnRPZmZzZXQgPSBpbml0aWFsT2Zmc2V0O1xuICBsZXQgb2Zmc2V0ID0gaW5pdGlhbE9mZnNldDtcbiAgbGV0IGJpdHNEYXRhID0gMDtcbiAgbGV0IGJpdHNDb3VudCA9IDA7XG4gIGZ1bmN0aW9uIHJlYWRCaXQoKSB7XG4gICAgaWYgKGJpdHNDb3VudCA+IDApIHtcbiAgICAgIGJpdHNDb3VudC0tO1xuICAgICAgcmV0dXJuIChiaXRzRGF0YSA+PiBiaXRzQ291bnQpICYgMTtcbiAgICB9XG4gICAgYml0c0RhdGEgPSBkYXRhW29mZnNldCsrXTtcbiAgICBpZiAoYml0c0RhdGEgPT09IDB4RkYpIHtcbiAgICAgIGNvbnN0IG5leHRCeXRlID0gZGF0YVtvZmZzZXQrK107XG4gICAgICBpZiAobmV4dEJ5dGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmV4cGVjdGVkIG1hcmtlcjogJHsoKGJpdHNEYXRhIDw8IDgpIHwgbmV4dEJ5dGUpLnRvU3RyaW5nKDE2KX1gKTtcbiAgICAgIH1cbiAgICAgIC8vIHVuc3R1ZmYgMFxuICAgIH1cbiAgICBiaXRzQ291bnQgPSA3O1xuICAgIHJldHVybiBiaXRzRGF0YSA+Pj4gNztcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGVIdWZmbWFuKHRyZWUpIHtcbiAgICBsZXQgbm9kZSA9IHRyZWU7XG4gICAgbGV0IGJpdDtcbiAgICB3aGlsZSAoKGJpdCA9IHJlYWRCaXQoKSkgIT09IG51bGwpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25kLWFzc2lnblxuICAgICAgbm9kZSA9IG5vZGVbYml0XTtcbiAgICAgIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBodWZmbWFuIHNlcXVlbmNlJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIHJlY2VpdmUoaW5pdGlhbExlbmd0aCkge1xuICAgIGxldCBsZW5ndGggPSBpbml0aWFsTGVuZ3RoO1xuICAgIGxldCBuID0gMDtcbiAgICB3aGlsZSAobGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgYml0ID0gcmVhZEJpdCgpO1xuICAgICAgaWYgKGJpdCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgbiA9IChuIDw8IDEpIHwgYml0O1xuICAgICAgLS1sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9XG4gIGZ1bmN0aW9uIHJlY2VpdmVBbmRFeHRlbmQobGVuZ3RoKSB7XG4gICAgY29uc3QgbiA9IHJlY2VpdmUobGVuZ3RoKTtcbiAgICBpZiAobiA+PSAxIDw8IChsZW5ndGggLSAxKSkge1xuICAgICAgcmV0dXJuIG47XG4gICAgfVxuICAgIHJldHVybiBuICsgKC0xIDw8IGxlbmd0aCkgKyAxO1xuICB9XG4gIGZ1bmN0aW9uIGRlY29kZUJhc2VsaW5lKGNvbXBvbmVudCwgenopIHtcbiAgICBjb25zdCB0ID0gZGVjb2RlSHVmZm1hbihjb21wb25lbnQuaHVmZm1hblRhYmxlREMpO1xuICAgIGNvbnN0IGRpZmYgPSB0ID09PSAwID8gMCA6IHJlY2VpdmVBbmRFeHRlbmQodCk7XG4gICAgY29tcG9uZW50LnByZWQgKz0gZGlmZjtcbiAgICB6elswXSA9IGNvbXBvbmVudC5wcmVkO1xuICAgIGxldCBrID0gMTtcbiAgICB3aGlsZSAoayA8IDY0KSB7XG4gICAgICBjb25zdCBycyA9IGRlY29kZUh1ZmZtYW4oY29tcG9uZW50Lmh1ZmZtYW5UYWJsZUFDKTtcbiAgICAgIGNvbnN0IHMgPSBycyAmIDE1O1xuICAgICAgY29uc3QgciA9IHJzID4+IDQ7XG4gICAgICBpZiAocyA9PT0gMCkge1xuICAgICAgICBpZiAociA8IDE1KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgayArPSAxNjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGsgKz0gcjtcbiAgICAgICAgY29uc3QgeiA9IGRjdFppZ1phZ1trXTtcbiAgICAgICAgenpbel0gPSByZWNlaXZlQW5kRXh0ZW5kKHMpO1xuICAgICAgICBrKys7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGRlY29kZURDRmlyc3QoY29tcG9uZW50LCB6eikge1xuICAgIGNvbnN0IHQgPSBkZWNvZGVIdWZmbWFuKGNvbXBvbmVudC5odWZmbWFuVGFibGVEQyk7XG4gICAgY29uc3QgZGlmZiA9IHQgPT09IDAgPyAwIDogKHJlY2VpdmVBbmRFeHRlbmQodCkgPDwgc3VjY2Vzc2l2ZSk7XG4gICAgY29tcG9uZW50LnByZWQgKz0gZGlmZjtcbiAgICB6elswXSA9IGNvbXBvbmVudC5wcmVkO1xuICB9XG4gIGZ1bmN0aW9uIGRlY29kZURDU3VjY2Vzc2l2ZShjb21wb25lbnQsIHp6KSB7XG4gICAgenpbMF0gfD0gcmVhZEJpdCgpIDw8IHN1Y2Nlc3NpdmU7XG4gIH1cbiAgbGV0IGVvYnJ1biA9IDA7XG4gIGZ1bmN0aW9uIGRlY29kZUFDRmlyc3QoY29tcG9uZW50LCB6eikge1xuICAgIGlmIChlb2JydW4gPiAwKSB7XG4gICAgICBlb2JydW4tLTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGsgPSBzcGVjdHJhbFN0YXJ0O1xuICAgIGNvbnN0IGUgPSBzcGVjdHJhbEVuZDtcbiAgICB3aGlsZSAoayA8PSBlKSB7XG4gICAgICBjb25zdCBycyA9IGRlY29kZUh1ZmZtYW4oY29tcG9uZW50Lmh1ZmZtYW5UYWJsZUFDKTtcbiAgICAgIGNvbnN0IHMgPSBycyAmIDE1O1xuICAgICAgY29uc3QgciA9IHJzID4+IDQ7XG4gICAgICBpZiAocyA9PT0gMCkge1xuICAgICAgICBpZiAociA8IDE1KSB7XG4gICAgICAgICAgZW9icnVuID0gcmVjZWl2ZShyKSArICgxIDw8IHIpIC0gMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBrICs9IDE2O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgayArPSByO1xuICAgICAgICBjb25zdCB6ID0gZGN0WmlnWmFnW2tdO1xuICAgICAgICB6elt6XSA9IHJlY2VpdmVBbmRFeHRlbmQocykgKiAoMSA8PCBzdWNjZXNzaXZlKTtcbiAgICAgICAgaysrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBsZXQgc3VjY2Vzc2l2ZUFDU3RhdGUgPSAwO1xuICBsZXQgc3VjY2Vzc2l2ZUFDTmV4dFZhbHVlO1xuICBmdW5jdGlvbiBkZWNvZGVBQ1N1Y2Nlc3NpdmUoY29tcG9uZW50LCB6eikge1xuICAgIGxldCBrID0gc3BlY3RyYWxTdGFydDtcbiAgICBjb25zdCBlID0gc3BlY3RyYWxFbmQ7XG4gICAgbGV0IHIgPSAwO1xuICAgIHdoaWxlIChrIDw9IGUpIHtcbiAgICAgIGNvbnN0IHogPSBkY3RaaWdaYWdba107XG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSB6elt6XSA8IDAgPyAtMSA6IDE7XG4gICAgICBzd2l0Y2ggKHN1Y2Nlc3NpdmVBQ1N0YXRlKSB7XG4gICAgICAgIGNhc2UgMDogeyAvLyBpbml0aWFsIHN0YXRlXG4gICAgICAgICAgY29uc3QgcnMgPSBkZWNvZGVIdWZmbWFuKGNvbXBvbmVudC5odWZmbWFuVGFibGVBQyk7XG4gICAgICAgICAgY29uc3QgcyA9IHJzICYgMTU7XG4gICAgICAgICAgciA9IHJzID4+IDQ7XG4gICAgICAgICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChyIDwgMTUpIHtcbiAgICAgICAgICAgICAgZW9icnVuID0gcmVjZWl2ZShyKSArICgxIDw8IHIpO1xuICAgICAgICAgICAgICBzdWNjZXNzaXZlQUNTdGF0ZSA9IDQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByID0gMTY7XG4gICAgICAgICAgICAgIHN1Y2Nlc3NpdmVBQ1N0YXRlID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHMgIT09IDEpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIEFDbiBlbmNvZGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3VjY2Vzc2l2ZUFDTmV4dFZhbHVlID0gcmVjZWl2ZUFuZEV4dGVuZChzKTtcbiAgICAgICAgICAgIHN1Y2Nlc3NpdmVBQ1N0YXRlID0gciA/IDIgOiAzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIGNhc2UgMTogLy8gc2tpcHBpbmcgciB6ZXJvIGl0ZW1zXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBpZiAoenpbel0pIHtcbiAgICAgICAgICAgIHp6W3pdICs9IChyZWFkQml0KCkgPDwgc3VjY2Vzc2l2ZSkgKiBkaXJlY3Rpb247XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHItLTtcbiAgICAgICAgICAgIGlmIChyID09PSAwKSB7XG4gICAgICAgICAgICAgIHN1Y2Nlc3NpdmVBQ1N0YXRlID0gc3VjY2Vzc2l2ZUFDU3RhdGUgPT09IDIgPyAzIDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogLy8gc2V0IHZhbHVlIGZvciBhIHplcm8gaXRlbVxuICAgICAgICAgIGlmICh6elt6XSkge1xuICAgICAgICAgICAgenpbel0gKz0gKHJlYWRCaXQoKSA8PCBzdWNjZXNzaXZlKSAqIGRpcmVjdGlvbjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgenpbel0gPSBzdWNjZXNzaXZlQUNOZXh0VmFsdWUgPDwgc3VjY2Vzc2l2ZTtcbiAgICAgICAgICAgIHN1Y2Nlc3NpdmVBQ1N0YXRlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDogLy8gZW9iXG4gICAgICAgICAgaWYgKHp6W3pdKSB7XG4gICAgICAgICAgICB6elt6XSArPSAocmVhZEJpdCgpIDw8IHN1Y2Nlc3NpdmUpICogZGlyZWN0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGsrKztcbiAgICB9XG4gICAgaWYgKHN1Y2Nlc3NpdmVBQ1N0YXRlID09PSA0KSB7XG4gICAgICBlb2JydW4tLTtcbiAgICAgIGlmIChlb2JydW4gPT09IDApIHtcbiAgICAgICAgc3VjY2Vzc2l2ZUFDU3RhdGUgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkZWNvZGVNY3UoY29tcG9uZW50LCBkZWNvZGVGdW5jdGlvbiwgbWN1LCByb3csIGNvbCkge1xuICAgIGNvbnN0IG1jdVJvdyA9IChtY3UgLyBtY3VzUGVyTGluZSkgfCAwO1xuICAgIGNvbnN0IG1jdUNvbCA9IG1jdSAlIG1jdXNQZXJMaW5lO1xuICAgIGNvbnN0IGJsb2NrUm93ID0gKG1jdVJvdyAqIGNvbXBvbmVudC52KSArIHJvdztcbiAgICBjb25zdCBibG9ja0NvbCA9IChtY3VDb2wgKiBjb21wb25lbnQuaCkgKyBjb2w7XG4gICAgZGVjb2RlRnVuY3Rpb24oY29tcG9uZW50LCBjb21wb25lbnQuYmxvY2tzW2Jsb2NrUm93XVtibG9ja0NvbF0pO1xuICB9XG4gIGZ1bmN0aW9uIGRlY29kZUJsb2NrKGNvbXBvbmVudCwgZGVjb2RlRnVuY3Rpb24sIG1jdSkge1xuICAgIGNvbnN0IGJsb2NrUm93ID0gKG1jdSAvIGNvbXBvbmVudC5ibG9ja3NQZXJMaW5lKSB8IDA7XG4gICAgY29uc3QgYmxvY2tDb2wgPSBtY3UgJSBjb21wb25lbnQuYmxvY2tzUGVyTGluZTtcbiAgICBkZWNvZGVGdW5jdGlvbihjb21wb25lbnQsIGNvbXBvbmVudC5ibG9ja3NbYmxvY2tSb3ddW2Jsb2NrQ29sXSk7XG4gIH1cblxuICBjb25zdCBjb21wb25lbnRzTGVuZ3RoID0gY29tcG9uZW50cy5sZW5ndGg7XG4gIGxldCBjb21wb25lbnQ7XG4gIGxldCBpO1xuICBsZXQgajtcbiAgbGV0IGs7XG4gIGxldCBuO1xuICBsZXQgZGVjb2RlRm47XG4gIGlmIChwcm9ncmVzc2l2ZSkge1xuICAgIGlmIChzcGVjdHJhbFN0YXJ0ID09PSAwKSB7XG4gICAgICBkZWNvZGVGbiA9IHN1Y2Nlc3NpdmVQcmV2ID09PSAwID8gZGVjb2RlRENGaXJzdCA6IGRlY29kZURDU3VjY2Vzc2l2ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVjb2RlRm4gPSBzdWNjZXNzaXZlUHJldiA9PT0gMCA/IGRlY29kZUFDRmlyc3QgOiBkZWNvZGVBQ1N1Y2Nlc3NpdmU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRlY29kZUZuID0gZGVjb2RlQmFzZWxpbmU7XG4gIH1cblxuICBsZXQgbWN1ID0gMDtcbiAgbGV0IG1hcmtlcjtcbiAgbGV0IG1jdUV4cGVjdGVkO1xuICBpZiAoY29tcG9uZW50c0xlbmd0aCA9PT0gMSkge1xuICAgIG1jdUV4cGVjdGVkID0gY29tcG9uZW50c1swXS5ibG9ja3NQZXJMaW5lICogY29tcG9uZW50c1swXS5ibG9ja3NQZXJDb2x1bW47XG4gIH0gZWxzZSB7XG4gICAgbWN1RXhwZWN0ZWQgPSBtY3VzUGVyTGluZSAqIGZyYW1lLm1jdXNQZXJDb2x1bW47XG4gIH1cblxuICBjb25zdCB1c2VkUmVzZXRJbnRlcnZhbCA9IHJlc2V0SW50ZXJ2YWwgfHwgbWN1RXhwZWN0ZWQ7XG5cbiAgd2hpbGUgKG1jdSA8IG1jdUV4cGVjdGVkKSB7XG4gICAgLy8gcmVzZXQgaW50ZXJ2YWwgc3R1ZmZcbiAgICBmb3IgKGkgPSAwOyBpIDwgY29tcG9uZW50c0xlbmd0aDsgaSsrKSB7XG4gICAgICBjb21wb25lbnRzW2ldLnByZWQgPSAwO1xuICAgIH1cbiAgICBlb2JydW4gPSAwO1xuXG4gICAgaWYgKGNvbXBvbmVudHNMZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbMF07XG4gICAgICBmb3IgKG4gPSAwOyBuIDwgdXNlZFJlc2V0SW50ZXJ2YWw7IG4rKykge1xuICAgICAgICBkZWNvZGVCbG9jayhjb21wb25lbnQsIGRlY29kZUZuLCBtY3UpO1xuICAgICAgICBtY3UrKztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChuID0gMDsgbiA8IHVzZWRSZXNldEludGVydmFsOyBuKyspIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbXBvbmVudHNMZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbaV07XG4gICAgICAgICAgY29uc3QgeyBoLCB2IH0gPSBjb21wb25lbnQ7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IHY7IGorKykge1xuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGg7IGsrKykge1xuICAgICAgICAgICAgICBkZWNvZGVNY3UoY29tcG9uZW50LCBkZWNvZGVGbiwgbWN1LCBqLCBrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWN1Kys7XG5cbiAgICAgICAgLy8gSWYgd2UndmUgcmVhY2hlZCBvdXIgZXhwZWN0ZWQgTUNVJ3MsIHN0b3AgZGVjb2RpbmdcbiAgICAgICAgaWYgKG1jdSA9PT0gbWN1RXhwZWN0ZWQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZpbmQgbWFya2VyXG4gICAgYml0c0NvdW50ID0gMDtcbiAgICBtYXJrZXIgPSAoZGF0YVtvZmZzZXRdIDw8IDgpIHwgZGF0YVtvZmZzZXQgKyAxXTtcbiAgICBpZiAobWFya2VyIDwgMHhGRjAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcmtlciB3YXMgbm90IGZvdW5kJyk7XG4gICAgfVxuXG4gICAgaWYgKG1hcmtlciA+PSAweEZGRDAgJiYgbWFya2VyIDw9IDB4RkZENykgeyAvLyBSU1R4XG4gICAgICBvZmZzZXQgKz0gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCAtIHN0YXJ0T2Zmc2V0O1xufVxuXG5mdW5jdGlvbiBidWlsZENvbXBvbmVudERhdGEoZnJhbWUsIGNvbXBvbmVudCkge1xuICBjb25zdCBsaW5lcyA9IFtdO1xuICBjb25zdCB7IGJsb2Nrc1BlckxpbmUsIGJsb2Nrc1BlckNvbHVtbiB9ID0gY29tcG9uZW50O1xuICBjb25zdCBzYW1wbGVzUGVyTGluZSA9IGJsb2Nrc1BlckxpbmUgPDwgMztcbiAgY29uc3QgUiA9IG5ldyBJbnQzMkFycmF5KDY0KTtcbiAgY29uc3QgciA9IG5ldyBVaW50OEFycmF5KDY0KTtcblxuICAvLyBBIHBvcnQgb2YgcG9wcGxlcidzIElEQ1QgbWV0aG9kIHdoaWNoIGluIHR1cm4gaXMgdGFrZW4gZnJvbTpcbiAgLy8gICBDaHJpc3RvcGggTG9lZmZsZXIsIEFkcmlhYW4gTGlndGVuYmVyZywgR2VvcmdlIFMuIE1vc2NoeXR6LFxuICAvLyAgIFwiUHJhY3RpY2FsIEZhc3QgMS1EIERDVCBBbGdvcml0aG1zIHdpdGggMTEgTXVsdGlwbGljYXRpb25zXCIsXG4gIC8vICAgSUVFRSBJbnRsLiBDb25mLiBvbiBBY291c3RpY3MsIFNwZWVjaCAmIFNpZ25hbCBQcm9jZXNzaW5nLCAxOTg5LFxuICAvLyAgIDk4OC05OTEuXG4gIGZ1bmN0aW9uIHF1YW50aXplQW5kSW52ZXJzZSh6eiwgZGF0YU91dCwgZGF0YUluKSB7XG4gICAgY29uc3QgcXQgPSBjb21wb25lbnQucXVhbnRpemF0aW9uVGFibGU7XG4gICAgbGV0IHYwO1xuICAgIGxldCB2MTtcbiAgICBsZXQgdjI7XG4gICAgbGV0IHYzO1xuICAgIGxldCB2NDtcbiAgICBsZXQgdjU7XG4gICAgbGV0IHY2O1xuICAgIGxldCB2NztcbiAgICBsZXQgdDtcbiAgICBjb25zdCBwID0gZGF0YUluO1xuICAgIGxldCBpO1xuXG4gICAgLy8gZGVxdWFudFxuICAgIGZvciAoaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgICBwW2ldID0genpbaV0gKiBxdFtpXTtcbiAgICB9XG5cbiAgICAvLyBpbnZlcnNlIERDVCBvbiByb3dzXG4gICAgZm9yIChpID0gMDsgaSA8IDg7ICsraSkge1xuICAgICAgY29uc3Qgcm93ID0gOCAqIGk7XG5cbiAgICAgIC8vIGNoZWNrIGZvciBhbGwtemVybyBBQyBjb2VmZmljaWVudHNcbiAgICAgIGlmIChwWzEgKyByb3ddID09PSAwICYmIHBbMiArIHJvd10gPT09IDAgJiYgcFszICsgcm93XSA9PT0gMFxuICAgICAgICAmJiBwWzQgKyByb3ddID09PSAwICYmIHBbNSArIHJvd10gPT09IDAgJiYgcFs2ICsgcm93XSA9PT0gMFxuICAgICAgICAmJiBwWzcgKyByb3ddID09PSAwKSB7XG4gICAgICAgIHQgPSAoKGRjdFNxcnQyICogcFswICsgcm93XSkgKyA1MTIpID4+IDEwO1xuICAgICAgICBwWzAgKyByb3ddID0gdDtcbiAgICAgICAgcFsxICsgcm93XSA9IHQ7XG4gICAgICAgIHBbMiArIHJvd10gPSB0O1xuICAgICAgICBwWzMgKyByb3ddID0gdDtcbiAgICAgICAgcFs0ICsgcm93XSA9IHQ7XG4gICAgICAgIHBbNSArIHJvd10gPSB0O1xuICAgICAgICBwWzYgKyByb3ddID0gdDtcbiAgICAgICAgcFs3ICsgcm93XSA9IHQ7XG4gICAgICAgIGNvbnRpbnVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHN0YWdlIDRcbiAgICAgIHYwID0gKChkY3RTcXJ0MiAqIHBbMCArIHJvd10pICsgMTI4KSA+PiA4O1xuICAgICAgdjEgPSAoKGRjdFNxcnQyICogcFs0ICsgcm93XSkgKyAxMjgpID4+IDg7XG4gICAgICB2MiA9IHBbMiArIHJvd107XG4gICAgICB2MyA9IHBbNiArIHJvd107XG4gICAgICB2NCA9ICgoZGN0U3FydDFkMiAqIChwWzEgKyByb3ddIC0gcFs3ICsgcm93XSkpICsgMTI4KSA+PiA4O1xuICAgICAgdjcgPSAoKGRjdFNxcnQxZDIgKiAocFsxICsgcm93XSArIHBbNyArIHJvd10pKSArIDEyOCkgPj4gODtcbiAgICAgIHY1ID0gcFszICsgcm93XSA8PCA0O1xuICAgICAgdjYgPSBwWzUgKyByb3ddIDw8IDQ7XG5cbiAgICAgIC8vIHN0YWdlIDNcbiAgICAgIHQgPSAodjAgLSB2MSArIDEpID4+IDE7XG4gICAgICB2MCA9ICh2MCArIHYxICsgMSkgPj4gMTtcbiAgICAgIHYxID0gdDtcbiAgICAgIHQgPSAoKHYyICogZGN0U2luNikgKyAodjMgKiBkY3RDb3M2KSArIDEyOCkgPj4gODtcbiAgICAgIHYyID0gKCh2MiAqIGRjdENvczYpIC0gKHYzICogZGN0U2luNikgKyAxMjgpID4+IDg7XG4gICAgICB2MyA9IHQ7XG4gICAgICB0ID0gKHY0IC0gdjYgKyAxKSA+PiAxO1xuICAgICAgdjQgPSAodjQgKyB2NiArIDEpID4+IDE7XG4gICAgICB2NiA9IHQ7XG4gICAgICB0ID0gKHY3ICsgdjUgKyAxKSA+PiAxO1xuICAgICAgdjUgPSAodjcgLSB2NSArIDEpID4+IDE7XG4gICAgICB2NyA9IHQ7XG5cbiAgICAgIC8vIHN0YWdlIDJcbiAgICAgIHQgPSAodjAgLSB2MyArIDEpID4+IDE7XG4gICAgICB2MCA9ICh2MCArIHYzICsgMSkgPj4gMTtcbiAgICAgIHYzID0gdDtcbiAgICAgIHQgPSAodjEgLSB2MiArIDEpID4+IDE7XG4gICAgICB2MSA9ICh2MSArIHYyICsgMSkgPj4gMTtcbiAgICAgIHYyID0gdDtcbiAgICAgIHQgPSAoKHY0ICogZGN0U2luMykgKyAodjcgKiBkY3RDb3MzKSArIDIwNDgpID4+IDEyO1xuICAgICAgdjQgPSAoKHY0ICogZGN0Q29zMykgLSAodjcgKiBkY3RTaW4zKSArIDIwNDgpID4+IDEyO1xuICAgICAgdjcgPSB0O1xuICAgICAgdCA9ICgodjUgKiBkY3RTaW4xKSArICh2NiAqIGRjdENvczEpICsgMjA0OCkgPj4gMTI7XG4gICAgICB2NSA9ICgodjUgKiBkY3RDb3MxKSAtICh2NiAqIGRjdFNpbjEpICsgMjA0OCkgPj4gMTI7XG4gICAgICB2NiA9IHQ7XG5cbiAgICAgIC8vIHN0YWdlIDFcbiAgICAgIHBbMCArIHJvd10gPSB2MCArIHY3O1xuICAgICAgcFs3ICsgcm93XSA9IHYwIC0gdjc7XG4gICAgICBwWzEgKyByb3ddID0gdjEgKyB2NjtcbiAgICAgIHBbNiArIHJvd10gPSB2MSAtIHY2O1xuICAgICAgcFsyICsgcm93XSA9IHYyICsgdjU7XG4gICAgICBwWzUgKyByb3ddID0gdjIgLSB2NTtcbiAgICAgIHBbMyArIHJvd10gPSB2MyArIHY0O1xuICAgICAgcFs0ICsgcm93XSA9IHYzIC0gdjQ7XG4gICAgfVxuXG4gICAgLy8gaW52ZXJzZSBEQ1Qgb24gY29sdW1uc1xuICAgIGZvciAoaSA9IDA7IGkgPCA4OyArK2kpIHtcbiAgICAgIGNvbnN0IGNvbCA9IGk7XG5cbiAgICAgIC8vIGNoZWNrIGZvciBhbGwtemVybyBBQyBjb2VmZmljaWVudHNcbiAgICAgIGlmIChwWygxICogOCkgKyBjb2xdID09PSAwICYmIHBbKDIgKiA4KSArIGNvbF0gPT09IDAgJiYgcFsoMyAqIDgpICsgY29sXSA9PT0gMFxuICAgICAgICAmJiBwWyg0ICogOCkgKyBjb2xdID09PSAwICYmIHBbKDUgKiA4KSArIGNvbF0gPT09IDAgJiYgcFsoNiAqIDgpICsgY29sXSA9PT0gMFxuICAgICAgICAmJiBwWyg3ICogOCkgKyBjb2xdID09PSAwKSB7XG4gICAgICAgIHQgPSAoKGRjdFNxcnQyICogZGF0YUluW2kgKyAwXSkgKyA4MTkyKSA+PiAxNDtcbiAgICAgICAgcFsoMCAqIDgpICsgY29sXSA9IHQ7XG4gICAgICAgIHBbKDEgKiA4KSArIGNvbF0gPSB0O1xuICAgICAgICBwWygyICogOCkgKyBjb2xdID0gdDtcbiAgICAgICAgcFsoMyAqIDgpICsgY29sXSA9IHQ7XG4gICAgICAgIHBbKDQgKiA4KSArIGNvbF0gPSB0O1xuICAgICAgICBwWyg1ICogOCkgKyBjb2xdID0gdDtcbiAgICAgICAgcFsoNiAqIDgpICsgY29sXSA9IHQ7XG4gICAgICAgIHBbKDcgKiA4KSArIGNvbF0gPSB0O1xuICAgICAgICBjb250aW51ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyBzdGFnZSA0XG4gICAgICB2MCA9ICgoZGN0U3FydDIgKiBwWygwICogOCkgKyBjb2xdKSArIDIwNDgpID4+IDEyO1xuICAgICAgdjEgPSAoKGRjdFNxcnQyICogcFsoNCAqIDgpICsgY29sXSkgKyAyMDQ4KSA+PiAxMjtcbiAgICAgIHYyID0gcFsoMiAqIDgpICsgY29sXTtcbiAgICAgIHYzID0gcFsoNiAqIDgpICsgY29sXTtcbiAgICAgIHY0ID0gKChkY3RTcXJ0MWQyICogKHBbKDEgKiA4KSArIGNvbF0gLSBwWyg3ICogOCkgKyBjb2xdKSkgKyAyMDQ4KSA+PiAxMjtcbiAgICAgIHY3ID0gKChkY3RTcXJ0MWQyICogKHBbKDEgKiA4KSArIGNvbF0gKyBwWyg3ICogOCkgKyBjb2xdKSkgKyAyMDQ4KSA+PiAxMjtcbiAgICAgIHY1ID0gcFsoMyAqIDgpICsgY29sXTtcbiAgICAgIHY2ID0gcFsoNSAqIDgpICsgY29sXTtcblxuICAgICAgLy8gc3RhZ2UgM1xuICAgICAgdCA9ICh2MCAtIHYxICsgMSkgPj4gMTtcbiAgICAgIHYwID0gKHYwICsgdjEgKyAxKSA+PiAxO1xuICAgICAgdjEgPSB0O1xuICAgICAgdCA9ICgodjIgKiBkY3RTaW42KSArICh2MyAqIGRjdENvczYpICsgMjA0OCkgPj4gMTI7XG4gICAgICB2MiA9ICgodjIgKiBkY3RDb3M2KSAtICh2MyAqIGRjdFNpbjYpICsgMjA0OCkgPj4gMTI7XG4gICAgICB2MyA9IHQ7XG4gICAgICB0ID0gKHY0IC0gdjYgKyAxKSA+PiAxO1xuICAgICAgdjQgPSAodjQgKyB2NiArIDEpID4+IDE7XG4gICAgICB2NiA9IHQ7XG4gICAgICB0ID0gKHY3ICsgdjUgKyAxKSA+PiAxO1xuICAgICAgdjUgPSAodjcgLSB2NSArIDEpID4+IDE7XG4gICAgICB2NyA9IHQ7XG5cbiAgICAgIC8vIHN0YWdlIDJcbiAgICAgIHQgPSAodjAgLSB2MyArIDEpID4+IDE7XG4gICAgICB2MCA9ICh2MCArIHYzICsgMSkgPj4gMTtcbiAgICAgIHYzID0gdDtcbiAgICAgIHQgPSAodjEgLSB2MiArIDEpID4+IDE7XG4gICAgICB2MSA9ICh2MSArIHYyICsgMSkgPj4gMTtcbiAgICAgIHYyID0gdDtcbiAgICAgIHQgPSAoKHY0ICogZGN0U2luMykgKyAodjcgKiBkY3RDb3MzKSArIDIwNDgpID4+IDEyO1xuICAgICAgdjQgPSAoKHY0ICogZGN0Q29zMykgLSAodjcgKiBkY3RTaW4zKSArIDIwNDgpID4+IDEyO1xuICAgICAgdjcgPSB0O1xuICAgICAgdCA9ICgodjUgKiBkY3RTaW4xKSArICh2NiAqIGRjdENvczEpICsgMjA0OCkgPj4gMTI7XG4gICAgICB2NSA9ICgodjUgKiBkY3RDb3MxKSAtICh2NiAqIGRjdFNpbjEpICsgMjA0OCkgPj4gMTI7XG4gICAgICB2NiA9IHQ7XG5cbiAgICAgIC8vIHN0YWdlIDFcbiAgICAgIHBbKDAgKiA4KSArIGNvbF0gPSB2MCArIHY3O1xuICAgICAgcFsoNyAqIDgpICsgY29sXSA9IHYwIC0gdjc7XG4gICAgICBwWygxICogOCkgKyBjb2xdID0gdjEgKyB2NjtcbiAgICAgIHBbKDYgKiA4KSArIGNvbF0gPSB2MSAtIHY2O1xuICAgICAgcFsoMiAqIDgpICsgY29sXSA9IHYyICsgdjU7XG4gICAgICBwWyg1ICogOCkgKyBjb2xdID0gdjIgLSB2NTtcbiAgICAgIHBbKDMgKiA4KSArIGNvbF0gPSB2MyArIHY0O1xuICAgICAgcFsoNCAqIDgpICsgY29sXSA9IHYzIC0gdjQ7XG4gICAgfVxuXG4gICAgLy8gY29udmVydCB0byA4LWJpdCBpbnRlZ2Vyc1xuICAgIGZvciAoaSA9IDA7IGkgPCA2NDsgKytpKSB7XG4gICAgICBjb25zdCBzYW1wbGUgPSAxMjggKyAoKHBbaV0gKyA4KSA+PiA0KTtcbiAgICAgIGlmIChzYW1wbGUgPCAwKSB7XG4gICAgICAgIGRhdGFPdXRbaV0gPSAwO1xuICAgICAgfSBlbHNlIGlmIChzYW1wbGUgPiAwWEZGKSB7XG4gICAgICAgIGRhdGFPdXRbaV0gPSAweEZGO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YU91dFtpXSA9IHNhbXBsZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKGxldCBibG9ja1JvdyA9IDA7IGJsb2NrUm93IDwgYmxvY2tzUGVyQ29sdW1uOyBibG9ja1JvdysrKSB7XG4gICAgY29uc3Qgc2NhbkxpbmUgPSBibG9ja1JvdyA8PCAzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICBsaW5lcy5wdXNoKG5ldyBVaW50OEFycmF5KHNhbXBsZXNQZXJMaW5lKSk7XG4gICAgfVxuICAgIGZvciAobGV0IGJsb2NrQ29sID0gMDsgYmxvY2tDb2wgPCBibG9ja3NQZXJMaW5lOyBibG9ja0NvbCsrKSB7XG4gICAgICBxdWFudGl6ZUFuZEludmVyc2UoY29tcG9uZW50LmJsb2Nrc1tibG9ja1Jvd11bYmxvY2tDb2xdLCByLCBSKTtcblxuICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICBjb25zdCBzYW1wbGUgPSBibG9ja0NvbCA8PCAzO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA4OyBqKyspIHtcbiAgICAgICAgY29uc3QgbGluZSA9IGxpbmVzW3NjYW5MaW5lICsgal07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICAgICAgbGluZVtzYW1wbGUgKyBpXSA9IHJbb2Zmc2V0KytdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBsaW5lcztcbn1cblxuY2xhc3MgSnBlZ1N0cmVhbVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuamZpZiA9IG51bGw7XG4gICAgdGhpcy5hZG9iZSA9IG51bGw7XG5cbiAgICB0aGlzLnF1YW50aXphdGlvblRhYmxlcyA9IFtdO1xuICAgIHRoaXMuaHVmZm1hblRhYmxlc0FDID0gW107XG4gICAgdGhpcy5odWZmbWFuVGFibGVzREMgPSBbXTtcbiAgICB0aGlzLnJlc2V0RnJhbWVzKCk7XG4gIH1cblxuICByZXNldEZyYW1lcygpIHtcbiAgICB0aGlzLmZyYW1lcyA9IFtdO1xuICB9XG5cbiAgcGFyc2UoZGF0YSkge1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIC8vIGNvbnN0IHsgbGVuZ3RoIH0gPSBkYXRhO1xuICAgIGZ1bmN0aW9uIHJlYWRVaW50MTYoKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IChkYXRhW29mZnNldF0gPDwgOCkgfCBkYXRhW29mZnNldCArIDFdO1xuICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWREYXRhQmxvY2soKSB7XG4gICAgICBjb25zdCBsZW5ndGggPSByZWFkVWludDE2KCk7XG4gICAgICBjb25zdCBhcnJheSA9IGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGggLSAyKTtcbiAgICAgIG9mZnNldCArPSBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZXBhcmVDb21wb25lbnRzKGZyYW1lKSB7XG4gICAgICBsZXQgbWF4SCA9IDA7XG4gICAgICBsZXQgbWF4ViA9IDA7XG4gICAgICBsZXQgY29tcG9uZW50O1xuICAgICAgbGV0IGNvbXBvbmVudElkO1xuICAgICAgZm9yIChjb21wb25lbnRJZCBpbiBmcmFtZS5jb21wb25lbnRzKSB7XG4gICAgICAgIGlmIChmcmFtZS5jb21wb25lbnRzLmhhc093blByb3BlcnR5KGNvbXBvbmVudElkKSkge1xuICAgICAgICAgIGNvbXBvbmVudCA9IGZyYW1lLmNvbXBvbmVudHNbY29tcG9uZW50SWRdO1xuICAgICAgICAgIGlmIChtYXhIIDwgY29tcG9uZW50LmgpIHtcbiAgICAgICAgICAgIG1heEggPSBjb21wb25lbnQuaDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1heFYgPCBjb21wb25lbnQudikge1xuICAgICAgICAgICAgbWF4ViA9IGNvbXBvbmVudC52O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgbWN1c1BlckxpbmUgPSBNYXRoLmNlaWwoZnJhbWUuc2FtcGxlc1BlckxpbmUgLyA4IC8gbWF4SCk7XG4gICAgICBjb25zdCBtY3VzUGVyQ29sdW1uID0gTWF0aC5jZWlsKGZyYW1lLnNjYW5MaW5lcyAvIDggLyBtYXhWKTtcbiAgICAgIGZvciAoY29tcG9uZW50SWQgaW4gZnJhbWUuY29tcG9uZW50cykge1xuICAgICAgICBpZiAoZnJhbWUuY29tcG9uZW50cy5oYXNPd25Qcm9wZXJ0eShjb21wb25lbnRJZCkpIHtcbiAgICAgICAgICBjb21wb25lbnQgPSBmcmFtZS5jb21wb25lbnRzW2NvbXBvbmVudElkXTtcbiAgICAgICAgICBjb25zdCBibG9ja3NQZXJMaW5lID0gTWF0aC5jZWlsKE1hdGguY2VpbChmcmFtZS5zYW1wbGVzUGVyTGluZSAvIDgpICogY29tcG9uZW50LmggLyBtYXhIKTtcbiAgICAgICAgICBjb25zdCBibG9ja3NQZXJDb2x1bW4gPSBNYXRoLmNlaWwoTWF0aC5jZWlsKGZyYW1lLnNjYW5MaW5lcyAvIDgpICogY29tcG9uZW50LnYgLyBtYXhWKTtcbiAgICAgICAgICBjb25zdCBibG9ja3NQZXJMaW5lRm9yTWN1ID0gbWN1c1BlckxpbmUgKiBjb21wb25lbnQuaDtcbiAgICAgICAgICBjb25zdCBibG9ja3NQZXJDb2x1bW5Gb3JNY3UgPSBtY3VzUGVyQ29sdW1uICogY29tcG9uZW50LnY7XG4gICAgICAgICAgY29uc3QgYmxvY2tzID0gW107XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja3NQZXJDb2x1bW5Gb3JNY3U7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgcm93ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJsb2Nrc1BlckxpbmVGb3JNY3U7IGorKykge1xuICAgICAgICAgICAgICByb3cucHVzaChuZXcgSW50MzJBcnJheSg2NCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmxvY2tzLnB1c2gocm93KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29tcG9uZW50LmJsb2Nrc1BlckxpbmUgPSBibG9ja3NQZXJMaW5lO1xuICAgICAgICAgIGNvbXBvbmVudC5ibG9ja3NQZXJDb2x1bW4gPSBibG9ja3NQZXJDb2x1bW47XG4gICAgICAgICAgY29tcG9uZW50LmJsb2NrcyA9IGJsb2NrcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnJhbWUubWF4SCA9IG1heEg7XG4gICAgICBmcmFtZS5tYXhWID0gbWF4VjtcbiAgICAgIGZyYW1lLm1jdXNQZXJMaW5lID0gbWN1c1BlckxpbmU7XG4gICAgICBmcmFtZS5tY3VzUGVyQ29sdW1uID0gbWN1c1BlckNvbHVtbjtcbiAgICB9XG5cbiAgICBsZXQgZmlsZU1hcmtlciA9IHJlYWRVaW50MTYoKTtcbiAgICBpZiAoZmlsZU1hcmtlciAhPT0gMHhGRkQ4KSB7IC8vIFNPSSAoU3RhcnQgb2YgSW1hZ2UpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NPSSBub3QgZm91bmQnKTtcbiAgICB9XG5cbiAgICBmaWxlTWFya2VyID0gcmVhZFVpbnQxNigpO1xuICAgIHdoaWxlIChmaWxlTWFya2VyICE9PSAweEZGRDkpIHsgLy8gRU9JIChFbmQgb2YgaW1hZ2UpXG4gICAgICBzd2l0Y2ggKGZpbGVNYXJrZXIpIHtcbiAgICAgICAgY2FzZSAweEZGMDA6IGJyZWFrO1xuICAgICAgICBjYXNlIDB4RkZFMDogLy8gQVBQMCAoQXBwbGljYXRpb24gU3BlY2lmaWMpXG4gICAgICAgIGNhc2UgMHhGRkUxOiAvLyBBUFAxXG4gICAgICAgIGNhc2UgMHhGRkUyOiAvLyBBUFAyXG4gICAgICAgIGNhc2UgMHhGRkUzOiAvLyBBUFAzXG4gICAgICAgIGNhc2UgMHhGRkU0OiAvLyBBUFA0XG4gICAgICAgIGNhc2UgMHhGRkU1OiAvLyBBUFA1XG4gICAgICAgIGNhc2UgMHhGRkU2OiAvLyBBUFA2XG4gICAgICAgIGNhc2UgMHhGRkU3OiAvLyBBUFA3XG4gICAgICAgIGNhc2UgMHhGRkU4OiAvLyBBUFA4XG4gICAgICAgIGNhc2UgMHhGRkU5OiAvLyBBUFA5XG4gICAgICAgIGNhc2UgMHhGRkVBOiAvLyBBUFAxMFxuICAgICAgICBjYXNlIDB4RkZFQjogLy8gQVBQMTFcbiAgICAgICAgY2FzZSAweEZGRUM6IC8vIEFQUDEyXG4gICAgICAgIGNhc2UgMHhGRkVEOiAvLyBBUFAxM1xuICAgICAgICBjYXNlIDB4RkZFRTogLy8gQVBQMTRcbiAgICAgICAgY2FzZSAweEZGRUY6IC8vIEFQUDE1XG4gICAgICAgIGNhc2UgMHhGRkZFOiB7IC8vIENPTSAoQ29tbWVudClcbiAgICAgICAgICBjb25zdCBhcHBEYXRhID0gcmVhZERhdGFCbG9jaygpO1xuXG4gICAgICAgICAgaWYgKGZpbGVNYXJrZXIgPT09IDB4RkZFMCkge1xuICAgICAgICAgICAgaWYgKGFwcERhdGFbMF0gPT09IDB4NEEgJiYgYXBwRGF0YVsxXSA9PT0gMHg0NiAmJiBhcHBEYXRhWzJdID09PSAweDQ5XG4gICAgICAgICAgICAgICYmIGFwcERhdGFbM10gPT09IDB4NDYgJiYgYXBwRGF0YVs0XSA9PT0gMCkgeyAvLyAnSkZJRlxceDAwJ1xuICAgICAgICAgICAgICB0aGlzLmpmaWYgPSB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogeyBtYWpvcjogYXBwRGF0YVs1XSwgbWlub3I6IGFwcERhdGFbNl0gfSxcbiAgICAgICAgICAgICAgICBkZW5zaXR5VW5pdHM6IGFwcERhdGFbN10sXG4gICAgICAgICAgICAgICAgeERlbnNpdHk6IChhcHBEYXRhWzhdIDw8IDgpIHwgYXBwRGF0YVs5XSxcbiAgICAgICAgICAgICAgICB5RGVuc2l0eTogKGFwcERhdGFbMTBdIDw8IDgpIHwgYXBwRGF0YVsxMV0sXG4gICAgICAgICAgICAgICAgdGh1bWJXaWR0aDogYXBwRGF0YVsxMl0sXG4gICAgICAgICAgICAgICAgdGh1bWJIZWlnaHQ6IGFwcERhdGFbMTNdLFxuICAgICAgICAgICAgICAgIHRodW1iRGF0YTogYXBwRGF0YS5zdWJhcnJheSgxNCwgMTQgKyAoMyAqIGFwcERhdGFbMTJdICogYXBwRGF0YVsxM10pKSxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVE9ETyBBUFAxIC0gRXhpZlxuICAgICAgICAgIGlmIChmaWxlTWFya2VyID09PSAweEZGRUUpIHtcbiAgICAgICAgICAgIGlmIChhcHBEYXRhWzBdID09PSAweDQxICYmIGFwcERhdGFbMV0gPT09IDB4NjQgJiYgYXBwRGF0YVsyXSA9PT0gMHg2RlxuICAgICAgICAgICAgICAmJiBhcHBEYXRhWzNdID09PSAweDYyICYmIGFwcERhdGFbNF0gPT09IDB4NjUgJiYgYXBwRGF0YVs1XSA9PT0gMCkgeyAvLyAnQWRvYmVcXHgwMCdcbiAgICAgICAgICAgICAgdGhpcy5hZG9iZSA9IHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBhcHBEYXRhWzZdLFxuICAgICAgICAgICAgICAgIGZsYWdzMDogKGFwcERhdGFbN10gPDwgOCkgfCBhcHBEYXRhWzhdLFxuICAgICAgICAgICAgICAgIGZsYWdzMTogKGFwcERhdGFbOV0gPDwgOCkgfCBhcHBEYXRhWzEwXSxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1Db2RlOiBhcHBEYXRhWzExXSxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjYXNlIDB4RkZEQjogeyAvLyBEUVQgKERlZmluZSBRdWFudGl6YXRpb24gVGFibGVzKVxuICAgICAgICAgIGNvbnN0IHF1YW50aXphdGlvblRhYmxlc0xlbmd0aCA9IHJlYWRVaW50MTYoKTtcbiAgICAgICAgICBjb25zdCBxdWFudGl6YXRpb25UYWJsZXNFbmQgPSBxdWFudGl6YXRpb25UYWJsZXNMZW5ndGggKyBvZmZzZXQgLSAyO1xuICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBxdWFudGl6YXRpb25UYWJsZXNFbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1YW50aXphdGlvblRhYmxlU3BlYyA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgICAgICAgY29uc3QgdGFibGVEYXRhID0gbmV3IEludDMyQXJyYXkoNjQpO1xuICAgICAgICAgICAgaWYgKChxdWFudGl6YXRpb25UYWJsZVNwZWMgPj4gNCkgPT09IDApIHsgLy8gOCBiaXQgdmFsdWVzXG4gICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgNjQ7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHogPSBkY3RaaWdaYWdbal07XG4gICAgICAgICAgICAgICAgdGFibGVEYXRhW3pdID0gZGF0YVtvZmZzZXQrK107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKHF1YW50aXphdGlvblRhYmxlU3BlYyA+PiA0KSA9PT0gMSkgeyAvLyAxNiBiaXRcbiAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA2NDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeiA9IGRjdFppZ1phZ1tqXTtcbiAgICAgICAgICAgICAgICB0YWJsZURhdGFbel0gPSByZWFkVWludDE2KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRFFUOiBpbnZhbGlkIHRhYmxlIHNwZWMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucXVhbnRpemF0aW9uVGFibGVzW3F1YW50aXphdGlvblRhYmxlU3BlYyAmIDE1XSA9IHRhYmxlRGF0YTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjYXNlIDB4RkZDMDogLy8gU09GMCAoU3RhcnQgb2YgRnJhbWUsIEJhc2VsaW5lIERDVClcbiAgICAgICAgY2FzZSAweEZGQzE6IC8vIFNPRjEgKFN0YXJ0IG9mIEZyYW1lLCBFeHRlbmRlZCBEQ1QpXG4gICAgICAgIGNhc2UgMHhGRkMyOiB7IC8vIFNPRjIgKFN0YXJ0IG9mIEZyYW1lLCBQcm9ncmVzc2l2ZSBEQ1QpXG4gICAgICAgICAgcmVhZFVpbnQxNigpOyAvLyBza2lwIGRhdGEgbGVuZ3RoXG4gICAgICAgICAgY29uc3QgZnJhbWUgPSB7XG4gICAgICAgICAgICBleHRlbmRlZDogKGZpbGVNYXJrZXIgPT09IDB4RkZDMSksXG4gICAgICAgICAgICBwcm9ncmVzc2l2ZTogKGZpbGVNYXJrZXIgPT09IDB4RkZDMiksXG4gICAgICAgICAgICBwcmVjaXNpb246IGRhdGFbb2Zmc2V0KytdLFxuICAgICAgICAgICAgc2NhbkxpbmVzOiByZWFkVWludDE2KCksXG4gICAgICAgICAgICBzYW1wbGVzUGVyTGluZTogcmVhZFVpbnQxNigpLFxuICAgICAgICAgICAgY29tcG9uZW50czoge30sXG4gICAgICAgICAgICBjb21wb25lbnRzT3JkZXI6IFtdLFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBjb25zdCBjb21wb25lbnRzQ291bnQgPSBkYXRhW29mZnNldCsrXTtcbiAgICAgICAgICBsZXQgY29tcG9uZW50SWQ7XG4gICAgICAgICAgLy8gbGV0IG1heEggPSAwO1xuICAgICAgICAgIC8vIGxldCBtYXhWID0gMDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbXBvbmVudHNDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb21wb25lbnRJZCA9IGRhdGFbb2Zmc2V0XTtcbiAgICAgICAgICAgIGNvbnN0IGggPSBkYXRhW29mZnNldCArIDFdID4+IDQ7XG4gICAgICAgICAgICBjb25zdCB2ID0gZGF0YVtvZmZzZXQgKyAxXSAmIDE1O1xuICAgICAgICAgICAgY29uc3QgcUlkID0gZGF0YVtvZmZzZXQgKyAyXTtcbiAgICAgICAgICAgIGZyYW1lLmNvbXBvbmVudHNPcmRlci5wdXNoKGNvbXBvbmVudElkKTtcbiAgICAgICAgICAgIGZyYW1lLmNvbXBvbmVudHNbY29tcG9uZW50SWRdID0ge1xuICAgICAgICAgICAgICBoLFxuICAgICAgICAgICAgICB2LFxuICAgICAgICAgICAgICBxdWFudGl6YXRpb25JZHg6IHFJZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBvZmZzZXQgKz0gMztcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJlcGFyZUNvbXBvbmVudHMoZnJhbWUpO1xuICAgICAgICAgIHRoaXMuZnJhbWVzLnB1c2goZnJhbWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAweEZGQzQ6IHsgLy8gREhUIChEZWZpbmUgSHVmZm1hbiBUYWJsZXMpXG4gICAgICAgICAgY29uc3QgaHVmZm1hbkxlbmd0aCA9IHJlYWRVaW50MTYoKTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMjsgaSA8IGh1ZmZtYW5MZW5ndGg7KSB7XG4gICAgICAgICAgICBjb25zdCBodWZmbWFuVGFibGVTcGVjID0gZGF0YVtvZmZzZXQrK107XG4gICAgICAgICAgICBjb25zdCBjb2RlTGVuZ3RocyA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICAgICAgICAgIGxldCBjb2RlTGVuZ3RoU3VtID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMTY7IGorKywgb2Zmc2V0KyspIHtcbiAgICAgICAgICAgICAgY29kZUxlbmd0aHNbal0gPSBkYXRhW29mZnNldF07XG4gICAgICAgICAgICAgIGNvZGVMZW5ndGhTdW0gKz0gY29kZUxlbmd0aHNbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBodWZmbWFuVmFsdWVzID0gbmV3IFVpbnQ4QXJyYXkoY29kZUxlbmd0aFN1bSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvZGVMZW5ndGhTdW07IGorKywgb2Zmc2V0KyspIHtcbiAgICAgICAgICAgICAgaHVmZm1hblZhbHVlc1tqXSA9IGRhdGFbb2Zmc2V0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkgKz0gMTcgKyBjb2RlTGVuZ3RoU3VtO1xuXG4gICAgICAgICAgICBpZiAoKGh1ZmZtYW5UYWJsZVNwZWMgPj4gNCkgPT09IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5odWZmbWFuVGFibGVzRENbaHVmZm1hblRhYmxlU3BlYyAmIDE1XSA9IGJ1aWxkSHVmZm1hblRhYmxlKFxuICAgICAgICAgICAgICAgIGNvZGVMZW5ndGhzLCBodWZmbWFuVmFsdWVzLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5odWZmbWFuVGFibGVzQUNbaHVmZm1hblRhYmxlU3BlYyAmIDE1XSA9IGJ1aWxkSHVmZm1hblRhYmxlKFxuICAgICAgICAgICAgICAgIGNvZGVMZW5ndGhzLCBodWZmbWFuVmFsdWVzLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgMHhGRkREOiAvLyBEUkkgKERlZmluZSBSZXN0YXJ0IEludGVydmFsKVxuICAgICAgICAgIHJlYWRVaW50MTYoKTsgLy8gc2tpcCBkYXRhIGxlbmd0aFxuICAgICAgICAgIHRoaXMucmVzZXRJbnRlcnZhbCA9IHJlYWRVaW50MTYoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDB4RkZEQTogeyAvLyBTT1MgKFN0YXJ0IG9mIFNjYW4pXG4gICAgICAgICAgcmVhZFVpbnQxNigpOyAvLyBza2lwIGxlbmd0aFxuICAgICAgICAgIGNvbnN0IHNlbGVjdG9yc0NvdW50ID0gZGF0YVtvZmZzZXQrK107XG4gICAgICAgICAgY29uc3QgY29tcG9uZW50cyA9IFtdO1xuICAgICAgICAgIGNvbnN0IGZyYW1lID0gdGhpcy5mcmFtZXNbMF07XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3RvcnNDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSBmcmFtZS5jb21wb25lbnRzW2RhdGFbb2Zmc2V0KytdXTtcbiAgICAgICAgICAgIGNvbnN0IHRhYmxlU3BlYyA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgICAgICAgY29tcG9uZW50Lmh1ZmZtYW5UYWJsZURDID0gdGhpcy5odWZmbWFuVGFibGVzRENbdGFibGVTcGVjID4+IDRdO1xuICAgICAgICAgICAgY29tcG9uZW50Lmh1ZmZtYW5UYWJsZUFDID0gdGhpcy5odWZmbWFuVGFibGVzQUNbdGFibGVTcGVjICYgMTVdO1xuICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHNwZWN0cmFsU3RhcnQgPSBkYXRhW29mZnNldCsrXTtcbiAgICAgICAgICBjb25zdCBzcGVjdHJhbEVuZCA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgICAgIGNvbnN0IHN1Y2Nlc3NpdmVBcHByb3hpbWF0aW9uID0gZGF0YVtvZmZzZXQrK107XG4gICAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0gZGVjb2RlU2NhbihkYXRhLCBvZmZzZXQsXG4gICAgICAgICAgICBmcmFtZSwgY29tcG9uZW50cywgdGhpcy5yZXNldEludGVydmFsLFxuICAgICAgICAgICAgc3BlY3RyYWxTdGFydCwgc3BlY3RyYWxFbmQsXG4gICAgICAgICAgICBzdWNjZXNzaXZlQXBwcm94aW1hdGlvbiA+PiA0LCBzdWNjZXNzaXZlQXBwcm94aW1hdGlvbiAmIDE1KTtcbiAgICAgICAgICBvZmZzZXQgKz0gcHJvY2Vzc2VkO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAweEZGRkY6IC8vIEZpbGwgYnl0ZXNcbiAgICAgICAgICBpZiAoZGF0YVtvZmZzZXRdICE9PSAweEZGKSB7IC8vIEF2b2lkIHNraXBwaW5nIGEgdmFsaWQgbWFya2VyLlxuICAgICAgICAgICAgb2Zmc2V0LS07XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKGRhdGFbb2Zmc2V0IC0gM10gPT09IDB4RkZcbiAgICAgICAgICAgICYmIGRhdGFbb2Zmc2V0IC0gMl0gPj0gMHhDMCAmJiBkYXRhW29mZnNldCAtIDJdIDw9IDB4RkUpIHtcbiAgICAgICAgICAgIC8vIGNvdWxkIGJlIGluY29ycmVjdCBlbmNvZGluZyAtLSBsYXN0IDB4RkYgYnl0ZSBvZiB0aGUgcHJldmlvdXNcbiAgICAgICAgICAgIC8vIGJsb2NrIHdhcyBlYXRlbiBieSB0aGUgZW5jb2RlclxuICAgICAgICAgICAgb2Zmc2V0IC09IDM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIEpQRUcgbWFya2VyICR7ZmlsZU1hcmtlci50b1N0cmluZygxNil9YCk7XG4gICAgICB9XG4gICAgICBmaWxlTWFya2VyID0gcmVhZFVpbnQxNigpO1xuICAgIH1cbiAgfVxuXG4gIGdldFJlc3VsdCgpIHtcbiAgICBjb25zdCB7IGZyYW1lcyB9ID0gdGhpcztcbiAgICBpZiAodGhpcy5mcmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGZyYW1lcyB3ZXJlIGRlY29kZWQnKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZnJhbWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGNvbnNvbGUud2FybignbW9yZSB0aGFuIG9uZSBmcmFtZSBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuXG4gICAgLy8gc2V0IGVhY2ggZnJhbWUncyBjb21wb25lbnRzIHF1YW50aXphdGlvbiB0YWJsZVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5mcmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNwID0gdGhpcy5mcmFtZXNbaV0uY29tcG9uZW50cztcbiAgICAgIGZvciAoY29uc3QgaiBvZiBPYmplY3Qua2V5cyhjcCkpIHtcbiAgICAgICAgY3Bbal0ucXVhbnRpemF0aW9uVGFibGUgPSB0aGlzLnF1YW50aXphdGlvblRhYmxlc1tjcFtqXS5xdWFudGl6YXRpb25JZHhdO1xuICAgICAgICBkZWxldGUgY3Bbal0ucXVhbnRpemF0aW9uSWR4O1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGZyYW1lID0gZnJhbWVzWzBdO1xuICAgIGNvbnN0IHsgY29tcG9uZW50cywgY29tcG9uZW50c09yZGVyIH0gPSBmcmFtZTtcbiAgICBjb25zdCBvdXRDb21wb25lbnRzID0gW107XG4gICAgY29uc3Qgd2lkdGggPSBmcmFtZS5zYW1wbGVzUGVyTGluZTtcbiAgICBjb25zdCBoZWlnaHQgPSBmcmFtZS5zY2FuTGluZXM7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbXBvbmVudHNPcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY29tcG9uZW50ID0gY29tcG9uZW50c1tjb21wb25lbnRzT3JkZXJbaV1dO1xuICAgICAgb3V0Q29tcG9uZW50cy5wdXNoKHtcbiAgICAgICAgbGluZXM6IGJ1aWxkQ29tcG9uZW50RGF0YShmcmFtZSwgY29tcG9uZW50KSxcbiAgICAgICAgc2NhbGVYOiBjb21wb25lbnQuaCAvIGZyYW1lLm1heEgsXG4gICAgICAgIHNjYWxlWTogY29tcG9uZW50LnYgLyBmcmFtZS5tYXhWLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiBvdXRDb21wb25lbnRzLmxlbmd0aCk7XG4gICAgbGV0IG9pID0gMDtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgKyt5KSB7XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyArK3gpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRDb21wb25lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gb3V0Q29tcG9uZW50c1tpXTtcbiAgICAgICAgICBvdXRbb2ldID0gY29tcG9uZW50LmxpbmVzWzAgfCB5ICogY29tcG9uZW50LnNjYWxlWV1bMCB8IHggKiBjb21wb25lbnQuc2NhbGVYXTtcbiAgICAgICAgICArK29pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSnBlZ0RlY29kZXIgZXh0ZW5kcyBCYXNlRGVjb2RlciB7XG4gIGNvbnN0cnVjdG9yKGZpbGVEaXJlY3RvcnkpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucmVhZGVyID0gbmV3IEpwZWdTdHJlYW1SZWFkZXIoKTtcbiAgICBpZiAoZmlsZURpcmVjdG9yeS5KUEVHVGFibGVzKSB7XG4gICAgICB0aGlzLnJlYWRlci5wYXJzZShmaWxlRGlyZWN0b3J5LkpQRUdUYWJsZXMpO1xuICAgIH1cbiAgfVxuXG4gIGRlY29kZUJsb2NrKGJ1ZmZlcikge1xuICAgIHRoaXMucmVhZGVyLnJlc2V0RnJhbWVzKCk7XG4gICAgdGhpcy5yZWFkZXIucGFyc2UobmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSk7XG4gICAgcmV0dXJuIHRoaXMucmVhZGVyLmdldFJlc3VsdCgpLmJ1ZmZlcjtcbiAgfVxufVxuIiwiZnVuY3Rpb24gZGVjb2RlUm93QWNjKHJvdywgc3RyaWRlKSB7XG4gIGxldCBsZW5ndGggPSByb3cubGVuZ3RoIC0gc3RyaWRlO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZG8ge1xuICAgIGZvciAobGV0IGkgPSBzdHJpZGU7IGkgPiAwOyBpLS0pIHtcbiAgICAgIHJvd1tvZmZzZXQgKyBzdHJpZGVdICs9IHJvd1tvZmZzZXRdO1xuICAgICAgb2Zmc2V0Kys7XG4gICAgfVxuXG4gICAgbGVuZ3RoIC09IHN0cmlkZTtcbiAgfSB3aGlsZSAobGVuZ3RoID4gMCk7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVJvd0Zsb2F0aW5nUG9pbnQocm93LCBzdHJpZGUsIGJ5dGVzUGVyU2FtcGxlKSB7XG4gIGxldCBpbmRleCA9IDA7XG4gIGxldCBjb3VudCA9IHJvdy5sZW5ndGg7XG4gIGNvbnN0IHdjID0gY291bnQgLyBieXRlc1BlclNhbXBsZTtcblxuICB3aGlsZSAoY291bnQgPiBzdHJpZGUpIHtcbiAgICBmb3IgKGxldCBpID0gc3RyaWRlOyBpID4gMDsgLS1pKSB7XG4gICAgICByb3dbaW5kZXggKyBzdHJpZGVdICs9IHJvd1tpbmRleF07XG4gICAgICArK2luZGV4O1xuICAgIH1cbiAgICBjb3VudCAtPSBzdHJpZGU7XG4gIH1cblxuICBjb25zdCBjb3B5ID0gcm93LnNsaWNlKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgd2M7ICsraSkge1xuICAgIGZvciAobGV0IGIgPSAwOyBiIDwgYnl0ZXNQZXJTYW1wbGU7ICsrYikge1xuICAgICAgcm93WyhieXRlc1BlclNhbXBsZSAqIGkpICsgYl0gPSBjb3B5WygoYnl0ZXNQZXJTYW1wbGUgLSBiIC0gMSkgKiB3YykgKyBpXTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5UHJlZGljdG9yKGJsb2NrLCBwcmVkaWN0b3IsIHdpZHRoLCBoZWlnaHQsIGJpdHNQZXJTYW1wbGUsXG4gIHBsYW5hckNvbmZpZ3VyYXRpb24pIHtcbiAgaWYgKCFwcmVkaWN0b3IgfHwgcHJlZGljdG9yID09PSAxKSB7XG4gICAgcmV0dXJuIGJsb2NrO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaXRzUGVyU2FtcGxlLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGJpdHNQZXJTYW1wbGVbaV0gJSA4ICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1doZW4gZGVjb2Rpbmcgd2l0aCBwcmVkaWN0b3IsIG9ubHkgbXVsdGlwbGUgb2YgOCBiaXRzIGFyZSBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuICAgIGlmIChiaXRzUGVyU2FtcGxlW2ldICE9PSBiaXRzUGVyU2FtcGxlWzBdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1doZW4gZGVjb2Rpbmcgd2l0aCBwcmVkaWN0b3IsIGFsbCBzYW1wbGVzIG11c3QgaGF2ZSB0aGUgc2FtZSBzaXplLicpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGJ5dGVzUGVyU2FtcGxlID0gYml0c1BlclNhbXBsZVswXSAvIDg7XG4gIGNvbnN0IHN0cmlkZSA9IHBsYW5hckNvbmZpZ3VyYXRpb24gPT09IDIgPyAxIDogYml0c1BlclNhbXBsZS5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWlnaHQ7ICsraSkge1xuICAgIC8vIExhc3Qgc3RyaXAgd2lsbCBiZSB0cnVuY2F0ZWQgaWYgaGVpZ2h0ICUgc3RyaXBIZWlnaHQgIT0gMFxuICAgIGlmIChpICogc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSA+PSBibG9jay5ieXRlTGVuZ3RoKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbGV0IHJvdztcbiAgICBpZiAocHJlZGljdG9yID09PSAyKSB7IC8vIGhvcml6b250YWwgcHJlZGljdGlvblxuICAgICAgc3dpdGNoIChiaXRzUGVyU2FtcGxlWzBdKSB7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICByb3cgPSBuZXcgVWludDhBcnJheShcbiAgICAgICAgICAgIGJsb2NrLCBpICogc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSwgc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgIHJvdyA9IG5ldyBVaW50MTZBcnJheShcbiAgICAgICAgICAgIGJsb2NrLCBpICogc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSwgc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSAvIDIsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICByb3cgPSBuZXcgVWludDMyQXJyYXkoXG4gICAgICAgICAgICBibG9jaywgaSAqIHN0cmlkZSAqIHdpZHRoICogYnl0ZXNQZXJTYW1wbGUsIHN0cmlkZSAqIHdpZHRoICogYnl0ZXNQZXJTYW1wbGUgLyA0LFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcmVkaWN0b3IgMiBub3QgYWxsb3dlZCB3aXRoICR7Yml0c1BlclNhbXBsZVswXX0gYml0cyBwZXIgc2FtcGxlLmApO1xuICAgICAgfVxuICAgICAgZGVjb2RlUm93QWNjKHJvdywgc3RyaWRlLCBieXRlc1BlclNhbXBsZSk7XG4gICAgfSBlbHNlIGlmIChwcmVkaWN0b3IgPT09IDMpIHsgLy8gaG9yaXpvbnRhbCBmbG9hdGluZyBwb2ludFxuICAgICAgcm93ID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgIGJsb2NrLCBpICogc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSwgc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSxcbiAgICAgICk7XG4gICAgICBkZWNvZGVSb3dGbG9hdGluZ1BvaW50KHJvdywgc3RyaWRlLCBieXRlc1BlclNhbXBsZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBibG9jaztcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==
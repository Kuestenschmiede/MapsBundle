"use strict";
(self["webpackChunkmapsbundle"] = self["webpackChunkmapsbundle"] || []).push([["node_modules_geotiff_src_compression_lzw_js"],{

/***/ "./node_modules/geotiff/src/compression/basedecoder.js":
/*!*************************************************************!*\
  !*** ./node_modules/geotiff/src/compression/basedecoder.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BaseDecoder)
/* harmony export */ });
/* harmony import */ var _predictor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../predictor */ "./node_modules/geotiff/src/predictor.js");


class BaseDecoder {
  async decode(fileDirectory, buffer) {
    const decoded = await this.decodeBlock(buffer);
    const predictor = fileDirectory.Predictor || 1;
    if (predictor !== 1) {
      const isTiled = !fileDirectory.StripOffsets;
      const tileWidth = isTiled ? fileDirectory.TileWidth : fileDirectory.ImageWidth;
      const tileHeight = isTiled ? fileDirectory.TileLength : (
        fileDirectory.RowsPerStrip || fileDirectory.ImageLength
      );
      return (0,_predictor__WEBPACK_IMPORTED_MODULE_0__.applyPredictor)(
        decoded, predictor, tileWidth, tileHeight, fileDirectory.BitsPerSample,
        fileDirectory.PlanarConfiguration,
      );
    }
    return decoded;
  }
}


/***/ }),

/***/ "./node_modules/geotiff/src/compression/lzw.js":
/*!*****************************************************!*\
  !*** ./node_modules/geotiff/src/compression/lzw.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LZWDecoder)
/* harmony export */ });
/* harmony import */ var _basedecoder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basedecoder */ "./node_modules/geotiff/src/compression/basedecoder.js");


const MIN_BITS = 9;
const CLEAR_CODE = 256; // clear code
const EOI_CODE = 257; // end of information
const MAX_BYTELENGTH = 12;

function getByte(array, position, length) {
  const d = position % 8;
  const a = Math.floor(position / 8);
  const de = 8 - d;
  const ef = (position + length) - ((a + 1) * 8);
  let fg = (8 * (a + 2)) - (position + length);
  const dg = ((a + 2) * 8) - position;
  fg = Math.max(0, fg);
  if (a >= array.length) {
    console.warn('ran off the end of the buffer before finding EOI_CODE (end on input code)');
    return EOI_CODE;
  }
  let chunk1 = array[a] & ((2 ** (8 - d)) - 1);
  chunk1 <<= (length - de);
  let chunks = chunk1;
  if (a + 1 < array.length) {
    let chunk2 = array[a + 1] >>> fg;
    chunk2 <<= Math.max(0, (length - dg));
    chunks += chunk2;
  }
  if (ef > 8 && a + 2 < array.length) {
    const hi = ((a + 3) * 8) - (position + length);
    const chunk3 = array[a + 2] >>> hi;
    chunks += chunk3;
  }
  return chunks;
}

function appendReversed(dest, source) {
  for (let i = source.length - 1; i >= 0; i--) {
    dest.push(source[i]);
  }
  return dest;
}

function decompress(input) {
  const dictionaryIndex = new Uint16Array(4093);
  const dictionaryChar = new Uint8Array(4093);
  for (let i = 0; i <= 257; i++) {
    dictionaryIndex[i] = 4096;
    dictionaryChar[i] = i;
  }
  let dictionaryLength = 258;
  let byteLength = MIN_BITS;
  let position = 0;

  function initDictionary() {
    dictionaryLength = 258;
    byteLength = MIN_BITS;
  }
  function getNext(array) {
    const byte = getByte(array, position, byteLength);
    position += byteLength;
    return byte;
  }
  function addToDictionary(i, c) {
    dictionaryChar[dictionaryLength] = c;
    dictionaryIndex[dictionaryLength] = i;
    dictionaryLength++;
    return dictionaryLength - 1;
  }
  function getDictionaryReversed(n) {
    const rev = [];
    for (let i = n; i !== 4096; i = dictionaryIndex[i]) {
      rev.push(dictionaryChar[i]);
    }
    return rev;
  }

  const result = [];
  initDictionary();
  const array = new Uint8Array(input);
  let code = getNext(array);
  let oldCode;
  while (code !== EOI_CODE) {
    if (code === CLEAR_CODE) {
      initDictionary();
      code = getNext(array);
      while (code === CLEAR_CODE) {
        code = getNext(array);
      }

      if (code === EOI_CODE) {
        break;
      } else if (code > CLEAR_CODE) {
        throw new Error(`corrupted code at scanline ${code}`);
      } else {
        const val = getDictionaryReversed(code);
        appendReversed(result, val);
        oldCode = code;
      }
    } else if (code < dictionaryLength) {
      const val = getDictionaryReversed(code);
      appendReversed(result, val);
      addToDictionary(oldCode, val[val.length - 1]);
      oldCode = code;
    } else {
      const oldVal = getDictionaryReversed(oldCode);
      if (!oldVal) {
        throw new Error(`Bogus entry. Not in dictionary, ${oldCode} / ${dictionaryLength}, position: ${position}`);
      }
      appendReversed(result, oldVal);
      result.push(oldVal[oldVal.length - 1]);
      addToDictionary(oldCode, oldVal[oldVal.length - 1]);
      oldCode = code;
    }

    if (dictionaryLength + 1 >= (2 ** byteLength)) {
      if (byteLength === MAX_BYTELENGTH) {
        oldCode = undefined;
      } else {
        byteLength++;
      }
    }
    code = getNext(array);
  }
  return new Uint8Array(result);
}

class LZWDecoder extends _basedecoder__WEBPACK_IMPORTED_MODULE_0__["default"] {
  decodeBlock(buffer) {
    return decompress(buffer, false).buffer;
  }
}


/***/ }),

/***/ "./node_modules/geotiff/src/predictor.js":
/*!***********************************************!*\
  !*** ./node_modules/geotiff/src/predictor.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "applyPredictor": () => (/* binding */ applyPredictor)
/* harmony export */ });
function decodeRowAcc(row, stride) {
  let length = row.length - stride;
  let offset = 0;
  do {
    for (let i = stride; i > 0; i--) {
      row[offset + stride] += row[offset];
      offset++;
    }

    length -= stride;
  } while (length > 0);
}

function decodeRowFloatingPoint(row, stride, bytesPerSample) {
  let index = 0;
  let count = row.length;
  const wc = count / bytesPerSample;

  while (count > stride) {
    for (let i = stride; i > 0; --i) {
      row[index + stride] += row[index];
      ++index;
    }
    count -= stride;
  }

  const copy = row.slice();
  for (let i = 0; i < wc; ++i) {
    for (let b = 0; b < bytesPerSample; ++b) {
      row[(bytesPerSample * i) + b] = copy[((bytesPerSample - b - 1) * wc) + i];
    }
  }
}

function applyPredictor(block, predictor, width, height, bitsPerSample,
  planarConfiguration) {
  if (!predictor || predictor === 1) {
    return block;
  }

  for (let i = 0; i < bitsPerSample.length; ++i) {
    if (bitsPerSample[i] % 8 !== 0) {
      throw new Error('When decoding with predictor, only multiple of 8 bits are supported.');
    }
    if (bitsPerSample[i] !== bitsPerSample[0]) {
      throw new Error('When decoding with predictor, all samples must have the same size.');
    }
  }

  const bytesPerSample = bitsPerSample[0] / 8;
  const stride = planarConfiguration === 2 ? 1 : bitsPerSample.length;

  for (let i = 0; i < height; ++i) {
    // Last strip will be truncated if height % stripHeight != 0
    if (i * stride * width * bytesPerSample >= block.byteLength) {
      break;
    }
    let row;
    if (predictor === 2) { // horizontal prediction
      switch (bitsPerSample[0]) {
        case 8:
          row = new Uint8Array(
            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,
          );
          break;
        case 16:
          row = new Uint16Array(
            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 2,
          );
          break;
        case 32:
          row = new Uint32Array(
            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 4,
          );
          break;
        default:
          throw new Error(`Predictor 2 not allowed with ${bitsPerSample[0]} bits per sample.`);
      }
      decodeRowAcc(row, stride, bytesPerSample);
    } else if (predictor === 3) { // horizontal floating point
      row = new Uint8Array(
        block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,
      );
      decodeRowFloatingPoint(row, stride, bytesPerSample);
    }
  }
  return block;
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2dlb3RpZmZfc3JjX2NvbXByZXNzaW9uX2x6d19qcy5idW5kbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBOEM7O0FBRS9CO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwwREFBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ25Cd0M7O0FBRXhDO0FBQ0Esd0JBQXdCO0FBQ3hCLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHNEQUFzRCxLQUFLO0FBQzNELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsMkRBQTJELFNBQVMsSUFBSSxpQkFBaUIsY0FBYyxTQUFTO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWUseUJBQXlCLG9EQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNsSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUIsb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsa0JBQWtCO0FBQzVFO0FBQ0E7QUFDQSxNQUFNLDRCQUE0QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFwc2J1bmRsZS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL3NyYy9jb21wcmVzc2lvbi9iYXNlZGVjb2Rlci5qcyIsIndlYnBhY2s6Ly9tYXBzYnVuZGxlLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvc3JjL2NvbXByZXNzaW9uL2x6dy5qcyIsIndlYnBhY2s6Ly9tYXBzYnVuZGxlLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvc3JjL3ByZWRpY3Rvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhcHBseVByZWRpY3RvciB9IGZyb20gJy4uL3ByZWRpY3Rvcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2VEZWNvZGVyIHtcbiAgYXN5bmMgZGVjb2RlKGZpbGVEaXJlY3RvcnksIGJ1ZmZlcikge1xuICAgIGNvbnN0IGRlY29kZWQgPSBhd2FpdCB0aGlzLmRlY29kZUJsb2NrKGJ1ZmZlcik7XG4gICAgY29uc3QgcHJlZGljdG9yID0gZmlsZURpcmVjdG9yeS5QcmVkaWN0b3IgfHwgMTtcbiAgICBpZiAocHJlZGljdG9yICE9PSAxKSB7XG4gICAgICBjb25zdCBpc1RpbGVkID0gIWZpbGVEaXJlY3RvcnkuU3RyaXBPZmZzZXRzO1xuICAgICAgY29uc3QgdGlsZVdpZHRoID0gaXNUaWxlZCA/IGZpbGVEaXJlY3RvcnkuVGlsZVdpZHRoIDogZmlsZURpcmVjdG9yeS5JbWFnZVdpZHRoO1xuICAgICAgY29uc3QgdGlsZUhlaWdodCA9IGlzVGlsZWQgPyBmaWxlRGlyZWN0b3J5LlRpbGVMZW5ndGggOiAoXG4gICAgICAgIGZpbGVEaXJlY3RvcnkuUm93c1BlclN0cmlwIHx8IGZpbGVEaXJlY3RvcnkuSW1hZ2VMZW5ndGhcbiAgICAgICk7XG4gICAgICByZXR1cm4gYXBwbHlQcmVkaWN0b3IoXG4gICAgICAgIGRlY29kZWQsIHByZWRpY3RvciwgdGlsZVdpZHRoLCB0aWxlSGVpZ2h0LCBmaWxlRGlyZWN0b3J5LkJpdHNQZXJTYW1wbGUsXG4gICAgICAgIGZpbGVEaXJlY3RvcnkuUGxhbmFyQ29uZmlndXJhdGlvbixcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVkO1xuICB9XG59XG4iLCJpbXBvcnQgQmFzZURlY29kZXIgZnJvbSAnLi9iYXNlZGVjb2Rlcic7XG5cbmNvbnN0IE1JTl9CSVRTID0gOTtcbmNvbnN0IENMRUFSX0NPREUgPSAyNTY7IC8vIGNsZWFyIGNvZGVcbmNvbnN0IEVPSV9DT0RFID0gMjU3OyAvLyBlbmQgb2YgaW5mb3JtYXRpb25cbmNvbnN0IE1BWF9CWVRFTEVOR1RIID0gMTI7XG5cbmZ1bmN0aW9uIGdldEJ5dGUoYXJyYXksIHBvc2l0aW9uLCBsZW5ndGgpIHtcbiAgY29uc3QgZCA9IHBvc2l0aW9uICUgODtcbiAgY29uc3QgYSA9IE1hdGguZmxvb3IocG9zaXRpb24gLyA4KTtcbiAgY29uc3QgZGUgPSA4IC0gZDtcbiAgY29uc3QgZWYgPSAocG9zaXRpb24gKyBsZW5ndGgpIC0gKChhICsgMSkgKiA4KTtcbiAgbGV0IGZnID0gKDggKiAoYSArIDIpKSAtIChwb3NpdGlvbiArIGxlbmd0aCk7XG4gIGNvbnN0IGRnID0gKChhICsgMikgKiA4KSAtIHBvc2l0aW9uO1xuICBmZyA9IE1hdGgubWF4KDAsIGZnKTtcbiAgaWYgKGEgPj0gYXJyYXkubGVuZ3RoKSB7XG4gICAgY29uc29sZS53YXJuKCdyYW4gb2ZmIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciBiZWZvcmUgZmluZGluZyBFT0lfQ09ERSAoZW5kIG9uIGlucHV0IGNvZGUpJyk7XG4gICAgcmV0dXJuIEVPSV9DT0RFO1xuICB9XG4gIGxldCBjaHVuazEgPSBhcnJheVthXSAmICgoMiAqKiAoOCAtIGQpKSAtIDEpO1xuICBjaHVuazEgPDw9IChsZW5ndGggLSBkZSk7XG4gIGxldCBjaHVua3MgPSBjaHVuazE7XG4gIGlmIChhICsgMSA8IGFycmF5Lmxlbmd0aCkge1xuICAgIGxldCBjaHVuazIgPSBhcnJheVthICsgMV0gPj4+IGZnO1xuICAgIGNodW5rMiA8PD0gTWF0aC5tYXgoMCwgKGxlbmd0aCAtIGRnKSk7XG4gICAgY2h1bmtzICs9IGNodW5rMjtcbiAgfVxuICBpZiAoZWYgPiA4ICYmIGEgKyAyIDwgYXJyYXkubGVuZ3RoKSB7XG4gICAgY29uc3QgaGkgPSAoKGEgKyAzKSAqIDgpIC0gKHBvc2l0aW9uICsgbGVuZ3RoKTtcbiAgICBjb25zdCBjaHVuazMgPSBhcnJheVthICsgMl0gPj4+IGhpO1xuICAgIGNodW5rcyArPSBjaHVuazM7XG4gIH1cbiAgcmV0dXJuIGNodW5rcztcbn1cblxuZnVuY3Rpb24gYXBwZW5kUmV2ZXJzZWQoZGVzdCwgc291cmNlKSB7XG4gIGZvciAobGV0IGkgPSBzb3VyY2UubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBkZXN0LnB1c2goc291cmNlW2ldKTtcbiAgfVxuICByZXR1cm4gZGVzdDtcbn1cblxuZnVuY3Rpb24gZGVjb21wcmVzcyhpbnB1dCkge1xuICBjb25zdCBkaWN0aW9uYXJ5SW5kZXggPSBuZXcgVWludDE2QXJyYXkoNDA5Myk7XG4gIGNvbnN0IGRpY3Rpb25hcnlDaGFyID0gbmV3IFVpbnQ4QXJyYXkoNDA5Myk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDw9IDI1NzsgaSsrKSB7XG4gICAgZGljdGlvbmFyeUluZGV4W2ldID0gNDA5NjtcbiAgICBkaWN0aW9uYXJ5Q2hhcltpXSA9IGk7XG4gIH1cbiAgbGV0IGRpY3Rpb25hcnlMZW5ndGggPSAyNTg7XG4gIGxldCBieXRlTGVuZ3RoID0gTUlOX0JJVFM7XG4gIGxldCBwb3NpdGlvbiA9IDA7XG5cbiAgZnVuY3Rpb24gaW5pdERpY3Rpb25hcnkoKSB7XG4gICAgZGljdGlvbmFyeUxlbmd0aCA9IDI1ODtcbiAgICBieXRlTGVuZ3RoID0gTUlOX0JJVFM7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0TmV4dChhcnJheSkge1xuICAgIGNvbnN0IGJ5dGUgPSBnZXRCeXRlKGFycmF5LCBwb3NpdGlvbiwgYnl0ZUxlbmd0aCk7XG4gICAgcG9zaXRpb24gKz0gYnl0ZUxlbmd0aDtcbiAgICByZXR1cm4gYnl0ZTtcbiAgfVxuICBmdW5jdGlvbiBhZGRUb0RpY3Rpb25hcnkoaSwgYykge1xuICAgIGRpY3Rpb25hcnlDaGFyW2RpY3Rpb25hcnlMZW5ndGhdID0gYztcbiAgICBkaWN0aW9uYXJ5SW5kZXhbZGljdGlvbmFyeUxlbmd0aF0gPSBpO1xuICAgIGRpY3Rpb25hcnlMZW5ndGgrKztcbiAgICByZXR1cm4gZGljdGlvbmFyeUxlbmd0aCAtIDE7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RGljdGlvbmFyeVJldmVyc2VkKG4pIHtcbiAgICBjb25zdCByZXYgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gbjsgaSAhPT0gNDA5NjsgaSA9IGRpY3Rpb25hcnlJbmRleFtpXSkge1xuICAgICAgcmV2LnB1c2goZGljdGlvbmFyeUNoYXJbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV2O1xuICB9XG5cbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGluaXREaWN0aW9uYXJ5KCk7XG4gIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoaW5wdXQpO1xuICBsZXQgY29kZSA9IGdldE5leHQoYXJyYXkpO1xuICBsZXQgb2xkQ29kZTtcbiAgd2hpbGUgKGNvZGUgIT09IEVPSV9DT0RFKSB7XG4gICAgaWYgKGNvZGUgPT09IENMRUFSX0NPREUpIHtcbiAgICAgIGluaXREaWN0aW9uYXJ5KCk7XG4gICAgICBjb2RlID0gZ2V0TmV4dChhcnJheSk7XG4gICAgICB3aGlsZSAoY29kZSA9PT0gQ0xFQVJfQ09ERSkge1xuICAgICAgICBjb2RlID0gZ2V0TmV4dChhcnJheSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb2RlID09PSBFT0lfQ09ERSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA+IENMRUFSX0NPREUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb3JydXB0ZWQgY29kZSBhdCBzY2FubGluZSAke2NvZGV9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB2YWwgPSBnZXREaWN0aW9uYXJ5UmV2ZXJzZWQoY29kZSk7XG4gICAgICAgIGFwcGVuZFJldmVyc2VkKHJlc3VsdCwgdmFsKTtcbiAgICAgICAgb2xkQ29kZSA9IGNvZGU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb2RlIDwgZGljdGlvbmFyeUxlbmd0aCkge1xuICAgICAgY29uc3QgdmFsID0gZ2V0RGljdGlvbmFyeVJldmVyc2VkKGNvZGUpO1xuICAgICAgYXBwZW5kUmV2ZXJzZWQocmVzdWx0LCB2YWwpO1xuICAgICAgYWRkVG9EaWN0aW9uYXJ5KG9sZENvZGUsIHZhbFt2YWwubGVuZ3RoIC0gMV0pO1xuICAgICAgb2xkQ29kZSA9IGNvZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9sZFZhbCA9IGdldERpY3Rpb25hcnlSZXZlcnNlZChvbGRDb2RlKTtcbiAgICAgIGlmICghb2xkVmFsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQm9ndXMgZW50cnkuIE5vdCBpbiBkaWN0aW9uYXJ5LCAke29sZENvZGV9IC8gJHtkaWN0aW9uYXJ5TGVuZ3RofSwgcG9zaXRpb246ICR7cG9zaXRpb259YCk7XG4gICAgICB9XG4gICAgICBhcHBlbmRSZXZlcnNlZChyZXN1bHQsIG9sZFZhbCk7XG4gICAgICByZXN1bHQucHVzaChvbGRWYWxbb2xkVmFsLmxlbmd0aCAtIDFdKTtcbiAgICAgIGFkZFRvRGljdGlvbmFyeShvbGRDb2RlLCBvbGRWYWxbb2xkVmFsLmxlbmd0aCAtIDFdKTtcbiAgICAgIG9sZENvZGUgPSBjb2RlO1xuICAgIH1cblxuICAgIGlmIChkaWN0aW9uYXJ5TGVuZ3RoICsgMSA+PSAoMiAqKiBieXRlTGVuZ3RoKSkge1xuICAgICAgaWYgKGJ5dGVMZW5ndGggPT09IE1BWF9CWVRFTEVOR1RIKSB7XG4gICAgICAgIG9sZENvZGUgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBieXRlTGVuZ3RoKys7XG4gICAgICB9XG4gICAgfVxuICAgIGNvZGUgPSBnZXROZXh0KGFycmF5KTtcbiAgfVxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVzdWx0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTFpXRGVjb2RlciBleHRlbmRzIEJhc2VEZWNvZGVyIHtcbiAgZGVjb2RlQmxvY2soYnVmZmVyKSB7XG4gICAgcmV0dXJuIGRlY29tcHJlc3MoYnVmZmVyLCBmYWxzZSkuYnVmZmVyO1xuICB9XG59XG4iLCJmdW5jdGlvbiBkZWNvZGVSb3dBY2Mocm93LCBzdHJpZGUpIHtcbiAgbGV0IGxlbmd0aCA9IHJvdy5sZW5ndGggLSBzdHJpZGU7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBkbyB7XG4gICAgZm9yIChsZXQgaSA9IHN0cmlkZTsgaSA+IDA7IGktLSkge1xuICAgICAgcm93W29mZnNldCArIHN0cmlkZV0gKz0gcm93W29mZnNldF07XG4gICAgICBvZmZzZXQrKztcbiAgICB9XG5cbiAgICBsZW5ndGggLT0gc3RyaWRlO1xuICB9IHdoaWxlIChsZW5ndGggPiAwKTtcbn1cblxuZnVuY3Rpb24gZGVjb2RlUm93RmxvYXRpbmdQb2ludChyb3csIHN0cmlkZSwgYnl0ZXNQZXJTYW1wbGUpIHtcbiAgbGV0IGluZGV4ID0gMDtcbiAgbGV0IGNvdW50ID0gcm93Lmxlbmd0aDtcbiAgY29uc3Qgd2MgPSBjb3VudCAvIGJ5dGVzUGVyU2FtcGxlO1xuXG4gIHdoaWxlIChjb3VudCA+IHN0cmlkZSkge1xuICAgIGZvciAobGV0IGkgPSBzdHJpZGU7IGkgPiAwOyAtLWkpIHtcbiAgICAgIHJvd1tpbmRleCArIHN0cmlkZV0gKz0gcm93W2luZGV4XTtcbiAgICAgICsraW5kZXg7XG4gICAgfVxuICAgIGNvdW50IC09IHN0cmlkZTtcbiAgfVxuXG4gIGNvbnN0IGNvcHkgPSByb3cuc2xpY2UoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB3YzsgKytpKSB7XG4gICAgZm9yIChsZXQgYiA9IDA7IGIgPCBieXRlc1BlclNhbXBsZTsgKytiKSB7XG4gICAgICByb3dbKGJ5dGVzUGVyU2FtcGxlICogaSkgKyBiXSA9IGNvcHlbKChieXRlc1BlclNhbXBsZSAtIGIgLSAxKSAqIHdjKSArIGldO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlQcmVkaWN0b3IoYmxvY2ssIHByZWRpY3Rvciwgd2lkdGgsIGhlaWdodCwgYml0c1BlclNhbXBsZSxcbiAgcGxhbmFyQ29uZmlndXJhdGlvbikge1xuICBpZiAoIXByZWRpY3RvciB8fCBwcmVkaWN0b3IgPT09IDEpIHtcbiAgICByZXR1cm4gYmxvY2s7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJpdHNQZXJTYW1wbGUubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYml0c1BlclNhbXBsZVtpXSAlIDggIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2hlbiBkZWNvZGluZyB3aXRoIHByZWRpY3Rvciwgb25seSBtdWx0aXBsZSBvZiA4IGJpdHMgYXJlIHN1cHBvcnRlZC4nKTtcbiAgICB9XG4gICAgaWYgKGJpdHNQZXJTYW1wbGVbaV0gIT09IGJpdHNQZXJTYW1wbGVbMF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2hlbiBkZWNvZGluZyB3aXRoIHByZWRpY3RvciwgYWxsIHNhbXBsZXMgbXVzdCBoYXZlIHRoZSBzYW1lIHNpemUuJyk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgYnl0ZXNQZXJTYW1wbGUgPSBiaXRzUGVyU2FtcGxlWzBdIC8gODtcbiAgY29uc3Qgc3RyaWRlID0gcGxhbmFyQ29uZmlndXJhdGlvbiA9PT0gMiA/IDEgOiBiaXRzUGVyU2FtcGxlLmxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGhlaWdodDsgKytpKSB7XG4gICAgLy8gTGFzdCBzdHJpcCB3aWxsIGJlIHRydW5jYXRlZCBpZiBoZWlnaHQgJSBzdHJpcEhlaWdodCAhPSAwXG4gICAgaWYgKGkgKiBzdHJpZGUgKiB3aWR0aCAqIGJ5dGVzUGVyU2FtcGxlID49IGJsb2NrLmJ5dGVMZW5ndGgpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBsZXQgcm93O1xuICAgIGlmIChwcmVkaWN0b3IgPT09IDIpIHsgLy8gaG9yaXpvbnRhbCBwcmVkaWN0aW9uXG4gICAgICBzd2l0Y2ggKGJpdHNQZXJTYW1wbGVbMF0pIHtcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIHJvdyA9IG5ldyBVaW50OEFycmF5KFxuICAgICAgICAgICAgYmxvY2ssIGkgKiBzdHJpZGUgKiB3aWR0aCAqIGJ5dGVzUGVyU2FtcGxlLCBzdHJpZGUgKiB3aWR0aCAqIGJ5dGVzUGVyU2FtcGxlLFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgcm93ID0gbmV3IFVpbnQxNkFycmF5KFxuICAgICAgICAgICAgYmxvY2ssIGkgKiBzdHJpZGUgKiB3aWR0aCAqIGJ5dGVzUGVyU2FtcGxlLCBzdHJpZGUgKiB3aWR0aCAqIGJ5dGVzUGVyU2FtcGxlIC8gMixcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgIHJvdyA9IG5ldyBVaW50MzJBcnJheShcbiAgICAgICAgICAgIGJsb2NrLCBpICogc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSwgc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSAvIDQsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByZWRpY3RvciAyIG5vdCBhbGxvd2VkIHdpdGggJHtiaXRzUGVyU2FtcGxlWzBdfSBiaXRzIHBlciBzYW1wbGUuYCk7XG4gICAgICB9XG4gICAgICBkZWNvZGVSb3dBY2Mocm93LCBzdHJpZGUsIGJ5dGVzUGVyU2FtcGxlKTtcbiAgICB9IGVsc2UgaWYgKHByZWRpY3RvciA9PT0gMykgeyAvLyBob3Jpem9udGFsIGZsb2F0aW5nIHBvaW50XG4gICAgICByb3cgPSBuZXcgVWludDhBcnJheShcbiAgICAgICAgYmxvY2ssIGkgKiBzdHJpZGUgKiB3aWR0aCAqIGJ5dGVzUGVyU2FtcGxlLCBzdHJpZGUgKiB3aWR0aCAqIGJ5dGVzUGVyU2FtcGxlLFxuICAgICAgKTtcbiAgICAgIGRlY29kZVJvd0Zsb2F0aW5nUG9pbnQocm93LCBzdHJpZGUsIGJ5dGVzUGVyU2FtcGxlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJsb2NrO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9
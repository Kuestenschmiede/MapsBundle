"use strict";(self.webpackChunkmapsbundle=self.webpackChunkmapsbundle||[]).push([["node_modules_geotiff_dist-module_compression_webimage_js"],{"./node_modules/geotiff/dist-module/compression/basedecoder.js":(e,t,n)=>{function o(e,t){let n=e.length-t,o=0;do{for(let n=t;n>0;n--)e[o+t]+=e[o],o++;n-=t}while(n>0)}function r(e,t,n){let o=0,r=e.length;const a=r/n;for(;r>t;){for(let n=t;n>0;--n)e[o+t]+=e[o],++o;r-=t}const i=e.slice();for(let t=0;t<a;++t)for(let o=0;o<n;++o)e[n*t+o]=i[(n-o-1)*a+t]}n.d(t,{Z:()=>a});class a{async decode(e,t){const n=await this.decodeBlock(t),a=e.Predictor||1;if(1!==a){const t=!e.StripOffsets;return function(e,t,n,a,i,s){if(!t||1===t)return e;for(let e=0;e<i.length;++e){if(i[e]%8!=0)throw new Error("When decoding with predictor, only multiple of 8 bits are supported.");if(i[e]!==i[0])throw new Error("When decoding with predictor, all samples must have the same size.")}const d=i[0]/8,c=2===s?1:i.length;for(let s=0;s<a&&!(s*c*n*d>=e.byteLength);++s){let a;if(2===t){switch(i[0]){case 8:a=new Uint8Array(e,s*c*n*d,c*n*d);break;case 16:a=new Uint16Array(e,s*c*n*d,c*n*d/2);break;case 32:a=new Uint32Array(e,s*c*n*d,c*n*d/4);break;default:throw new Error(`Predictor 2 not allowed with ${i[0]} bits per sample.`)}o(a,c)}else 3===t&&(a=new Uint8Array(e,s*c*n*d,c*n*d),r(a,c,d))}return e}(n,a,t?e.TileWidth:e.ImageWidth,t?e.TileLength:e.RowsPerStrip||e.ImageLength,e.BitsPerSample,e.PlanarConfiguration)}return n}}},"./node_modules/geotiff/dist-module/compression/webimage.js":(e,t,n)=>{n.r(t),n.d(t,{default:()=>r});var o=n("./node_modules/geotiff/dist-module/compression/basedecoder.js");class r extends o.Z{constructor(){if(super(),"undefined"==typeof createImageBitmap)throw new Error("Cannot decode WebImage as `createImageBitmap` is not available");if("undefined"==typeof document&&"undefined"==typeof OffscreenCanvas)throw new Error("Cannot decode WebImage as neither `document` nor `OffscreenCanvas` is not available")}async decode(e,t){const n=new Blob([t]),o=await createImageBitmap(n);let r;"undefined"!=typeof document?(r=document.createElement("canvas"),r.width=o.width,r.height=o.height):r=new OffscreenCanvas(o.width,o.height);const a=r.getContext("2d");return a.drawImage(o,0,0),a.getImageData(0,0,o.width,o.height).data.buffer}}}}]);
(self["webpackChunkmapsbundle"] = self["webpackChunkmapsbundle"] || []).push([["vendors-node_modules_geotiff_src_compression_lerc_js"],{

/***/ "./node_modules/geotiff/src/compression/lerc.js":
/*!******************************************************!*\
  !*** ./node_modules/geotiff/src/compression/lerc.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LercDecoder)
/* harmony export */ });
/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pako */ "./node_modules/pako/dist/pako.esm.mjs");
/* harmony import */ var lerc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lerc */ "./node_modules/lerc/LercDecode.js");
/* harmony import */ var lerc__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lerc__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _basedecoder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basedecoder */ "./node_modules/geotiff/src/compression/basedecoder.js");
/* harmony import */ var _globals__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../globals */ "./node_modules/geotiff/src/globals.js");





class LercDecoder extends _basedecoder__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor(fileDirectory) {
    super();

    this.planarConfiguration = typeof fileDirectory.PlanarConfiguration !== 'undefined' ? fileDirectory.PlanarConfiguration : 1;
    this.samplesPerPixel = typeof fileDirectory.SamplesPerPixel !== 'undefined' ? fileDirectory.SamplesPerPixel : 1;

    this.addCompression = fileDirectory.LercParameters[_globals__WEBPACK_IMPORTED_MODULE_3__.LercParameters.AddCompression];
  }

  decodeBlock(buffer) {
    switch (this.addCompression) {
      case _globals__WEBPACK_IMPORTED_MODULE_3__.LercAddCompression.None:
        break;
      case _globals__WEBPACK_IMPORTED_MODULE_3__.LercAddCompression.Deflate:
        buffer = (0,pako__WEBPACK_IMPORTED_MODULE_0__.inflate)(new Uint8Array(buffer)).buffer; // eslint-disable-line no-param-reassign, prefer-destructuring
        break;
      default:
        throw new Error(`Unsupported LERC additional compression method identifier: ${this.addCompression}`);
    }

    const lercResult = lerc__WEBPACK_IMPORTED_MODULE_1___default().decode(buffer, { returnPixelInterleavedDims: this.planarConfiguration === 1 });
    const lercData = lercResult.pixels[0];
    return lercData.buffer;
  }
}


/***/ }),

/***/ "./node_modules/lerc/LercDecode.js":
/*!*****************************************!*\
  !*** ./node_modules/lerc/LercDecode.js ***!
  \*****************************************/
/***/ ((module, exports) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;ï»¿/* jshint forin: false, bitwise: false */
/*
Copyright 2015-2021 Esri

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

A copy of the license and additional notices are located with the
source distribution at:

http://github.com/Esri/lerc/

Contributors:  Johannes Schmid, (LERC v1)
               Chayanika Khatua, (LERC v1)
               Wenxue Ju (LERC v1, v2.x)
*/

/* Copyright 2015-2021 Esri. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 @preserve */

/**
 * a module for decoding LERC blobs
 * @module Lerc
 */
(function() {
  //this decoder supports all lerc versions, each version has its own class (LercDecode and Lerc2Decode). 
  //the exported module handles format variation autoamtically.

  //the original LercDecode for Version 1
  var LercDecode = (function() {

    // Note: currently, this module only has an implementation for decoding LERC data, not encoding. The name of
    // the class was chosen to be future proof.

    var CntZImage = {};

    CntZImage.defaultNoDataValue = -3.4027999387901484e+38; // smallest Float32 value

    /**
     * Decode a LERC byte stream and return an object containing the pixel data and some required and optional
     * information about it, such as the image's width and height.
     *
     * @param {ArrayBuffer} input The LERC input byte stream
     * @param {object} [options] Decoding options, containing any of the following properties:
     * @config {number} [inputOffset = 0]
     *        Skip the first inputOffset bytes of the input byte stream. A valid LERC file is expected at that position.
     * @config {Uint8Array} [encodedMask = null]
     *        If specified, the decoder will not read mask information from the input and use the specified encoded
     *        mask data instead. Mask header/data must not be present in the LERC byte stream in this case.
     * @config {number} [noDataValue = LercCode.defaultNoDataValue]
     *        Pixel value to use for masked pixels.
     * @config {ArrayBufferView|Array} [pixelType = Float32Array]
     *        The desired type of the pixelData array in the return value. Note that it is the caller's responsibility to
     *        provide an appropriate noDataValue if the default pixelType is overridden.
     * @config {boolean} [returnMask = false]
     *        If true, the return value will contain a maskData property of type Uint8Array which has one element per
     *        pixel, the value of which is 1 or 0 depending on whether that pixel's data is present or masked. If the
     *        input LERC data does not contain a mask, maskData will not be returned.
     * @config {boolean} [returnEncodedMask = false]
     *        If true, the return value will contain a encodedMaskData property, which can be passed into encode() as
     *        encodedMask.
     * @config {boolean} [returnFileInfo = false]
     *        If true, the return value will have a fileInfo property that contains metadata obtained from the
     *        LERC headers and the decoding process.
     * @config {boolean} [computeUsedBitDepths = false]
     *        If true, the fileInfo property in the return value will contain the set of all block bit depths
     *        encountered during decoding. Will only have an effect if returnFileInfo option is true.
     * @returns {{width, height, pixelData, minValue, maxValue, noDataValue, maskData, encodedMaskData, fileInfo}}
     */
    CntZImage.decode = function(input, options) {
      options = options || {};

      var skipMask = options.encodedMaskData || (options.encodedMaskData === null);
      var parsedData = parse(input, options.inputOffset || 0, skipMask);

      var noDataValue = (options.noDataValue !== null) ? options.noDataValue : CntZImage.defaultNoDataValue;

      var uncompressedData = uncompressPixelValues(parsedData, options.pixelType || Float32Array,
        options.encodedMaskData, noDataValue, options.returnMask);

      var result = {
        width: parsedData.width,
        height: parsedData.height,
        pixelData: uncompressedData.resultPixels,
        minValue: uncompressedData.minValue,
        maxValue: parsedData.pixels.maxValue,
        noDataValue: noDataValue
      };

      if (uncompressedData.resultMask) {
        result.maskData = uncompressedData.resultMask;
      }

      if (options.returnEncodedMask && parsedData.mask) {
        result.encodedMaskData = parsedData.mask.bitset ? parsedData.mask.bitset : null;
      }

      if (options.returnFileInfo) {
        result.fileInfo = formatFileInfo(parsedData);
        if (options.computeUsedBitDepths) {
          result.fileInfo.bitDepths = computeUsedBitDepths(parsedData);
        }
      }

      return result;
    };

    var uncompressPixelValues = function(data, TypedArrayClass, maskBitset, noDataValue, storeDecodedMask) {
      var blockIdx = 0;
      var numX = data.pixels.numBlocksX;
      var numY = data.pixels.numBlocksY;
      var blockWidth = Math.floor(data.width / numX);
      var blockHeight = Math.floor(data.height / numY);
      var scale = 2 * data.maxZError;
      var minValue = Number.MAX_VALUE, currentValue;
      maskBitset = maskBitset || ((data.mask) ? data.mask.bitset : null);

      var resultPixels, resultMask;
      resultPixels = new TypedArrayClass(data.width * data.height);
      if (storeDecodedMask && maskBitset) {
        resultMask = new Uint8Array(data.width * data.height);
      }
      var blockDataBuffer = new Float32Array(blockWidth * blockHeight);

      var xx, yy;
      for (var y = 0; y <= numY; y++) {
        var thisBlockHeight = (y !== numY) ? blockHeight : (data.height % numY);
        if (thisBlockHeight === 0) {
          continue;
        }
        for (var x = 0; x <= numX; x++) {
          var thisBlockWidth = (x !== numX) ? blockWidth : (data.width % numX);
          if (thisBlockWidth === 0) {
            continue;
          }

          var outPtr = y * data.width * blockHeight + x * blockWidth;
          var outStride = data.width - thisBlockWidth;

          var block = data.pixels.blocks[blockIdx];

          var blockData, blockPtr, constValue;
          if (block.encoding < 2) {
            // block is either uncompressed or bit-stuffed (encodings 0 and 1)
            if (block.encoding === 0) {
              // block is uncompressed
              blockData = block.rawData;
            } else {
              // block is bit-stuffed
              unstuff(block.stuffedData, block.bitsPerPixel, block.numValidPixels, block.offset, scale, blockDataBuffer, data.pixels.maxValue);
              blockData = blockDataBuffer;
            }
            blockPtr = 0;
          }
          else if (block.encoding === 2) {
            // block is all 0
            constValue = 0;
          }
          else {
            // block has constant value (encoding === 3)
            constValue = block.offset;
          }

          var maskByte;
          if (maskBitset) {
            for (yy = 0; yy < thisBlockHeight; yy++) {
              if (outPtr & 7) {
                //
                maskByte = maskBitset[outPtr >> 3];
                maskByte <<= outPtr & 7;
              }
              for (xx = 0; xx < thisBlockWidth; xx++) {
                if (!(outPtr & 7)) {
                  // read next byte from mask
                  maskByte = maskBitset[outPtr >> 3];
                }
                if (maskByte & 128) {
                  // pixel data present
                  if (resultMask) {
                    resultMask[outPtr] = 1;
                  }
                  currentValue = (block.encoding < 2) ? blockData[blockPtr++] : constValue;
                  minValue = minValue > currentValue ? currentValue : minValue;
                  resultPixels[outPtr++] = currentValue;
                } else {
                  // pixel data not present
                  if (resultMask) {
                    resultMask[outPtr] = 0;
                  }
                  resultPixels[outPtr++] = noDataValue;
                }
                maskByte <<= 1;
              }
              outPtr += outStride;
            }
          } else {
            // mask not present, simply copy block over
            if (block.encoding < 2) {
              // duplicating this code block for performance reasons
              // blockData case:
              for (yy = 0; yy < thisBlockHeight; yy++) {
                for (xx = 0; xx < thisBlockWidth; xx++) {
                  currentValue = blockData[blockPtr++];
                  minValue = minValue > currentValue ? currentValue : minValue;
                  resultPixels[outPtr++] = currentValue;
                }
                outPtr += outStride;
              }
            }
            else {
              // constValue case:
              minValue = minValue > constValue ? constValue : minValue;
              for (yy = 0; yy < thisBlockHeight; yy++) {
                for (xx = 0; xx < thisBlockWidth; xx++) {
                  resultPixels[outPtr++] = constValue;
                }
                outPtr += outStride;
              }
            }
          }
          if ((block.encoding === 1) && (blockPtr !== block.numValidPixels)) {
            throw "Block and Mask do not match";
          }
          blockIdx++;
        }
      }

      return {
        resultPixels: resultPixels,
        resultMask: resultMask,
        minValue: minValue
      };
    };

    var formatFileInfo = function(data) {
      return {
        "fileIdentifierString": data.fileIdentifierString,
        "fileVersion": data.fileVersion,
        "imageType": data.imageType,
        "height": data.height,
        "width": data.width,
        "maxZError": data.maxZError,
        "eofOffset": data.eofOffset,
        "mask": data.mask ? {
          "numBlocksX": data.mask.numBlocksX,
          "numBlocksY": data.mask.numBlocksY,
          "numBytes": data.mask.numBytes,
          "maxValue": data.mask.maxValue
        } : null,
        "pixels": {
          "numBlocksX": data.pixels.numBlocksX,
          "numBlocksY": data.pixels.numBlocksY,
          "numBytes": data.pixels.numBytes,
          "maxValue": data.pixels.maxValue,
          "noDataValue": data.noDataValue
        }
      };
    };

    var computeUsedBitDepths = function(data) {
      var numBlocks = data.pixels.numBlocksX * data.pixels.numBlocksY;
      var bitDepths = {};
      for (var i = 0; i < numBlocks; i++) {
        var block = data.pixels.blocks[i];
        if (block.encoding === 0) {
          bitDepths.float32 = true;
        } else if (block.encoding === 1) {
          bitDepths[block.bitsPerPixel] = true;
        } else {
          bitDepths[0] = true;
        }
      }

      return Object.keys(bitDepths);
    };

    var parse = function(input, fp, skipMask) {
      var data = {};

      // File header
      var fileIdView = new Uint8Array(input, fp, 10);
      data.fileIdentifierString = String.fromCharCode.apply(null, fileIdView);
      if (data.fileIdentifierString.trim() !== "CntZImage") {
        throw "Unexpected file identifier string: " + data.fileIdentifierString;
      }
      fp += 10;
      var view = new DataView(input, fp, 24);
      data.fileVersion = view.getInt32(0, true);
      data.imageType = view.getInt32(4, true);
      data.height = view.getUint32(8, true);
      data.width = view.getUint32(12, true);
      data.maxZError = view.getFloat64(16, true);
      fp += 24;

      // Mask Header
      if (!skipMask) {
        view = new DataView(input, fp, 16);
        data.mask = {};
        data.mask.numBlocksY = view.getUint32(0, true);
        data.mask.numBlocksX = view.getUint32(4, true);
        data.mask.numBytes = view.getUint32(8, true);
        data.mask.maxValue = view.getFloat32(12, true);
        fp += 16;

        // Mask Data
        if (data.mask.numBytes > 0) {
          var bitset = new Uint8Array(Math.ceil(data.width * data.height / 8));
          view = new DataView(input, fp, data.mask.numBytes);
          var cnt = view.getInt16(0, true);
          var ip = 2, op = 0;
          do {
            if (cnt > 0) {
              while (cnt--) { bitset[op++] = view.getUint8(ip++); }
            } else {
              var val = view.getUint8(ip++);
              cnt = -cnt;
              while (cnt--) { bitset[op++] = val; }
            }
            cnt = view.getInt16(ip, true);
            ip += 2;
          } while (ip < data.mask.numBytes);
          if ((cnt !== -32768) || (op < bitset.length)) {
            throw "Unexpected end of mask RLE encoding";
          }
          data.mask.bitset = bitset;
          fp += data.mask.numBytes;
        }
        else if ((data.mask.numBytes | data.mask.numBlocksY | data.mask.maxValue) === 0) {  // Special case, all nodata
          data.mask.bitset = new Uint8Array(Math.ceil(data.width * data.height / 8));
        }
      }

      // Pixel Header
      view = new DataView(input, fp, 16);
      data.pixels = {};
      data.pixels.numBlocksY = view.getUint32(0, true);
      data.pixels.numBlocksX = view.getUint32(4, true);
      data.pixels.numBytes = view.getUint32(8, true);
      data.pixels.maxValue = view.getFloat32(12, true);
      fp += 16;

      var numBlocksX = data.pixels.numBlocksX;
      var numBlocksY = data.pixels.numBlocksY;
      // the number of blocks specified in the header does not take into account the blocks at the end of
      // each row/column with a special width/height that make the image complete in case the width is not
      // evenly divisible by the number of blocks.
      var actualNumBlocksX = numBlocksX + ((data.width % numBlocksX) > 0 ? 1 : 0);
      var actualNumBlocksY = numBlocksY + ((data.height % numBlocksY) > 0 ? 1 : 0);
      data.pixels.blocks = new Array(actualNumBlocksX * actualNumBlocksY);
      var blockI = 0;
      for (var blockY = 0; blockY < actualNumBlocksY; blockY++) {
        for (var blockX = 0; blockX < actualNumBlocksX; blockX++) {

          // Block
          var size = 0;
          var bytesLeft = input.byteLength - fp;
          view = new DataView(input, fp, Math.min(10, bytesLeft));
          var block = {};
          data.pixels.blocks[blockI++] = block;
          var headerByte = view.getUint8(0); size++;
          block.encoding = headerByte & 63;
          if (block.encoding > 3) {
            throw "Invalid block encoding (" + block.encoding + ")";
          }
          if (block.encoding === 2) {
            fp++;
            continue;
          }
          if ((headerByte !== 0) && (headerByte !== 2)) {
            headerByte >>= 6;
            block.offsetType = headerByte;
            if (headerByte === 2) {
              block.offset = view.getInt8(1); size++;
            } else if (headerByte === 1) {
              block.offset = view.getInt16(1, true); size += 2;
            } else if (headerByte === 0) {
              block.offset = view.getFloat32(1, true); size += 4;
            } else {
              throw "Invalid block offset type";
            }

            if (block.encoding === 1) {
              headerByte = view.getUint8(size); size++;
              block.bitsPerPixel = headerByte & 63;
              headerByte >>= 6;
              block.numValidPixelsType = headerByte;
              if (headerByte === 2) {
                block.numValidPixels = view.getUint8(size); size++;
              } else if (headerByte === 1) {
                block.numValidPixels = view.getUint16(size, true); size += 2;
              } else if (headerByte === 0) {
                block.numValidPixels = view.getUint32(size, true); size += 4;
              } else {
                throw "Invalid valid pixel count type";
              }
            }
          }
          fp += size;

          if (block.encoding === 3) {
            continue;
          }

          var arrayBuf, store8;
          if (block.encoding === 0) {
            var numPixels = (data.pixels.numBytes - 1) / 4;
            if (numPixels !== Math.floor(numPixels)) {
              throw "uncompressed block has invalid length";
            }
            arrayBuf = new ArrayBuffer(numPixels * 4);
            store8 = new Uint8Array(arrayBuf);
            store8.set(new Uint8Array(input, fp, numPixels * 4));
            var rawData = new Float32Array(arrayBuf);
            block.rawData = rawData;
            fp += numPixels * 4;
          } else if (block.encoding === 1) {
            var dataBytes = Math.ceil(block.numValidPixels * block.bitsPerPixel / 8);
            var dataWords = Math.ceil(dataBytes / 4);
            arrayBuf = new ArrayBuffer(dataWords * 4);
            store8 = new Uint8Array(arrayBuf);
            store8.set(new Uint8Array(input, fp, dataBytes));
            block.stuffedData = new Uint32Array(arrayBuf);
            fp += dataBytes;
          }
        }
      }
      data.eofOffset = fp;
      return data;
    };

    var unstuff = function(src, bitsPerPixel, numPixels, offset, scale, dest, maxValue) {
      var bitMask = (1 << bitsPerPixel) - 1;
      var i = 0, o;
      var bitsLeft = 0;
      var n, buffer;
      var nmax = Math.ceil((maxValue - offset) / scale);
      // get rid of trailing bytes that are already part of next block
      var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);
      src[src.length - 1] <<= 8 * numInvalidTailBytes;

      for (o = 0; o < numPixels; o++) {
        if (bitsLeft === 0) {
          buffer = src[i++];
          bitsLeft = 32;
        }
        if (bitsLeft >= bitsPerPixel) {
          n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;
          bitsLeft -= bitsPerPixel;
        } else {
          var missingBits = (bitsPerPixel - bitsLeft);
          n = ((buffer & bitMask) << missingBits) & bitMask;
          buffer = src[i++];
          bitsLeft = 32 - missingBits;
          n += (buffer >>> bitsLeft);
        }
        //pixel values may exceed max due to quantization
        dest[o] = n < nmax ? offset + n * scale : maxValue;
      }
      return dest;
    };

    return CntZImage;
  })();

  //version 2. Supports 2.1, 2.2, 2.3
  var Lerc2Decode = (function() {
    "use strict";
    // Note: currently, this module only has an implementation for decoding LERC data, not encoding. The name of
    // the class was chosen to be future proof, following LercDecode.

    /*****************************************
    * private static class bitsutffer used by Lerc2Decode
    *******************************************/
    var BitStuffer = {
      //methods ending with 2 are for the new byte order used by Lerc2.3 and above.
      //originalUnstuff is used to unpack Huffman code table. code is duplicated to unstuffx for performance reasons.
      unstuff: function(src, dest, bitsPerPixel, numPixels, lutArr, offset, scale, maxValue) {
        var bitMask = (1 << bitsPerPixel) - 1;
        var i = 0, o;
        var bitsLeft = 0;
        var n, buffer, missingBits, nmax;

        // get rid of trailing bytes that are already part of next block
        var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);
        src[src.length - 1] <<= 8 * numInvalidTailBytes;
        if (lutArr) {
          for (o = 0; o < numPixels; o++) {
            if (bitsLeft === 0) {
              buffer = src[i++];
              bitsLeft = 32;
            }
            if (bitsLeft >= bitsPerPixel) {
              n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;
              bitsLeft -= bitsPerPixel;
            }
            else {
              missingBits = (bitsPerPixel - bitsLeft);
              n = ((buffer & bitMask) << missingBits) & bitMask;
              buffer = src[i++];
              bitsLeft = 32 - missingBits;
              n += (buffer >>> bitsLeft);
            }
            dest[o] = lutArr[n];//offset + lutArr[n] * scale;
          }
        }
        else {
          nmax = Math.ceil((maxValue - offset) / scale);
          for (o = 0; o < numPixels; o++) {
            if (bitsLeft === 0) {
              buffer = src[i++];
              bitsLeft = 32;
            }
            if (bitsLeft >= bitsPerPixel) {
              n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;
              bitsLeft -= bitsPerPixel;
            }
            else {
              missingBits = (bitsPerPixel - bitsLeft);
              n = ((buffer & bitMask) << missingBits) & bitMask;
              buffer = src[i++];
              bitsLeft = 32 - missingBits;
              n += (buffer >>> bitsLeft);
            }
            //pixel values may exceed max due to quantization
            dest[o] = n < nmax ? offset + n * scale : maxValue;
          }
        }
      },

      unstuffLUT: function(src, bitsPerPixel, numPixels, offset, scale, maxValue) {
        var bitMask = (1 << bitsPerPixel) - 1;
        var i = 0, o = 0, missingBits = 0, bitsLeft = 0, n = 0;
        var buffer;
        var dest = [];

        // get rid of trailing bytes that are already part of next block
        var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);
        src[src.length - 1] <<= 8 * numInvalidTailBytes;

        var nmax = Math.ceil((maxValue - offset) / scale);
        for (o = 0; o < numPixels; o++) {
          if (bitsLeft === 0) {
            buffer = src[i++];
            bitsLeft = 32;
          }
          if (bitsLeft >= bitsPerPixel) {
            n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;
            bitsLeft -= bitsPerPixel;
          } else {
            missingBits = (bitsPerPixel - bitsLeft);
            n = ((buffer & bitMask) << missingBits) & bitMask;
            buffer = src[i++];
            bitsLeft = 32 - missingBits;
            n += (buffer >>> bitsLeft);
          }
          //dest.push(n);
          dest[o] = n < nmax ? offset + n * scale : maxValue;
        }
        dest.unshift(offset);//1st one
        return dest;
      },

      unstuff2: function(src, dest, bitsPerPixel, numPixels, lutArr, offset, scale, maxValue) {
        var bitMask = (1 << bitsPerPixel) - 1;
        var i = 0, o;
        var bitsLeft = 0, bitPos = 0;
        var n, buffer, missingBits;
        if (lutArr) {
          for (o = 0; o < numPixels; o++) {
            if (bitsLeft === 0) {
              buffer = src[i++];
              bitsLeft = 32;
              bitPos = 0;
            }
            if (bitsLeft >= bitsPerPixel) {
              n = ((buffer >>> bitPos) & bitMask);
              bitsLeft -= bitsPerPixel;
              bitPos += bitsPerPixel;
            } else {
              missingBits = (bitsPerPixel - bitsLeft);
              n = (buffer >>> bitPos) & bitMask;
              buffer = src[i++];
              bitsLeft = 32 - missingBits;
              n |= (buffer & ((1 << missingBits) - 1)) << (bitsPerPixel - missingBits);
              bitPos = missingBits;
            }
            dest[o] = lutArr[n];
          }
        }
        else {
          var nmax = Math.ceil((maxValue - offset) / scale);
          for (o = 0; o < numPixels; o++) {
            if (bitsLeft === 0) {
              buffer = src[i++];
              bitsLeft = 32;
              bitPos = 0;
            }
            if (bitsLeft >= bitsPerPixel) {
              //no unsigned left shift
              n = ((buffer >>> bitPos) & bitMask);
              bitsLeft -= bitsPerPixel;
              bitPos += bitsPerPixel;
            } else {
              missingBits = (bitsPerPixel - bitsLeft);
              n = (buffer >>> bitPos) & bitMask;//((buffer & bitMask) << missingBits) & bitMask;
              buffer = src[i++];
              bitsLeft = 32 - missingBits;
              n |= (buffer & ((1 << missingBits) - 1)) << (bitsPerPixel - missingBits);
              bitPos = missingBits;
            }
            //pixel values may exceed max due to quantization
            dest[o] = n < nmax ? offset + n * scale : maxValue;
          }
        }
        return dest;
      },

      unstuffLUT2: function(src, bitsPerPixel, numPixels, offset, scale, maxValue) {
        var bitMask = (1 << bitsPerPixel) - 1;
        var i = 0, o = 0, missingBits = 0, bitsLeft = 0, n = 0, bitPos = 0;
        var buffer;
        var dest = [];
        var nmax = Math.ceil((maxValue - offset) / scale);
        for (o = 0; o < numPixels; o++) {
          if (bitsLeft === 0) {
            buffer = src[i++];
            bitsLeft = 32;
            bitPos = 0;
          }
          if (bitsLeft >= bitsPerPixel) {
            //no unsigned left shift
            n = ((buffer >>> bitPos) & bitMask);
            bitsLeft -= bitsPerPixel;
            bitPos += bitsPerPixel;
          } else {
            missingBits = (bitsPerPixel - bitsLeft);
            n = (buffer >>> bitPos) & bitMask;//((buffer & bitMask) << missingBits) & bitMask;
            buffer = src[i++];
            bitsLeft = 32 - missingBits;
            n |= (buffer & ((1 << missingBits) - 1)) << (bitsPerPixel - missingBits);
            bitPos = missingBits;
          }
          //dest.push(n);
          dest[o] = n < nmax ? offset + n * scale : maxValue;
        }
        dest.unshift(offset);
        return dest;
      },

      originalUnstuff: function(src, dest, bitsPerPixel, numPixels) {
        var bitMask = (1 << bitsPerPixel) - 1;
        var i = 0, o;
        var bitsLeft = 0;
        var n, buffer, missingBits;

        // get rid of trailing bytes that are already part of next block
        var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);
        src[src.length - 1] <<= 8 * numInvalidTailBytes;

        for (o = 0; o < numPixels; o++) {
          if (bitsLeft === 0) {
            buffer = src[i++];
            bitsLeft = 32;
          }
          if (bitsLeft >= bitsPerPixel) {
            n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;
            bitsLeft -= bitsPerPixel;
          }
          else {
            missingBits = (bitsPerPixel - bitsLeft);
            n = ((buffer & bitMask) << missingBits) & bitMask;
            buffer = src[i++];
            bitsLeft = 32 - missingBits;
            n += (buffer >>> bitsLeft);
          }
          dest[o] = n;
        }
        return dest;
      },

      originalUnstuff2: function(src, dest, bitsPerPixel, numPixels) {
        var bitMask = (1 << bitsPerPixel) - 1;
        var i = 0, o;
        var bitsLeft = 0, bitPos = 0;
        var n, buffer, missingBits;
        //micro-optimizations
        for (o = 0; o < numPixels; o++) {
          if (bitsLeft === 0) {
            buffer = src[i++];
            bitsLeft = 32;
            bitPos = 0;
          }
          if (bitsLeft >= bitsPerPixel) {
            //no unsigned left shift
            n = ((buffer >>> bitPos) & bitMask);
            bitsLeft -= bitsPerPixel;
            bitPos += bitsPerPixel;
          } else {
            missingBits = (bitsPerPixel - bitsLeft);
            n = (buffer >>> bitPos) & bitMask;//((buffer & bitMask) << missingBits) & bitMask;
            buffer = src[i++];
            bitsLeft = 32 - missingBits;
            n |= (buffer & ((1 << missingBits) - 1)) << (bitsPerPixel - missingBits);
            bitPos = missingBits;
          }
          dest[o] = n;
        }
        return dest;
      }
    };

    /*****************************************
    *private static class used by Lerc2Decode
    ******************************************/
    var Lerc2Helpers = {
      HUFFMAN_LUT_BITS_MAX: 12, //use 2^12 lut, treat it like constant
      computeChecksumFletcher32: function(input) {

        var sum1 = 0xffff, sum2 = 0xffff;
        var len = input.length;
        var words = Math.floor(len / 2);
        var i = 0;
        while (words) {
          var tlen = (words >= 359) ? 359 : words;
          words -= tlen;
          do {
            sum1 += (input[i++] << 8);
            sum2 += sum1 += input[i++];
          } while (--tlen);

          sum1 = (sum1 & 0xffff) + (sum1 >>> 16);
          sum2 = (sum2 & 0xffff) + (sum2 >>> 16);
        }

        // add the straggler byte if it exists
        if (len & 1) {
          sum2 += sum1 += (input[i] << 8);
        }
        // second reduction step to reduce sums to 16 bits
        sum1 = (sum1 & 0xffff) + (sum1 >>> 16);
        sum2 = (sum2 & 0xffff) + (sum2 >>> 16);

        return (sum2 << 16 | sum1) >>> 0;
      },

      readHeaderInfo: function(input, data) {
        var ptr = data.ptr;
        var fileIdView = new Uint8Array(input, ptr, 6);
        var headerInfo = {};
        headerInfo.fileIdentifierString = String.fromCharCode.apply(null, fileIdView);
        if (headerInfo.fileIdentifierString.lastIndexOf("Lerc2", 0) !== 0) {
          throw "Unexpected file identifier string (expect Lerc2 ): " + headerInfo.fileIdentifierString;
        }
        ptr += 6;
        var view = new DataView(input, ptr, 8);
        var fileVersion = view.getInt32(0, true);
        headerInfo.fileVersion = fileVersion;
        ptr += 4;
        if (fileVersion >= 3) {
          headerInfo.checksum = view.getUint32(4, true); //nrows
          ptr += 4;
        }

        //keys start from here
        view = new DataView(input, ptr, 12);
        headerInfo.height = view.getUint32(0, true); //nrows
        headerInfo.width = view.getUint32(4, true); //ncols
        ptr += 8;
        if (fileVersion >= 4) {
          headerInfo.numDims = view.getUint32(8, true);
          ptr += 4;
        }
        else {
          headerInfo.numDims = 1;
        }

        view = new DataView(input, ptr, 40);
        headerInfo.numValidPixel = view.getUint32(0, true);
        headerInfo.microBlockSize = view.getInt32(4, true);
        headerInfo.blobSize = view.getInt32(8, true);
        headerInfo.imageType = view.getInt32(12, true);

        headerInfo.maxZError = view.getFloat64(16, true);
        headerInfo.zMin = view.getFloat64(24, true);
        headerInfo.zMax = view.getFloat64(32, true);
        ptr += 40;
        data.headerInfo = headerInfo;
        data.ptr = ptr;

        var checksum, keyLength;
        if (fileVersion >= 3) {
          keyLength = fileVersion >= 4 ? 52 : 48;
          checksum = this.computeChecksumFletcher32(new Uint8Array(input, ptr - keyLength, headerInfo.blobSize - 14));
          if (checksum !== headerInfo.checksum) {
            throw "Checksum failed.";
          }
        }
        return true;
      },

      checkMinMaxRanges: function(input, data) {
        var headerInfo = data.headerInfo;
        var OutPixelTypeArray = this.getDataTypeArray(headerInfo.imageType);
        var rangeBytes = headerInfo.numDims * this.getDataTypeSize(headerInfo.imageType);
        var minValues = this.readSubArray(input, data.ptr, OutPixelTypeArray, rangeBytes);
        var maxValues = this.readSubArray(input, data.ptr + rangeBytes, OutPixelTypeArray, rangeBytes);
        data.ptr += (2 * rangeBytes);
        var i, equal = true;
        for (i = 0; i < headerInfo.numDims; i++) {
          if (minValues[i] !== maxValues[i]) {
            equal = false;
            break;
          }
        }
        headerInfo.minValues = minValues;
        headerInfo.maxValues = maxValues;
        return equal;
      },

      readSubArray: function(input, ptr, OutPixelTypeArray, numBytes) {
        var rawData;
        if (OutPixelTypeArray === Uint8Array) {
          rawData = new Uint8Array(input, ptr, numBytes);
        }
        else {
          var arrayBuf = new ArrayBuffer(numBytes);
          var store8 = new Uint8Array(arrayBuf);
          store8.set(new Uint8Array(input, ptr, numBytes));
          rawData = new OutPixelTypeArray(arrayBuf);
        }
        return rawData;
      },

      readMask: function(input, data) {
        var ptr = data.ptr;
        var headerInfo = data.headerInfo;
        var numPixels = headerInfo.width * headerInfo.height;
        var numValidPixel = headerInfo.numValidPixel;

        var view = new DataView(input, ptr, 4);
        var mask = {};
        mask.numBytes = view.getUint32(0, true);
        ptr += 4;

        // Mask Data
        if ((0 === numValidPixel || numPixels === numValidPixel) && 0 !== mask.numBytes) {
          throw ("invalid mask");
        }
        var bitset, resultMask;
        if (numValidPixel === 0) {
          bitset = new Uint8Array(Math.ceil(numPixels / 8));
          mask.bitset = bitset;
          resultMask = new Uint8Array(numPixels);
          data.pixels.resultMask = resultMask;
          ptr += mask.numBytes;
        }// ????? else if (data.mask.numBytes > 0 && data.mask.numBytes< data.numValidPixel) {
        else if (mask.numBytes > 0) {
          bitset = new Uint8Array(Math.ceil(numPixels / 8));
          view = new DataView(input, ptr, mask.numBytes);
          var cnt = view.getInt16(0, true);
          var ip = 2, op = 0, val = 0;
          do {
            if (cnt > 0) {
              while (cnt--) { bitset[op++] = view.getUint8(ip++); }
            } else {
              val = view.getUint8(ip++);
              cnt = -cnt;
              while (cnt--) { bitset[op++] = val; }
            }
            cnt = view.getInt16(ip, true);
            ip += 2;
          } while (ip < mask.numBytes);
          if ((cnt !== -32768) || (op < bitset.length)) {
            throw "Unexpected end of mask RLE encoding";
          }

          resultMask = new Uint8Array(numPixels);
          var mb = 0, k = 0;

          for (k = 0; k < numPixels; k++) {
            if (k & 7) {
              mb = bitset[k >> 3];
              mb <<= k & 7;
            }
            else {
              mb = bitset[k >> 3];
            }
            if (mb & 128) {
              resultMask[k] = 1;
            }
          }
          data.pixels.resultMask = resultMask;

          mask.bitset = bitset;
          ptr += mask.numBytes;
        }
        data.ptr = ptr;
        data.mask = mask;
        return true;
      },

      readDataOneSweep: function(input, data, OutPixelTypeArray, useBSQForOutputDim) {
        var ptr = data.ptr;
        var headerInfo = data.headerInfo;
        var numDims = headerInfo.numDims;
        var numPixels = headerInfo.width * headerInfo.height;
        var imageType = headerInfo.imageType;
        var numBytes = headerInfo.numValidPixel * Lerc2Helpers.getDataTypeSize(imageType) * numDims;
        //data.pixels.numBytes = numBytes;
        var rawData;
        var mask = data.pixels.resultMask;
        if (OutPixelTypeArray === Uint8Array) {
          rawData = new Uint8Array(input, ptr, numBytes);
        }
        else {
          var arrayBuf = new ArrayBuffer(numBytes);
          var store8 = new Uint8Array(arrayBuf);
          store8.set(new Uint8Array(input, ptr, numBytes));
          rawData = new OutPixelTypeArray(arrayBuf);
        }
        if (rawData.length === numPixels * numDims) {
          if (useBSQForOutputDim) {
            data.pixels.resultPixels = Lerc2Helpers.swapDimensionOrder(rawData, numPixels, numDims, OutPixelTypeArray, true);
          }
          else {
            data.pixels.resultPixels = rawData;
          }
        }
        else  //mask
        {
          data.pixels.resultPixels = new OutPixelTypeArray(numPixels * numDims);
          var z = 0, k = 0, i = 0, nStart = 0;
          if (numDims > 1) {
            if (useBSQForOutputDim) {
              for (k = 0; k < numPixels; k++) {
                if (mask[k]) {
                  nStart = k;
                  for (i = 0; i < numDims; i++, nStart+=numPixels) {
                    data.pixels.resultPixels[nStart] = rawData[z++];
                  }
                }
              }
            }
            else {
              for (k = 0; k < numPixels; k++) {
                if (mask[k]) {
                  nStart = k * numDims;
                  for (i = 0; i < numDims; i++) {
                    data.pixels.resultPixels[nStart + i] = rawData[z++];
                  }
                }
              }
            }
          }
          else {
            for (k = 0; k < numPixels; k++) {
              if (mask[k]) {
                data.pixels.resultPixels[k] = rawData[z++];
              }
            }
          }
        }
        ptr += numBytes;
        data.ptr = ptr;       //return data;
        return true;
      },

      readHuffmanTree: function(input, data) {
        var BITS_MAX = this.HUFFMAN_LUT_BITS_MAX; //8 is slow for the large test image
        //var size_max = 1 << BITS_MAX;
        /* ************************
        * reading code table
        *************************/
        var view = new DataView(input, data.ptr, 16);
        data.ptr += 16;
        var version = view.getInt32(0, true);
        if (version < 2) {
          throw "unsupported Huffman version";
        }
        var size = view.getInt32(4, true);
        var i0 = view.getInt32(8, true);
        var i1 = view.getInt32(12, true);
        if (i0 >= i1) {
          return false;
        }
        var blockDataBuffer = new Uint32Array(i1 - i0);
        Lerc2Helpers.decodeBits(input, data, blockDataBuffer);
        var codeTable = []; //size
        var i, j, k, len;

        for (i = i0; i < i1; i++) {
          j = i - (i < size ? 0 : size);//wrap around
          codeTable[j] = { first: blockDataBuffer[i - i0], second: null };
        }

        var dataBytes = input.byteLength - data.ptr;
        var dataWords = Math.ceil(dataBytes / 4);
        var arrayBuf = new ArrayBuffer(dataWords * 4);
        var store8 = new Uint8Array(arrayBuf);
        store8.set(new Uint8Array(input, data.ptr, dataBytes));
        var stuffedData = new Uint32Array(arrayBuf); //must start from x*4
        var bitPos = 0, word, srcPtr = 0;
        word = stuffedData[0];
        for (i = i0; i < i1; i++) {
          j = i - (i < size ? 0 : size);//wrap around
          len = codeTable[j].first;
          if (len > 0) {
            codeTable[j].second = (word << bitPos) >>> (32 - len);

            if (32 - bitPos >= len) {
              bitPos += len;
              if (bitPos === 32) {
                bitPos = 0;
                srcPtr++;
                word = stuffedData[srcPtr];
              }
            }
            else {
              bitPos += len - 32;
              srcPtr++;
              word = stuffedData[srcPtr];
              codeTable[j].second |= word >>> (32 - bitPos);
            }
          }
        }

        //finished reading code table

        /* ************************
        * building lut
        *************************/
        var numBitsLUT = 0, numBitsLUTQick = 0;
        var tree = new TreeNode();
        for (i = 0; i < codeTable.length; i++) {
          if (codeTable[i] !== undefined) {
            numBitsLUT = Math.max(numBitsLUT, codeTable[i].first);
          }
        }
        if (numBitsLUT >= BITS_MAX) {
          numBitsLUTQick = BITS_MAX;
        }
        else {
          numBitsLUTQick = numBitsLUT;
        }
        // for debugging purpose
        // if (numBitsLUT >= 30) {
        //   console.log("WARning, large NUM LUT BITS IS " + numBitsLUT);
        // }
        var decodeLut = [], entry, code, numEntries, jj, currentBit, node;
        for (i = i0; i < i1; i++) {
          j = i - (i < size ? 0 : size);//wrap around
          len = codeTable[j].first;
          if (len > 0) {
            entry = [len, j];
            if (len <= numBitsLUTQick) {
              code = codeTable[j].second << (numBitsLUTQick - len);
              numEntries = 1 << (numBitsLUTQick - len);
              for (k = 0; k < numEntries; k++) {
                decodeLut[code | k] = entry;
              }
            }
            else {
              //build tree
              code = codeTable[j].second;
              node = tree;
              for (jj = len - 1; jj >= 0; jj--) {
                currentBit = code >>> jj & 1; //no left shift as length could be 30,31
                if (currentBit) {
                  if (!node.right) {
                    node.right = new TreeNode();
                  }
                  node = node.right;
                }
                else {
                  if (!node.left) {
                    node.left = new TreeNode();
                  }
                  node = node.left;
                }
                if (jj === 0 && !node.val) {
                  node.val = entry[1];
                }
              }
            }
          }
        }
        return {
          decodeLut: decodeLut,
          numBitsLUTQick: numBitsLUTQick,
          numBitsLUT: numBitsLUT,
          tree: tree,
          stuffedData: stuffedData,
          srcPtr: srcPtr,
          bitPos: bitPos
        };
      },

      readHuffman: function(input, data, OutPixelTypeArray, useBSQForOutputDim) {
        var headerInfo = data.headerInfo;
        var numDims = headerInfo.numDims;
        var height = data.headerInfo.height;
        var width = data.headerInfo.width;
        var numPixels = width * height;
        //var size_max = 1 << BITS_MAX;
        /* ************************
        * reading huffman structure info
        *************************/
        var huffmanInfo = this.readHuffmanTree(input, data);
        var decodeLut = huffmanInfo.decodeLut;
        var tree = huffmanInfo.tree;
        //stuffedData includes huffman headers
        var stuffedData = huffmanInfo.stuffedData;
        var srcPtr = huffmanInfo.srcPtr;
        var bitPos = huffmanInfo.bitPos;
        var numBitsLUTQick = huffmanInfo.numBitsLUTQick;
        var numBitsLUT = huffmanInfo.numBitsLUT;
        var offset = data.headerInfo.imageType === 0 ? 128 : 0;
        /*************************
        *  decode
        ***************************/
        var node, val, delta, mask = data.pixels.resultMask, valTmp, valTmpQuick, currentBit;
        var i, j, k, ii;
        var prevVal = 0;
        if (bitPos > 0) {
          srcPtr++;
          bitPos = 0;
        }
        var word = stuffedData[srcPtr];
        var deltaEncode = data.encodeMode === 1;
        var resultPixelsAllDim = new OutPixelTypeArray(numPixels * numDims);
        var resultPixels = resultPixelsAllDim;
        var iDim;
        // TODO: reevaluate the need to keep inlined decoding code as IE support is phasing out
        if (numDims < 2 || deltaEncode) {
          for (iDim = 0; iDim < numDims; iDim++) {
            if (numDims > 1) {
              //get the mem block of current dimension
              resultPixels = new OutPixelTypeArray(resultPixelsAllDim.buffer, numPixels * iDim, numPixels);
              prevVal = 0;
            }
            if (data.headerInfo.numValidPixel === width * height) { //all valid
              for (k = 0, i = 0; i < height; i++) {
                for (j = 0; j < width; j++, k++) {
                  val = 0;
                  valTmp = (word << bitPos) >>> (32 - numBitsLUTQick);
                  valTmpQuick = valTmp;// >>> deltaBits;
                  if (32 - bitPos < numBitsLUTQick) {
                    valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUTQick));
                    valTmpQuick = valTmp;// >>> deltaBits;
                  }
                  if (decodeLut[valTmpQuick])    // if there, move the correct number of bits and done
                  {
                    val = decodeLut[valTmpQuick][1];
                    bitPos += decodeLut[valTmpQuick][0];
                  }
                  else {
                    valTmp = (word << bitPos) >>> (32 - numBitsLUT);
                    valTmpQuick = valTmp;// >>> deltaBits;
                    if (32 - bitPos < numBitsLUT) {
                      valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUT));
                      valTmpQuick = valTmp;// >>> deltaBits;
                    }
                    node = tree;
                    for (ii = 0; ii < numBitsLUT; ii++) {
                      currentBit = valTmp >>> (numBitsLUT - ii - 1) & 1;
                      node = currentBit ? node.right : node.left;
                      if (!(node.left || node.right)) {
                        val = node.val;
                        bitPos = bitPos + ii + 1;
                        break;
                      }
                    }
                  }
    
                  if (bitPos >= 32) {
                    bitPos -= 32;
                    srcPtr++;
                    word = stuffedData[srcPtr];
                  }
    
                  delta = val - offset;
                  if (deltaEncode) {
                    if (j > 0) {
                      delta += prevVal;    // use overflow
                    }
                    else if (i > 0) {
                      delta += resultPixels[k - width];
                    }
                    else {
                      delta += prevVal;
                    }
                    delta &= 0xFF; //overflow
                    resultPixels[k] = delta;//overflow
                    prevVal = delta;
                  }
                  else {
                    resultPixels[k] = delta;
                  }
                }
              }
            }
            else { //not all valid, use mask
              for (k = 0, i = 0; i < height; i++) {
                for (j = 0; j < width; j++, k++) {
                  if (mask[k]) {
                    val = 0;
                    valTmp = (word << bitPos) >>> (32 - numBitsLUTQick);
                    valTmpQuick = valTmp;// >>> deltaBits;
                    if (32 - bitPos < numBitsLUTQick) {
                      valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUTQick));
                      valTmpQuick = valTmp;// >>> deltaBits;
                    }
                    if (decodeLut[valTmpQuick])    // if there, move the correct number of bits and done
                    {
                      val = decodeLut[valTmpQuick][1];
                      bitPos += decodeLut[valTmpQuick][0];
                    }
                    else {
                      valTmp = (word << bitPos) >>> (32 - numBitsLUT);
                      valTmpQuick = valTmp;// >>> deltaBits;
                      if (32 - bitPos < numBitsLUT) {
                        valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUT));
                        valTmpQuick = valTmp;// >>> deltaBits;
                      }
                      node = tree;
                      for (ii = 0; ii < numBitsLUT; ii++) {
                        currentBit = valTmp >>> (numBitsLUT - ii - 1) & 1;
                        node = currentBit ? node.right : node.left;
                        if (!(node.left || node.right)) {
                          val = node.val;
                          bitPos = bitPos + ii + 1;
                          break;
                        }
                      }
                    }
    
                    if (bitPos >= 32) {
                      bitPos -= 32;
                      srcPtr++;
                      word = stuffedData[srcPtr];
                    }
    
                    delta = val - offset;
                    if (deltaEncode) {
                      if (j > 0 && mask[k - 1]) {
                        delta += prevVal;    // use overflow
                      }
                      else if (i > 0 && mask[k - width]) {
                        delta += resultPixels[k - width];
                      }
                      else {
                        delta += prevVal;
                      }
    
                      delta &= 0xFF; //overflow
                      resultPixels[k] = delta;//overflow
                      prevVal = delta;
                    }
                    else {
                      resultPixels[k] = delta;
                    }
                  }
                }
              }
            }
          }
        }
        else {
          for (k = 0, i = 0; i < height; i++) {
            for (j = 0; j < width; j++) {
              k = i * width + j;
              if (!mask || mask[k]) {
                for (iDim = 0; iDim < numDims; iDim++, k+=numPixels) {
                  val = 0;
                  valTmp = (word << bitPos) >>> (32 - numBitsLUTQick);
                  valTmpQuick = valTmp;
                  if (32 - bitPos < numBitsLUTQick) {
                    valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUTQick));
                    valTmpQuick = valTmp;
                  }
                  if (decodeLut[valTmpQuick])
                  {
                    val = decodeLut[valTmpQuick][1];
                    bitPos += decodeLut[valTmpQuick][0];
                  }
                  else {
                    valTmp = (word << bitPos) >>> (32 - numBitsLUT);
                    valTmpQuick = valTmp;
                    if (32 - bitPos < numBitsLUT) {
                      valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUT));
                      valTmpQuick = valTmp;
                    }
                    node = tree;
                    for (ii = 0; ii < numBitsLUT; ii++) {
                      currentBit = valTmp >>> (numBitsLUT - ii - 1) & 1;
                      node = currentBit ? node.right : node.left;
                      if (!(node.left || node.right)) {
                        val = node.val;
                        bitPos = bitPos + ii + 1;
                        break;
                      }
                    }
                  }

                  if (bitPos >= 32) {
                    bitPos -= 32;
                    srcPtr++;
                    word = stuffedData[srcPtr];
                  }

                  delta = val - offset;
                  resultPixels[k] = delta;
                }
              }
            }
          }
        }
        data.ptr = data.ptr + (srcPtr + 1) * 4 + (bitPos > 0 ? 4 : 0);
        data.pixels.resultPixels = resultPixelsAllDim;
        //swap for BIP layout
        if (numDims > 1 && !useBSQForOutputDim) {
          data.pixels.resultPixels = Lerc2Helpers.swapDimensionOrder(resultPixelsAllDim, numPixels, numDims, OutPixelTypeArray);
        }
      },

      decodeBits: function(input, data, blockDataBuffer, offset, iDim) {
        {
          //bitstuff encoding is 3
          var headerInfo = data.headerInfo;
          var fileVersion = headerInfo.fileVersion;
          //var block = {};
          var blockPtr = 0;
          var viewByteLength = ((input.byteLength - data.ptr) >= 5) ? 5 : (input.byteLength - data.ptr);
          var view = new DataView(input, data.ptr, viewByteLength);
          var headerByte = view.getUint8(0);
          blockPtr++;
          var bits67 = headerByte >> 6;
          var n = (bits67 === 0) ? 4 : 3 - bits67;
          var doLut = (headerByte & 32) > 0 ? true : false;//5th bit
          var numBits = headerByte & 31;
          var numElements = 0;
          if (n === 1) {
            numElements = view.getUint8(blockPtr); blockPtr++;
          } else if (n === 2) {
            numElements = view.getUint16(blockPtr, true); blockPtr += 2;
          } else if (n === 4) {
            numElements = view.getUint32(blockPtr, true); blockPtr += 4;
          } else {
            throw "Invalid valid pixel count type";
          }
          //fix: huffman codes are bit stuffed, but not bound by data's max value, so need to use originalUnstuff
          //offset = offset || 0;
          var scale = 2 * headerInfo.maxZError;
          var stuffedData, arrayBuf, store8, dataBytes, dataWords;
          var lutArr, lutData, lutBytes, lutBitsPerElement, bitsPerPixel;
          var zMax = headerInfo.numDims > 1 ? headerInfo.maxValues[iDim] : headerInfo.zMax;
          if (doLut) {
            data.counter.lut++;
            lutBytes = view.getUint8(blockPtr);
            lutBitsPerElement = numBits;
            blockPtr++;
            dataBytes = Math.ceil((lutBytes - 1) * numBits / 8);
            dataWords = Math.ceil(dataBytes / 4);
            arrayBuf = new ArrayBuffer(dataWords * 4);
            store8 = new Uint8Array(arrayBuf);

            data.ptr += blockPtr;
            store8.set(new Uint8Array(input, data.ptr, dataBytes));

            lutData = new Uint32Array(arrayBuf);
            data.ptr += dataBytes;

            bitsPerPixel = 0;
            while ((lutBytes - 1) >>> bitsPerPixel) {
              bitsPerPixel++;
            }
            dataBytes = Math.ceil(numElements * bitsPerPixel / 8);
            dataWords = Math.ceil(dataBytes / 4);
            arrayBuf = new ArrayBuffer(dataWords * 4);
            store8 = new Uint8Array(arrayBuf);
            store8.set(new Uint8Array(input, data.ptr, dataBytes));
            stuffedData = new Uint32Array(arrayBuf);
            data.ptr += dataBytes;
            if (fileVersion >= 3) {
              lutArr = BitStuffer.unstuffLUT2(lutData, numBits, lutBytes - 1, offset, scale, zMax);
            }
            else {
              lutArr = BitStuffer.unstuffLUT(lutData, numBits, lutBytes - 1, offset, scale, zMax);
            }
            //lutArr.unshift(0);
            if (fileVersion >= 3) {
              //BitStuffer.unstuff2(block, blockDataBuffer, headerInfo.zMax);
              BitStuffer.unstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements, lutArr);
            }
            else {
              BitStuffer.unstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements, lutArr);
            }
          }
          else {
            //console.debug("bitstuffer");
            data.counter.bitstuffer++;
            bitsPerPixel = numBits;
            data.ptr += blockPtr;
            if (bitsPerPixel > 0) {
              dataBytes = Math.ceil(numElements * bitsPerPixel / 8);
              dataWords = Math.ceil(dataBytes / 4);
              arrayBuf = new ArrayBuffer(dataWords * 4);
              store8 = new Uint8Array(arrayBuf);
              store8.set(new Uint8Array(input, data.ptr, dataBytes));
              stuffedData = new Uint32Array(arrayBuf);
              data.ptr += dataBytes;
              if (fileVersion >= 3) {
                if (offset == null) {
                  BitStuffer.originalUnstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements);
                }
                else {
                  BitStuffer.unstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements, false, offset, scale, zMax);
                }
              }
              else {
                if (offset == null) {
                  BitStuffer.originalUnstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements);
                }
                else {
                  BitStuffer.unstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements, false, offset, scale, zMax);
                }
              }
            }
          }
        }

      },

      readTiles: function(input, data, OutPixelTypeArray, useBSQForOutputDim) {
        var headerInfo = data.headerInfo;
        var width = headerInfo.width;
        var height = headerInfo.height;
        var numPixels = width * height;
        var microBlockSize = headerInfo.microBlockSize;
        var imageType = headerInfo.imageType;
        var dataTypeSize = Lerc2Helpers.getDataTypeSize(imageType);
        var numBlocksX = Math.ceil(width / microBlockSize);
        var numBlocksY = Math.ceil(height / microBlockSize);
        data.pixels.numBlocksY = numBlocksY;
        data.pixels.numBlocksX = numBlocksX;
        data.pixels.ptr = 0;
        var row = 0, col = 0, blockY = 0, blockX = 0, thisBlockHeight = 0, thisBlockWidth = 0, bytesLeft = 0, headerByte = 0, bits67 = 0, testCode = 0, outPtr = 0, outStride = 0, numBytes = 0, bytesleft = 0, z = 0, blockPtr = 0;
        var view, block, arrayBuf, store8, rawData;
        var blockEncoding;
        var blockDataBuffer = new OutPixelTypeArray(microBlockSize * microBlockSize);
        var lastBlockHeight = (height % microBlockSize) || microBlockSize;
        var lastBlockWidth = (width % microBlockSize) || microBlockSize;
        var offsetType, offset;
        var numDims = headerInfo.numDims, iDim;
        var mask = data.pixels.resultMask;
        var resultPixels = data.pixels.resultPixels;
        var fileVersion = headerInfo.fileVersion;
        var fileVersionCheckNum = fileVersion >= 5 ? 14 : 15;
        var isDiffEncoding;
        var zMax = headerInfo.zMax;
        //var resultPixelsAllDim = resultPixels;
        var resultPixelsPrevDim;
        for (blockY = 0; blockY < numBlocksY; blockY++) {
          thisBlockHeight = (blockY !== numBlocksY - 1) ? microBlockSize : lastBlockHeight;
          for (blockX = 0; blockX < numBlocksX; blockX++) {
            //console.debug("y" + blockY + " x" + blockX);
            thisBlockWidth = (blockX !== numBlocksX - 1) ? microBlockSize : lastBlockWidth;

            outPtr = blockY * width * microBlockSize + blockX * microBlockSize;
            outStride = width - thisBlockWidth;

            for (iDim = 0; iDim < numDims; iDim++) {
              if (numDims > 1) {
                resultPixelsPrevDim = resultPixels;
                outPtr = blockY * width * microBlockSize + blockX * microBlockSize;
                resultPixels = new OutPixelTypeArray(data.pixels.resultPixels.buffer, numPixels * iDim * dataTypeSize, numPixels);
                zMax = headerInfo.maxValues[iDim];
              } else {
                resultPixelsPrevDim = null;
              }
              bytesLeft = input.byteLength - data.ptr;
              view = new DataView(input, data.ptr, Math.min(10, bytesLeft));
              block = {};
              blockPtr = 0;
              headerByte = view.getUint8(0);
              blockPtr++;
              isDiffEncoding = headerInfo.fileVersion >= 5 ? headerByte & 4 : 0;
              bits67 = (headerByte >> 6) & 0xFF;
              testCode = (headerByte >> 2) & fileVersionCheckNum;    // use bits 2345 for integrity check
              if (testCode !== (((blockX * microBlockSize) >> 3) & fileVersionCheckNum)) {
                throw "integrity issue";
              }

              if (isDiffEncoding && iDim === 0) {
                throw "integrity issue";
              }

              blockEncoding = headerByte & 3;
              if (blockEncoding > 3) {
                data.ptr += blockPtr;
                throw "Invalid block encoding (" + blockEncoding + ")";
              }
              else if (blockEncoding === 2) { //constant 0
                if (isDiffEncoding) {
                  if (mask) {
                    for (row = 0; row < thisBlockHeight; row++) {
                      for (col = 0; col < thisBlockWidth; col++) {
                        if (mask[outPtr]) {
                          resultPixels[outPtr] = resultPixelsPrevDim[outPtr];
                        }
                        outPtr++;
                      }
                    }
                  }
                  else {
                    for (row = 0; row < thisBlockHeight; row++) {
                      for (col = 0; col < thisBlockWidth; col++) {
                        resultPixels[outPtr] = resultPixelsPrevDim[outPtr];
                        outPtr++;
                      }
                    }
                  }
                }
                data.counter.constant++;
                data.ptr += blockPtr;
                continue;
              }
              else if (blockEncoding === 0) {  //uncompressed
                if (isDiffEncoding) {
                  // doesn't make sense, should not happen
                  throw "integrity issue";
                }
                data.counter.uncompressed++;
                data.ptr += blockPtr;
                numBytes = thisBlockHeight * thisBlockWidth * dataTypeSize;
                bytesleft = input.byteLength - data.ptr;
                numBytes = numBytes < bytesleft ? numBytes : bytesleft;
                //bit alignment
                arrayBuf = new ArrayBuffer((numBytes % dataTypeSize) === 0 ? numBytes : (numBytes + dataTypeSize - numBytes % dataTypeSize));
                store8 = new Uint8Array(arrayBuf);
                store8.set(new Uint8Array(input, data.ptr, numBytes));
                rawData = new OutPixelTypeArray(arrayBuf);
                z = 0;
                if (mask) {
                  for (row = 0; row < thisBlockHeight; row++) {
                    for (col = 0; col < thisBlockWidth; col++) {
                      if (mask[outPtr]) {
                        resultPixels[outPtr] = rawData[z++];
                      }
                      outPtr++;
                    }
                    outPtr += outStride;
                  }
                }
                else {//all valid
                  for (row = 0; row < thisBlockHeight; row++) {
                    for (col = 0; col < thisBlockWidth; col++) {
                      resultPixels[outPtr++] = rawData[z++];
                    }
                    outPtr += outStride;
                  }
                }
                data.ptr += z * dataTypeSize;
              }
              else { //1 or 3
                offsetType = Lerc2Helpers.getDataTypeUsed((isDiffEncoding && imageType < 6) ? 4 : imageType, bits67);
                offset = Lerc2Helpers.getOnePixel(block, blockPtr, offsetType, view);
                blockPtr += Lerc2Helpers.getDataTypeSize(offsetType);
                if (blockEncoding === 3) //constant offset value
                {
                  data.ptr += blockPtr;
                  data.counter.constantoffset++;
                  //you can delete the following resultMask case in favor of performance because val is constant and users use nodata mask, otherwise nodatavalue post processing handles it too.
                  //while the above statement is true, we're not doing it as we want to keep invalid pixel value at 0 rather than arbitrary values
                  if (mask) {
                    for (row = 0; row < thisBlockHeight; row++) {
                      for (col = 0; col < thisBlockWidth; col++) {
                        if (mask[outPtr]) {
                          resultPixels[outPtr] = isDiffEncoding ? Math.min(zMax, resultPixelsPrevDim[outPtr] + offset) : offset;
                        }
                        outPtr++;
                      }
                      outPtr += outStride;
                    }
                  }
                  else {
                    for (row = 0; row < thisBlockHeight; row++) {
                      for (col = 0; col < thisBlockWidth; col++) {
                        resultPixels[outPtr] = isDiffEncoding ? Math.min(zMax, resultPixelsPrevDim[outPtr] + offset) : offset;
                        outPtr++;
                      }
                      outPtr += outStride;
                    }
                  }
                }
                else { //bitstuff encoding is 3
                  data.ptr += blockPtr;
                  //heavy lifting
                  Lerc2Helpers.decodeBits(input, data, blockDataBuffer, offset, iDim);
                  blockPtr = 0;
                  // duplicate code to favor performance, diff encoding is for multidimension only
                  if (isDiffEncoding) {
                    if (mask) {
                      for (row = 0; row < thisBlockHeight; row++) {
                        for (col = 0; col < thisBlockWidth; col++) {
                          if (mask[outPtr]) {
                            resultPixels[outPtr] = blockDataBuffer[blockPtr++] + resultPixelsPrevDim[outPtr];
                          }
                          outPtr++;
                        }
                        outPtr += outStride;
                      }
                    }
                    else {
                      for (row = 0; row < thisBlockHeight; row++) {
                        for (col = 0; col < thisBlockWidth; col++) {
                          resultPixels[outPtr] = blockDataBuffer[blockPtr++] + resultPixelsPrevDim[outPtr];
                          outPtr++;
                        }
                        outPtr += outStride;
                      }
                    }
                  }
                  else if (mask) {
                    for (row = 0; row < thisBlockHeight; row++) {
                      for (col = 0; col < thisBlockWidth; col++) {
                        if (mask[outPtr]) {
                          resultPixels[outPtr] = blockDataBuffer[blockPtr++];
                        }
                        outPtr++;
                      }
                      outPtr += outStride;
                    }
                  }
                  else {
                    for (row = 0; row < thisBlockHeight; row++) {
                      for (col = 0; col < thisBlockWidth; col++) {
                        resultPixels[outPtr++] = blockDataBuffer[blockPtr++];
                      }
                      outPtr += outStride;
                    }
                  }
                }
              }
            }
          }
        }
        //swap for BIP: it's always easier for clients to handle BSQ so we keep existing logic and introduce a swap here to minimze changes
        if (numDims > 1 && !useBSQForOutputDim) {
          data.pixels.resultPixels = Lerc2Helpers.swapDimensionOrder(data.pixels.resultPixels, numPixels, numDims, OutPixelTypeArray);
        }
      },

      /*****************
      *  private methods (helper methods)
      *****************/

      formatFileInfo: function(data) {
        return {
          "fileIdentifierString": data.headerInfo.fileIdentifierString,
          "fileVersion": data.headerInfo.fileVersion,
          "imageType": data.headerInfo.imageType,
          "height": data.headerInfo.height,
          "width": data.headerInfo.width,
          "numValidPixel": data.headerInfo.numValidPixel,
          "microBlockSize": data.headerInfo.microBlockSize,
          "blobSize": data.headerInfo.blobSize,
          "maxZError": data.headerInfo.maxZError,
          "pixelType": Lerc2Helpers.getPixelType(data.headerInfo.imageType),
          "eofOffset": data.eofOffset,
          "mask": data.mask ? {
            "numBytes": data.mask.numBytes
          } : null,
          "pixels": {
            "numBlocksX": data.pixels.numBlocksX,
            "numBlocksY": data.pixels.numBlocksY,
            //"numBytes": data.pixels.numBytes,
            "maxValue": data.headerInfo.zMax,
            "minValue": data.headerInfo.zMin,
            "noDataValue": data.noDataValue
          }
        };
      },

      constructConstantSurface: function(data, useBSQForOutputDim) {
        var val = data.headerInfo.zMax;
        var valMin = data.headerInfo.zMin;
        var maxValues = data.headerInfo.maxValues;
        var numDims = data.headerInfo.numDims;
        var numPixels = data.headerInfo.height * data.headerInfo.width;
        var i = 0, k = 0, nStart = 0;
        var mask = data.pixels.resultMask;
        var resultPixels = data.pixels.resultPixels;
        if (mask) {
          if (numDims > 1) {
            if (useBSQForOutputDim) {
              for (i = 0; i < numDims; i++) {
                nStart = i * numPixels;
                val = maxValues[i];
                for (k = 0; k < numPixels; k++) {
                  if (mask[k]) {
                    resultPixels[nStart + k] = val;
                  }
                }
              }  
            }
            else {
              for (k = 0; k < numPixels; k++) {
                if (mask[k]) {
                  nStart = k * numDims;
                  for (i = 0; i < numDims; i++) {
                    resultPixels[nStart + numDims] = maxValues[i];
                  }
                }
              }
            }
          }
          else {
            for (k = 0; k < numPixels; k++) {
              if (mask[k]) {
                resultPixels[k] = val;
              }
            }
          }
        }
        else {
          if (numDims > 1 && valMin !== val) {
            if (useBSQForOutputDim) {
              for (i = 0; i < numDims; i++) {
                nStart = i * numPixels;
                val = maxValues[i];
                for (k = 0; k < numPixels; k++) {
                  resultPixels[nStart + k] = val;
                }
              }
            }
            else {
              for (k = 0; k < numPixels; k++) {
                nStart = k * numDims;
                for (i = 0; i < numDims; i++) {
                  resultPixels[nStart + i] = maxValues[i];
                }
              }
            }
          }
          else {
            for (k = 0; k < numPixels * numDims; k++) {
              resultPixels[k] = val;
            }
          }
        }
        return;
      },

      getDataTypeArray: function(t) {
        var tp;
        switch (t) {
          case 0: //char
            tp = Int8Array;
            break;
          case 1: //byte
            tp = Uint8Array;
            break;
          case 2: //short
            tp = Int16Array;
            break;
          case 3: //ushort
            tp = Uint16Array;
            break;
          case 4:
            tp = Int32Array;
            break;
          case 5:
            tp = Uint32Array;
            break;
          case 6:
            tp = Float32Array;
            break;
          case 7:
            tp = Float64Array;
            break;
          default:
            tp = Float32Array;
        }
        return tp;
      },

      getPixelType: function(t) {
        var tp;
        switch (t) {
          case 0: //char
            tp = "S8";
            break;
          case 1: //byte
            tp = "U8";
            break;
          case 2: //short
            tp = "S16";
            break;
          case 3: //ushort
            tp = "U16";
            break;
          case 4:
            tp = "S32";
            break;
          case 5:
            tp = "U32";
            break;
          case 6:
            tp = "F32";
            break;
          case 7:
            tp = "F64";
            break;
          default:
            tp = "F32";
        }
        return tp;
      },

      isValidPixelValue: function(t, val) {
        if (val == null) {
          return false;
        }
        var isValid;
        switch (t) {
          case 0: //char
            isValid = val >= -128 && val <= 127;
            break;
          case 1: //byte  (unsigned char)
            isValid = val >= 0 && val <= 255;
            break;
          case 2: //short
            isValid = val >= -32768 && val <= 32767;
            break;
          case 3: //ushort
            isValid = val >= 0 && val <= 65536;
            break;
          case 4: //int 32
            isValid = val >= -2147483648 && val <= 2147483647;
            break;
          case 5: //uinit 32
            isValid = val >= 0 && val <= 4294967296;
            break;
          case 6:
            isValid = val >= -3.4027999387901484e+38 && val <= 3.4027999387901484e+38;
            break;
          case 7:
            isValid = val >= -1.7976931348623157e+308 && val <= 1.7976931348623157e+308;
            break;
          default:
            isValid = false;
        }
        return isValid;
      },

      getDataTypeSize: function(t) {
        var s = 0;
        switch (t) {
          case 0: //ubyte
          case 1: //byte
            s = 1;
            break;
          case 2: //short
          case 3: //ushort
            s = 2;
            break;
          case 4:
          case 5:
          case 6:
            s = 4;
            break;
          case 7:
            s = 8;
            break;
          default:
            s = t;
        }
        return s;
      },

      getDataTypeUsed: function(dt, tc) {
        var t = dt;
        switch (dt) {
          case 2: //short
          case 4: //long
            t = dt - tc;
            break;
          case 3: //ushort
          case 5: //ulong
            t = dt - 2 * tc;
            break;
          case 6: //float
            if (0 === tc) {
              t = dt;
            }
            else if (1 === tc) {
              t = 2;
            }
            else {
              t = 1;//byte
            }
            break;
          case 7: //double
            if (0 === tc) {
              t = dt;
            }
            else {
              t = dt - 2 * tc + 1;
            }
            break;
          default:
            t = dt;
            break;
        }
        return t;
      },

      getOnePixel: function(block, blockPtr, offsetType, view) {
        var temp = 0;
        switch (offsetType) {
          case 0: //char
            temp = view.getInt8(blockPtr);
            break;
          case 1: //byte
            temp = view.getUint8(blockPtr);
            break;
          case 2:
            temp = view.getInt16(blockPtr, true);
            break;
          case 3:
            temp = view.getUint16(blockPtr, true);
            break;
          case 4:
            temp = view.getInt32(blockPtr, true);
            break;
          case 5:
            temp = view.getUInt32(blockPtr, true);
            break;
          case 6:
            temp = view.getFloat32(blockPtr, true);
            break;
          case 7:
            temp = view.getFloat64(blockPtr, true);
            break;
          default:
            throw ("the decoder does not understand this pixel type");
        }
        return temp;
      },

      swapDimensionOrder: function(pixels, numPixels, numDims, OutPixelTypeArray, inputIsBIP) {
        var i = 0, j = 0, iDim = 0, temp = 0, swap = pixels;
        if (numDims > 1) {
          swap = new OutPixelTypeArray(numPixels * numDims);
          if (inputIsBIP) {
            for (i=0; i<numPixels; i++) {
              temp = i;
              for (iDim=0; iDim < numDims; iDim++, temp += numPixels) {
                swap[temp] = pixels[j++];
              }
            }  
          }
          else {
            for (i=0; i<numPixels; i++) {
              temp = i;
              for (iDim=0; iDim < numDims; iDim++, temp += numPixels) {
                swap[j++] = pixels[temp];
              }
            }
          }
        }
        return swap;
      }
    };

    /***************************************************
    *private class for a tree node. Huffman code is in Lerc2Helpers
    ****************************************************/
    var TreeNode = function(val, left, right) {
      this.val = val;
      this.left = left;
      this.right = right;
    };

    var Lerc2Decode = {
      /*
      * ********removed options compared to LERC1. We can bring some of them back if needed.
       * removed pixel type. LERC2 is typed and doesn't require user to give pixel type
       * changed encodedMaskData to maskData. LERC2 's js version make it faster to use maskData directly.
       * removed returnMask. mask is used by LERC2 internally and is cost free. In case of user input mask, it's returned as well and has neglible cost.
       * removed nodatavalue. Because LERC2 pixels are typed, nodatavalue will sacrify a useful value for many types (8bit, 16bit) etc,
       *       user has to be knowledgable enough about raster and their data to avoid usability issues. so nodata value is simply removed now.
       *       We can add it back later if their's a clear requirement.
       * removed encodedMask. This option was not implemented in LercDecode. It can be done after decoding (less efficient)
       * removed computeUsedBitDepths.
       *
       *
       * response changes compared to LERC1
       * 1. encodedMaskData is not available
       * 2. noDataValue is optional (returns only if user's noDataValue is with in the valid data type range)
       * 3. maskData is always available
      */
      /*****************
      *  public properties
      ******************/
      //HUFFMAN_LUT_BITS_MAX: 12, //use 2^12 lut, not configurable

      /*****************
      *  public methods
      *****************/

      /**
       * Decode a LERC2 byte stream and return an object containing the pixel data and optional metadata.
       *
       * @param {ArrayBuffer} input The LERC input byte stream
       * @param {object} [options] options Decoding options
       * @param {number} [options.inputOffset] The number of bytes to skip in the input byte stream. A valid LERC file is expected at that position
       * @param {boolean} [options.returnFileInfo] If true, the return value will have a fileInfo property that contains metadata obtained from the LERC headers and the decoding process
       * @param {boolean} [options.returnPixelInterleavedDims]  If true, returned dimensions are pixel-interleaved, a.k.a [p1_dim0, p1_dim1, p1_dimn, p2_dim0...], default is [p1_dim0, p2_dim0, ..., p1_dim1, p2_dim1...]
       */
      decode: function(/*byte array*/ input, /*object*/ options) {
        //currently there's a bug in the sparse array, so please do not set to false
        options = options || {};
        var noDataValue = options.noDataValue;

        //initialize
        var i = 0, data = {};
        data.ptr = options.inputOffset || 0;
        data.pixels = {};

        // File header
        if (!Lerc2Helpers.readHeaderInfo(input, data)) {
          return;
        }

        var headerInfo = data.headerInfo;
        var fileVersion = headerInfo.fileVersion;
        var OutPixelTypeArray = Lerc2Helpers.getDataTypeArray(headerInfo.imageType);

        // version check
        if (fileVersion > 5) {
          throw "unsupported lerc version 2." + fileVersion;
        }

        // Mask Header
        Lerc2Helpers.readMask(input, data);
        if (headerInfo.numValidPixel !== headerInfo.width * headerInfo.height && !data.pixels.resultMask) {
          data.pixels.resultMask = options.maskData;
        }

        var numPixels = headerInfo.width * headerInfo.height;
        data.pixels.resultPixels = new OutPixelTypeArray(numPixels * headerInfo.numDims);

        data.counter = {
          onesweep: 0,
          uncompressed: 0,
          lut: 0,
          bitstuffer: 0,
          constant: 0,
          constantoffset: 0
        };
        var useBSQForOutputDim = !options.returnPixelInterleavedDims;
        if (headerInfo.numValidPixel !== 0) {
          //not tested
          if (headerInfo.zMax === headerInfo.zMin) //constant surface
          {
            Lerc2Helpers.constructConstantSurface(data, useBSQForOutputDim);
          }
          else if (fileVersion >= 4 && Lerc2Helpers.checkMinMaxRanges(input, data)) {
            Lerc2Helpers.constructConstantSurface(data, useBSQForOutputDim);
          }
          else {
            var view = new DataView(input, data.ptr, 2);
            var bReadDataOneSweep = view.getUint8(0);
            data.ptr++;
            if (bReadDataOneSweep) {
              //console.debug("OneSweep");
              Lerc2Helpers.readDataOneSweep(input, data, OutPixelTypeArray, useBSQForOutputDim);
            }
            else {
              //lerc2.1: //bitstuffing + lut
              //lerc2.2: //bitstuffing + lut + huffman
              //lerc2.3: new bitstuffer
              if (fileVersion > 1 && headerInfo.imageType <= 1 && Math.abs(headerInfo.maxZError - 0.5) < 0.00001) {
                //this is 2.x plus 8 bit (unsigned and signed) data, possiblity of Huffman
                var flagHuffman = view.getUint8(1);
                data.ptr++;
                data.encodeMode = flagHuffman;
                if (flagHuffman > 2 || (fileVersion < 4 && flagHuffman > 1)) {
                  throw "Invalid Huffman flag " + flagHuffman;
                }
                if (flagHuffman) {//1 - delta Huffman, 2 - Huffman
                  //console.log("Huffman");
                  Lerc2Helpers.readHuffman(input, data, OutPixelTypeArray, useBSQForOutputDim);
                }
                else {
                  //console.log("Tiles");
                  Lerc2Helpers.readTiles(input, data, OutPixelTypeArray, useBSQForOutputDim);
                }
              }
              else { //lerc2.x non-8 bit data
                //console.log("Tiles");
                Lerc2Helpers.readTiles(input, data, OutPixelTypeArray, useBSQForOutputDim);
              }
            }
          }
        }

        data.eofOffset = data.ptr;
        var diff;
        if (options.inputOffset) {
          diff = data.headerInfo.blobSize + options.inputOffset - data.ptr;
          if (Math.abs(diff) >= 1) {
            //console.debug("incorrect eof: dataptr " + data.ptr + " offset " + options.inputOffset + " blobsize " + data.headerInfo.blobSize + " diff: " + diff);
            data.eofOffset = options.inputOffset + data.headerInfo.blobSize;
          }
        }
        else {
          diff = data.headerInfo.blobSize - data.ptr;
          if (Math.abs(diff) >= 1) {
            //console.debug("incorrect first band eof: dataptr " + data.ptr + " blobsize " + data.headerInfo.blobSize + " diff: " + diff);
            data.eofOffset = data.headerInfo.blobSize;
          }
        }

        var result = {
          width: headerInfo.width,
          height: headerInfo.height,
          pixelData: data.pixels.resultPixels,
          minValue: headerInfo.zMin,
          maxValue: headerInfo.zMax,
          validPixelCount: headerInfo.numValidPixel,
          dimCount: headerInfo.numDims,
          dimStats: {
            minValues: headerInfo.minValues,
            maxValues: headerInfo.maxValues
          },
          maskData: data.pixels.resultMask
          //noDataValue: noDataValue
        };

        //we should remove this if there's no existing client
        //optional noDataValue processing, it's user's responsiblity
        if (data.pixels.resultMask && Lerc2Helpers.isValidPixelValue(headerInfo.imageType, noDataValue)) {
          var mask = data.pixels.resultMask;
          for (i = 0; i < numPixels; i++) {
            if (!mask[i]) {
              result.pixelData[i] = noDataValue;
            }
          }
          result.noDataValue = noDataValue;
        }
        data.noDataValue = noDataValue;
        if (options.returnFileInfo) {
          result.fileInfo = Lerc2Helpers.formatFileInfo(data);
        }
        return result;
      },

      getBandCount: function(/*byte array*/ input) {
        var count = 0;
        var i = 0;
        var temp = {};
        temp.ptr = 0;
        temp.pixels = {};
        while (i < input.byteLength - 58) {
          Lerc2Helpers.readHeaderInfo(input, temp);
          i += temp.headerInfo.blobSize;
          count++;
          temp.ptr = i;
        }
        return count;
      }
    };

    return Lerc2Decode;
  })();

  var isPlatformLittleEndian = (function() {
    var a = new ArrayBuffer(4);
    var b = new Uint8Array(a);
    var c = new Uint32Array(a);
    c[0] = 1;
    return b[0] === 1;
  })();

  var Lerc = {
    /************wrapper**********************************************/
    /**
     * A wrapper for decoding both LERC1 and LERC2 byte streams capable of handling multiband pixel blocks for various pixel types.
     *
     * @alias module:Lerc
     * @param {ArrayBuffer} input The LERC input byte stream
     * @param {object} [options] The decoding options below are optional.
     * @param {number} [options.inputOffset] The number of bytes to skip in the input byte stream. A valid Lerc file is expected at that position.
     * @param {string} [options.pixelType] (LERC1 only) Default value is F32. Valid pixel types for input are U8/S8/S16/U16/S32/U32/F32.
     * @param {number} [options.noDataValue] (LERC1 only). It is recommended to use the returned mask instead of setting this value.
     * @param {boolean} [options.returnPixelInterleavedDims] (nDim LERC2 only) If true, returned dimensions are pixel-interleaved, a.k.a [p1_dim0, p1_dim1, p1_dimn, p2_dim0...], default is [p1_dim0, p2_dim0, ..., p1_dim1, p2_dim1...]
     * @returns {{width, height, pixels, pixelType, mask, statistics}}
       * @property {number} width Width of decoded image.
       * @property {number} height Height of decoded image.
       * @property {array} pixels [band1, band2, â¦] Each band is a typed array of width*height.
       * @property {string} pixelType The type of pixels represented in the output.
       * @property {mask} mask Typed array with a size of width*height, or null if all pixels are valid.
       * @property {array} statistics [statistics_band1, statistics_band2, â¦] Each element is a statistics object representing min and max values
    **/
    decode: function(encodedData, options) {
      if (!isPlatformLittleEndian) {
        throw "Big endian system is not supported.";
      }
      options = options || {};
      var inputOffset = options.inputOffset || 0;
      var fileIdView = new Uint8Array(encodedData, inputOffset, 10);
      var fileIdentifierString = String.fromCharCode.apply(null, fileIdView);
      var lerc, majorVersion;
      if (fileIdentifierString.trim() === "CntZImage") {
        lerc = LercDecode;
        majorVersion = 1;
      }
      else if (fileIdentifierString.substring(0, 5) === "Lerc2") {
        lerc = Lerc2Decode;
        majorVersion = 2;
      }
      else {
        throw "Unexpected file identifier string: " + fileIdentifierString;
      }

      var iPlane = 0, eof = encodedData.byteLength - 10, encodedMaskData, bandMasks = [], bandMask, maskData;
      var decodedPixelBlock = {
        width: 0,
        height: 0,
        pixels: [],
        pixelType: options.pixelType,
        mask: null,
        statistics: []
      };
      var uniqueBandMaskCount = 0;

      while (inputOffset < eof) {
        var result = lerc.decode(encodedData, {
          inputOffset: inputOffset,//for both lerc1 and lerc2
          encodedMaskData: encodedMaskData,//lerc1 only
          maskData: maskData,//lerc2 only
          returnMask: iPlane === 0 ? true : false,//lerc1 only
          returnEncodedMask: iPlane === 0 ? true : false,//lerc1 only
          returnFileInfo: true,//for both lerc1 and lerc2
          returnPixelInterleavedDims: options.returnPixelInterleavedDims,//for ndim lerc2 only
          pixelType: options.pixelType || null,//lerc1 only
          noDataValue: options.noDataValue || null//lerc1 only
        });

        inputOffset = result.fileInfo.eofOffset;
        maskData = result.maskData;//lerc2
        if (iPlane === 0) {
          encodedMaskData = result.encodedMaskData;//lerc1
          decodedPixelBlock.width = result.width;
          decodedPixelBlock.height = result.height;
          decodedPixelBlock.dimCount = result.dimCount || 1;
          //decodedPixelBlock.dimStats = decodedPixelBlock.dimStats;
          decodedPixelBlock.pixelType = result.pixelType || result.fileInfo.pixelType;
          decodedPixelBlock.mask = maskData;
        }
        if (majorVersion > 1) {
          if (maskData) {
            bandMasks.push(maskData);
          }
          if (result.fileInfo.mask && result.fileInfo.mask.numBytes > 0) {
            uniqueBandMaskCount++;
          }
        }

        iPlane++;
        decodedPixelBlock.pixels.push(result.pixelData);
        decodedPixelBlock.statistics.push({
          minValue: result.minValue,
          maxValue: result.maxValue,
          noDataValue: result.noDataValue,
          dimStats: result.dimStats
        });
      }
      var i, j, numPixels;
      if (majorVersion > 1 && uniqueBandMaskCount > 1) {
        numPixels = decodedPixelBlock.width * decodedPixelBlock.height;
        decodedPixelBlock.bandMasks = bandMasks;
        maskData = new Uint8Array(numPixels);
        maskData.set(bandMasks[0]);
        for (i = 1; i < bandMasks.length; i++) {
          bandMask = bandMasks[i];
          for (j = 0; j < numPixels; j++) {
            maskData[j] = maskData[j] & bandMask[j];
          }
        }
        decodedPixelBlock.maskData = maskData;
      }

      return decodedPixelBlock;
    }
  };

  if (true) {/* jshint ignore:line */
    //amd loaders such as dojo and requireJS
    //http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() { return Lerc; }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));/* jshint ignore:line */
  }
  else {}

})();


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfZ2VvdGlmZl9zcmNfY29tcHJlc3Npb25fbGVyY19qcy5idW5kbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQ1A7QUFDZ0I7QUFDd0I7O0FBRWpELDBCQUEwQixvREFBVztBQUNwRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdURBQXVELG1FQUE2QjtBQUNwRjs7QUFFQTtBQUNBO0FBQ0EsV0FBVyw2REFBdUI7QUFDbEM7QUFDQSxXQUFXLGdFQUEwQjtBQUNyQyxpQkFBaUIsNkNBQU8saUNBQWlDO0FBQ3pEO0FBQ0E7QUFDQSxzRkFBc0Ysb0JBQW9CO0FBQzFHOztBQUVBLHVCQUF1QixrREFBVyxXQUFXLDREQUE0RDtBQUN6RztBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM5QkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkZBQTZGOztBQUU3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsNERBQTREOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLHNCQUFzQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pELDZCQUE2QixxQkFBcUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pELDZCQUE2QixxQkFBcUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLGNBQWM7QUFDZDtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJCQUEyQjtBQUN0RCw2QkFBNkIsMkJBQTJCOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLGNBQWM7QUFDZCxxREFBcUQ7QUFDckQsY0FBYztBQUNkLHVEQUF1RDtBQUN2RCxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RCxnQkFBZ0I7QUFDaEIsbUVBQW1FO0FBQ25FLGdCQUFnQjtBQUNoQixtRUFBbUU7QUFDbkUsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLGNBQWM7QUFDZDtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZUFBZTtBQUN6QztBQUNBO0FBQ0EsOEJBQThCLGFBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGVBQWU7QUFDekM7QUFDQTtBQUNBLDhCQUE4QixhQUFhO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxPQUFPOztBQUVQO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qjs7QUFFQSxxQkFBcUIsUUFBUTtBQUM3Qix3Q0FBd0M7QUFDeEMsMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0Isd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnQkFBZ0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsU0FBUztBQUMxQyw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdCQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFLGlDQUFpQyxZQUFZO0FBQzdDLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBLGlDQUFpQyxpQkFBaUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsaUNBQWlDLFlBQVk7QUFDN0MsNEJBQTRCLFdBQVc7QUFDdkM7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxtQ0FBbUMsaUJBQWlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixZQUFZO0FBQ3pDLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQSwrQkFBK0IsZ0JBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsaUJBQWlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQsWUFBWTtBQUNaLDBEQUEwRDtBQUMxRCxZQUFZO0FBQ1osMERBQTBEO0FBQzFELFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscUJBQXFCO0FBQzlDO0FBQ0EsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0Esa0NBQWtDLHVCQUF1QjtBQUN6RCxvQ0FBb0Msc0JBQXNCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsdUJBQXVCO0FBQ3pELG9DQUFvQyxzQkFBc0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsdUJBQXVCO0FBQ3ZELGtDQUFrQyxzQkFBc0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixnQ0FBZ0MsdUJBQXVCO0FBQ3ZELGtDQUFrQyxzQkFBc0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsdUJBQXVCO0FBQ3pELG9DQUFvQyxzQkFBc0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHVCQUF1QjtBQUN6RCxvQ0FBb0Msc0JBQXNCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHVCQUF1QjtBQUMzRCxzQ0FBc0Msc0JBQXNCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx1QkFBdUI7QUFDM0Qsc0NBQXNDLHNCQUFzQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHVCQUF1QjtBQUN6RCxvQ0FBb0Msc0JBQXNCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx1QkFBdUI7QUFDekQsb0NBQW9DLHNCQUFzQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGVBQWU7QUFDekM7QUFDQTtBQUNBLDhCQUE4QixhQUFhO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZUFBZTtBQUN6QztBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QztBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTSxJQUEwQyxHQUFHO0FBQ25EO0FBQ0E7QUFDQSxJQUFJLGlDQUFPLEVBQUUsbUNBQUUsYUFBYSxjQUFjO0FBQUEsa0dBQUMsQ0FBQztBQUM1QztBQUNBLE9BQU8sRUFRSjs7QUFFSCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFwc2J1bmRsZS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL3NyYy9jb21wcmVzc2lvbi9sZXJjLmpzIiwid2VicGFjazovL21hcHNidW5kbGUvLi9ub2RlX21vZHVsZXMvbGVyYy9MZXJjRGVjb2RlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGluZmxhdGUgfSBmcm9tICdwYWtvJztcbmltcG9ydCBMZXJjIGZyb20gJ2xlcmMnO1xuaW1wb3J0IEJhc2VEZWNvZGVyIGZyb20gJy4vYmFzZWRlY29kZXInO1xuaW1wb3J0IHsgTGVyY1BhcmFtZXRlcnMsIExlcmNBZGRDb21wcmVzc2lvbiB9IGZyb20gJy4uL2dsb2JhbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMZXJjRGVjb2RlciBleHRlbmRzIEJhc2VEZWNvZGVyIHtcbiAgY29uc3RydWN0b3IoZmlsZURpcmVjdG9yeSkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLnBsYW5hckNvbmZpZ3VyYXRpb24gPSB0eXBlb2YgZmlsZURpcmVjdG9yeS5QbGFuYXJDb25maWd1cmF0aW9uICE9PSAndW5kZWZpbmVkJyA/IGZpbGVEaXJlY3RvcnkuUGxhbmFyQ29uZmlndXJhdGlvbiA6IDE7XG4gICAgdGhpcy5zYW1wbGVzUGVyUGl4ZWwgPSB0eXBlb2YgZmlsZURpcmVjdG9yeS5TYW1wbGVzUGVyUGl4ZWwgIT09ICd1bmRlZmluZWQnID8gZmlsZURpcmVjdG9yeS5TYW1wbGVzUGVyUGl4ZWwgOiAxO1xuXG4gICAgdGhpcy5hZGRDb21wcmVzc2lvbiA9IGZpbGVEaXJlY3RvcnkuTGVyY1BhcmFtZXRlcnNbTGVyY1BhcmFtZXRlcnMuQWRkQ29tcHJlc3Npb25dO1xuICB9XG5cbiAgZGVjb2RlQmxvY2soYnVmZmVyKSB7XG4gICAgc3dpdGNoICh0aGlzLmFkZENvbXByZXNzaW9uKSB7XG4gICAgICBjYXNlIExlcmNBZGRDb21wcmVzc2lvbi5Ob25lOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTGVyY0FkZENvbXByZXNzaW9uLkRlZmxhdGU6XG4gICAgICAgIGJ1ZmZlciA9IGluZmxhdGUobmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSkuYnVmZmVyOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduLCBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgTEVSQyBhZGRpdGlvbmFsIGNvbXByZXNzaW9uIG1ldGhvZCBpZGVudGlmaWVyOiAke3RoaXMuYWRkQ29tcHJlc3Npb259YCk7XG4gICAgfVxuXG4gICAgY29uc3QgbGVyY1Jlc3VsdCA9IExlcmMuZGVjb2RlKGJ1ZmZlciwgeyByZXR1cm5QaXhlbEludGVybGVhdmVkRGltczogdGhpcy5wbGFuYXJDb25maWd1cmF0aW9uID09PSAxIH0pO1xuICAgIGNvbnN0IGxlcmNEYXRhID0gbGVyY1Jlc3VsdC5waXhlbHNbMF07XG4gICAgcmV0dXJuIGxlcmNEYXRhLmJ1ZmZlcjtcbiAgfVxufVxuIiwi77u/LyoganNoaW50IGZvcmluOiBmYWxzZSwgYml0d2lzZTogZmFsc2UgKi9cbi8qXG5Db3B5cmlnaHQgMjAxNS0yMDIxIEVzcmlcblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG5odHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuQSBjb3B5IG9mIHRoZSBsaWNlbnNlIGFuZCBhZGRpdGlvbmFsIG5vdGljZXMgYXJlIGxvY2F0ZWQgd2l0aCB0aGVcbnNvdXJjZSBkaXN0cmlidXRpb24gYXQ6XG5cbmh0dHA6Ly9naXRodWIuY29tL0VzcmkvbGVyYy9cblxuQ29udHJpYnV0b3JzOiAgSm9oYW5uZXMgU2NobWlkLCAoTEVSQyB2MSlcbiAgICAgICAgICAgICAgIENoYXlhbmlrYSBLaGF0dWEsIChMRVJDIHYxKVxuICAgICAgICAgICAgICAgV2VueHVlIEp1IChMRVJDIHYxLCB2Mi54KVxuKi9cblxuLyogQ29weXJpZ2h0IDIwMTUtMjAyMSBFc3JpLiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAgQHByZXNlcnZlICovXG5cbi8qKlxuICogYSBtb2R1bGUgZm9yIGRlY29kaW5nIExFUkMgYmxvYnNcbiAqIEBtb2R1bGUgTGVyY1xuICovXG4oZnVuY3Rpb24oKSB7XG4gIC8vdGhpcyBkZWNvZGVyIHN1cHBvcnRzIGFsbCBsZXJjIHZlcnNpb25zLCBlYWNoIHZlcnNpb24gaGFzIGl0cyBvd24gY2xhc3MgKExlcmNEZWNvZGUgYW5kIExlcmMyRGVjb2RlKS4gXG4gIC8vdGhlIGV4cG9ydGVkIG1vZHVsZSBoYW5kbGVzIGZvcm1hdCB2YXJpYXRpb24gYXV0b2FtdGljYWxseS5cblxuICAvL3RoZSBvcmlnaW5hbCBMZXJjRGVjb2RlIGZvciBWZXJzaW9uIDFcbiAgdmFyIExlcmNEZWNvZGUgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAvLyBOb3RlOiBjdXJyZW50bHksIHRoaXMgbW9kdWxlIG9ubHkgaGFzIGFuIGltcGxlbWVudGF0aW9uIGZvciBkZWNvZGluZyBMRVJDIGRhdGEsIG5vdCBlbmNvZGluZy4gVGhlIG5hbWUgb2ZcbiAgICAvLyB0aGUgY2xhc3Mgd2FzIGNob3NlbiB0byBiZSBmdXR1cmUgcHJvb2YuXG5cbiAgICB2YXIgQ250WkltYWdlID0ge307XG5cbiAgICBDbnRaSW1hZ2UuZGVmYXVsdE5vRGF0YVZhbHVlID0gLTMuNDAyNzk5OTM4NzkwMTQ4NGUrMzg7IC8vIHNtYWxsZXN0IEZsb2F0MzIgdmFsdWVcblxuICAgIC8qKlxuICAgICAqIERlY29kZSBhIExFUkMgYnl0ZSBzdHJlYW0gYW5kIHJldHVybiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgcGl4ZWwgZGF0YSBhbmQgc29tZSByZXF1aXJlZCBhbmQgb3B0aW9uYWxcbiAgICAgKiBpbmZvcm1hdGlvbiBhYm91dCBpdCwgc3VjaCBhcyB0aGUgaW1hZ2UncyB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gaW5wdXQgVGhlIExFUkMgaW5wdXQgYnl0ZSBzdHJlYW1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIERlY29kaW5nIG9wdGlvbnMsIGNvbnRhaW5pbmcgYW55IG9mIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgKiBAY29uZmlnIHtudW1iZXJ9IFtpbnB1dE9mZnNldCA9IDBdXG4gICAgICogICAgICAgIFNraXAgdGhlIGZpcnN0IGlucHV0T2Zmc2V0IGJ5dGVzIG9mIHRoZSBpbnB1dCBieXRlIHN0cmVhbS4gQSB2YWxpZCBMRVJDIGZpbGUgaXMgZXhwZWN0ZWQgYXQgdGhhdCBwb3NpdGlvbi5cbiAgICAgKiBAY29uZmlnIHtVaW50OEFycmF5fSBbZW5jb2RlZE1hc2sgPSBudWxsXVxuICAgICAqICAgICAgICBJZiBzcGVjaWZpZWQsIHRoZSBkZWNvZGVyIHdpbGwgbm90IHJlYWQgbWFzayBpbmZvcm1hdGlvbiBmcm9tIHRoZSBpbnB1dCBhbmQgdXNlIHRoZSBzcGVjaWZpZWQgZW5jb2RlZFxuICAgICAqICAgICAgICBtYXNrIGRhdGEgaW5zdGVhZC4gTWFzayBoZWFkZXIvZGF0YSBtdXN0IG5vdCBiZSBwcmVzZW50IGluIHRoZSBMRVJDIGJ5dGUgc3RyZWFtIGluIHRoaXMgY2FzZS5cbiAgICAgKiBAY29uZmlnIHtudW1iZXJ9IFtub0RhdGFWYWx1ZSA9IExlcmNDb2RlLmRlZmF1bHROb0RhdGFWYWx1ZV1cbiAgICAgKiAgICAgICAgUGl4ZWwgdmFsdWUgdG8gdXNlIGZvciBtYXNrZWQgcGl4ZWxzLlxuICAgICAqIEBjb25maWcge0FycmF5QnVmZmVyVmlld3xBcnJheX0gW3BpeGVsVHlwZSA9IEZsb2F0MzJBcnJheV1cbiAgICAgKiAgICAgICAgVGhlIGRlc2lyZWQgdHlwZSBvZiB0aGUgcGl4ZWxEYXRhIGFycmF5IGluIHRoZSByZXR1cm4gdmFsdWUuIE5vdGUgdGhhdCBpdCBpcyB0aGUgY2FsbGVyJ3MgcmVzcG9uc2liaWxpdHkgdG9cbiAgICAgKiAgICAgICAgcHJvdmlkZSBhbiBhcHByb3ByaWF0ZSBub0RhdGFWYWx1ZSBpZiB0aGUgZGVmYXVsdCBwaXhlbFR5cGUgaXMgb3ZlcnJpZGRlbi5cbiAgICAgKiBAY29uZmlnIHtib29sZWFufSBbcmV0dXJuTWFzayA9IGZhbHNlXVxuICAgICAqICAgICAgICBJZiB0cnVlLCB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgY29udGFpbiBhIG1hc2tEYXRhIHByb3BlcnR5IG9mIHR5cGUgVWludDhBcnJheSB3aGljaCBoYXMgb25lIGVsZW1lbnQgcGVyXG4gICAgICogICAgICAgIHBpeGVsLCB0aGUgdmFsdWUgb2Ygd2hpY2ggaXMgMSBvciAwIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoYXQgcGl4ZWwncyBkYXRhIGlzIHByZXNlbnQgb3IgbWFza2VkLiBJZiB0aGVcbiAgICAgKiAgICAgICAgaW5wdXQgTEVSQyBkYXRhIGRvZXMgbm90IGNvbnRhaW4gYSBtYXNrLCBtYXNrRGF0YSB3aWxsIG5vdCBiZSByZXR1cm5lZC5cbiAgICAgKiBAY29uZmlnIHtib29sZWFufSBbcmV0dXJuRW5jb2RlZE1hc2sgPSBmYWxzZV1cbiAgICAgKiAgICAgICAgSWYgdHJ1ZSwgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGNvbnRhaW4gYSBlbmNvZGVkTWFza0RhdGEgcHJvcGVydHksIHdoaWNoIGNhbiBiZSBwYXNzZWQgaW50byBlbmNvZGUoKSBhc1xuICAgICAqICAgICAgICBlbmNvZGVkTWFzay5cbiAgICAgKiBAY29uZmlnIHtib29sZWFufSBbcmV0dXJuRmlsZUluZm8gPSBmYWxzZV1cbiAgICAgKiAgICAgICAgSWYgdHJ1ZSwgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGhhdmUgYSBmaWxlSW5mbyBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zIG1ldGFkYXRhIG9idGFpbmVkIGZyb20gdGhlXG4gICAgICogICAgICAgIExFUkMgaGVhZGVycyBhbmQgdGhlIGRlY29kaW5nIHByb2Nlc3MuXG4gICAgICogQGNvbmZpZyB7Ym9vbGVhbn0gW2NvbXB1dGVVc2VkQml0RGVwdGhzID0gZmFsc2VdXG4gICAgICogICAgICAgIElmIHRydWUsIHRoZSBmaWxlSW5mbyBwcm9wZXJ0eSBpbiB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgY29udGFpbiB0aGUgc2V0IG9mIGFsbCBibG9jayBiaXQgZGVwdGhzXG4gICAgICogICAgICAgIGVuY291bnRlcmVkIGR1cmluZyBkZWNvZGluZy4gV2lsbCBvbmx5IGhhdmUgYW4gZWZmZWN0IGlmIHJldHVybkZpbGVJbmZvIG9wdGlvbiBpcyB0cnVlLlxuICAgICAqIEByZXR1cm5zIHt7d2lkdGgsIGhlaWdodCwgcGl4ZWxEYXRhLCBtaW5WYWx1ZSwgbWF4VmFsdWUsIG5vRGF0YVZhbHVlLCBtYXNrRGF0YSwgZW5jb2RlZE1hc2tEYXRhLCBmaWxlSW5mb319XG4gICAgICovXG4gICAgQ250WkltYWdlLmRlY29kZSA9IGZ1bmN0aW9uKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgdmFyIHNraXBNYXNrID0gb3B0aW9ucy5lbmNvZGVkTWFza0RhdGEgfHwgKG9wdGlvbnMuZW5jb2RlZE1hc2tEYXRhID09PSBudWxsKTtcbiAgICAgIHZhciBwYXJzZWREYXRhID0gcGFyc2UoaW5wdXQsIG9wdGlvbnMuaW5wdXRPZmZzZXQgfHwgMCwgc2tpcE1hc2spO1xuXG4gICAgICB2YXIgbm9EYXRhVmFsdWUgPSAob3B0aW9ucy5ub0RhdGFWYWx1ZSAhPT0gbnVsbCkgPyBvcHRpb25zLm5vRGF0YVZhbHVlIDogQ250WkltYWdlLmRlZmF1bHROb0RhdGFWYWx1ZTtcblxuICAgICAgdmFyIHVuY29tcHJlc3NlZERhdGEgPSB1bmNvbXByZXNzUGl4ZWxWYWx1ZXMocGFyc2VkRGF0YSwgb3B0aW9ucy5waXhlbFR5cGUgfHwgRmxvYXQzMkFycmF5LFxuICAgICAgICBvcHRpb25zLmVuY29kZWRNYXNrRGF0YSwgbm9EYXRhVmFsdWUsIG9wdGlvbnMucmV0dXJuTWFzayk7XG5cbiAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIHdpZHRoOiBwYXJzZWREYXRhLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHBhcnNlZERhdGEuaGVpZ2h0LFxuICAgICAgICBwaXhlbERhdGE6IHVuY29tcHJlc3NlZERhdGEucmVzdWx0UGl4ZWxzLFxuICAgICAgICBtaW5WYWx1ZTogdW5jb21wcmVzc2VkRGF0YS5taW5WYWx1ZSxcbiAgICAgICAgbWF4VmFsdWU6IHBhcnNlZERhdGEucGl4ZWxzLm1heFZhbHVlLFxuICAgICAgICBub0RhdGFWYWx1ZTogbm9EYXRhVmFsdWVcbiAgICAgIH07XG5cbiAgICAgIGlmICh1bmNvbXByZXNzZWREYXRhLnJlc3VsdE1hc2spIHtcbiAgICAgICAgcmVzdWx0Lm1hc2tEYXRhID0gdW5jb21wcmVzc2VkRGF0YS5yZXN1bHRNYXNrO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5yZXR1cm5FbmNvZGVkTWFzayAmJiBwYXJzZWREYXRhLm1hc2spIHtcbiAgICAgICAgcmVzdWx0LmVuY29kZWRNYXNrRGF0YSA9IHBhcnNlZERhdGEubWFzay5iaXRzZXQgPyBwYXJzZWREYXRhLm1hc2suYml0c2V0IDogbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMucmV0dXJuRmlsZUluZm8pIHtcbiAgICAgICAgcmVzdWx0LmZpbGVJbmZvID0gZm9ybWF0RmlsZUluZm8ocGFyc2VkRGF0YSk7XG4gICAgICAgIGlmIChvcHRpb25zLmNvbXB1dGVVc2VkQml0RGVwdGhzKSB7XG4gICAgICAgICAgcmVzdWx0LmZpbGVJbmZvLmJpdERlcHRocyA9IGNvbXB1dGVVc2VkQml0RGVwdGhzKHBhcnNlZERhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHZhciB1bmNvbXByZXNzUGl4ZWxWYWx1ZXMgPSBmdW5jdGlvbihkYXRhLCBUeXBlZEFycmF5Q2xhc3MsIG1hc2tCaXRzZXQsIG5vRGF0YVZhbHVlLCBzdG9yZURlY29kZWRNYXNrKSB7XG4gICAgICB2YXIgYmxvY2tJZHggPSAwO1xuICAgICAgdmFyIG51bVggPSBkYXRhLnBpeGVscy5udW1CbG9ja3NYO1xuICAgICAgdmFyIG51bVkgPSBkYXRhLnBpeGVscy5udW1CbG9ja3NZO1xuICAgICAgdmFyIGJsb2NrV2lkdGggPSBNYXRoLmZsb29yKGRhdGEud2lkdGggLyBudW1YKTtcbiAgICAgIHZhciBibG9ja0hlaWdodCA9IE1hdGguZmxvb3IoZGF0YS5oZWlnaHQgLyBudW1ZKTtcbiAgICAgIHZhciBzY2FsZSA9IDIgKiBkYXRhLm1heFpFcnJvcjtcbiAgICAgIHZhciBtaW5WYWx1ZSA9IE51bWJlci5NQVhfVkFMVUUsIGN1cnJlbnRWYWx1ZTtcbiAgICAgIG1hc2tCaXRzZXQgPSBtYXNrQml0c2V0IHx8ICgoZGF0YS5tYXNrKSA/IGRhdGEubWFzay5iaXRzZXQgOiBudWxsKTtcblxuICAgICAgdmFyIHJlc3VsdFBpeGVscywgcmVzdWx0TWFzaztcbiAgICAgIHJlc3VsdFBpeGVscyA9IG5ldyBUeXBlZEFycmF5Q2xhc3MoZGF0YS53aWR0aCAqIGRhdGEuaGVpZ2h0KTtcbiAgICAgIGlmIChzdG9yZURlY29kZWRNYXNrICYmIG1hc2tCaXRzZXQpIHtcbiAgICAgICAgcmVzdWx0TWFzayA9IG5ldyBVaW50OEFycmF5KGRhdGEud2lkdGggKiBkYXRhLmhlaWdodCk7XG4gICAgICB9XG4gICAgICB2YXIgYmxvY2tEYXRhQnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShibG9ja1dpZHRoICogYmxvY2tIZWlnaHQpO1xuXG4gICAgICB2YXIgeHgsIHl5O1xuICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPD0gbnVtWTsgeSsrKSB7XG4gICAgICAgIHZhciB0aGlzQmxvY2tIZWlnaHQgPSAoeSAhPT0gbnVtWSkgPyBibG9ja0hlaWdodCA6IChkYXRhLmhlaWdodCAlIG51bVkpO1xuICAgICAgICBpZiAodGhpc0Jsb2NrSGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPD0gbnVtWDsgeCsrKSB7XG4gICAgICAgICAgdmFyIHRoaXNCbG9ja1dpZHRoID0gKHggIT09IG51bVgpID8gYmxvY2tXaWR0aCA6IChkYXRhLndpZHRoICUgbnVtWCk7XG4gICAgICAgICAgaWYgKHRoaXNCbG9ja1dpZHRoID09PSAwKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgb3V0UHRyID0geSAqIGRhdGEud2lkdGggKiBibG9ja0hlaWdodCArIHggKiBibG9ja1dpZHRoO1xuICAgICAgICAgIHZhciBvdXRTdHJpZGUgPSBkYXRhLndpZHRoIC0gdGhpc0Jsb2NrV2lkdGg7XG5cbiAgICAgICAgICB2YXIgYmxvY2sgPSBkYXRhLnBpeGVscy5ibG9ja3NbYmxvY2tJZHhdO1xuXG4gICAgICAgICAgdmFyIGJsb2NrRGF0YSwgYmxvY2tQdHIsIGNvbnN0VmFsdWU7XG4gICAgICAgICAgaWYgKGJsb2NrLmVuY29kaW5nIDwgMikge1xuICAgICAgICAgICAgLy8gYmxvY2sgaXMgZWl0aGVyIHVuY29tcHJlc3NlZCBvciBiaXQtc3R1ZmZlZCAoZW5jb2RpbmdzIDAgYW5kIDEpXG4gICAgICAgICAgICBpZiAoYmxvY2suZW5jb2RpbmcgPT09IDApIHtcbiAgICAgICAgICAgICAgLy8gYmxvY2sgaXMgdW5jb21wcmVzc2VkXG4gICAgICAgICAgICAgIGJsb2NrRGF0YSA9IGJsb2NrLnJhd0RhdGE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBibG9jayBpcyBiaXQtc3R1ZmZlZFxuICAgICAgICAgICAgICB1bnN0dWZmKGJsb2NrLnN0dWZmZWREYXRhLCBibG9jay5iaXRzUGVyUGl4ZWwsIGJsb2NrLm51bVZhbGlkUGl4ZWxzLCBibG9jay5vZmZzZXQsIHNjYWxlLCBibG9ja0RhdGFCdWZmZXIsIGRhdGEucGl4ZWxzLm1heFZhbHVlKTtcbiAgICAgICAgICAgICAgYmxvY2tEYXRhID0gYmxvY2tEYXRhQnVmZmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmxvY2tQdHIgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChibG9jay5lbmNvZGluZyA9PT0gMikge1xuICAgICAgICAgICAgLy8gYmxvY2sgaXMgYWxsIDBcbiAgICAgICAgICAgIGNvbnN0VmFsdWUgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGJsb2NrIGhhcyBjb25zdGFudCB2YWx1ZSAoZW5jb2RpbmcgPT09IDMpXG4gICAgICAgICAgICBjb25zdFZhbHVlID0gYmxvY2sub2Zmc2V0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBtYXNrQnl0ZTtcbiAgICAgICAgICBpZiAobWFza0JpdHNldCkge1xuICAgICAgICAgICAgZm9yICh5eSA9IDA7IHl5IDwgdGhpc0Jsb2NrSGVpZ2h0OyB5eSsrKSB7XG4gICAgICAgICAgICAgIGlmIChvdXRQdHIgJiA3KSB7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBtYXNrQnl0ZSA9IG1hc2tCaXRzZXRbb3V0UHRyID4+IDNdO1xuICAgICAgICAgICAgICAgIG1hc2tCeXRlIDw8PSBvdXRQdHIgJiA3O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAoeHggPSAwOyB4eCA8IHRoaXNCbG9ja1dpZHRoOyB4eCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEob3V0UHRyICYgNykpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHJlYWQgbmV4dCBieXRlIGZyb20gbWFza1xuICAgICAgICAgICAgICAgICAgbWFza0J5dGUgPSBtYXNrQml0c2V0W291dFB0ciA+PiAzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1hc2tCeXRlICYgMTI4KSB7XG4gICAgICAgICAgICAgICAgICAvLyBwaXhlbCBkYXRhIHByZXNlbnRcbiAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRNYXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdE1hc2tbb3V0UHRyXSA9IDE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUgPSAoYmxvY2suZW5jb2RpbmcgPCAyKSA/IGJsb2NrRGF0YVtibG9ja1B0cisrXSA6IGNvbnN0VmFsdWU7XG4gICAgICAgICAgICAgICAgICBtaW5WYWx1ZSA9IG1pblZhbHVlID4gY3VycmVudFZhbHVlID8gY3VycmVudFZhbHVlIDogbWluVmFsdWU7XG4gICAgICAgICAgICAgICAgICByZXN1bHRQaXhlbHNbb3V0UHRyKytdID0gY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBwaXhlbCBkYXRhIG5vdCBwcmVzZW50XG4gICAgICAgICAgICAgICAgICBpZiAocmVzdWx0TWFzaykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRNYXNrW291dFB0cl0gPSAwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzW291dFB0cisrXSA9IG5vRGF0YVZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXNrQnl0ZSA8PD0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvdXRQdHIgKz0gb3V0U3RyaWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBtYXNrIG5vdCBwcmVzZW50LCBzaW1wbHkgY29weSBibG9jayBvdmVyXG4gICAgICAgICAgICBpZiAoYmxvY2suZW5jb2RpbmcgPCAyKSB7XG4gICAgICAgICAgICAgIC8vIGR1cGxpY2F0aW5nIHRoaXMgY29kZSBibG9jayBmb3IgcGVyZm9ybWFuY2UgcmVhc29uc1xuICAgICAgICAgICAgICAvLyBibG9ja0RhdGEgY2FzZTpcbiAgICAgICAgICAgICAgZm9yICh5eSA9IDA7IHl5IDwgdGhpc0Jsb2NrSGVpZ2h0OyB5eSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh4eCA9IDA7IHh4IDwgdGhpc0Jsb2NrV2lkdGg7IHh4KyspIHtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IGJsb2NrRGF0YVtibG9ja1B0cisrXTtcbiAgICAgICAgICAgICAgICAgIG1pblZhbHVlID0gbWluVmFsdWUgPiBjdXJyZW50VmFsdWUgPyBjdXJyZW50VmFsdWUgOiBtaW5WYWx1ZTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1tvdXRQdHIrK10gPSBjdXJyZW50VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dFB0ciArPSBvdXRTdHJpZGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyBjb25zdFZhbHVlIGNhc2U6XG4gICAgICAgICAgICAgIG1pblZhbHVlID0gbWluVmFsdWUgPiBjb25zdFZhbHVlID8gY29uc3RWYWx1ZSA6IG1pblZhbHVlO1xuICAgICAgICAgICAgICBmb3IgKHl5ID0gMDsgeXkgPCB0aGlzQmxvY2tIZWlnaHQ7IHl5KyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHh4ID0gMDsgeHggPCB0aGlzQmxvY2tXaWR0aDsgeHgrKykge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzW291dFB0cisrXSA9IGNvbnN0VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dFB0ciArPSBvdXRTdHJpZGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKChibG9jay5lbmNvZGluZyA9PT0gMSkgJiYgKGJsb2NrUHRyICE9PSBibG9jay5udW1WYWxpZFBpeGVscykpIHtcbiAgICAgICAgICAgIHRocm93IFwiQmxvY2sgYW5kIE1hc2sgZG8gbm90IG1hdGNoXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJsb2NrSWR4Kys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0UGl4ZWxzOiByZXN1bHRQaXhlbHMsXG4gICAgICAgIHJlc3VsdE1hc2s6IHJlc3VsdE1hc2ssXG4gICAgICAgIG1pblZhbHVlOiBtaW5WYWx1ZVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGZvcm1hdEZpbGVJbmZvID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgXCJmaWxlSWRlbnRpZmllclN0cmluZ1wiOiBkYXRhLmZpbGVJZGVudGlmaWVyU3RyaW5nLFxuICAgICAgICBcImZpbGVWZXJzaW9uXCI6IGRhdGEuZmlsZVZlcnNpb24sXG4gICAgICAgIFwiaW1hZ2VUeXBlXCI6IGRhdGEuaW1hZ2VUeXBlLFxuICAgICAgICBcImhlaWdodFwiOiBkYXRhLmhlaWdodCxcbiAgICAgICAgXCJ3aWR0aFwiOiBkYXRhLndpZHRoLFxuICAgICAgICBcIm1heFpFcnJvclwiOiBkYXRhLm1heFpFcnJvcixcbiAgICAgICAgXCJlb2ZPZmZzZXRcIjogZGF0YS5lb2ZPZmZzZXQsXG4gICAgICAgIFwibWFza1wiOiBkYXRhLm1hc2sgPyB7XG4gICAgICAgICAgXCJudW1CbG9ja3NYXCI6IGRhdGEubWFzay5udW1CbG9ja3NYLFxuICAgICAgICAgIFwibnVtQmxvY2tzWVwiOiBkYXRhLm1hc2subnVtQmxvY2tzWSxcbiAgICAgICAgICBcIm51bUJ5dGVzXCI6IGRhdGEubWFzay5udW1CeXRlcyxcbiAgICAgICAgICBcIm1heFZhbHVlXCI6IGRhdGEubWFzay5tYXhWYWx1ZVxuICAgICAgICB9IDogbnVsbCxcbiAgICAgICAgXCJwaXhlbHNcIjoge1xuICAgICAgICAgIFwibnVtQmxvY2tzWFwiOiBkYXRhLnBpeGVscy5udW1CbG9ja3NYLFxuICAgICAgICAgIFwibnVtQmxvY2tzWVwiOiBkYXRhLnBpeGVscy5udW1CbG9ja3NZLFxuICAgICAgICAgIFwibnVtQnl0ZXNcIjogZGF0YS5waXhlbHMubnVtQnl0ZXMsXG4gICAgICAgICAgXCJtYXhWYWx1ZVwiOiBkYXRhLnBpeGVscy5tYXhWYWx1ZSxcbiAgICAgICAgICBcIm5vRGF0YVZhbHVlXCI6IGRhdGEubm9EYXRhVmFsdWVcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNvbXB1dGVVc2VkQml0RGVwdGhzID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdmFyIG51bUJsb2NrcyA9IGRhdGEucGl4ZWxzLm51bUJsb2Nrc1ggKiBkYXRhLnBpeGVscy5udW1CbG9ja3NZO1xuICAgICAgdmFyIGJpdERlcHRocyA9IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1CbG9ja3M7IGkrKykge1xuICAgICAgICB2YXIgYmxvY2sgPSBkYXRhLnBpeGVscy5ibG9ja3NbaV07XG4gICAgICAgIGlmIChibG9jay5lbmNvZGluZyA9PT0gMCkge1xuICAgICAgICAgIGJpdERlcHRocy5mbG9hdDMyID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChibG9jay5lbmNvZGluZyA9PT0gMSkge1xuICAgICAgICAgIGJpdERlcHRoc1tibG9jay5iaXRzUGVyUGl4ZWxdID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBiaXREZXB0aHNbMF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhiaXREZXB0aHMpO1xuICAgIH07XG5cbiAgICB2YXIgcGFyc2UgPSBmdW5jdGlvbihpbnB1dCwgZnAsIHNraXBNYXNrKSB7XG4gICAgICB2YXIgZGF0YSA9IHt9O1xuXG4gICAgICAvLyBGaWxlIGhlYWRlclxuICAgICAgdmFyIGZpbGVJZFZpZXcgPSBuZXcgVWludDhBcnJheShpbnB1dCwgZnAsIDEwKTtcbiAgICAgIGRhdGEuZmlsZUlkZW50aWZpZXJTdHJpbmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGZpbGVJZFZpZXcpO1xuICAgICAgaWYgKGRhdGEuZmlsZUlkZW50aWZpZXJTdHJpbmcudHJpbSgpICE9PSBcIkNudFpJbWFnZVwiKSB7XG4gICAgICAgIHRocm93IFwiVW5leHBlY3RlZCBmaWxlIGlkZW50aWZpZXIgc3RyaW5nOiBcIiArIGRhdGEuZmlsZUlkZW50aWZpZXJTdHJpbmc7XG4gICAgICB9XG4gICAgICBmcCArPSAxMDtcbiAgICAgIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KGlucHV0LCBmcCwgMjQpO1xuICAgICAgZGF0YS5maWxlVmVyc2lvbiA9IHZpZXcuZ2V0SW50MzIoMCwgdHJ1ZSk7XG4gICAgICBkYXRhLmltYWdlVHlwZSA9IHZpZXcuZ2V0SW50MzIoNCwgdHJ1ZSk7XG4gICAgICBkYXRhLmhlaWdodCA9IHZpZXcuZ2V0VWludDMyKDgsIHRydWUpO1xuICAgICAgZGF0YS53aWR0aCA9IHZpZXcuZ2V0VWludDMyKDEyLCB0cnVlKTtcbiAgICAgIGRhdGEubWF4WkVycm9yID0gdmlldy5nZXRGbG9hdDY0KDE2LCB0cnVlKTtcbiAgICAgIGZwICs9IDI0O1xuXG4gICAgICAvLyBNYXNrIEhlYWRlclxuICAgICAgaWYgKCFza2lwTWFzaykge1xuICAgICAgICB2aWV3ID0gbmV3IERhdGFWaWV3KGlucHV0LCBmcCwgMTYpO1xuICAgICAgICBkYXRhLm1hc2sgPSB7fTtcbiAgICAgICAgZGF0YS5tYXNrLm51bUJsb2Nrc1kgPSB2aWV3LmdldFVpbnQzMigwLCB0cnVlKTtcbiAgICAgICAgZGF0YS5tYXNrLm51bUJsb2Nrc1ggPSB2aWV3LmdldFVpbnQzMig0LCB0cnVlKTtcbiAgICAgICAgZGF0YS5tYXNrLm51bUJ5dGVzID0gdmlldy5nZXRVaW50MzIoOCwgdHJ1ZSk7XG4gICAgICAgIGRhdGEubWFzay5tYXhWYWx1ZSA9IHZpZXcuZ2V0RmxvYXQzMigxMiwgdHJ1ZSk7XG4gICAgICAgIGZwICs9IDE2O1xuXG4gICAgICAgIC8vIE1hc2sgRGF0YVxuICAgICAgICBpZiAoZGF0YS5tYXNrLm51bUJ5dGVzID4gMCkge1xuICAgICAgICAgIHZhciBiaXRzZXQgPSBuZXcgVWludDhBcnJheShNYXRoLmNlaWwoZGF0YS53aWR0aCAqIGRhdGEuaGVpZ2h0IC8gOCkpO1xuICAgICAgICAgIHZpZXcgPSBuZXcgRGF0YVZpZXcoaW5wdXQsIGZwLCBkYXRhLm1hc2subnVtQnl0ZXMpO1xuICAgICAgICAgIHZhciBjbnQgPSB2aWV3LmdldEludDE2KDAsIHRydWUpO1xuICAgICAgICAgIHZhciBpcCA9IDIsIG9wID0gMDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoY250ID4gMCkge1xuICAgICAgICAgICAgICB3aGlsZSAoY250LS0pIHsgYml0c2V0W29wKytdID0gdmlldy5nZXRVaW50OChpcCsrKTsgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHZhbCA9IHZpZXcuZ2V0VWludDgoaXArKyk7XG4gICAgICAgICAgICAgIGNudCA9IC1jbnQ7XG4gICAgICAgICAgICAgIHdoaWxlIChjbnQtLSkgeyBiaXRzZXRbb3ArK10gPSB2YWw7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNudCA9IHZpZXcuZ2V0SW50MTYoaXAsIHRydWUpO1xuICAgICAgICAgICAgaXAgKz0gMjtcbiAgICAgICAgICB9IHdoaWxlIChpcCA8IGRhdGEubWFzay5udW1CeXRlcyk7XG4gICAgICAgICAgaWYgKChjbnQgIT09IC0zMjc2OCkgfHwgKG9wIDwgYml0c2V0Lmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHRocm93IFwiVW5leHBlY3RlZCBlbmQgb2YgbWFzayBSTEUgZW5jb2RpbmdcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YS5tYXNrLmJpdHNldCA9IGJpdHNldDtcbiAgICAgICAgICBmcCArPSBkYXRhLm1hc2subnVtQnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGRhdGEubWFzay5udW1CeXRlcyB8IGRhdGEubWFzay5udW1CbG9ja3NZIHwgZGF0YS5tYXNrLm1heFZhbHVlKSA9PT0gMCkgeyAgLy8gU3BlY2lhbCBjYXNlLCBhbGwgbm9kYXRhXG4gICAgICAgICAgZGF0YS5tYXNrLmJpdHNldCA9IG5ldyBVaW50OEFycmF5KE1hdGguY2VpbChkYXRhLndpZHRoICogZGF0YS5oZWlnaHQgLyA4KSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUGl4ZWwgSGVhZGVyXG4gICAgICB2aWV3ID0gbmV3IERhdGFWaWV3KGlucHV0LCBmcCwgMTYpO1xuICAgICAgZGF0YS5waXhlbHMgPSB7fTtcbiAgICAgIGRhdGEucGl4ZWxzLm51bUJsb2Nrc1kgPSB2aWV3LmdldFVpbnQzMigwLCB0cnVlKTtcbiAgICAgIGRhdGEucGl4ZWxzLm51bUJsb2Nrc1ggPSB2aWV3LmdldFVpbnQzMig0LCB0cnVlKTtcbiAgICAgIGRhdGEucGl4ZWxzLm51bUJ5dGVzID0gdmlldy5nZXRVaW50MzIoOCwgdHJ1ZSk7XG4gICAgICBkYXRhLnBpeGVscy5tYXhWYWx1ZSA9IHZpZXcuZ2V0RmxvYXQzMigxMiwgdHJ1ZSk7XG4gICAgICBmcCArPSAxNjtcblxuICAgICAgdmFyIG51bUJsb2Nrc1ggPSBkYXRhLnBpeGVscy5udW1CbG9ja3NYO1xuICAgICAgdmFyIG51bUJsb2Nrc1kgPSBkYXRhLnBpeGVscy5udW1CbG9ja3NZO1xuICAgICAgLy8gdGhlIG51bWJlciBvZiBibG9ja3Mgc3BlY2lmaWVkIGluIHRoZSBoZWFkZXIgZG9lcyBub3QgdGFrZSBpbnRvIGFjY291bnQgdGhlIGJsb2NrcyBhdCB0aGUgZW5kIG9mXG4gICAgICAvLyBlYWNoIHJvdy9jb2x1bW4gd2l0aCBhIHNwZWNpYWwgd2lkdGgvaGVpZ2h0IHRoYXQgbWFrZSB0aGUgaW1hZ2UgY29tcGxldGUgaW4gY2FzZSB0aGUgd2lkdGggaXMgbm90XG4gICAgICAvLyBldmVubHkgZGl2aXNpYmxlIGJ5IHRoZSBudW1iZXIgb2YgYmxvY2tzLlxuICAgICAgdmFyIGFjdHVhbE51bUJsb2Nrc1ggPSBudW1CbG9ja3NYICsgKChkYXRhLndpZHRoICUgbnVtQmxvY2tzWCkgPiAwID8gMSA6IDApO1xuICAgICAgdmFyIGFjdHVhbE51bUJsb2Nrc1kgPSBudW1CbG9ja3NZICsgKChkYXRhLmhlaWdodCAlIG51bUJsb2Nrc1kpID4gMCA/IDEgOiAwKTtcbiAgICAgIGRhdGEucGl4ZWxzLmJsb2NrcyA9IG5ldyBBcnJheShhY3R1YWxOdW1CbG9ja3NYICogYWN0dWFsTnVtQmxvY2tzWSk7XG4gICAgICB2YXIgYmxvY2tJID0gMDtcbiAgICAgIGZvciAodmFyIGJsb2NrWSA9IDA7IGJsb2NrWSA8IGFjdHVhbE51bUJsb2Nrc1k7IGJsb2NrWSsrKSB7XG4gICAgICAgIGZvciAodmFyIGJsb2NrWCA9IDA7IGJsb2NrWCA8IGFjdHVhbE51bUJsb2Nrc1g7IGJsb2NrWCsrKSB7XG5cbiAgICAgICAgICAvLyBCbG9ja1xuICAgICAgICAgIHZhciBzaXplID0gMDtcbiAgICAgICAgICB2YXIgYnl0ZXNMZWZ0ID0gaW5wdXQuYnl0ZUxlbmd0aCAtIGZwO1xuICAgICAgICAgIHZpZXcgPSBuZXcgRGF0YVZpZXcoaW5wdXQsIGZwLCBNYXRoLm1pbigxMCwgYnl0ZXNMZWZ0KSk7XG4gICAgICAgICAgdmFyIGJsb2NrID0ge307XG4gICAgICAgICAgZGF0YS5waXhlbHMuYmxvY2tzW2Jsb2NrSSsrXSA9IGJsb2NrO1xuICAgICAgICAgIHZhciBoZWFkZXJCeXRlID0gdmlldy5nZXRVaW50OCgwKTsgc2l6ZSsrO1xuICAgICAgICAgIGJsb2NrLmVuY29kaW5nID0gaGVhZGVyQnl0ZSAmIDYzO1xuICAgICAgICAgIGlmIChibG9jay5lbmNvZGluZyA+IDMpIHtcbiAgICAgICAgICAgIHRocm93IFwiSW52YWxpZCBibG9jayBlbmNvZGluZyAoXCIgKyBibG9jay5lbmNvZGluZyArIFwiKVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYmxvY2suZW5jb2RpbmcgPT09IDIpIHtcbiAgICAgICAgICAgIGZwKys7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKChoZWFkZXJCeXRlICE9PSAwKSAmJiAoaGVhZGVyQnl0ZSAhPT0gMikpIHtcbiAgICAgICAgICAgIGhlYWRlckJ5dGUgPj49IDY7XG4gICAgICAgICAgICBibG9jay5vZmZzZXRUeXBlID0gaGVhZGVyQnl0ZTtcbiAgICAgICAgICAgIGlmIChoZWFkZXJCeXRlID09PSAyKSB7XG4gICAgICAgICAgICAgIGJsb2NrLm9mZnNldCA9IHZpZXcuZ2V0SW50OCgxKTsgc2l6ZSsrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChoZWFkZXJCeXRlID09PSAxKSB7XG4gICAgICAgICAgICAgIGJsb2NrLm9mZnNldCA9IHZpZXcuZ2V0SW50MTYoMSwgdHJ1ZSk7IHNpemUgKz0gMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaGVhZGVyQnl0ZSA9PT0gMCkge1xuICAgICAgICAgICAgICBibG9jay5vZmZzZXQgPSB2aWV3LmdldEZsb2F0MzIoMSwgdHJ1ZSk7IHNpemUgKz0gNDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IFwiSW52YWxpZCBibG9jayBvZmZzZXQgdHlwZVwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYmxvY2suZW5jb2RpbmcgPT09IDEpIHtcbiAgICAgICAgICAgICAgaGVhZGVyQnl0ZSA9IHZpZXcuZ2V0VWludDgoc2l6ZSk7IHNpemUrKztcbiAgICAgICAgICAgICAgYmxvY2suYml0c1BlclBpeGVsID0gaGVhZGVyQnl0ZSAmIDYzO1xuICAgICAgICAgICAgICBoZWFkZXJCeXRlID4+PSA2O1xuICAgICAgICAgICAgICBibG9jay5udW1WYWxpZFBpeGVsc1R5cGUgPSBoZWFkZXJCeXRlO1xuICAgICAgICAgICAgICBpZiAoaGVhZGVyQnl0ZSA9PT0gMikge1xuICAgICAgICAgICAgICAgIGJsb2NrLm51bVZhbGlkUGl4ZWxzID0gdmlldy5nZXRVaW50OChzaXplKTsgc2l6ZSsrO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhlYWRlckJ5dGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBibG9jay5udW1WYWxpZFBpeGVscyA9IHZpZXcuZ2V0VWludDE2KHNpemUsIHRydWUpOyBzaXplICs9IDI7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGVhZGVyQnl0ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJsb2NrLm51bVZhbGlkUGl4ZWxzID0gdmlldy5nZXRVaW50MzIoc2l6ZSwgdHJ1ZSk7IHNpemUgKz0gNDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBcIkludmFsaWQgdmFsaWQgcGl4ZWwgY291bnQgdHlwZVwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZwICs9IHNpemU7XG5cbiAgICAgICAgICBpZiAoYmxvY2suZW5jb2RpbmcgPT09IDMpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBhcnJheUJ1Ziwgc3RvcmU4O1xuICAgICAgICAgIGlmIChibG9jay5lbmNvZGluZyA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIG51bVBpeGVscyA9IChkYXRhLnBpeGVscy5udW1CeXRlcyAtIDEpIC8gNDtcbiAgICAgICAgICAgIGlmIChudW1QaXhlbHMgIT09IE1hdGguZmxvb3IobnVtUGl4ZWxzKSkge1xuICAgICAgICAgICAgICB0aHJvdyBcInVuY29tcHJlc3NlZCBibG9jayBoYXMgaW52YWxpZCBsZW5ndGhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFycmF5QnVmID0gbmV3IEFycmF5QnVmZmVyKG51bVBpeGVscyAqIDQpO1xuICAgICAgICAgICAgc3RvcmU4ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWYpO1xuICAgICAgICAgICAgc3RvcmU4LnNldChuZXcgVWludDhBcnJheShpbnB1dCwgZnAsIG51bVBpeGVscyAqIDQpKTtcbiAgICAgICAgICAgIHZhciByYXdEYXRhID0gbmV3IEZsb2F0MzJBcnJheShhcnJheUJ1Zik7XG4gICAgICAgICAgICBibG9jay5yYXdEYXRhID0gcmF3RGF0YTtcbiAgICAgICAgICAgIGZwICs9IG51bVBpeGVscyAqIDQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChibG9jay5lbmNvZGluZyA9PT0gMSkge1xuICAgICAgICAgICAgdmFyIGRhdGFCeXRlcyA9IE1hdGguY2VpbChibG9jay5udW1WYWxpZFBpeGVscyAqIGJsb2NrLmJpdHNQZXJQaXhlbCAvIDgpO1xuICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IE1hdGguY2VpbChkYXRhQnl0ZXMgLyA0KTtcbiAgICAgICAgICAgIGFycmF5QnVmID0gbmV3IEFycmF5QnVmZmVyKGRhdGFXb3JkcyAqIDQpO1xuICAgICAgICAgICAgc3RvcmU4ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWYpO1xuICAgICAgICAgICAgc3RvcmU4LnNldChuZXcgVWludDhBcnJheShpbnB1dCwgZnAsIGRhdGFCeXRlcykpO1xuICAgICAgICAgICAgYmxvY2suc3R1ZmZlZERhdGEgPSBuZXcgVWludDMyQXJyYXkoYXJyYXlCdWYpO1xuICAgICAgICAgICAgZnAgKz0gZGF0YUJ5dGVzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGF0YS5lb2ZPZmZzZXQgPSBmcDtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG5cbiAgICB2YXIgdW5zdHVmZiA9IGZ1bmN0aW9uKHNyYywgYml0c1BlclBpeGVsLCBudW1QaXhlbHMsIG9mZnNldCwgc2NhbGUsIGRlc3QsIG1heFZhbHVlKSB7XG4gICAgICB2YXIgYml0TWFzayA9ICgxIDw8IGJpdHNQZXJQaXhlbCkgLSAxO1xuICAgICAgdmFyIGkgPSAwLCBvO1xuICAgICAgdmFyIGJpdHNMZWZ0ID0gMDtcbiAgICAgIHZhciBuLCBidWZmZXI7XG4gICAgICB2YXIgbm1heCA9IE1hdGguY2VpbCgobWF4VmFsdWUgLSBvZmZzZXQpIC8gc2NhbGUpO1xuICAgICAgLy8gZ2V0IHJpZCBvZiB0cmFpbGluZyBieXRlcyB0aGF0IGFyZSBhbHJlYWR5IHBhcnQgb2YgbmV4dCBibG9ja1xuICAgICAgdmFyIG51bUludmFsaWRUYWlsQnl0ZXMgPSBzcmMubGVuZ3RoICogNCAtIE1hdGguY2VpbChiaXRzUGVyUGl4ZWwgKiBudW1QaXhlbHMgLyA4KTtcbiAgICAgIHNyY1tzcmMubGVuZ3RoIC0gMV0gPDw9IDggKiBudW1JbnZhbGlkVGFpbEJ5dGVzO1xuXG4gICAgICBmb3IgKG8gPSAwOyBvIDwgbnVtUGl4ZWxzOyBvKyspIHtcbiAgICAgICAgaWYgKGJpdHNMZWZ0ID09PSAwKSB7XG4gICAgICAgICAgYnVmZmVyID0gc3JjW2krK107XG4gICAgICAgICAgYml0c0xlZnQgPSAzMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYml0c0xlZnQgPj0gYml0c1BlclBpeGVsKSB7XG4gICAgICAgICAgbiA9IChidWZmZXIgPj4+IChiaXRzTGVmdCAtIGJpdHNQZXJQaXhlbCkpICYgYml0TWFzaztcbiAgICAgICAgICBiaXRzTGVmdCAtPSBiaXRzUGVyUGl4ZWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG1pc3NpbmdCaXRzID0gKGJpdHNQZXJQaXhlbCAtIGJpdHNMZWZ0KTtcbiAgICAgICAgICBuID0gKChidWZmZXIgJiBiaXRNYXNrKSA8PCBtaXNzaW5nQml0cykgJiBiaXRNYXNrO1xuICAgICAgICAgIGJ1ZmZlciA9IHNyY1tpKytdO1xuICAgICAgICAgIGJpdHNMZWZ0ID0gMzIgLSBtaXNzaW5nQml0cztcbiAgICAgICAgICBuICs9IChidWZmZXIgPj4+IGJpdHNMZWZ0KTtcbiAgICAgICAgfVxuICAgICAgICAvL3BpeGVsIHZhbHVlcyBtYXkgZXhjZWVkIG1heCBkdWUgdG8gcXVhbnRpemF0aW9uXG4gICAgICAgIGRlc3Rbb10gPSBuIDwgbm1heCA/IG9mZnNldCArIG4gKiBzY2FsZSA6IG1heFZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfTtcblxuICAgIHJldHVybiBDbnRaSW1hZ2U7XG4gIH0pKCk7XG5cbiAgLy92ZXJzaW9uIDIuIFN1cHBvcnRzIDIuMSwgMi4yLCAyLjNcbiAgdmFyIExlcmMyRGVjb2RlID0gKGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIC8vIE5vdGU6IGN1cnJlbnRseSwgdGhpcyBtb2R1bGUgb25seSBoYXMgYW4gaW1wbGVtZW50YXRpb24gZm9yIGRlY29kaW5nIExFUkMgZGF0YSwgbm90IGVuY29kaW5nLiBUaGUgbmFtZSBvZlxuICAgIC8vIHRoZSBjbGFzcyB3YXMgY2hvc2VuIHRvIGJlIGZ1dHVyZSBwcm9vZiwgZm9sbG93aW5nIExlcmNEZWNvZGUuXG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAqIHByaXZhdGUgc3RhdGljIGNsYXNzIGJpdHN1dGZmZXIgdXNlZCBieSBMZXJjMkRlY29kZVxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgdmFyIEJpdFN0dWZmZXIgPSB7XG4gICAgICAvL21ldGhvZHMgZW5kaW5nIHdpdGggMiBhcmUgZm9yIHRoZSBuZXcgYnl0ZSBvcmRlciB1c2VkIGJ5IExlcmMyLjMgYW5kIGFib3ZlLlxuICAgICAgLy9vcmlnaW5hbFVuc3R1ZmYgaXMgdXNlZCB0byB1bnBhY2sgSHVmZm1hbiBjb2RlIHRhYmxlLiBjb2RlIGlzIGR1cGxpY2F0ZWQgdG8gdW5zdHVmZnggZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuXG4gICAgICB1bnN0dWZmOiBmdW5jdGlvbihzcmMsIGRlc3QsIGJpdHNQZXJQaXhlbCwgbnVtUGl4ZWxzLCBsdXRBcnIsIG9mZnNldCwgc2NhbGUsIG1heFZhbHVlKSB7XG4gICAgICAgIHZhciBiaXRNYXNrID0gKDEgPDwgYml0c1BlclBpeGVsKSAtIDE7XG4gICAgICAgIHZhciBpID0gMCwgbztcbiAgICAgICAgdmFyIGJpdHNMZWZ0ID0gMDtcbiAgICAgICAgdmFyIG4sIGJ1ZmZlciwgbWlzc2luZ0JpdHMsIG5tYXg7XG5cbiAgICAgICAgLy8gZ2V0IHJpZCBvZiB0cmFpbGluZyBieXRlcyB0aGF0IGFyZSBhbHJlYWR5IHBhcnQgb2YgbmV4dCBibG9ja1xuICAgICAgICB2YXIgbnVtSW52YWxpZFRhaWxCeXRlcyA9IHNyYy5sZW5ndGggKiA0IC0gTWF0aC5jZWlsKGJpdHNQZXJQaXhlbCAqIG51bVBpeGVscyAvIDgpO1xuICAgICAgICBzcmNbc3JjLmxlbmd0aCAtIDFdIDw8PSA4ICogbnVtSW52YWxpZFRhaWxCeXRlcztcbiAgICAgICAgaWYgKGx1dEFycikge1xuICAgICAgICAgIGZvciAobyA9IDA7IG8gPCBudW1QaXhlbHM7IG8rKykge1xuICAgICAgICAgICAgaWYgKGJpdHNMZWZ0ID09PSAwKSB7XG4gICAgICAgICAgICAgIGJ1ZmZlciA9IHNyY1tpKytdO1xuICAgICAgICAgICAgICBiaXRzTGVmdCA9IDMyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJpdHNMZWZ0ID49IGJpdHNQZXJQaXhlbCkge1xuICAgICAgICAgICAgICBuID0gKGJ1ZmZlciA+Pj4gKGJpdHNMZWZ0IC0gYml0c1BlclBpeGVsKSkgJiBiaXRNYXNrO1xuICAgICAgICAgICAgICBiaXRzTGVmdCAtPSBiaXRzUGVyUGl4ZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgbWlzc2luZ0JpdHMgPSAoYml0c1BlclBpeGVsIC0gYml0c0xlZnQpO1xuICAgICAgICAgICAgICBuID0gKChidWZmZXIgJiBiaXRNYXNrKSA8PCBtaXNzaW5nQml0cykgJiBiaXRNYXNrO1xuICAgICAgICAgICAgICBidWZmZXIgPSBzcmNbaSsrXTtcbiAgICAgICAgICAgICAgYml0c0xlZnQgPSAzMiAtIG1pc3NpbmdCaXRzO1xuICAgICAgICAgICAgICBuICs9IChidWZmZXIgPj4+IGJpdHNMZWZ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlc3Rbb10gPSBsdXRBcnJbbl07Ly9vZmZzZXQgKyBsdXRBcnJbbl0gKiBzY2FsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbm1heCA9IE1hdGguY2VpbCgobWF4VmFsdWUgLSBvZmZzZXQpIC8gc2NhbGUpO1xuICAgICAgICAgIGZvciAobyA9IDA7IG8gPCBudW1QaXhlbHM7IG8rKykge1xuICAgICAgICAgICAgaWYgKGJpdHNMZWZ0ID09PSAwKSB7XG4gICAgICAgICAgICAgIGJ1ZmZlciA9IHNyY1tpKytdO1xuICAgICAgICAgICAgICBiaXRzTGVmdCA9IDMyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJpdHNMZWZ0ID49IGJpdHNQZXJQaXhlbCkge1xuICAgICAgICAgICAgICBuID0gKGJ1ZmZlciA+Pj4gKGJpdHNMZWZ0IC0gYml0c1BlclBpeGVsKSkgJiBiaXRNYXNrO1xuICAgICAgICAgICAgICBiaXRzTGVmdCAtPSBiaXRzUGVyUGl4ZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgbWlzc2luZ0JpdHMgPSAoYml0c1BlclBpeGVsIC0gYml0c0xlZnQpO1xuICAgICAgICAgICAgICBuID0gKChidWZmZXIgJiBiaXRNYXNrKSA8PCBtaXNzaW5nQml0cykgJiBiaXRNYXNrO1xuICAgICAgICAgICAgICBidWZmZXIgPSBzcmNbaSsrXTtcbiAgICAgICAgICAgICAgYml0c0xlZnQgPSAzMiAtIG1pc3NpbmdCaXRzO1xuICAgICAgICAgICAgICBuICs9IChidWZmZXIgPj4+IGJpdHNMZWZ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vcGl4ZWwgdmFsdWVzIG1heSBleGNlZWQgbWF4IGR1ZSB0byBxdWFudGl6YXRpb25cbiAgICAgICAgICAgIGRlc3Rbb10gPSBuIDwgbm1heCA/IG9mZnNldCArIG4gKiBzY2FsZSA6IG1heFZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgdW5zdHVmZkxVVDogZnVuY3Rpb24oc3JjLCBiaXRzUGVyUGl4ZWwsIG51bVBpeGVscywgb2Zmc2V0LCBzY2FsZSwgbWF4VmFsdWUpIHtcbiAgICAgICAgdmFyIGJpdE1hc2sgPSAoMSA8PCBiaXRzUGVyUGl4ZWwpIC0gMTtcbiAgICAgICAgdmFyIGkgPSAwLCBvID0gMCwgbWlzc2luZ0JpdHMgPSAwLCBiaXRzTGVmdCA9IDAsIG4gPSAwO1xuICAgICAgICB2YXIgYnVmZmVyO1xuICAgICAgICB2YXIgZGVzdCA9IFtdO1xuXG4gICAgICAgIC8vIGdldCByaWQgb2YgdHJhaWxpbmcgYnl0ZXMgdGhhdCBhcmUgYWxyZWFkeSBwYXJ0IG9mIG5leHQgYmxvY2tcbiAgICAgICAgdmFyIG51bUludmFsaWRUYWlsQnl0ZXMgPSBzcmMubGVuZ3RoICogNCAtIE1hdGguY2VpbChiaXRzUGVyUGl4ZWwgKiBudW1QaXhlbHMgLyA4KTtcbiAgICAgICAgc3JjW3NyYy5sZW5ndGggLSAxXSA8PD0gOCAqIG51bUludmFsaWRUYWlsQnl0ZXM7XG5cbiAgICAgICAgdmFyIG5tYXggPSBNYXRoLmNlaWwoKG1heFZhbHVlIC0gb2Zmc2V0KSAvIHNjYWxlKTtcbiAgICAgICAgZm9yIChvID0gMDsgbyA8IG51bVBpeGVsczsgbysrKSB7XG4gICAgICAgICAgaWYgKGJpdHNMZWZ0ID09PSAwKSB7XG4gICAgICAgICAgICBidWZmZXIgPSBzcmNbaSsrXTtcbiAgICAgICAgICAgIGJpdHNMZWZ0ID0gMzI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChiaXRzTGVmdCA+PSBiaXRzUGVyUGl4ZWwpIHtcbiAgICAgICAgICAgIG4gPSAoYnVmZmVyID4+PiAoYml0c0xlZnQgLSBiaXRzUGVyUGl4ZWwpKSAmIGJpdE1hc2s7XG4gICAgICAgICAgICBiaXRzTGVmdCAtPSBiaXRzUGVyUGl4ZWw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1pc3NpbmdCaXRzID0gKGJpdHNQZXJQaXhlbCAtIGJpdHNMZWZ0KTtcbiAgICAgICAgICAgIG4gPSAoKGJ1ZmZlciAmIGJpdE1hc2spIDw8IG1pc3NpbmdCaXRzKSAmIGJpdE1hc2s7XG4gICAgICAgICAgICBidWZmZXIgPSBzcmNbaSsrXTtcbiAgICAgICAgICAgIGJpdHNMZWZ0ID0gMzIgLSBtaXNzaW5nQml0cztcbiAgICAgICAgICAgIG4gKz0gKGJ1ZmZlciA+Pj4gYml0c0xlZnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvL2Rlc3QucHVzaChuKTtcbiAgICAgICAgICBkZXN0W29dID0gbiA8IG5tYXggPyBvZmZzZXQgKyBuICogc2NhbGUgOiBtYXhWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBkZXN0LnVuc2hpZnQob2Zmc2V0KTsvLzFzdCBvbmVcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICB9LFxuXG4gICAgICB1bnN0dWZmMjogZnVuY3Rpb24oc3JjLCBkZXN0LCBiaXRzUGVyUGl4ZWwsIG51bVBpeGVscywgbHV0QXJyLCBvZmZzZXQsIHNjYWxlLCBtYXhWYWx1ZSkge1xuICAgICAgICB2YXIgYml0TWFzayA9ICgxIDw8IGJpdHNQZXJQaXhlbCkgLSAxO1xuICAgICAgICB2YXIgaSA9IDAsIG87XG4gICAgICAgIHZhciBiaXRzTGVmdCA9IDAsIGJpdFBvcyA9IDA7XG4gICAgICAgIHZhciBuLCBidWZmZXIsIG1pc3NpbmdCaXRzO1xuICAgICAgICBpZiAobHV0QXJyKSB7XG4gICAgICAgICAgZm9yIChvID0gMDsgbyA8IG51bVBpeGVsczsgbysrKSB7XG4gICAgICAgICAgICBpZiAoYml0c0xlZnQgPT09IDApIHtcbiAgICAgICAgICAgICAgYnVmZmVyID0gc3JjW2krK107XG4gICAgICAgICAgICAgIGJpdHNMZWZ0ID0gMzI7XG4gICAgICAgICAgICAgIGJpdFBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYml0c0xlZnQgPj0gYml0c1BlclBpeGVsKSB7XG4gICAgICAgICAgICAgIG4gPSAoKGJ1ZmZlciA+Pj4gYml0UG9zKSAmIGJpdE1hc2spO1xuICAgICAgICAgICAgICBiaXRzTGVmdCAtPSBiaXRzUGVyUGl4ZWw7XG4gICAgICAgICAgICAgIGJpdFBvcyArPSBiaXRzUGVyUGl4ZWw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtaXNzaW5nQml0cyA9IChiaXRzUGVyUGl4ZWwgLSBiaXRzTGVmdCk7XG4gICAgICAgICAgICAgIG4gPSAoYnVmZmVyID4+PiBiaXRQb3MpICYgYml0TWFzaztcbiAgICAgICAgICAgICAgYnVmZmVyID0gc3JjW2krK107XG4gICAgICAgICAgICAgIGJpdHNMZWZ0ID0gMzIgLSBtaXNzaW5nQml0cztcbiAgICAgICAgICAgICAgbiB8PSAoYnVmZmVyICYgKCgxIDw8IG1pc3NpbmdCaXRzKSAtIDEpKSA8PCAoYml0c1BlclBpeGVsIC0gbWlzc2luZ0JpdHMpO1xuICAgICAgICAgICAgICBiaXRQb3MgPSBtaXNzaW5nQml0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlc3Rbb10gPSBsdXRBcnJbbl07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBubWF4ID0gTWF0aC5jZWlsKChtYXhWYWx1ZSAtIG9mZnNldCkgLyBzY2FsZSk7XG4gICAgICAgICAgZm9yIChvID0gMDsgbyA8IG51bVBpeGVsczsgbysrKSB7XG4gICAgICAgICAgICBpZiAoYml0c0xlZnQgPT09IDApIHtcbiAgICAgICAgICAgICAgYnVmZmVyID0gc3JjW2krK107XG4gICAgICAgICAgICAgIGJpdHNMZWZ0ID0gMzI7XG4gICAgICAgICAgICAgIGJpdFBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYml0c0xlZnQgPj0gYml0c1BlclBpeGVsKSB7XG4gICAgICAgICAgICAgIC8vbm8gdW5zaWduZWQgbGVmdCBzaGlmdFxuICAgICAgICAgICAgICBuID0gKChidWZmZXIgPj4+IGJpdFBvcykgJiBiaXRNYXNrKTtcbiAgICAgICAgICAgICAgYml0c0xlZnQgLT0gYml0c1BlclBpeGVsO1xuICAgICAgICAgICAgICBiaXRQb3MgKz0gYml0c1BlclBpeGVsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWlzc2luZ0JpdHMgPSAoYml0c1BlclBpeGVsIC0gYml0c0xlZnQpO1xuICAgICAgICAgICAgICBuID0gKGJ1ZmZlciA+Pj4gYml0UG9zKSAmIGJpdE1hc2s7Ly8oKGJ1ZmZlciAmIGJpdE1hc2spIDw8IG1pc3NpbmdCaXRzKSAmIGJpdE1hc2s7XG4gICAgICAgICAgICAgIGJ1ZmZlciA9IHNyY1tpKytdO1xuICAgICAgICAgICAgICBiaXRzTGVmdCA9IDMyIC0gbWlzc2luZ0JpdHM7XG4gICAgICAgICAgICAgIG4gfD0gKGJ1ZmZlciAmICgoMSA8PCBtaXNzaW5nQml0cykgLSAxKSkgPDwgKGJpdHNQZXJQaXhlbCAtIG1pc3NpbmdCaXRzKTtcbiAgICAgICAgICAgICAgYml0UG9zID0gbWlzc2luZ0JpdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL3BpeGVsIHZhbHVlcyBtYXkgZXhjZWVkIG1heCBkdWUgdG8gcXVhbnRpemF0aW9uXG4gICAgICAgICAgICBkZXN0W29dID0gbiA8IG5tYXggPyBvZmZzZXQgKyBuICogc2NhbGUgOiBtYXhWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICB9LFxuXG4gICAgICB1bnN0dWZmTFVUMjogZnVuY3Rpb24oc3JjLCBiaXRzUGVyUGl4ZWwsIG51bVBpeGVscywgb2Zmc2V0LCBzY2FsZSwgbWF4VmFsdWUpIHtcbiAgICAgICAgdmFyIGJpdE1hc2sgPSAoMSA8PCBiaXRzUGVyUGl4ZWwpIC0gMTtcbiAgICAgICAgdmFyIGkgPSAwLCBvID0gMCwgbWlzc2luZ0JpdHMgPSAwLCBiaXRzTGVmdCA9IDAsIG4gPSAwLCBiaXRQb3MgPSAwO1xuICAgICAgICB2YXIgYnVmZmVyO1xuICAgICAgICB2YXIgZGVzdCA9IFtdO1xuICAgICAgICB2YXIgbm1heCA9IE1hdGguY2VpbCgobWF4VmFsdWUgLSBvZmZzZXQpIC8gc2NhbGUpO1xuICAgICAgICBmb3IgKG8gPSAwOyBvIDwgbnVtUGl4ZWxzOyBvKyspIHtcbiAgICAgICAgICBpZiAoYml0c0xlZnQgPT09IDApIHtcbiAgICAgICAgICAgIGJ1ZmZlciA9IHNyY1tpKytdO1xuICAgICAgICAgICAgYml0c0xlZnQgPSAzMjtcbiAgICAgICAgICAgIGJpdFBvcyA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChiaXRzTGVmdCA+PSBiaXRzUGVyUGl4ZWwpIHtcbiAgICAgICAgICAgIC8vbm8gdW5zaWduZWQgbGVmdCBzaGlmdFxuICAgICAgICAgICAgbiA9ICgoYnVmZmVyID4+PiBiaXRQb3MpICYgYml0TWFzayk7XG4gICAgICAgICAgICBiaXRzTGVmdCAtPSBiaXRzUGVyUGl4ZWw7XG4gICAgICAgICAgICBiaXRQb3MgKz0gYml0c1BlclBpeGVsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtaXNzaW5nQml0cyA9IChiaXRzUGVyUGl4ZWwgLSBiaXRzTGVmdCk7XG4gICAgICAgICAgICBuID0gKGJ1ZmZlciA+Pj4gYml0UG9zKSAmIGJpdE1hc2s7Ly8oKGJ1ZmZlciAmIGJpdE1hc2spIDw8IG1pc3NpbmdCaXRzKSAmIGJpdE1hc2s7XG4gICAgICAgICAgICBidWZmZXIgPSBzcmNbaSsrXTtcbiAgICAgICAgICAgIGJpdHNMZWZ0ID0gMzIgLSBtaXNzaW5nQml0cztcbiAgICAgICAgICAgIG4gfD0gKGJ1ZmZlciAmICgoMSA8PCBtaXNzaW5nQml0cykgLSAxKSkgPDwgKGJpdHNQZXJQaXhlbCAtIG1pc3NpbmdCaXRzKTtcbiAgICAgICAgICAgIGJpdFBvcyA9IG1pc3NpbmdCaXRzO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvL2Rlc3QucHVzaChuKTtcbiAgICAgICAgICBkZXN0W29dID0gbiA8IG5tYXggPyBvZmZzZXQgKyBuICogc2NhbGUgOiBtYXhWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBkZXN0LnVuc2hpZnQob2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICB9LFxuXG4gICAgICBvcmlnaW5hbFVuc3R1ZmY6IGZ1bmN0aW9uKHNyYywgZGVzdCwgYml0c1BlclBpeGVsLCBudW1QaXhlbHMpIHtcbiAgICAgICAgdmFyIGJpdE1hc2sgPSAoMSA8PCBiaXRzUGVyUGl4ZWwpIC0gMTtcbiAgICAgICAgdmFyIGkgPSAwLCBvO1xuICAgICAgICB2YXIgYml0c0xlZnQgPSAwO1xuICAgICAgICB2YXIgbiwgYnVmZmVyLCBtaXNzaW5nQml0cztcblxuICAgICAgICAvLyBnZXQgcmlkIG9mIHRyYWlsaW5nIGJ5dGVzIHRoYXQgYXJlIGFscmVhZHkgcGFydCBvZiBuZXh0IGJsb2NrXG4gICAgICAgIHZhciBudW1JbnZhbGlkVGFpbEJ5dGVzID0gc3JjLmxlbmd0aCAqIDQgLSBNYXRoLmNlaWwoYml0c1BlclBpeGVsICogbnVtUGl4ZWxzIC8gOCk7XG4gICAgICAgIHNyY1tzcmMubGVuZ3RoIC0gMV0gPDw9IDggKiBudW1JbnZhbGlkVGFpbEJ5dGVzO1xuXG4gICAgICAgIGZvciAobyA9IDA7IG8gPCBudW1QaXhlbHM7IG8rKykge1xuICAgICAgICAgIGlmIChiaXRzTGVmdCA9PT0gMCkge1xuICAgICAgICAgICAgYnVmZmVyID0gc3JjW2krK107XG4gICAgICAgICAgICBiaXRzTGVmdCA9IDMyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYml0c0xlZnQgPj0gYml0c1BlclBpeGVsKSB7XG4gICAgICAgICAgICBuID0gKGJ1ZmZlciA+Pj4gKGJpdHNMZWZ0IC0gYml0c1BlclBpeGVsKSkgJiBiaXRNYXNrO1xuICAgICAgICAgICAgYml0c0xlZnQgLT0gYml0c1BlclBpeGVsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1pc3NpbmdCaXRzID0gKGJpdHNQZXJQaXhlbCAtIGJpdHNMZWZ0KTtcbiAgICAgICAgICAgIG4gPSAoKGJ1ZmZlciAmIGJpdE1hc2spIDw8IG1pc3NpbmdCaXRzKSAmIGJpdE1hc2s7XG4gICAgICAgICAgICBidWZmZXIgPSBzcmNbaSsrXTtcbiAgICAgICAgICAgIGJpdHNMZWZ0ID0gMzIgLSBtaXNzaW5nQml0cztcbiAgICAgICAgICAgIG4gKz0gKGJ1ZmZlciA+Pj4gYml0c0xlZnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZXN0W29dID0gbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgIH0sXG5cbiAgICAgIG9yaWdpbmFsVW5zdHVmZjI6IGZ1bmN0aW9uKHNyYywgZGVzdCwgYml0c1BlclBpeGVsLCBudW1QaXhlbHMpIHtcbiAgICAgICAgdmFyIGJpdE1hc2sgPSAoMSA8PCBiaXRzUGVyUGl4ZWwpIC0gMTtcbiAgICAgICAgdmFyIGkgPSAwLCBvO1xuICAgICAgICB2YXIgYml0c0xlZnQgPSAwLCBiaXRQb3MgPSAwO1xuICAgICAgICB2YXIgbiwgYnVmZmVyLCBtaXNzaW5nQml0cztcbiAgICAgICAgLy9taWNyby1vcHRpbWl6YXRpb25zXG4gICAgICAgIGZvciAobyA9IDA7IG8gPCBudW1QaXhlbHM7IG8rKykge1xuICAgICAgICAgIGlmIChiaXRzTGVmdCA9PT0gMCkge1xuICAgICAgICAgICAgYnVmZmVyID0gc3JjW2krK107XG4gICAgICAgICAgICBiaXRzTGVmdCA9IDMyO1xuICAgICAgICAgICAgYml0UG9zID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJpdHNMZWZ0ID49IGJpdHNQZXJQaXhlbCkge1xuICAgICAgICAgICAgLy9ubyB1bnNpZ25lZCBsZWZ0IHNoaWZ0XG4gICAgICAgICAgICBuID0gKChidWZmZXIgPj4+IGJpdFBvcykgJiBiaXRNYXNrKTtcbiAgICAgICAgICAgIGJpdHNMZWZ0IC09IGJpdHNQZXJQaXhlbDtcbiAgICAgICAgICAgIGJpdFBvcyArPSBiaXRzUGVyUGl4ZWw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1pc3NpbmdCaXRzID0gKGJpdHNQZXJQaXhlbCAtIGJpdHNMZWZ0KTtcbiAgICAgICAgICAgIG4gPSAoYnVmZmVyID4+PiBiaXRQb3MpICYgYml0TWFzazsvLygoYnVmZmVyICYgYml0TWFzaykgPDwgbWlzc2luZ0JpdHMpICYgYml0TWFzaztcbiAgICAgICAgICAgIGJ1ZmZlciA9IHNyY1tpKytdO1xuICAgICAgICAgICAgYml0c0xlZnQgPSAzMiAtIG1pc3NpbmdCaXRzO1xuICAgICAgICAgICAgbiB8PSAoYnVmZmVyICYgKCgxIDw8IG1pc3NpbmdCaXRzKSAtIDEpKSA8PCAoYml0c1BlclBpeGVsIC0gbWlzc2luZ0JpdHMpO1xuICAgICAgICAgICAgYml0UG9zID0gbWlzc2luZ0JpdHM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlc3Rbb10gPSBuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAqcHJpdmF0ZSBzdGF0aWMgY2xhc3MgdXNlZCBieSBMZXJjMkRlY29kZVxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICB2YXIgTGVyYzJIZWxwZXJzID0ge1xuICAgICAgSFVGRk1BTl9MVVRfQklUU19NQVg6IDEyLCAvL3VzZSAyXjEyIGx1dCwgdHJlYXQgaXQgbGlrZSBjb25zdGFudFxuICAgICAgY29tcHV0ZUNoZWNrc3VtRmxldGNoZXIzMjogZnVuY3Rpb24oaW5wdXQpIHtcblxuICAgICAgICB2YXIgc3VtMSA9IDB4ZmZmZiwgc3VtMiA9IDB4ZmZmZjtcbiAgICAgICAgdmFyIGxlbiA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgdmFyIHdvcmRzID0gTWF0aC5mbG9vcihsZW4gLyAyKTtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAod29yZHMpIHtcbiAgICAgICAgICB2YXIgdGxlbiA9ICh3b3JkcyA+PSAzNTkpID8gMzU5IDogd29yZHM7XG4gICAgICAgICAgd29yZHMgLT0gdGxlbjtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBzdW0xICs9IChpbnB1dFtpKytdIDw8IDgpO1xuICAgICAgICAgICAgc3VtMiArPSBzdW0xICs9IGlucHV0W2krK107XG4gICAgICAgICAgfSB3aGlsZSAoLS10bGVuKTtcblxuICAgICAgICAgIHN1bTEgPSAoc3VtMSAmIDB4ZmZmZikgKyAoc3VtMSA+Pj4gMTYpO1xuICAgICAgICAgIHN1bTIgPSAoc3VtMiAmIDB4ZmZmZikgKyAoc3VtMiA+Pj4gMTYpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHRoZSBzdHJhZ2dsZXIgYnl0ZSBpZiBpdCBleGlzdHNcbiAgICAgICAgaWYgKGxlbiAmIDEpIHtcbiAgICAgICAgICBzdW0yICs9IHN1bTEgKz0gKGlucHV0W2ldIDw8IDgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNlY29uZCByZWR1Y3Rpb24gc3RlcCB0byByZWR1Y2Ugc3VtcyB0byAxNiBiaXRzXG4gICAgICAgIHN1bTEgPSAoc3VtMSAmIDB4ZmZmZikgKyAoc3VtMSA+Pj4gMTYpO1xuICAgICAgICBzdW0yID0gKHN1bTIgJiAweGZmZmYpICsgKHN1bTIgPj4+IDE2KTtcblxuICAgICAgICByZXR1cm4gKHN1bTIgPDwgMTYgfCBzdW0xKSA+Pj4gMDtcbiAgICAgIH0sXG5cbiAgICAgIHJlYWRIZWFkZXJJbmZvOiBmdW5jdGlvbihpbnB1dCwgZGF0YSkge1xuICAgICAgICB2YXIgcHRyID0gZGF0YS5wdHI7XG4gICAgICAgIHZhciBmaWxlSWRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoaW5wdXQsIHB0ciwgNik7XG4gICAgICAgIHZhciBoZWFkZXJJbmZvID0ge307XG4gICAgICAgIGhlYWRlckluZm8uZmlsZUlkZW50aWZpZXJTdHJpbmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGZpbGVJZFZpZXcpO1xuICAgICAgICBpZiAoaGVhZGVySW5mby5maWxlSWRlbnRpZmllclN0cmluZy5sYXN0SW5kZXhPZihcIkxlcmMyXCIsIDApICE9PSAwKSB7XG4gICAgICAgICAgdGhyb3cgXCJVbmV4cGVjdGVkIGZpbGUgaWRlbnRpZmllciBzdHJpbmcgKGV4cGVjdCBMZXJjMiApOiBcIiArIGhlYWRlckluZm8uZmlsZUlkZW50aWZpZXJTdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgcHRyICs9IDY7XG4gICAgICAgIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KGlucHV0LCBwdHIsIDgpO1xuICAgICAgICB2YXIgZmlsZVZlcnNpb24gPSB2aWV3LmdldEludDMyKDAsIHRydWUpO1xuICAgICAgICBoZWFkZXJJbmZvLmZpbGVWZXJzaW9uID0gZmlsZVZlcnNpb247XG4gICAgICAgIHB0ciArPSA0O1xuICAgICAgICBpZiAoZmlsZVZlcnNpb24gPj0gMykge1xuICAgICAgICAgIGhlYWRlckluZm8uY2hlY2tzdW0gPSB2aWV3LmdldFVpbnQzMig0LCB0cnVlKTsgLy9ucm93c1xuICAgICAgICAgIHB0ciArPSA0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy9rZXlzIHN0YXJ0IGZyb20gaGVyZVxuICAgICAgICB2aWV3ID0gbmV3IERhdGFWaWV3KGlucHV0LCBwdHIsIDEyKTtcbiAgICAgICAgaGVhZGVySW5mby5oZWlnaHQgPSB2aWV3LmdldFVpbnQzMigwLCB0cnVlKTsgLy9ucm93c1xuICAgICAgICBoZWFkZXJJbmZvLndpZHRoID0gdmlldy5nZXRVaW50MzIoNCwgdHJ1ZSk7IC8vbmNvbHNcbiAgICAgICAgcHRyICs9IDg7XG4gICAgICAgIGlmIChmaWxlVmVyc2lvbiA+PSA0KSB7XG4gICAgICAgICAgaGVhZGVySW5mby5udW1EaW1zID0gdmlldy5nZXRVaW50MzIoOCwgdHJ1ZSk7XG4gICAgICAgICAgcHRyICs9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaGVhZGVySW5mby5udW1EaW1zID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZpZXcgPSBuZXcgRGF0YVZpZXcoaW5wdXQsIHB0ciwgNDApO1xuICAgICAgICBoZWFkZXJJbmZvLm51bVZhbGlkUGl4ZWwgPSB2aWV3LmdldFVpbnQzMigwLCB0cnVlKTtcbiAgICAgICAgaGVhZGVySW5mby5taWNyb0Jsb2NrU2l6ZSA9IHZpZXcuZ2V0SW50MzIoNCwgdHJ1ZSk7XG4gICAgICAgIGhlYWRlckluZm8uYmxvYlNpemUgPSB2aWV3LmdldEludDMyKDgsIHRydWUpO1xuICAgICAgICBoZWFkZXJJbmZvLmltYWdlVHlwZSA9IHZpZXcuZ2V0SW50MzIoMTIsIHRydWUpO1xuXG4gICAgICAgIGhlYWRlckluZm8ubWF4WkVycm9yID0gdmlldy5nZXRGbG9hdDY0KDE2LCB0cnVlKTtcbiAgICAgICAgaGVhZGVySW5mby56TWluID0gdmlldy5nZXRGbG9hdDY0KDI0LCB0cnVlKTtcbiAgICAgICAgaGVhZGVySW5mby56TWF4ID0gdmlldy5nZXRGbG9hdDY0KDMyLCB0cnVlKTtcbiAgICAgICAgcHRyICs9IDQwO1xuICAgICAgICBkYXRhLmhlYWRlckluZm8gPSBoZWFkZXJJbmZvO1xuICAgICAgICBkYXRhLnB0ciA9IHB0cjtcblxuICAgICAgICB2YXIgY2hlY2tzdW0sIGtleUxlbmd0aDtcbiAgICAgICAgaWYgKGZpbGVWZXJzaW9uID49IDMpIHtcbiAgICAgICAgICBrZXlMZW5ndGggPSBmaWxlVmVyc2lvbiA+PSA0ID8gNTIgOiA0ODtcbiAgICAgICAgICBjaGVja3N1bSA9IHRoaXMuY29tcHV0ZUNoZWNrc3VtRmxldGNoZXIzMihuZXcgVWludDhBcnJheShpbnB1dCwgcHRyIC0ga2V5TGVuZ3RoLCBoZWFkZXJJbmZvLmJsb2JTaXplIC0gMTQpKTtcbiAgICAgICAgICBpZiAoY2hlY2tzdW0gIT09IGhlYWRlckluZm8uY2hlY2tzdW0pIHtcbiAgICAgICAgICAgIHRocm93IFwiQ2hlY2tzdW0gZmFpbGVkLlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG5cbiAgICAgIGNoZWNrTWluTWF4UmFuZ2VzOiBmdW5jdGlvbihpbnB1dCwgZGF0YSkge1xuICAgICAgICB2YXIgaGVhZGVySW5mbyA9IGRhdGEuaGVhZGVySW5mbztcbiAgICAgICAgdmFyIE91dFBpeGVsVHlwZUFycmF5ID0gdGhpcy5nZXREYXRhVHlwZUFycmF5KGhlYWRlckluZm8uaW1hZ2VUeXBlKTtcbiAgICAgICAgdmFyIHJhbmdlQnl0ZXMgPSBoZWFkZXJJbmZvLm51bURpbXMgKiB0aGlzLmdldERhdGFUeXBlU2l6ZShoZWFkZXJJbmZvLmltYWdlVHlwZSk7XG4gICAgICAgIHZhciBtaW5WYWx1ZXMgPSB0aGlzLnJlYWRTdWJBcnJheShpbnB1dCwgZGF0YS5wdHIsIE91dFBpeGVsVHlwZUFycmF5LCByYW5nZUJ5dGVzKTtcbiAgICAgICAgdmFyIG1heFZhbHVlcyA9IHRoaXMucmVhZFN1YkFycmF5KGlucHV0LCBkYXRhLnB0ciArIHJhbmdlQnl0ZXMsIE91dFBpeGVsVHlwZUFycmF5LCByYW5nZUJ5dGVzKTtcbiAgICAgICAgZGF0YS5wdHIgKz0gKDIgKiByYW5nZUJ5dGVzKTtcbiAgICAgICAgdmFyIGksIGVxdWFsID0gdHJ1ZTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGhlYWRlckluZm8ubnVtRGltczsgaSsrKSB7XG4gICAgICAgICAgaWYgKG1pblZhbHVlc1tpXSAhPT0gbWF4VmFsdWVzW2ldKSB7XG4gICAgICAgICAgICBlcXVhbCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGhlYWRlckluZm8ubWluVmFsdWVzID0gbWluVmFsdWVzO1xuICAgICAgICBoZWFkZXJJbmZvLm1heFZhbHVlcyA9IG1heFZhbHVlcztcbiAgICAgICAgcmV0dXJuIGVxdWFsO1xuICAgICAgfSxcblxuICAgICAgcmVhZFN1YkFycmF5OiBmdW5jdGlvbihpbnB1dCwgcHRyLCBPdXRQaXhlbFR5cGVBcnJheSwgbnVtQnl0ZXMpIHtcbiAgICAgICAgdmFyIHJhd0RhdGE7XG4gICAgICAgIGlmIChPdXRQaXhlbFR5cGVBcnJheSA9PT0gVWludDhBcnJheSkge1xuICAgICAgICAgIHJhd0RhdGEgPSBuZXcgVWludDhBcnJheShpbnB1dCwgcHRyLCBudW1CeXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIGFycmF5QnVmID0gbmV3IEFycmF5QnVmZmVyKG51bUJ5dGVzKTtcbiAgICAgICAgICB2YXIgc3RvcmU4ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWYpO1xuICAgICAgICAgIHN0b3JlOC5zZXQobmV3IFVpbnQ4QXJyYXkoaW5wdXQsIHB0ciwgbnVtQnl0ZXMpKTtcbiAgICAgICAgICByYXdEYXRhID0gbmV3IE91dFBpeGVsVHlwZUFycmF5KGFycmF5QnVmKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmF3RGF0YTtcbiAgICAgIH0sXG5cbiAgICAgIHJlYWRNYXNrOiBmdW5jdGlvbihpbnB1dCwgZGF0YSkge1xuICAgICAgICB2YXIgcHRyID0gZGF0YS5wdHI7XG4gICAgICAgIHZhciBoZWFkZXJJbmZvID0gZGF0YS5oZWFkZXJJbmZvO1xuICAgICAgICB2YXIgbnVtUGl4ZWxzID0gaGVhZGVySW5mby53aWR0aCAqIGhlYWRlckluZm8uaGVpZ2h0O1xuICAgICAgICB2YXIgbnVtVmFsaWRQaXhlbCA9IGhlYWRlckluZm8ubnVtVmFsaWRQaXhlbDtcblxuICAgICAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhpbnB1dCwgcHRyLCA0KTtcbiAgICAgICAgdmFyIG1hc2sgPSB7fTtcbiAgICAgICAgbWFzay5udW1CeXRlcyA9IHZpZXcuZ2V0VWludDMyKDAsIHRydWUpO1xuICAgICAgICBwdHIgKz0gNDtcblxuICAgICAgICAvLyBNYXNrIERhdGFcbiAgICAgICAgaWYgKCgwID09PSBudW1WYWxpZFBpeGVsIHx8IG51bVBpeGVscyA9PT0gbnVtVmFsaWRQaXhlbCkgJiYgMCAhPT0gbWFzay5udW1CeXRlcykge1xuICAgICAgICAgIHRocm93IChcImludmFsaWQgbWFza1wiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYml0c2V0LCByZXN1bHRNYXNrO1xuICAgICAgICBpZiAobnVtVmFsaWRQaXhlbCA9PT0gMCkge1xuICAgICAgICAgIGJpdHNldCA9IG5ldyBVaW50OEFycmF5KE1hdGguY2VpbChudW1QaXhlbHMgLyA4KSk7XG4gICAgICAgICAgbWFzay5iaXRzZXQgPSBiaXRzZXQ7XG4gICAgICAgICAgcmVzdWx0TWFzayA9IG5ldyBVaW50OEFycmF5KG51bVBpeGVscyk7XG4gICAgICAgICAgZGF0YS5waXhlbHMucmVzdWx0TWFzayA9IHJlc3VsdE1hc2s7XG4gICAgICAgICAgcHRyICs9IG1hc2subnVtQnl0ZXM7XG4gICAgICAgIH0vLyA/Pz8/PyBlbHNlIGlmIChkYXRhLm1hc2subnVtQnl0ZXMgPiAwICYmIGRhdGEubWFzay5udW1CeXRlczwgZGF0YS5udW1WYWxpZFBpeGVsKSB7XG4gICAgICAgIGVsc2UgaWYgKG1hc2subnVtQnl0ZXMgPiAwKSB7XG4gICAgICAgICAgYml0c2V0ID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKG51bVBpeGVscyAvIDgpKTtcbiAgICAgICAgICB2aWV3ID0gbmV3IERhdGFWaWV3KGlucHV0LCBwdHIsIG1hc2subnVtQnl0ZXMpO1xuICAgICAgICAgIHZhciBjbnQgPSB2aWV3LmdldEludDE2KDAsIHRydWUpO1xuICAgICAgICAgIHZhciBpcCA9IDIsIG9wID0gMCwgdmFsID0gMDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoY250ID4gMCkge1xuICAgICAgICAgICAgICB3aGlsZSAoY250LS0pIHsgYml0c2V0W29wKytdID0gdmlldy5nZXRVaW50OChpcCsrKTsgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFsID0gdmlldy5nZXRVaW50OChpcCsrKTtcbiAgICAgICAgICAgICAgY250ID0gLWNudDtcbiAgICAgICAgICAgICAgd2hpbGUgKGNudC0tKSB7IGJpdHNldFtvcCsrXSA9IHZhbDsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY250ID0gdmlldy5nZXRJbnQxNihpcCwgdHJ1ZSk7XG4gICAgICAgICAgICBpcCArPSAyO1xuICAgICAgICAgIH0gd2hpbGUgKGlwIDwgbWFzay5udW1CeXRlcyk7XG4gICAgICAgICAgaWYgKChjbnQgIT09IC0zMjc2OCkgfHwgKG9wIDwgYml0c2V0Lmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHRocm93IFwiVW5leHBlY3RlZCBlbmQgb2YgbWFzayBSTEUgZW5jb2RpbmdcIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXN1bHRNYXNrID0gbmV3IFVpbnQ4QXJyYXkobnVtUGl4ZWxzKTtcbiAgICAgICAgICB2YXIgbWIgPSAwLCBrID0gMDtcblxuICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBudW1QaXhlbHM7IGsrKykge1xuICAgICAgICAgICAgaWYgKGsgJiA3KSB7XG4gICAgICAgICAgICAgIG1iID0gYml0c2V0W2sgPj4gM107XG4gICAgICAgICAgICAgIG1iIDw8PSBrICYgNztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBtYiA9IGJpdHNldFtrID4+IDNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1iICYgMTI4KSB7XG4gICAgICAgICAgICAgIHJlc3VsdE1hc2tba10gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhLnBpeGVscy5yZXN1bHRNYXNrID0gcmVzdWx0TWFzaztcblxuICAgICAgICAgIG1hc2suYml0c2V0ID0gYml0c2V0O1xuICAgICAgICAgIHB0ciArPSBtYXNrLm51bUJ5dGVzO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEucHRyID0gcHRyO1xuICAgICAgICBkYXRhLm1hc2sgPSBtYXNrO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG5cbiAgICAgIHJlYWREYXRhT25lU3dlZXA6IGZ1bmN0aW9uKGlucHV0LCBkYXRhLCBPdXRQaXhlbFR5cGVBcnJheSwgdXNlQlNRRm9yT3V0cHV0RGltKSB7XG4gICAgICAgIHZhciBwdHIgPSBkYXRhLnB0cjtcbiAgICAgICAgdmFyIGhlYWRlckluZm8gPSBkYXRhLmhlYWRlckluZm87XG4gICAgICAgIHZhciBudW1EaW1zID0gaGVhZGVySW5mby5udW1EaW1zO1xuICAgICAgICB2YXIgbnVtUGl4ZWxzID0gaGVhZGVySW5mby53aWR0aCAqIGhlYWRlckluZm8uaGVpZ2h0O1xuICAgICAgICB2YXIgaW1hZ2VUeXBlID0gaGVhZGVySW5mby5pbWFnZVR5cGU7XG4gICAgICAgIHZhciBudW1CeXRlcyA9IGhlYWRlckluZm8ubnVtVmFsaWRQaXhlbCAqIExlcmMySGVscGVycy5nZXREYXRhVHlwZVNpemUoaW1hZ2VUeXBlKSAqIG51bURpbXM7XG4gICAgICAgIC8vZGF0YS5waXhlbHMubnVtQnl0ZXMgPSBudW1CeXRlcztcbiAgICAgICAgdmFyIHJhd0RhdGE7XG4gICAgICAgIHZhciBtYXNrID0gZGF0YS5waXhlbHMucmVzdWx0TWFzaztcbiAgICAgICAgaWYgKE91dFBpeGVsVHlwZUFycmF5ID09PSBVaW50OEFycmF5KSB7XG4gICAgICAgICAgcmF3RGF0YSA9IG5ldyBVaW50OEFycmF5KGlucHV0LCBwdHIsIG51bUJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgYXJyYXlCdWYgPSBuZXcgQXJyYXlCdWZmZXIobnVtQnl0ZXMpO1xuICAgICAgICAgIHZhciBzdG9yZTggPSBuZXcgVWludDhBcnJheShhcnJheUJ1Zik7XG4gICAgICAgICAgc3RvcmU4LnNldChuZXcgVWludDhBcnJheShpbnB1dCwgcHRyLCBudW1CeXRlcykpO1xuICAgICAgICAgIHJhd0RhdGEgPSBuZXcgT3V0UGl4ZWxUeXBlQXJyYXkoYXJyYXlCdWYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyYXdEYXRhLmxlbmd0aCA9PT0gbnVtUGl4ZWxzICogbnVtRGltcykge1xuICAgICAgICAgIGlmICh1c2VCU1FGb3JPdXRwdXREaW0pIHtcbiAgICAgICAgICAgIGRhdGEucGl4ZWxzLnJlc3VsdFBpeGVscyA9IExlcmMySGVscGVycy5zd2FwRGltZW5zaW9uT3JkZXIocmF3RGF0YSwgbnVtUGl4ZWxzLCBudW1EaW1zLCBPdXRQaXhlbFR5cGVBcnJheSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YS5waXhlbHMucmVzdWx0UGl4ZWxzID0gcmF3RGF0YTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSAgLy9tYXNrXG4gICAgICAgIHtcbiAgICAgICAgICBkYXRhLnBpeGVscy5yZXN1bHRQaXhlbHMgPSBuZXcgT3V0UGl4ZWxUeXBlQXJyYXkobnVtUGl4ZWxzICogbnVtRGltcyk7XG4gICAgICAgICAgdmFyIHogPSAwLCBrID0gMCwgaSA9IDAsIG5TdGFydCA9IDA7XG4gICAgICAgICAgaWYgKG51bURpbXMgPiAxKSB7XG4gICAgICAgICAgICBpZiAodXNlQlNRRm9yT3V0cHV0RGltKSB7XG4gICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBudW1QaXhlbHM7IGsrKykge1xuICAgICAgICAgICAgICAgIGlmIChtYXNrW2tdKSB7XG4gICAgICAgICAgICAgICAgICBuU3RhcnQgPSBrO1xuICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bURpbXM7IGkrKywgblN0YXJ0Kz1udW1QaXhlbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5waXhlbHMucmVzdWx0UGl4ZWxzW25TdGFydF0gPSByYXdEYXRhW3orK107XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IG51bVBpeGVsczsgaysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hc2tba10pIHtcbiAgICAgICAgICAgICAgICAgIG5TdGFydCA9IGsgKiBudW1EaW1zO1xuICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bURpbXM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnBpeGVscy5yZXN1bHRQaXhlbHNbblN0YXJ0ICsgaV0gPSByYXdEYXRhW3orK107XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IG51bVBpeGVsczsgaysrKSB7XG4gICAgICAgICAgICAgIGlmIChtYXNrW2tdKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5waXhlbHMucmVzdWx0UGl4ZWxzW2tdID0gcmF3RGF0YVt6KytdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHB0ciArPSBudW1CeXRlcztcbiAgICAgICAgZGF0YS5wdHIgPSBwdHI7ICAgICAgIC8vcmV0dXJuIGRhdGE7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcblxuICAgICAgcmVhZEh1ZmZtYW5UcmVlOiBmdW5jdGlvbihpbnB1dCwgZGF0YSkge1xuICAgICAgICB2YXIgQklUU19NQVggPSB0aGlzLkhVRkZNQU5fTFVUX0JJVFNfTUFYOyAvLzggaXMgc2xvdyBmb3IgdGhlIGxhcmdlIHRlc3QgaW1hZ2VcbiAgICAgICAgLy92YXIgc2l6ZV9tYXggPSAxIDw8IEJJVFNfTUFYO1xuICAgICAgICAvKiAqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgKiByZWFkaW5nIGNvZGUgdGFibGVcbiAgICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcoaW5wdXQsIGRhdGEucHRyLCAxNik7XG4gICAgICAgIGRhdGEucHRyICs9IDE2O1xuICAgICAgICB2YXIgdmVyc2lvbiA9IHZpZXcuZ2V0SW50MzIoMCwgdHJ1ZSk7XG4gICAgICAgIGlmICh2ZXJzaW9uIDwgMikge1xuICAgICAgICAgIHRocm93IFwidW5zdXBwb3J0ZWQgSHVmZm1hbiB2ZXJzaW9uXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNpemUgPSB2aWV3LmdldEludDMyKDQsIHRydWUpO1xuICAgICAgICB2YXIgaTAgPSB2aWV3LmdldEludDMyKDgsIHRydWUpO1xuICAgICAgICB2YXIgaTEgPSB2aWV3LmdldEludDMyKDEyLCB0cnVlKTtcbiAgICAgICAgaWYgKGkwID49IGkxKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBibG9ja0RhdGFCdWZmZXIgPSBuZXcgVWludDMyQXJyYXkoaTEgLSBpMCk7XG4gICAgICAgIExlcmMySGVscGVycy5kZWNvZGVCaXRzKGlucHV0LCBkYXRhLCBibG9ja0RhdGFCdWZmZXIpO1xuICAgICAgICB2YXIgY29kZVRhYmxlID0gW107IC8vc2l6ZVxuICAgICAgICB2YXIgaSwgaiwgaywgbGVuO1xuXG4gICAgICAgIGZvciAoaSA9IGkwOyBpIDwgaTE7IGkrKykge1xuICAgICAgICAgIGogPSBpIC0gKGkgPCBzaXplID8gMCA6IHNpemUpOy8vd3JhcCBhcm91bmRcbiAgICAgICAgICBjb2RlVGFibGVbal0gPSB7IGZpcnN0OiBibG9ja0RhdGFCdWZmZXJbaSAtIGkwXSwgc2Vjb25kOiBudWxsIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0YUJ5dGVzID0gaW5wdXQuYnl0ZUxlbmd0aCAtIGRhdGEucHRyO1xuICAgICAgICB2YXIgZGF0YVdvcmRzID0gTWF0aC5jZWlsKGRhdGFCeXRlcyAvIDQpO1xuICAgICAgICB2YXIgYXJyYXlCdWYgPSBuZXcgQXJyYXlCdWZmZXIoZGF0YVdvcmRzICogNCk7XG4gICAgICAgIHZhciBzdG9yZTggPSBuZXcgVWludDhBcnJheShhcnJheUJ1Zik7XG4gICAgICAgIHN0b3JlOC5zZXQobmV3IFVpbnQ4QXJyYXkoaW5wdXQsIGRhdGEucHRyLCBkYXRhQnl0ZXMpKTtcbiAgICAgICAgdmFyIHN0dWZmZWREYXRhID0gbmV3IFVpbnQzMkFycmF5KGFycmF5QnVmKTsgLy9tdXN0IHN0YXJ0IGZyb20geCo0XG4gICAgICAgIHZhciBiaXRQb3MgPSAwLCB3b3JkLCBzcmNQdHIgPSAwO1xuICAgICAgICB3b3JkID0gc3R1ZmZlZERhdGFbMF07XG4gICAgICAgIGZvciAoaSA9IGkwOyBpIDwgaTE7IGkrKykge1xuICAgICAgICAgIGogPSBpIC0gKGkgPCBzaXplID8gMCA6IHNpemUpOy8vd3JhcCBhcm91bmRcbiAgICAgICAgICBsZW4gPSBjb2RlVGFibGVbal0uZmlyc3Q7XG4gICAgICAgICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgICAgIGNvZGVUYWJsZVtqXS5zZWNvbmQgPSAod29yZCA8PCBiaXRQb3MpID4+PiAoMzIgLSBsZW4pO1xuXG4gICAgICAgICAgICBpZiAoMzIgLSBiaXRQb3MgPj0gbGVuKSB7XG4gICAgICAgICAgICAgIGJpdFBvcyArPSBsZW47XG4gICAgICAgICAgICAgIGlmIChiaXRQb3MgPT09IDMyKSB7XG4gICAgICAgICAgICAgICAgYml0UG9zID0gMDtcbiAgICAgICAgICAgICAgICBzcmNQdHIrKztcbiAgICAgICAgICAgICAgICB3b3JkID0gc3R1ZmZlZERhdGFbc3JjUHRyXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGJpdFBvcyArPSBsZW4gLSAzMjtcbiAgICAgICAgICAgICAgc3JjUHRyKys7XG4gICAgICAgICAgICAgIHdvcmQgPSBzdHVmZmVkRGF0YVtzcmNQdHJdO1xuICAgICAgICAgICAgICBjb2RlVGFibGVbal0uc2Vjb25kIHw9IHdvcmQgPj4+ICgzMiAtIGJpdFBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9maW5pc2hlZCByZWFkaW5nIGNvZGUgdGFibGVcblxuICAgICAgICAvKiAqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgKiBidWlsZGluZyBsdXRcbiAgICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgdmFyIG51bUJpdHNMVVQgPSAwLCBudW1CaXRzTFVUUWljayA9IDA7XG4gICAgICAgIHZhciB0cmVlID0gbmV3IFRyZWVOb2RlKCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2RlVGFibGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoY29kZVRhYmxlW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG51bUJpdHNMVVQgPSBNYXRoLm1heChudW1CaXRzTFVULCBjb2RlVGFibGVbaV0uZmlyc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtQml0c0xVVCA+PSBCSVRTX01BWCkge1xuICAgICAgICAgIG51bUJpdHNMVVRRaWNrID0gQklUU19NQVg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbnVtQml0c0xVVFFpY2sgPSBudW1CaXRzTFVUO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZvciBkZWJ1Z2dpbmcgcHVycG9zZVxuICAgICAgICAvLyBpZiAobnVtQml0c0xVVCA+PSAzMCkge1xuICAgICAgICAvLyAgIGNvbnNvbGUubG9nKFwiV0FSbmluZywgbGFyZ2UgTlVNIExVVCBCSVRTIElTIFwiICsgbnVtQml0c0xVVCk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgdmFyIGRlY29kZUx1dCA9IFtdLCBlbnRyeSwgY29kZSwgbnVtRW50cmllcywgamosIGN1cnJlbnRCaXQsIG5vZGU7XG4gICAgICAgIGZvciAoaSA9IGkwOyBpIDwgaTE7IGkrKykge1xuICAgICAgICAgIGogPSBpIC0gKGkgPCBzaXplID8gMCA6IHNpemUpOy8vd3JhcCBhcm91bmRcbiAgICAgICAgICBsZW4gPSBjb2RlVGFibGVbal0uZmlyc3Q7XG4gICAgICAgICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgICAgIGVudHJ5ID0gW2xlbiwgal07XG4gICAgICAgICAgICBpZiAobGVuIDw9IG51bUJpdHNMVVRRaWNrKSB7XG4gICAgICAgICAgICAgIGNvZGUgPSBjb2RlVGFibGVbal0uc2Vjb25kIDw8IChudW1CaXRzTFVUUWljayAtIGxlbik7XG4gICAgICAgICAgICAgIG51bUVudHJpZXMgPSAxIDw8IChudW1CaXRzTFVUUWljayAtIGxlbik7XG4gICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBudW1FbnRyaWVzOyBrKyspIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVMdXRbY29kZSB8IGtdID0gZW50cnk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvL2J1aWxkIHRyZWVcbiAgICAgICAgICAgICAgY29kZSA9IGNvZGVUYWJsZVtqXS5zZWNvbmQ7XG4gICAgICAgICAgICAgIG5vZGUgPSB0cmVlO1xuICAgICAgICAgICAgICBmb3IgKGpqID0gbGVuIC0gMTsgamogPj0gMDsgamotLSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCaXQgPSBjb2RlID4+PiBqaiAmIDE7IC8vbm8gbGVmdCBzaGlmdCBhcyBsZW5ndGggY291bGQgYmUgMzAsMzFcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEJpdCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLnJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucmlnaHQgPSBuZXcgVHJlZU5vZGUoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmICghbm9kZS5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUubGVmdCA9IG5ldyBUcmVlTm9kZSgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGpqID09PSAwICYmICFub2RlLnZhbCkge1xuICAgICAgICAgICAgICAgICAgbm9kZS52YWwgPSBlbnRyeVsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkZWNvZGVMdXQ6IGRlY29kZUx1dCxcbiAgICAgICAgICBudW1CaXRzTFVUUWljazogbnVtQml0c0xVVFFpY2ssXG4gICAgICAgICAgbnVtQml0c0xVVDogbnVtQml0c0xVVCxcbiAgICAgICAgICB0cmVlOiB0cmVlLFxuICAgICAgICAgIHN0dWZmZWREYXRhOiBzdHVmZmVkRGF0YSxcbiAgICAgICAgICBzcmNQdHI6IHNyY1B0cixcbiAgICAgICAgICBiaXRQb3M6IGJpdFBvc1xuICAgICAgICB9O1xuICAgICAgfSxcblxuICAgICAgcmVhZEh1ZmZtYW46IGZ1bmN0aW9uKGlucHV0LCBkYXRhLCBPdXRQaXhlbFR5cGVBcnJheSwgdXNlQlNRRm9yT3V0cHV0RGltKSB7XG4gICAgICAgIHZhciBoZWFkZXJJbmZvID0gZGF0YS5oZWFkZXJJbmZvO1xuICAgICAgICB2YXIgbnVtRGltcyA9IGhlYWRlckluZm8ubnVtRGltcztcbiAgICAgICAgdmFyIGhlaWdodCA9IGRhdGEuaGVhZGVySW5mby5oZWlnaHQ7XG4gICAgICAgIHZhciB3aWR0aCA9IGRhdGEuaGVhZGVySW5mby53aWR0aDtcbiAgICAgICAgdmFyIG51bVBpeGVscyA9IHdpZHRoICogaGVpZ2h0O1xuICAgICAgICAvL3ZhciBzaXplX21heCA9IDEgPDwgQklUU19NQVg7XG4gICAgICAgIC8qICoqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAqIHJlYWRpbmcgaHVmZm1hbiBzdHJ1Y3R1cmUgaW5mb1xuICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICB2YXIgaHVmZm1hbkluZm8gPSB0aGlzLnJlYWRIdWZmbWFuVHJlZShpbnB1dCwgZGF0YSk7XG4gICAgICAgIHZhciBkZWNvZGVMdXQgPSBodWZmbWFuSW5mby5kZWNvZGVMdXQ7XG4gICAgICAgIHZhciB0cmVlID0gaHVmZm1hbkluZm8udHJlZTtcbiAgICAgICAgLy9zdHVmZmVkRGF0YSBpbmNsdWRlcyBodWZmbWFuIGhlYWRlcnNcbiAgICAgICAgdmFyIHN0dWZmZWREYXRhID0gaHVmZm1hbkluZm8uc3R1ZmZlZERhdGE7XG4gICAgICAgIHZhciBzcmNQdHIgPSBodWZmbWFuSW5mby5zcmNQdHI7XG4gICAgICAgIHZhciBiaXRQb3MgPSBodWZmbWFuSW5mby5iaXRQb3M7XG4gICAgICAgIHZhciBudW1CaXRzTFVUUWljayA9IGh1ZmZtYW5JbmZvLm51bUJpdHNMVVRRaWNrO1xuICAgICAgICB2YXIgbnVtQml0c0xVVCA9IGh1ZmZtYW5JbmZvLm51bUJpdHNMVVQ7XG4gICAgICAgIHZhciBvZmZzZXQgPSBkYXRhLmhlYWRlckluZm8uaW1hZ2VUeXBlID09PSAwID8gMTI4IDogMDtcbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgKiAgZGVjb2RlXG4gICAgICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgdmFyIG5vZGUsIHZhbCwgZGVsdGEsIG1hc2sgPSBkYXRhLnBpeGVscy5yZXN1bHRNYXNrLCB2YWxUbXAsIHZhbFRtcFF1aWNrLCBjdXJyZW50Qml0O1xuICAgICAgICB2YXIgaSwgaiwgaywgaWk7XG4gICAgICAgIHZhciBwcmV2VmFsID0gMDtcbiAgICAgICAgaWYgKGJpdFBvcyA+IDApIHtcbiAgICAgICAgICBzcmNQdHIrKztcbiAgICAgICAgICBiaXRQb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3b3JkID0gc3R1ZmZlZERhdGFbc3JjUHRyXTtcbiAgICAgICAgdmFyIGRlbHRhRW5jb2RlID0gZGF0YS5lbmNvZGVNb2RlID09PSAxO1xuICAgICAgICB2YXIgcmVzdWx0UGl4ZWxzQWxsRGltID0gbmV3IE91dFBpeGVsVHlwZUFycmF5KG51bVBpeGVscyAqIG51bURpbXMpO1xuICAgICAgICB2YXIgcmVzdWx0UGl4ZWxzID0gcmVzdWx0UGl4ZWxzQWxsRGltO1xuICAgICAgICB2YXIgaURpbTtcbiAgICAgICAgLy8gVE9ETzogcmVldmFsdWF0ZSB0aGUgbmVlZCB0byBrZWVwIGlubGluZWQgZGVjb2RpbmcgY29kZSBhcyBJRSBzdXBwb3J0IGlzIHBoYXNpbmcgb3V0XG4gICAgICAgIGlmIChudW1EaW1zIDwgMiB8fCBkZWx0YUVuY29kZSkge1xuICAgICAgICAgIGZvciAoaURpbSA9IDA7IGlEaW0gPCBudW1EaW1zOyBpRGltKyspIHtcbiAgICAgICAgICAgIGlmIChudW1EaW1zID4gMSkge1xuICAgICAgICAgICAgICAvL2dldCB0aGUgbWVtIGJsb2NrIG9mIGN1cnJlbnQgZGltZW5zaW9uXG4gICAgICAgICAgICAgIHJlc3VsdFBpeGVscyA9IG5ldyBPdXRQaXhlbFR5cGVBcnJheShyZXN1bHRQaXhlbHNBbGxEaW0uYnVmZmVyLCBudW1QaXhlbHMgKiBpRGltLCBudW1QaXhlbHMpO1xuICAgICAgICAgICAgICBwcmV2VmFsID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLmhlYWRlckluZm8ubnVtVmFsaWRQaXhlbCA9PT0gd2lkdGggKiBoZWlnaHQpIHsgLy9hbGwgdmFsaWRcbiAgICAgICAgICAgICAgZm9yIChrID0gMCwgaSA9IDA7IGkgPCBoZWlnaHQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB3aWR0aDsgaisrLCBrKyspIHtcbiAgICAgICAgICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgICAgICAgICAgICB2YWxUbXAgPSAod29yZCA8PCBiaXRQb3MpID4+PiAoMzIgLSBudW1CaXRzTFVUUWljayk7XG4gICAgICAgICAgICAgICAgICB2YWxUbXBRdWljayA9IHZhbFRtcDsvLyA+Pj4gZGVsdGFCaXRzO1xuICAgICAgICAgICAgICAgICAgaWYgKDMyIC0gYml0UG9zIDwgbnVtQml0c0xVVFFpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsVG1wIHw9ICgoc3R1ZmZlZERhdGFbc3JjUHRyICsgMV0pID4+PiAoNjQgLSBiaXRQb3MgLSBudW1CaXRzTFVUUWljaykpO1xuICAgICAgICAgICAgICAgICAgICB2YWxUbXBRdWljayA9IHZhbFRtcDsvLyA+Pj4gZGVsdGFCaXRzO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGRlY29kZUx1dFt2YWxUbXBRdWlja10pICAgIC8vIGlmIHRoZXJlLCBtb3ZlIHRoZSBjb3JyZWN0IG51bWJlciBvZiBiaXRzIGFuZCBkb25lXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IGRlY29kZUx1dFt2YWxUbXBRdWlja11bMV07XG4gICAgICAgICAgICAgICAgICAgIGJpdFBvcyArPSBkZWNvZGVMdXRbdmFsVG1wUXVpY2tdWzBdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbFRtcCA9ICh3b3JkIDw8IGJpdFBvcykgPj4+ICgzMiAtIG51bUJpdHNMVVQpO1xuICAgICAgICAgICAgICAgICAgICB2YWxUbXBRdWljayA9IHZhbFRtcDsvLyA+Pj4gZGVsdGFCaXRzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoMzIgLSBiaXRQb3MgPCBudW1CaXRzTFVUKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsVG1wIHw9ICgoc3R1ZmZlZERhdGFbc3JjUHRyICsgMV0pID4+PiAoNjQgLSBiaXRQb3MgLSBudW1CaXRzTFVUKSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsVG1wUXVpY2sgPSB2YWxUbXA7Ly8gPj4+IGRlbHRhQml0cztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBub2RlID0gdHJlZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpaSA9IDA7IGlpIDwgbnVtQml0c0xVVDsgaWkrKykge1xuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRCaXQgPSB2YWxUbXAgPj4+IChudW1CaXRzTFVUIC0gaWkgLSAxKSAmIDE7XG4gICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGN1cnJlbnRCaXQgPyBub2RlLnJpZ2h0IDogbm9kZS5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgIGlmICghKG5vZGUubGVmdCB8fCBub2RlLnJpZ2h0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gbm9kZS52YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBiaXRQb3MgPSBiaXRQb3MgKyBpaSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgIGlmIChiaXRQb3MgPj0gMzIpIHtcbiAgICAgICAgICAgICAgICAgICAgYml0UG9zIC09IDMyO1xuICAgICAgICAgICAgICAgICAgICBzcmNQdHIrKztcbiAgICAgICAgICAgICAgICAgICAgd29yZCA9IHN0dWZmZWREYXRhW3NyY1B0cl07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICBkZWx0YSA9IHZhbCAtIG9mZnNldDtcbiAgICAgICAgICAgICAgICAgIGlmIChkZWx0YUVuY29kZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICBkZWx0YSArPSBwcmV2VmFsOyAgICAvLyB1c2Ugb3ZlcmZsb3dcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIGRlbHRhICs9IHJlc3VsdFBpeGVsc1trIC0gd2lkdGhdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGRlbHRhICs9IHByZXZWYWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVsdGEgJj0gMHhGRjsgLy9vdmVyZmxvd1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRQaXhlbHNba10gPSBkZWx0YTsvL292ZXJmbG93XG4gICAgICAgICAgICAgICAgICAgIHByZXZWYWwgPSBkZWx0YTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRQaXhlbHNba10gPSBkZWx0YTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAvL25vdCBhbGwgdmFsaWQsIHVzZSBtYXNrXG4gICAgICAgICAgICAgIGZvciAoayA9IDAsIGkgPSAwOyBpIDwgaGVpZ2h0OyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgd2lkdGg7IGorKywgaysrKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobWFza1trXSkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YWxUbXAgPSAod29yZCA8PCBiaXRQb3MpID4+PiAoMzIgLSBudW1CaXRzTFVUUWljayk7XG4gICAgICAgICAgICAgICAgICAgIHZhbFRtcFF1aWNrID0gdmFsVG1wOy8vID4+PiBkZWx0YUJpdHM7XG4gICAgICAgICAgICAgICAgICAgIGlmICgzMiAtIGJpdFBvcyA8IG51bUJpdHNMVVRRaWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsVG1wIHw9ICgoc3R1ZmZlZERhdGFbc3JjUHRyICsgMV0pID4+PiAoNjQgLSBiaXRQb3MgLSBudW1CaXRzTFVUUWljaykpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhbFRtcFF1aWNrID0gdmFsVG1wOy8vID4+PiBkZWx0YUJpdHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlY29kZUx1dFt2YWxUbXBRdWlja10pICAgIC8vIGlmIHRoZXJlLCBtb3ZlIHRoZSBjb3JyZWN0IG51bWJlciBvZiBiaXRzIGFuZCBkb25lXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBkZWNvZGVMdXRbdmFsVG1wUXVpY2tdWzFdO1xuICAgICAgICAgICAgICAgICAgICAgIGJpdFBvcyArPSBkZWNvZGVMdXRbdmFsVG1wUXVpY2tdWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHZhbFRtcCA9ICh3b3JkIDw8IGJpdFBvcykgPj4+ICgzMiAtIG51bUJpdHNMVVQpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhbFRtcFF1aWNrID0gdmFsVG1wOy8vID4+PiBkZWx0YUJpdHM7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKDMyIC0gYml0UG9zIDwgbnVtQml0c0xVVCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsVG1wIHw9ICgoc3R1ZmZlZERhdGFbc3JjUHRyICsgMV0pID4+PiAoNjQgLSBiaXRQb3MgLSBudW1CaXRzTFVUKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxUbXBRdWljayA9IHZhbFRtcDsvLyA+Pj4gZGVsdGFCaXRzO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBub2RlID0gdHJlZTtcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKGlpID0gMDsgaWkgPCBudW1CaXRzTFVUOyBpaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Qml0ID0gdmFsVG1wID4+PiAobnVtQml0c0xVVCAtIGlpIC0gMSkgJiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGN1cnJlbnRCaXQgPyBub2RlLnJpZ2h0IDogbm9kZS5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobm9kZS5sZWZ0IHx8IG5vZGUucmlnaHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IG5vZGUudmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRQb3MgPSBiaXRQb3MgKyBpaSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoYml0UG9zID49IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYml0UG9zIC09IDMyO1xuICAgICAgICAgICAgICAgICAgICAgIHNyY1B0cisrO1xuICAgICAgICAgICAgICAgICAgICAgIHdvcmQgPSBzdHVmZmVkRGF0YVtzcmNQdHJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhID0gdmFsIC0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVsdGFFbmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaiA+IDAgJiYgbWFza1trIC0gMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhICs9IHByZXZWYWw7ICAgIC8vIHVzZSBvdmVyZmxvd1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpID4gMCAmJiBtYXNrW2sgLSB3aWR0aF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhICs9IHJlc3VsdFBpeGVsc1trIC0gd2lkdGhdO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhICs9IHByZXZWYWw7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgIGRlbHRhICY9IDB4RkY7IC8vb3ZlcmZsb3dcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHRQaXhlbHNba10gPSBkZWx0YTsvL292ZXJmbG93XG4gICAgICAgICAgICAgICAgICAgICAgcHJldlZhbCA9IGRlbHRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1trXSA9IGRlbHRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGZvciAoayA9IDAsIGkgPSAwOyBpIDwgaGVpZ2h0OyBpKyspIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB3aWR0aDsgaisrKSB7XG4gICAgICAgICAgICAgIGsgPSBpICogd2lkdGggKyBqO1xuICAgICAgICAgICAgICBpZiAoIW1hc2sgfHwgbWFza1trXSkge1xuICAgICAgICAgICAgICAgIGZvciAoaURpbSA9IDA7IGlEaW0gPCBudW1EaW1zOyBpRGltKyssIGsrPW51bVBpeGVscykge1xuICAgICAgICAgICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgICAgICAgICAgIHZhbFRtcCA9ICh3b3JkIDw8IGJpdFBvcykgPj4+ICgzMiAtIG51bUJpdHNMVVRRaWNrKTtcbiAgICAgICAgICAgICAgICAgIHZhbFRtcFF1aWNrID0gdmFsVG1wO1xuICAgICAgICAgICAgICAgICAgaWYgKDMyIC0gYml0UG9zIDwgbnVtQml0c0xVVFFpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsVG1wIHw9ICgoc3R1ZmZlZERhdGFbc3JjUHRyICsgMV0pID4+PiAoNjQgLSBiaXRQb3MgLSBudW1CaXRzTFVUUWljaykpO1xuICAgICAgICAgICAgICAgICAgICB2YWxUbXBRdWljayA9IHZhbFRtcDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChkZWNvZGVMdXRbdmFsVG1wUXVpY2tdKVxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSBkZWNvZGVMdXRbdmFsVG1wUXVpY2tdWzFdO1xuICAgICAgICAgICAgICAgICAgICBiaXRQb3MgKz0gZGVjb2RlTHV0W3ZhbFRtcFF1aWNrXVswXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWxUbXAgPSAod29yZCA8PCBiaXRQb3MpID4+PiAoMzIgLSBudW1CaXRzTFVUKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsVG1wUXVpY2sgPSB2YWxUbXA7XG4gICAgICAgICAgICAgICAgICAgIGlmICgzMiAtIGJpdFBvcyA8IG51bUJpdHNMVVQpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YWxUbXAgfD0gKChzdHVmZmVkRGF0YVtzcmNQdHIgKyAxXSkgPj4+ICg2NCAtIGJpdFBvcyAtIG51bUJpdHNMVVQpKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YWxUbXBRdWljayA9IHZhbFRtcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBub2RlID0gdHJlZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpaSA9IDA7IGlpIDwgbnVtQml0c0xVVDsgaWkrKykge1xuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRCaXQgPSB2YWxUbXAgPj4+IChudW1CaXRzTFVUIC0gaWkgLSAxKSAmIDE7XG4gICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGN1cnJlbnRCaXQgPyBub2RlLnJpZ2h0IDogbm9kZS5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgIGlmICghKG5vZGUubGVmdCB8fCBub2RlLnJpZ2h0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gbm9kZS52YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBiaXRQb3MgPSBiaXRQb3MgKyBpaSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWYgKGJpdFBvcyA+PSAzMikge1xuICAgICAgICAgICAgICAgICAgICBiaXRQb3MgLT0gMzI7XG4gICAgICAgICAgICAgICAgICAgIHNyY1B0cisrO1xuICAgICAgICAgICAgICAgICAgICB3b3JkID0gc3R1ZmZlZERhdGFbc3JjUHRyXTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgZGVsdGEgPSB2YWwgLSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICByZXN1bHRQaXhlbHNba10gPSBkZWx0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGF0YS5wdHIgPSBkYXRhLnB0ciArIChzcmNQdHIgKyAxKSAqIDQgKyAoYml0UG9zID4gMCA/IDQgOiAwKTtcbiAgICAgICAgZGF0YS5waXhlbHMucmVzdWx0UGl4ZWxzID0gcmVzdWx0UGl4ZWxzQWxsRGltO1xuICAgICAgICAvL3N3YXAgZm9yIEJJUCBsYXlvdXRcbiAgICAgICAgaWYgKG51bURpbXMgPiAxICYmICF1c2VCU1FGb3JPdXRwdXREaW0pIHtcbiAgICAgICAgICBkYXRhLnBpeGVscy5yZXN1bHRQaXhlbHMgPSBMZXJjMkhlbHBlcnMuc3dhcERpbWVuc2lvbk9yZGVyKHJlc3VsdFBpeGVsc0FsbERpbSwgbnVtUGl4ZWxzLCBudW1EaW1zLCBPdXRQaXhlbFR5cGVBcnJheSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGRlY29kZUJpdHM6IGZ1bmN0aW9uKGlucHV0LCBkYXRhLCBibG9ja0RhdGFCdWZmZXIsIG9mZnNldCwgaURpbSkge1xuICAgICAgICB7XG4gICAgICAgICAgLy9iaXRzdHVmZiBlbmNvZGluZyBpcyAzXG4gICAgICAgICAgdmFyIGhlYWRlckluZm8gPSBkYXRhLmhlYWRlckluZm87XG4gICAgICAgICAgdmFyIGZpbGVWZXJzaW9uID0gaGVhZGVySW5mby5maWxlVmVyc2lvbjtcbiAgICAgICAgICAvL3ZhciBibG9jayA9IHt9O1xuICAgICAgICAgIHZhciBibG9ja1B0ciA9IDA7XG4gICAgICAgICAgdmFyIHZpZXdCeXRlTGVuZ3RoID0gKChpbnB1dC5ieXRlTGVuZ3RoIC0gZGF0YS5wdHIpID49IDUpID8gNSA6IChpbnB1dC5ieXRlTGVuZ3RoIC0gZGF0YS5wdHIpO1xuICAgICAgICAgIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KGlucHV0LCBkYXRhLnB0ciwgdmlld0J5dGVMZW5ndGgpO1xuICAgICAgICAgIHZhciBoZWFkZXJCeXRlID0gdmlldy5nZXRVaW50OCgwKTtcbiAgICAgICAgICBibG9ja1B0cisrO1xuICAgICAgICAgIHZhciBiaXRzNjcgPSBoZWFkZXJCeXRlID4+IDY7XG4gICAgICAgICAgdmFyIG4gPSAoYml0czY3ID09PSAwKSA/IDQgOiAzIC0gYml0czY3O1xuICAgICAgICAgIHZhciBkb0x1dCA9IChoZWFkZXJCeXRlICYgMzIpID4gMCA/IHRydWUgOiBmYWxzZTsvLzV0aCBiaXRcbiAgICAgICAgICB2YXIgbnVtQml0cyA9IGhlYWRlckJ5dGUgJiAzMTtcbiAgICAgICAgICB2YXIgbnVtRWxlbWVudHMgPSAwO1xuICAgICAgICAgIGlmIChuID09PSAxKSB7XG4gICAgICAgICAgICBudW1FbGVtZW50cyA9IHZpZXcuZ2V0VWludDgoYmxvY2tQdHIpOyBibG9ja1B0cisrO1xuICAgICAgICAgIH0gZWxzZSBpZiAobiA9PT0gMikge1xuICAgICAgICAgICAgbnVtRWxlbWVudHMgPSB2aWV3LmdldFVpbnQxNihibG9ja1B0ciwgdHJ1ZSk7IGJsb2NrUHRyICs9IDI7XG4gICAgICAgICAgfSBlbHNlIGlmIChuID09PSA0KSB7XG4gICAgICAgICAgICBudW1FbGVtZW50cyA9IHZpZXcuZ2V0VWludDMyKGJsb2NrUHRyLCB0cnVlKTsgYmxvY2tQdHIgKz0gNDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIHZhbGlkIHBpeGVsIGNvdW50IHR5cGVcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy9maXg6IGh1ZmZtYW4gY29kZXMgYXJlIGJpdCBzdHVmZmVkLCBidXQgbm90IGJvdW5kIGJ5IGRhdGEncyBtYXggdmFsdWUsIHNvIG5lZWQgdG8gdXNlIG9yaWdpbmFsVW5zdHVmZlxuICAgICAgICAgIC8vb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gICAgICAgICAgdmFyIHNjYWxlID0gMiAqIGhlYWRlckluZm8ubWF4WkVycm9yO1xuICAgICAgICAgIHZhciBzdHVmZmVkRGF0YSwgYXJyYXlCdWYsIHN0b3JlOCwgZGF0YUJ5dGVzLCBkYXRhV29yZHM7XG4gICAgICAgICAgdmFyIGx1dEFyciwgbHV0RGF0YSwgbHV0Qnl0ZXMsIGx1dEJpdHNQZXJFbGVtZW50LCBiaXRzUGVyUGl4ZWw7XG4gICAgICAgICAgdmFyIHpNYXggPSBoZWFkZXJJbmZvLm51bURpbXMgPiAxID8gaGVhZGVySW5mby5tYXhWYWx1ZXNbaURpbV0gOiBoZWFkZXJJbmZvLnpNYXg7XG4gICAgICAgICAgaWYgKGRvTHV0KSB7XG4gICAgICAgICAgICBkYXRhLmNvdW50ZXIubHV0Kys7XG4gICAgICAgICAgICBsdXRCeXRlcyA9IHZpZXcuZ2V0VWludDgoYmxvY2tQdHIpO1xuICAgICAgICAgICAgbHV0Qml0c1BlckVsZW1lbnQgPSBudW1CaXRzO1xuICAgICAgICAgICAgYmxvY2tQdHIrKztcbiAgICAgICAgICAgIGRhdGFCeXRlcyA9IE1hdGguY2VpbCgobHV0Qnl0ZXMgLSAxKSAqIG51bUJpdHMgLyA4KTtcbiAgICAgICAgICAgIGRhdGFXb3JkcyA9IE1hdGguY2VpbChkYXRhQnl0ZXMgLyA0KTtcbiAgICAgICAgICAgIGFycmF5QnVmID0gbmV3IEFycmF5QnVmZmVyKGRhdGFXb3JkcyAqIDQpO1xuICAgICAgICAgICAgc3RvcmU4ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWYpO1xuXG4gICAgICAgICAgICBkYXRhLnB0ciArPSBibG9ja1B0cjtcbiAgICAgICAgICAgIHN0b3JlOC5zZXQobmV3IFVpbnQ4QXJyYXkoaW5wdXQsIGRhdGEucHRyLCBkYXRhQnl0ZXMpKTtcblxuICAgICAgICAgICAgbHV0RGF0YSA9IG5ldyBVaW50MzJBcnJheShhcnJheUJ1Zik7XG4gICAgICAgICAgICBkYXRhLnB0ciArPSBkYXRhQnl0ZXM7XG5cbiAgICAgICAgICAgIGJpdHNQZXJQaXhlbCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoKGx1dEJ5dGVzIC0gMSkgPj4+IGJpdHNQZXJQaXhlbCkge1xuICAgICAgICAgICAgICBiaXRzUGVyUGl4ZWwrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGFCeXRlcyA9IE1hdGguY2VpbChudW1FbGVtZW50cyAqIGJpdHNQZXJQaXhlbCAvIDgpO1xuICAgICAgICAgICAgZGF0YVdvcmRzID0gTWF0aC5jZWlsKGRhdGFCeXRlcyAvIDQpO1xuICAgICAgICAgICAgYXJyYXlCdWYgPSBuZXcgQXJyYXlCdWZmZXIoZGF0YVdvcmRzICogNCk7XG4gICAgICAgICAgICBzdG9yZTggPSBuZXcgVWludDhBcnJheShhcnJheUJ1Zik7XG4gICAgICAgICAgICBzdG9yZTguc2V0KG5ldyBVaW50OEFycmF5KGlucHV0LCBkYXRhLnB0ciwgZGF0YUJ5dGVzKSk7XG4gICAgICAgICAgICBzdHVmZmVkRGF0YSA9IG5ldyBVaW50MzJBcnJheShhcnJheUJ1Zik7XG4gICAgICAgICAgICBkYXRhLnB0ciArPSBkYXRhQnl0ZXM7XG4gICAgICAgICAgICBpZiAoZmlsZVZlcnNpb24gPj0gMykge1xuICAgICAgICAgICAgICBsdXRBcnIgPSBCaXRTdHVmZmVyLnVuc3R1ZmZMVVQyKGx1dERhdGEsIG51bUJpdHMsIGx1dEJ5dGVzIC0gMSwgb2Zmc2V0LCBzY2FsZSwgek1heCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgbHV0QXJyID0gQml0U3R1ZmZlci51bnN0dWZmTFVUKGx1dERhdGEsIG51bUJpdHMsIGx1dEJ5dGVzIC0gMSwgb2Zmc2V0LCBzY2FsZSwgek1heCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2x1dEFyci51bnNoaWZ0KDApO1xuICAgICAgICAgICAgaWYgKGZpbGVWZXJzaW9uID49IDMpIHtcbiAgICAgICAgICAgICAgLy9CaXRTdHVmZmVyLnVuc3R1ZmYyKGJsb2NrLCBibG9ja0RhdGFCdWZmZXIsIGhlYWRlckluZm8uek1heCk7XG4gICAgICAgICAgICAgIEJpdFN0dWZmZXIudW5zdHVmZjIoc3R1ZmZlZERhdGEsIGJsb2NrRGF0YUJ1ZmZlciwgYml0c1BlclBpeGVsLCBudW1FbGVtZW50cywgbHV0QXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBCaXRTdHVmZmVyLnVuc3R1ZmYoc3R1ZmZlZERhdGEsIGJsb2NrRGF0YUJ1ZmZlciwgYml0c1BlclBpeGVsLCBudW1FbGVtZW50cywgbHV0QXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUuZGVidWcoXCJiaXRzdHVmZmVyXCIpO1xuICAgICAgICAgICAgZGF0YS5jb3VudGVyLmJpdHN0dWZmZXIrKztcbiAgICAgICAgICAgIGJpdHNQZXJQaXhlbCA9IG51bUJpdHM7XG4gICAgICAgICAgICBkYXRhLnB0ciArPSBibG9ja1B0cjtcbiAgICAgICAgICAgIGlmIChiaXRzUGVyUGl4ZWwgPiAwKSB7XG4gICAgICAgICAgICAgIGRhdGFCeXRlcyA9IE1hdGguY2VpbChudW1FbGVtZW50cyAqIGJpdHNQZXJQaXhlbCAvIDgpO1xuICAgICAgICAgICAgICBkYXRhV29yZHMgPSBNYXRoLmNlaWwoZGF0YUJ5dGVzIC8gNCk7XG4gICAgICAgICAgICAgIGFycmF5QnVmID0gbmV3IEFycmF5QnVmZmVyKGRhdGFXb3JkcyAqIDQpO1xuICAgICAgICAgICAgICBzdG9yZTggPSBuZXcgVWludDhBcnJheShhcnJheUJ1Zik7XG4gICAgICAgICAgICAgIHN0b3JlOC5zZXQobmV3IFVpbnQ4QXJyYXkoaW5wdXQsIGRhdGEucHRyLCBkYXRhQnl0ZXMpKTtcbiAgICAgICAgICAgICAgc3R1ZmZlZERhdGEgPSBuZXcgVWludDMyQXJyYXkoYXJyYXlCdWYpO1xuICAgICAgICAgICAgICBkYXRhLnB0ciArPSBkYXRhQnl0ZXM7XG4gICAgICAgICAgICAgIGlmIChmaWxlVmVyc2lvbiA+PSAzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBCaXRTdHVmZmVyLm9yaWdpbmFsVW5zdHVmZjIoc3R1ZmZlZERhdGEsIGJsb2NrRGF0YUJ1ZmZlciwgYml0c1BlclBpeGVsLCBudW1FbGVtZW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgQml0U3R1ZmZlci51bnN0dWZmMihzdHVmZmVkRGF0YSwgYmxvY2tEYXRhQnVmZmVyLCBiaXRzUGVyUGl4ZWwsIG51bUVsZW1lbnRzLCBmYWxzZSwgb2Zmc2V0LCBzY2FsZSwgek1heCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgQml0U3R1ZmZlci5vcmlnaW5hbFVuc3R1ZmYoc3R1ZmZlZERhdGEsIGJsb2NrRGF0YUJ1ZmZlciwgYml0c1BlclBpeGVsLCBudW1FbGVtZW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgQml0U3R1ZmZlci51bnN0dWZmKHN0dWZmZWREYXRhLCBibG9ja0RhdGFCdWZmZXIsIGJpdHNQZXJQaXhlbCwgbnVtRWxlbWVudHMsIGZhbHNlLCBvZmZzZXQsIHNjYWxlLCB6TWF4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgfSxcblxuICAgICAgcmVhZFRpbGVzOiBmdW5jdGlvbihpbnB1dCwgZGF0YSwgT3V0UGl4ZWxUeXBlQXJyYXksIHVzZUJTUUZvck91dHB1dERpbSkge1xuICAgICAgICB2YXIgaGVhZGVySW5mbyA9IGRhdGEuaGVhZGVySW5mbztcbiAgICAgICAgdmFyIHdpZHRoID0gaGVhZGVySW5mby53aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IGhlYWRlckluZm8uaGVpZ2h0O1xuICAgICAgICB2YXIgbnVtUGl4ZWxzID0gd2lkdGggKiBoZWlnaHQ7XG4gICAgICAgIHZhciBtaWNyb0Jsb2NrU2l6ZSA9IGhlYWRlckluZm8ubWljcm9CbG9ja1NpemU7XG4gICAgICAgIHZhciBpbWFnZVR5cGUgPSBoZWFkZXJJbmZvLmltYWdlVHlwZTtcbiAgICAgICAgdmFyIGRhdGFUeXBlU2l6ZSA9IExlcmMySGVscGVycy5nZXREYXRhVHlwZVNpemUoaW1hZ2VUeXBlKTtcbiAgICAgICAgdmFyIG51bUJsb2Nrc1ggPSBNYXRoLmNlaWwod2lkdGggLyBtaWNyb0Jsb2NrU2l6ZSk7XG4gICAgICAgIHZhciBudW1CbG9ja3NZID0gTWF0aC5jZWlsKGhlaWdodCAvIG1pY3JvQmxvY2tTaXplKTtcbiAgICAgICAgZGF0YS5waXhlbHMubnVtQmxvY2tzWSA9IG51bUJsb2Nrc1k7XG4gICAgICAgIGRhdGEucGl4ZWxzLm51bUJsb2Nrc1ggPSBudW1CbG9ja3NYO1xuICAgICAgICBkYXRhLnBpeGVscy5wdHIgPSAwO1xuICAgICAgICB2YXIgcm93ID0gMCwgY29sID0gMCwgYmxvY2tZID0gMCwgYmxvY2tYID0gMCwgdGhpc0Jsb2NrSGVpZ2h0ID0gMCwgdGhpc0Jsb2NrV2lkdGggPSAwLCBieXRlc0xlZnQgPSAwLCBoZWFkZXJCeXRlID0gMCwgYml0czY3ID0gMCwgdGVzdENvZGUgPSAwLCBvdXRQdHIgPSAwLCBvdXRTdHJpZGUgPSAwLCBudW1CeXRlcyA9IDAsIGJ5dGVzbGVmdCA9IDAsIHogPSAwLCBibG9ja1B0ciA9IDA7XG4gICAgICAgIHZhciB2aWV3LCBibG9jaywgYXJyYXlCdWYsIHN0b3JlOCwgcmF3RGF0YTtcbiAgICAgICAgdmFyIGJsb2NrRW5jb2Rpbmc7XG4gICAgICAgIHZhciBibG9ja0RhdGFCdWZmZXIgPSBuZXcgT3V0UGl4ZWxUeXBlQXJyYXkobWljcm9CbG9ja1NpemUgKiBtaWNyb0Jsb2NrU2l6ZSk7XG4gICAgICAgIHZhciBsYXN0QmxvY2tIZWlnaHQgPSAoaGVpZ2h0ICUgbWljcm9CbG9ja1NpemUpIHx8IG1pY3JvQmxvY2tTaXplO1xuICAgICAgICB2YXIgbGFzdEJsb2NrV2lkdGggPSAod2lkdGggJSBtaWNyb0Jsb2NrU2l6ZSkgfHwgbWljcm9CbG9ja1NpemU7XG4gICAgICAgIHZhciBvZmZzZXRUeXBlLCBvZmZzZXQ7XG4gICAgICAgIHZhciBudW1EaW1zID0gaGVhZGVySW5mby5udW1EaW1zLCBpRGltO1xuICAgICAgICB2YXIgbWFzayA9IGRhdGEucGl4ZWxzLnJlc3VsdE1hc2s7XG4gICAgICAgIHZhciByZXN1bHRQaXhlbHMgPSBkYXRhLnBpeGVscy5yZXN1bHRQaXhlbHM7XG4gICAgICAgIHZhciBmaWxlVmVyc2lvbiA9IGhlYWRlckluZm8uZmlsZVZlcnNpb247XG4gICAgICAgIHZhciBmaWxlVmVyc2lvbkNoZWNrTnVtID0gZmlsZVZlcnNpb24gPj0gNSA/IDE0IDogMTU7XG4gICAgICAgIHZhciBpc0RpZmZFbmNvZGluZztcbiAgICAgICAgdmFyIHpNYXggPSBoZWFkZXJJbmZvLnpNYXg7XG4gICAgICAgIC8vdmFyIHJlc3VsdFBpeGVsc0FsbERpbSA9IHJlc3VsdFBpeGVscztcbiAgICAgICAgdmFyIHJlc3VsdFBpeGVsc1ByZXZEaW07XG4gICAgICAgIGZvciAoYmxvY2tZID0gMDsgYmxvY2tZIDwgbnVtQmxvY2tzWTsgYmxvY2tZKyspIHtcbiAgICAgICAgICB0aGlzQmxvY2tIZWlnaHQgPSAoYmxvY2tZICE9PSBudW1CbG9ja3NZIC0gMSkgPyBtaWNyb0Jsb2NrU2l6ZSA6IGxhc3RCbG9ja0hlaWdodDtcbiAgICAgICAgICBmb3IgKGJsb2NrWCA9IDA7IGJsb2NrWCA8IG51bUJsb2Nrc1g7IGJsb2NrWCsrKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUuZGVidWcoXCJ5XCIgKyBibG9ja1kgKyBcIiB4XCIgKyBibG9ja1gpO1xuICAgICAgICAgICAgdGhpc0Jsb2NrV2lkdGggPSAoYmxvY2tYICE9PSBudW1CbG9ja3NYIC0gMSkgPyBtaWNyb0Jsb2NrU2l6ZSA6IGxhc3RCbG9ja1dpZHRoO1xuXG4gICAgICAgICAgICBvdXRQdHIgPSBibG9ja1kgKiB3aWR0aCAqIG1pY3JvQmxvY2tTaXplICsgYmxvY2tYICogbWljcm9CbG9ja1NpemU7XG4gICAgICAgICAgICBvdXRTdHJpZGUgPSB3aWR0aCAtIHRoaXNCbG9ja1dpZHRoO1xuXG4gICAgICAgICAgICBmb3IgKGlEaW0gPSAwOyBpRGltIDwgbnVtRGltczsgaURpbSsrKSB7XG4gICAgICAgICAgICAgIGlmIChudW1EaW1zID4gMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1ByZXZEaW0gPSByZXN1bHRQaXhlbHM7XG4gICAgICAgICAgICAgICAgb3V0UHRyID0gYmxvY2tZICogd2lkdGggKiBtaWNyb0Jsb2NrU2l6ZSArIGJsb2NrWCAqIG1pY3JvQmxvY2tTaXplO1xuICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVscyA9IG5ldyBPdXRQaXhlbFR5cGVBcnJheShkYXRhLnBpeGVscy5yZXN1bHRQaXhlbHMuYnVmZmVyLCBudW1QaXhlbHMgKiBpRGltICogZGF0YVR5cGVTaXplLCBudW1QaXhlbHMpO1xuICAgICAgICAgICAgICAgIHpNYXggPSBoZWFkZXJJbmZvLm1heFZhbHVlc1tpRGltXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRQaXhlbHNQcmV2RGltID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBieXRlc0xlZnQgPSBpbnB1dC5ieXRlTGVuZ3RoIC0gZGF0YS5wdHI7XG4gICAgICAgICAgICAgIHZpZXcgPSBuZXcgRGF0YVZpZXcoaW5wdXQsIGRhdGEucHRyLCBNYXRoLm1pbigxMCwgYnl0ZXNMZWZ0KSk7XG4gICAgICAgICAgICAgIGJsb2NrID0ge307XG4gICAgICAgICAgICAgIGJsb2NrUHRyID0gMDtcbiAgICAgICAgICAgICAgaGVhZGVyQnl0ZSA9IHZpZXcuZ2V0VWludDgoMCk7XG4gICAgICAgICAgICAgIGJsb2NrUHRyKys7XG4gICAgICAgICAgICAgIGlzRGlmZkVuY29kaW5nID0gaGVhZGVySW5mby5maWxlVmVyc2lvbiA+PSA1ID8gaGVhZGVyQnl0ZSAmIDQgOiAwO1xuICAgICAgICAgICAgICBiaXRzNjcgPSAoaGVhZGVyQnl0ZSA+PiA2KSAmIDB4RkY7XG4gICAgICAgICAgICAgIHRlc3RDb2RlID0gKGhlYWRlckJ5dGUgPj4gMikgJiBmaWxlVmVyc2lvbkNoZWNrTnVtOyAgICAvLyB1c2UgYml0cyAyMzQ1IGZvciBpbnRlZ3JpdHkgY2hlY2tcbiAgICAgICAgICAgICAgaWYgKHRlc3RDb2RlICE9PSAoKChibG9ja1ggKiBtaWNyb0Jsb2NrU2l6ZSkgPj4gMykgJiBmaWxlVmVyc2lvbkNoZWNrTnVtKSkge1xuICAgICAgICAgICAgICAgIHRocm93IFwiaW50ZWdyaXR5IGlzc3VlXCI7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoaXNEaWZmRW5jb2RpbmcgJiYgaURpbSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IFwiaW50ZWdyaXR5IGlzc3VlXCI7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBibG9ja0VuY29kaW5nID0gaGVhZGVyQnl0ZSAmIDM7XG4gICAgICAgICAgICAgIGlmIChibG9ja0VuY29kaW5nID4gMykge1xuICAgICAgICAgICAgICAgIGRhdGEucHRyICs9IGJsb2NrUHRyO1xuICAgICAgICAgICAgICAgIHRocm93IFwiSW52YWxpZCBibG9jayBlbmNvZGluZyAoXCIgKyBibG9ja0VuY29kaW5nICsgXCIpXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoYmxvY2tFbmNvZGluZyA9PT0gMikgeyAvL2NvbnN0YW50IDBcbiAgICAgICAgICAgICAgICBpZiAoaXNEaWZmRW5jb2RpbmcpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgdGhpc0Jsb2NrSGVpZ2h0OyByb3crKykge1xuICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29sID0gMDsgY29sIDwgdGhpc0Jsb2NrV2lkdGg7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFza1tvdXRQdHJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1tvdXRQdHJdID0gcmVzdWx0UGl4ZWxzUHJldkRpbVtvdXRQdHJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0UHRyKys7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPCB0aGlzQmxvY2tIZWlnaHQ7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCB0aGlzQmxvY2tXaWR0aDsgY29sKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1tvdXRQdHJdID0gcmVzdWx0UGl4ZWxzUHJldkRpbVtvdXRQdHJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0UHRyKys7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRhdGEuY291bnRlci5jb25zdGFudCsrO1xuICAgICAgICAgICAgICAgIGRhdGEucHRyICs9IGJsb2NrUHRyO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGJsb2NrRW5jb2RpbmcgPT09IDApIHsgIC8vdW5jb21wcmVzc2VkXG4gICAgICAgICAgICAgICAgaWYgKGlzRGlmZkVuY29kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAvLyBkb2Vzbid0IG1ha2Ugc2Vuc2UsIHNob3VsZCBub3QgaGFwcGVuXG4gICAgICAgICAgICAgICAgICB0aHJvdyBcImludGVncml0eSBpc3N1ZVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRhLmNvdW50ZXIudW5jb21wcmVzc2VkKys7XG4gICAgICAgICAgICAgICAgZGF0YS5wdHIgKz0gYmxvY2tQdHI7XG4gICAgICAgICAgICAgICAgbnVtQnl0ZXMgPSB0aGlzQmxvY2tIZWlnaHQgKiB0aGlzQmxvY2tXaWR0aCAqIGRhdGFUeXBlU2l6ZTtcbiAgICAgICAgICAgICAgICBieXRlc2xlZnQgPSBpbnB1dC5ieXRlTGVuZ3RoIC0gZGF0YS5wdHI7XG4gICAgICAgICAgICAgICAgbnVtQnl0ZXMgPSBudW1CeXRlcyA8IGJ5dGVzbGVmdCA/IG51bUJ5dGVzIDogYnl0ZXNsZWZ0O1xuICAgICAgICAgICAgICAgIC8vYml0IGFsaWdubWVudFxuICAgICAgICAgICAgICAgIGFycmF5QnVmID0gbmV3IEFycmF5QnVmZmVyKChudW1CeXRlcyAlIGRhdGFUeXBlU2l6ZSkgPT09IDAgPyBudW1CeXRlcyA6IChudW1CeXRlcyArIGRhdGFUeXBlU2l6ZSAtIG51bUJ5dGVzICUgZGF0YVR5cGVTaXplKSk7XG4gICAgICAgICAgICAgICAgc3RvcmU4ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWYpO1xuICAgICAgICAgICAgICAgIHN0b3JlOC5zZXQobmV3IFVpbnQ4QXJyYXkoaW5wdXQsIGRhdGEucHRyLCBudW1CeXRlcykpO1xuICAgICAgICAgICAgICAgIHJhd0RhdGEgPSBuZXcgT3V0UGl4ZWxUeXBlQXJyYXkoYXJyYXlCdWYpO1xuICAgICAgICAgICAgICAgIHogPSAwO1xuICAgICAgICAgICAgICAgIGlmIChtYXNrKSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IHRoaXNCbG9ja0hlaWdodDsgcm93KyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCB0aGlzQmxvY2tXaWR0aDsgY29sKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAobWFza1tvdXRQdHJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRQaXhlbHNbb3V0UHRyXSA9IHJhd0RhdGFbeisrXTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgb3V0UHRyKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3V0UHRyICs9IG91dFN0cmlkZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7Ly9hbGwgdmFsaWRcbiAgICAgICAgICAgICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgdGhpc0Jsb2NrSGVpZ2h0OyByb3crKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IHRoaXNCbG9ja1dpZHRoOyBjb2wrKykge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1tvdXRQdHIrK10gPSByYXdEYXRhW3orK107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3V0UHRyICs9IG91dFN0cmlkZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YS5wdHIgKz0geiAqIGRhdGFUeXBlU2l6ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHsgLy8xIG9yIDNcbiAgICAgICAgICAgICAgICBvZmZzZXRUeXBlID0gTGVyYzJIZWxwZXJzLmdldERhdGFUeXBlVXNlZCgoaXNEaWZmRW5jb2RpbmcgJiYgaW1hZ2VUeXBlIDwgNikgPyA0IDogaW1hZ2VUeXBlLCBiaXRzNjcpO1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IExlcmMySGVscGVycy5nZXRPbmVQaXhlbChibG9jaywgYmxvY2tQdHIsIG9mZnNldFR5cGUsIHZpZXcpO1xuICAgICAgICAgICAgICAgIGJsb2NrUHRyICs9IExlcmMySGVscGVycy5nZXREYXRhVHlwZVNpemUob2Zmc2V0VHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrRW5jb2RpbmcgPT09IDMpIC8vY29uc3RhbnQgb2Zmc2V0IHZhbHVlXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgZGF0YS5wdHIgKz0gYmxvY2tQdHI7XG4gICAgICAgICAgICAgICAgICBkYXRhLmNvdW50ZXIuY29uc3RhbnRvZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgIC8veW91IGNhbiBkZWxldGUgdGhlIGZvbGxvd2luZyByZXN1bHRNYXNrIGNhc2UgaW4gZmF2b3Igb2YgcGVyZm9ybWFuY2UgYmVjYXVzZSB2YWwgaXMgY29uc3RhbnQgYW5kIHVzZXJzIHVzZSBub2RhdGEgbWFzaywgb3RoZXJ3aXNlIG5vZGF0YXZhbHVlIHBvc3QgcHJvY2Vzc2luZyBoYW5kbGVzIGl0IHRvby5cbiAgICAgICAgICAgICAgICAgIC8vd2hpbGUgdGhlIGFib3ZlIHN0YXRlbWVudCBpcyB0cnVlLCB3ZSdyZSBub3QgZG9pbmcgaXQgYXMgd2Ugd2FudCB0byBrZWVwIGludmFsaWQgcGl4ZWwgdmFsdWUgYXQgMCByYXRoZXIgdGhhbiBhcmJpdHJhcnkgdmFsdWVzXG4gICAgICAgICAgICAgICAgICBpZiAobWFzaykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IHRoaXNCbG9ja0hlaWdodDsgcm93KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IHRoaXNCbG9ja1dpZHRoOyBjb2wrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hc2tbb3V0UHRyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRQaXhlbHNbb3V0UHRyXSA9IGlzRGlmZkVuY29kaW5nID8gTWF0aC5taW4oek1heCwgcmVzdWx0UGl4ZWxzUHJldkRpbVtvdXRQdHJdICsgb2Zmc2V0KSA6IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG91dFB0cisrO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBvdXRQdHIgKz0gb3V0U3RyaWRlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPCB0aGlzQmxvY2tIZWlnaHQ7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCB0aGlzQmxvY2tXaWR0aDsgY29sKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1tvdXRQdHJdID0gaXNEaWZmRW5jb2RpbmcgPyBNYXRoLm1pbih6TWF4LCByZXN1bHRQaXhlbHNQcmV2RGltW291dFB0cl0gKyBvZmZzZXQpIDogb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0UHRyKys7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIG91dFB0ciArPSBvdXRTdHJpZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7IC8vYml0c3R1ZmYgZW5jb2RpbmcgaXMgM1xuICAgICAgICAgICAgICAgICAgZGF0YS5wdHIgKz0gYmxvY2tQdHI7XG4gICAgICAgICAgICAgICAgICAvL2hlYXZ5IGxpZnRpbmdcbiAgICAgICAgICAgICAgICAgIExlcmMySGVscGVycy5kZWNvZGVCaXRzKGlucHV0LCBkYXRhLCBibG9ja0RhdGFCdWZmZXIsIG9mZnNldCwgaURpbSk7XG4gICAgICAgICAgICAgICAgICBibG9ja1B0ciA9IDA7XG4gICAgICAgICAgICAgICAgICAvLyBkdXBsaWNhdGUgY29kZSB0byBmYXZvciBwZXJmb3JtYW5jZSwgZGlmZiBlbmNvZGluZyBpcyBmb3IgbXVsdGlkaW1lbnNpb24gb25seVxuICAgICAgICAgICAgICAgICAgaWYgKGlzRGlmZkVuY29kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPCB0aGlzQmxvY2tIZWlnaHQ7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IHRoaXNCbG9ja1dpZHRoOyBjb2wrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFza1tvdXRQdHJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzW291dFB0cl0gPSBibG9ja0RhdGFCdWZmZXJbYmxvY2tQdHIrK10gKyByZXN1bHRQaXhlbHNQcmV2RGltW291dFB0cl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0UHRyKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRQdHIgKz0gb3V0U3RyaWRlO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IHRoaXNCbG9ja0hlaWdodDsgcm93KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29sID0gMDsgY29sIDwgdGhpc0Jsb2NrV2lkdGg7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1tvdXRQdHJdID0gYmxvY2tEYXRhQnVmZmVyW2Jsb2NrUHRyKytdICsgcmVzdWx0UGl4ZWxzUHJldkRpbVtvdXRQdHJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRQdHIrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG91dFB0ciArPSBvdXRTdHJpZGU7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgdGhpc0Jsb2NrSGVpZ2h0OyByb3crKykge1xuICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29sID0gMDsgY29sIDwgdGhpc0Jsb2NrV2lkdGg7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFza1tvdXRQdHJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1tvdXRQdHJdID0gYmxvY2tEYXRhQnVmZmVyW2Jsb2NrUHRyKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0UHRyKys7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIG91dFB0ciArPSBvdXRTdHJpZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IHRoaXNCbG9ja0hlaWdodDsgcm93KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IHRoaXNCbG9ja1dpZHRoOyBjb2wrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzW291dFB0cisrXSA9IGJsb2NrRGF0YUJ1ZmZlcltibG9ja1B0cisrXTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgb3V0UHRyICs9IG91dFN0cmlkZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvL3N3YXAgZm9yIEJJUDogaXQncyBhbHdheXMgZWFzaWVyIGZvciBjbGllbnRzIHRvIGhhbmRsZSBCU1Egc28gd2Uga2VlcCBleGlzdGluZyBsb2dpYyBhbmQgaW50cm9kdWNlIGEgc3dhcCBoZXJlIHRvIG1pbmltemUgY2hhbmdlc1xuICAgICAgICBpZiAobnVtRGltcyA+IDEgJiYgIXVzZUJTUUZvck91dHB1dERpbSkge1xuICAgICAgICAgIGRhdGEucGl4ZWxzLnJlc3VsdFBpeGVscyA9IExlcmMySGVscGVycy5zd2FwRGltZW5zaW9uT3JkZXIoZGF0YS5waXhlbHMucmVzdWx0UGl4ZWxzLCBudW1QaXhlbHMsIG51bURpbXMsIE91dFBpeGVsVHlwZUFycmF5KTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqKioqKioqKioqKioqKioqXG4gICAgICAqICBwcml2YXRlIG1ldGhvZHMgKGhlbHBlciBtZXRob2RzKVxuICAgICAgKioqKioqKioqKioqKioqKiovXG5cbiAgICAgIGZvcm1hdEZpbGVJbmZvOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgXCJmaWxlSWRlbnRpZmllclN0cmluZ1wiOiBkYXRhLmhlYWRlckluZm8uZmlsZUlkZW50aWZpZXJTdHJpbmcsXG4gICAgICAgICAgXCJmaWxlVmVyc2lvblwiOiBkYXRhLmhlYWRlckluZm8uZmlsZVZlcnNpb24sXG4gICAgICAgICAgXCJpbWFnZVR5cGVcIjogZGF0YS5oZWFkZXJJbmZvLmltYWdlVHlwZSxcbiAgICAgICAgICBcImhlaWdodFwiOiBkYXRhLmhlYWRlckluZm8uaGVpZ2h0LFxuICAgICAgICAgIFwid2lkdGhcIjogZGF0YS5oZWFkZXJJbmZvLndpZHRoLFxuICAgICAgICAgIFwibnVtVmFsaWRQaXhlbFwiOiBkYXRhLmhlYWRlckluZm8ubnVtVmFsaWRQaXhlbCxcbiAgICAgICAgICBcIm1pY3JvQmxvY2tTaXplXCI6IGRhdGEuaGVhZGVySW5mby5taWNyb0Jsb2NrU2l6ZSxcbiAgICAgICAgICBcImJsb2JTaXplXCI6IGRhdGEuaGVhZGVySW5mby5ibG9iU2l6ZSxcbiAgICAgICAgICBcIm1heFpFcnJvclwiOiBkYXRhLmhlYWRlckluZm8ubWF4WkVycm9yLFxuICAgICAgICAgIFwicGl4ZWxUeXBlXCI6IExlcmMySGVscGVycy5nZXRQaXhlbFR5cGUoZGF0YS5oZWFkZXJJbmZvLmltYWdlVHlwZSksXG4gICAgICAgICAgXCJlb2ZPZmZzZXRcIjogZGF0YS5lb2ZPZmZzZXQsXG4gICAgICAgICAgXCJtYXNrXCI6IGRhdGEubWFzayA/IHtcbiAgICAgICAgICAgIFwibnVtQnl0ZXNcIjogZGF0YS5tYXNrLm51bUJ5dGVzXG4gICAgICAgICAgfSA6IG51bGwsXG4gICAgICAgICAgXCJwaXhlbHNcIjoge1xuICAgICAgICAgICAgXCJudW1CbG9ja3NYXCI6IGRhdGEucGl4ZWxzLm51bUJsb2Nrc1gsXG4gICAgICAgICAgICBcIm51bUJsb2Nrc1lcIjogZGF0YS5waXhlbHMubnVtQmxvY2tzWSxcbiAgICAgICAgICAgIC8vXCJudW1CeXRlc1wiOiBkYXRhLnBpeGVscy5udW1CeXRlcyxcbiAgICAgICAgICAgIFwibWF4VmFsdWVcIjogZGF0YS5oZWFkZXJJbmZvLnpNYXgsXG4gICAgICAgICAgICBcIm1pblZhbHVlXCI6IGRhdGEuaGVhZGVySW5mby56TWluLFxuICAgICAgICAgICAgXCJub0RhdGFWYWx1ZVwiOiBkYXRhLm5vRGF0YVZhbHVlXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSxcblxuICAgICAgY29uc3RydWN0Q29uc3RhbnRTdXJmYWNlOiBmdW5jdGlvbihkYXRhLCB1c2VCU1FGb3JPdXRwdXREaW0pIHtcbiAgICAgICAgdmFyIHZhbCA9IGRhdGEuaGVhZGVySW5mby56TWF4O1xuICAgICAgICB2YXIgdmFsTWluID0gZGF0YS5oZWFkZXJJbmZvLnpNaW47XG4gICAgICAgIHZhciBtYXhWYWx1ZXMgPSBkYXRhLmhlYWRlckluZm8ubWF4VmFsdWVzO1xuICAgICAgICB2YXIgbnVtRGltcyA9IGRhdGEuaGVhZGVySW5mby5udW1EaW1zO1xuICAgICAgICB2YXIgbnVtUGl4ZWxzID0gZGF0YS5oZWFkZXJJbmZvLmhlaWdodCAqIGRhdGEuaGVhZGVySW5mby53aWR0aDtcbiAgICAgICAgdmFyIGkgPSAwLCBrID0gMCwgblN0YXJ0ID0gMDtcbiAgICAgICAgdmFyIG1hc2sgPSBkYXRhLnBpeGVscy5yZXN1bHRNYXNrO1xuICAgICAgICB2YXIgcmVzdWx0UGl4ZWxzID0gZGF0YS5waXhlbHMucmVzdWx0UGl4ZWxzO1xuICAgICAgICBpZiAobWFzaykge1xuICAgICAgICAgIGlmIChudW1EaW1zID4gMSkge1xuICAgICAgICAgICAgaWYgKHVzZUJTUUZvck91dHB1dERpbSkge1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtRGltczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgblN0YXJ0ID0gaSAqIG51bVBpeGVscztcbiAgICAgICAgICAgICAgICB2YWwgPSBtYXhWYWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IG51bVBpeGVsczsgaysrKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobWFza1trXSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRQaXhlbHNbblN0YXJ0ICsga10gPSB2YWw7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9ICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbnVtUGl4ZWxzOyBrKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobWFza1trXSkge1xuICAgICAgICAgICAgICAgICAgblN0YXJ0ID0gayAqIG51bURpbXM7XG4gICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtRGltczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1tuU3RhcnQgKyBudW1EaW1zXSA9IG1heFZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbnVtUGl4ZWxzOyBrKyspIHtcbiAgICAgICAgICAgICAgaWYgKG1hc2tba10pIHtcbiAgICAgICAgICAgICAgICByZXN1bHRQaXhlbHNba10gPSB2YWw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKG51bURpbXMgPiAxICYmIHZhbE1pbiAhPT0gdmFsKSB7XG4gICAgICAgICAgICBpZiAodXNlQlNRRm9yT3V0cHV0RGltKSB7XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1EaW1zOyBpKyspIHtcbiAgICAgICAgICAgICAgICBuU3RhcnQgPSBpICogbnVtUGl4ZWxzO1xuICAgICAgICAgICAgICAgIHZhbCA9IG1heFZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbnVtUGl4ZWxzOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1tuU3RhcnQgKyBrXSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbnVtUGl4ZWxzOyBrKyspIHtcbiAgICAgICAgICAgICAgICBuU3RhcnQgPSBrICogbnVtRGltcztcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtRGltczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHRQaXhlbHNbblN0YXJ0ICsgaV0gPSBtYXhWYWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IG51bVBpeGVscyAqIG51bURpbXM7IGsrKykge1xuICAgICAgICAgICAgICByZXN1bHRQaXhlbHNba10gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0sXG5cbiAgICAgIGdldERhdGFUeXBlQXJyYXk6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdmFyIHRwO1xuICAgICAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgICBjYXNlIDA6IC8vY2hhclxuICAgICAgICAgICAgdHAgPSBJbnQ4QXJyYXk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE6IC8vYnl0ZVxuICAgICAgICAgICAgdHAgPSBVaW50OEFycmF5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOiAvL3Nob3J0XG4gICAgICAgICAgICB0cCA9IEludDE2QXJyYXk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6IC8vdXNob3J0XG4gICAgICAgICAgICB0cCA9IFVpbnQxNkFycmF5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgdHAgPSBJbnQzMkFycmF5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgdHAgPSBVaW50MzJBcnJheTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHRwID0gRmxvYXQzMkFycmF5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgdHAgPSBGbG9hdDY0QXJyYXk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdHAgPSBGbG9hdDMyQXJyYXk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRwO1xuICAgICAgfSxcblxuICAgICAgZ2V0UGl4ZWxUeXBlOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHZhciB0cDtcbiAgICAgICAgc3dpdGNoICh0KSB7XG4gICAgICAgICAgY2FzZSAwOiAvL2NoYXJcbiAgICAgICAgICAgIHRwID0gXCJTOFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxOiAvL2J5dGVcbiAgICAgICAgICAgIHRwID0gXCJVOFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOiAvL3Nob3J0XG4gICAgICAgICAgICB0cCA9IFwiUzE2XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6IC8vdXNob3J0XG4gICAgICAgICAgICB0cCA9IFwiVTE2XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICB0cCA9IFwiUzMyXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICB0cCA9IFwiVTMyXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICB0cCA9IFwiRjMyXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICB0cCA9IFwiRjY0XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdHAgPSBcIkYzMlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cDtcbiAgICAgIH0sXG5cbiAgICAgIGlzVmFsaWRQaXhlbFZhbHVlOiBmdW5jdGlvbih0LCB2YWwpIHtcbiAgICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpc1ZhbGlkO1xuICAgICAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgICBjYXNlIDA6IC8vY2hhclxuICAgICAgICAgICAgaXNWYWxpZCA9IHZhbCA+PSAtMTI4ICYmIHZhbCA8PSAxMjc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE6IC8vYnl0ZSAgKHVuc2lnbmVkIGNoYXIpXG4gICAgICAgICAgICBpc1ZhbGlkID0gdmFsID49IDAgJiYgdmFsIDw9IDI1NTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjogLy9zaG9ydFxuICAgICAgICAgICAgaXNWYWxpZCA9IHZhbCA+PSAtMzI3NjggJiYgdmFsIDw9IDMyNzY3O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOiAvL3VzaG9ydFxuICAgICAgICAgICAgaXNWYWxpZCA9IHZhbCA+PSAwICYmIHZhbCA8PSA2NTUzNjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDogLy9pbnQgMzJcbiAgICAgICAgICAgIGlzVmFsaWQgPSB2YWwgPj0gLTIxNDc0ODM2NDggJiYgdmFsIDw9IDIxNDc0ODM2NDc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDU6IC8vdWluaXQgMzJcbiAgICAgICAgICAgIGlzVmFsaWQgPSB2YWwgPj0gMCAmJiB2YWwgPD0gNDI5NDk2NzI5NjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIGlzVmFsaWQgPSB2YWwgPj0gLTMuNDAyNzk5OTM4NzkwMTQ4NGUrMzggJiYgdmFsIDw9IDMuNDAyNzk5OTM4NzkwMTQ4NGUrMzg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBpc1ZhbGlkID0gdmFsID49IC0xLjc5NzY5MzEzNDg2MjMxNTdlKzMwOCAmJiB2YWwgPD0gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1ZhbGlkO1xuICAgICAgfSxcblxuICAgICAgZ2V0RGF0YVR5cGVTaXplOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHZhciBzID0gMDtcbiAgICAgICAgc3dpdGNoICh0KSB7XG4gICAgICAgICAgY2FzZSAwOiAvL3VieXRlXG4gICAgICAgICAgY2FzZSAxOiAvL2J5dGVcbiAgICAgICAgICAgIHMgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOiAvL3Nob3J0XG4gICAgICAgICAgY2FzZSAzOiAvL3VzaG9ydFxuICAgICAgICAgICAgcyA9IDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHMgPSA0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcyA9IDg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcyA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgICB9LFxuXG4gICAgICBnZXREYXRhVHlwZVVzZWQ6IGZ1bmN0aW9uKGR0LCB0Yykge1xuICAgICAgICB2YXIgdCA9IGR0O1xuICAgICAgICBzd2l0Y2ggKGR0KSB7XG4gICAgICAgICAgY2FzZSAyOiAvL3Nob3J0XG4gICAgICAgICAgY2FzZSA0OiAvL2xvbmdcbiAgICAgICAgICAgIHQgPSBkdCAtIHRjO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOiAvL3VzaG9ydFxuICAgICAgICAgIGNhc2UgNTogLy91bG9uZ1xuICAgICAgICAgICAgdCA9IGR0IC0gMiAqIHRjO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA2OiAvL2Zsb2F0XG4gICAgICAgICAgICBpZiAoMCA9PT0gdGMpIHtcbiAgICAgICAgICAgICAgdCA9IGR0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoMSA9PT0gdGMpIHtcbiAgICAgICAgICAgICAgdCA9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdCA9IDE7Ly9ieXRlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDc6IC8vZG91YmxlXG4gICAgICAgICAgICBpZiAoMCA9PT0gdGMpIHtcbiAgICAgICAgICAgICAgdCA9IGR0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHQgPSBkdCAtIDIgKiB0YyArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdCA9IGR0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9LFxuXG4gICAgICBnZXRPbmVQaXhlbDogZnVuY3Rpb24oYmxvY2ssIGJsb2NrUHRyLCBvZmZzZXRUeXBlLCB2aWV3KSB7XG4gICAgICAgIHZhciB0ZW1wID0gMDtcbiAgICAgICAgc3dpdGNoIChvZmZzZXRUeXBlKSB7XG4gICAgICAgICAgY2FzZSAwOiAvL2NoYXJcbiAgICAgICAgICAgIHRlbXAgPSB2aWV3LmdldEludDgoYmxvY2tQdHIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxOiAvL2J5dGVcbiAgICAgICAgICAgIHRlbXAgPSB2aWV3LmdldFVpbnQ4KGJsb2NrUHRyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHRlbXAgPSB2aWV3LmdldEludDE2KGJsb2NrUHRyLCB0cnVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHRlbXAgPSB2aWV3LmdldFVpbnQxNihibG9ja1B0ciwgdHJ1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICB0ZW1wID0gdmlldy5nZXRJbnQzMihibG9ja1B0ciwgdHJ1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICB0ZW1wID0gdmlldy5nZXRVSW50MzIoYmxvY2tQdHIsIHRydWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgdGVtcCA9IHZpZXcuZ2V0RmxvYXQzMihibG9ja1B0ciwgdHJ1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICB0ZW1wID0gdmlldy5nZXRGbG9hdDY0KGJsb2NrUHRyLCB0cnVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyAoXCJ0aGUgZGVjb2RlciBkb2VzIG5vdCB1bmRlcnN0YW5kIHRoaXMgcGl4ZWwgdHlwZVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVtcDtcbiAgICAgIH0sXG5cbiAgICAgIHN3YXBEaW1lbnNpb25PcmRlcjogZnVuY3Rpb24ocGl4ZWxzLCBudW1QaXhlbHMsIG51bURpbXMsIE91dFBpeGVsVHlwZUFycmF5LCBpbnB1dElzQklQKSB7XG4gICAgICAgIHZhciBpID0gMCwgaiA9IDAsIGlEaW0gPSAwLCB0ZW1wID0gMCwgc3dhcCA9IHBpeGVscztcbiAgICAgICAgaWYgKG51bURpbXMgPiAxKSB7XG4gICAgICAgICAgc3dhcCA9IG5ldyBPdXRQaXhlbFR5cGVBcnJheShudW1QaXhlbHMgKiBudW1EaW1zKTtcbiAgICAgICAgICBpZiAoaW5wdXRJc0JJUCkge1xuICAgICAgICAgICAgZm9yIChpPTA7IGk8bnVtUGl4ZWxzOyBpKyspIHtcbiAgICAgICAgICAgICAgdGVtcCA9IGk7XG4gICAgICAgICAgICAgIGZvciAoaURpbT0wOyBpRGltIDwgbnVtRGltczsgaURpbSsrLCB0ZW1wICs9IG51bVBpeGVscykge1xuICAgICAgICAgICAgICAgIHN3YXBbdGVtcF0gPSBwaXhlbHNbaisrXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAgXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChpPTA7IGk8bnVtUGl4ZWxzOyBpKyspIHtcbiAgICAgICAgICAgICAgdGVtcCA9IGk7XG4gICAgICAgICAgICAgIGZvciAoaURpbT0wOyBpRGltIDwgbnVtRGltczsgaURpbSsrLCB0ZW1wICs9IG51bVBpeGVscykge1xuICAgICAgICAgICAgICAgIHN3YXBbaisrXSA9IHBpeGVsc1t0ZW1wXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3dhcDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICpwcml2YXRlIGNsYXNzIGZvciBhIHRyZWUgbm9kZS4gSHVmZm1hbiBjb2RlIGlzIGluIExlcmMySGVscGVyc1xuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgdmFyIFRyZWVOb2RlID0gZnVuY3Rpb24odmFsLCBsZWZ0LCByaWdodCkge1xuICAgICAgdGhpcy52YWwgPSB2YWw7XG4gICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgIH07XG5cbiAgICB2YXIgTGVyYzJEZWNvZGUgPSB7XG4gICAgICAvKlxuICAgICAgKiAqKioqKioqKnJlbW92ZWQgb3B0aW9ucyBjb21wYXJlZCB0byBMRVJDMS4gV2UgY2FuIGJyaW5nIHNvbWUgb2YgdGhlbSBiYWNrIGlmIG5lZWRlZC5cbiAgICAgICAqIHJlbW92ZWQgcGl4ZWwgdHlwZS4gTEVSQzIgaXMgdHlwZWQgYW5kIGRvZXNuJ3QgcmVxdWlyZSB1c2VyIHRvIGdpdmUgcGl4ZWwgdHlwZVxuICAgICAgICogY2hhbmdlZCBlbmNvZGVkTWFza0RhdGEgdG8gbWFza0RhdGEuIExFUkMyICdzIGpzIHZlcnNpb24gbWFrZSBpdCBmYXN0ZXIgdG8gdXNlIG1hc2tEYXRhIGRpcmVjdGx5LlxuICAgICAgICogcmVtb3ZlZCByZXR1cm5NYXNrLiBtYXNrIGlzIHVzZWQgYnkgTEVSQzIgaW50ZXJuYWxseSBhbmQgaXMgY29zdCBmcmVlLiBJbiBjYXNlIG9mIHVzZXIgaW5wdXQgbWFzaywgaXQncyByZXR1cm5lZCBhcyB3ZWxsIGFuZCBoYXMgbmVnbGlibGUgY29zdC5cbiAgICAgICAqIHJlbW92ZWQgbm9kYXRhdmFsdWUuIEJlY2F1c2UgTEVSQzIgcGl4ZWxzIGFyZSB0eXBlZCwgbm9kYXRhdmFsdWUgd2lsbCBzYWNyaWZ5IGEgdXNlZnVsIHZhbHVlIGZvciBtYW55IHR5cGVzICg4Yml0LCAxNmJpdCkgZXRjLFxuICAgICAgICogICAgICAgdXNlciBoYXMgdG8gYmUga25vd2xlZGdhYmxlIGVub3VnaCBhYm91dCByYXN0ZXIgYW5kIHRoZWlyIGRhdGEgdG8gYXZvaWQgdXNhYmlsaXR5IGlzc3Vlcy4gc28gbm9kYXRhIHZhbHVlIGlzIHNpbXBseSByZW1vdmVkIG5vdy5cbiAgICAgICAqICAgICAgIFdlIGNhbiBhZGQgaXQgYmFjayBsYXRlciBpZiB0aGVpcidzIGEgY2xlYXIgcmVxdWlyZW1lbnQuXG4gICAgICAgKiByZW1vdmVkIGVuY29kZWRNYXNrLiBUaGlzIG9wdGlvbiB3YXMgbm90IGltcGxlbWVudGVkIGluIExlcmNEZWNvZGUuIEl0IGNhbiBiZSBkb25lIGFmdGVyIGRlY29kaW5nIChsZXNzIGVmZmljaWVudClcbiAgICAgICAqIHJlbW92ZWQgY29tcHV0ZVVzZWRCaXREZXB0aHMuXG4gICAgICAgKlxuICAgICAgICpcbiAgICAgICAqIHJlc3BvbnNlIGNoYW5nZXMgY29tcGFyZWQgdG8gTEVSQzFcbiAgICAgICAqIDEuIGVuY29kZWRNYXNrRGF0YSBpcyBub3QgYXZhaWxhYmxlXG4gICAgICAgKiAyLiBub0RhdGFWYWx1ZSBpcyBvcHRpb25hbCAocmV0dXJucyBvbmx5IGlmIHVzZXIncyBub0RhdGFWYWx1ZSBpcyB3aXRoIGluIHRoZSB2YWxpZCBkYXRhIHR5cGUgcmFuZ2UpXG4gICAgICAgKiAzLiBtYXNrRGF0YSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gICAgICAqL1xuICAgICAgLyoqKioqKioqKioqKioqKioqXG4gICAgICAqICBwdWJsaWMgcHJvcGVydGllc1xuICAgICAgKioqKioqKioqKioqKioqKioqL1xuICAgICAgLy9IVUZGTUFOX0xVVF9CSVRTX01BWDogMTIsIC8vdXNlIDJeMTIgbHV0LCBub3QgY29uZmlndXJhYmxlXG5cbiAgICAgIC8qKioqKioqKioqKioqKioqKlxuICAgICAgKiAgcHVibGljIG1ldGhvZHNcbiAgICAgICoqKioqKioqKioqKioqKioqL1xuXG4gICAgICAvKipcbiAgICAgICAqIERlY29kZSBhIExFUkMyIGJ5dGUgc3RyZWFtIGFuZCByZXR1cm4gYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHBpeGVsIGRhdGEgYW5kIG9wdGlvbmFsIG1ldGFkYXRhLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGlucHV0IFRoZSBMRVJDIGlucHV0IGJ5dGUgc3RyZWFtXG4gICAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIG9wdGlvbnMgRGVjb2Rpbmcgb3B0aW9uc1xuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmlucHV0T2Zmc2V0XSBUaGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgaW4gdGhlIGlucHV0IGJ5dGUgc3RyZWFtLiBBIHZhbGlkIExFUkMgZmlsZSBpcyBleHBlY3RlZCBhdCB0aGF0IHBvc2l0aW9uXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJldHVybkZpbGVJbmZvXSBJZiB0cnVlLCB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgaGF2ZSBhIGZpbGVJbmZvIHByb3BlcnR5IHRoYXQgY29udGFpbnMgbWV0YWRhdGEgb2J0YWluZWQgZnJvbSB0aGUgTEVSQyBoZWFkZXJzIGFuZCB0aGUgZGVjb2RpbmcgcHJvY2Vzc1xuICAgICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZXR1cm5QaXhlbEludGVybGVhdmVkRGltc10gIElmIHRydWUsIHJldHVybmVkIGRpbWVuc2lvbnMgYXJlIHBpeGVsLWludGVybGVhdmVkLCBhLmsuYSBbcDFfZGltMCwgcDFfZGltMSwgcDFfZGltbiwgcDJfZGltMC4uLl0sIGRlZmF1bHQgaXMgW3AxX2RpbTAsIHAyX2RpbTAsIC4uLiwgcDFfZGltMSwgcDJfZGltMS4uLl1cbiAgICAgICAqL1xuICAgICAgZGVjb2RlOiBmdW5jdGlvbigvKmJ5dGUgYXJyYXkqLyBpbnB1dCwgLypvYmplY3QqLyBvcHRpb25zKSB7XG4gICAgICAgIC8vY3VycmVudGx5IHRoZXJlJ3MgYSBidWcgaW4gdGhlIHNwYXJzZSBhcnJheSwgc28gcGxlYXNlIGRvIG5vdCBzZXQgdG8gZmFsc2VcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHZhciBub0RhdGFWYWx1ZSA9IG9wdGlvbnMubm9EYXRhVmFsdWU7XG5cbiAgICAgICAgLy9pbml0aWFsaXplXG4gICAgICAgIHZhciBpID0gMCwgZGF0YSA9IHt9O1xuICAgICAgICBkYXRhLnB0ciA9IG9wdGlvbnMuaW5wdXRPZmZzZXQgfHwgMDtcbiAgICAgICAgZGF0YS5waXhlbHMgPSB7fTtcblxuICAgICAgICAvLyBGaWxlIGhlYWRlclxuICAgICAgICBpZiAoIUxlcmMySGVscGVycy5yZWFkSGVhZGVySW5mbyhpbnB1dCwgZGF0YSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGVhZGVySW5mbyA9IGRhdGEuaGVhZGVySW5mbztcbiAgICAgICAgdmFyIGZpbGVWZXJzaW9uID0gaGVhZGVySW5mby5maWxlVmVyc2lvbjtcbiAgICAgICAgdmFyIE91dFBpeGVsVHlwZUFycmF5ID0gTGVyYzJIZWxwZXJzLmdldERhdGFUeXBlQXJyYXkoaGVhZGVySW5mby5pbWFnZVR5cGUpO1xuXG4gICAgICAgIC8vIHZlcnNpb24gY2hlY2tcbiAgICAgICAgaWYgKGZpbGVWZXJzaW9uID4gNSkge1xuICAgICAgICAgIHRocm93IFwidW5zdXBwb3J0ZWQgbGVyYyB2ZXJzaW9uIDIuXCIgKyBmaWxlVmVyc2lvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1hc2sgSGVhZGVyXG4gICAgICAgIExlcmMySGVscGVycy5yZWFkTWFzayhpbnB1dCwgZGF0YSk7XG4gICAgICAgIGlmIChoZWFkZXJJbmZvLm51bVZhbGlkUGl4ZWwgIT09IGhlYWRlckluZm8ud2lkdGggKiBoZWFkZXJJbmZvLmhlaWdodCAmJiAhZGF0YS5waXhlbHMucmVzdWx0TWFzaykge1xuICAgICAgICAgIGRhdGEucGl4ZWxzLnJlc3VsdE1hc2sgPSBvcHRpb25zLm1hc2tEYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG51bVBpeGVscyA9IGhlYWRlckluZm8ud2lkdGggKiBoZWFkZXJJbmZvLmhlaWdodDtcbiAgICAgICAgZGF0YS5waXhlbHMucmVzdWx0UGl4ZWxzID0gbmV3IE91dFBpeGVsVHlwZUFycmF5KG51bVBpeGVscyAqIGhlYWRlckluZm8ubnVtRGltcyk7XG5cbiAgICAgICAgZGF0YS5jb3VudGVyID0ge1xuICAgICAgICAgIG9uZXN3ZWVwOiAwLFxuICAgICAgICAgIHVuY29tcHJlc3NlZDogMCxcbiAgICAgICAgICBsdXQ6IDAsXG4gICAgICAgICAgYml0c3R1ZmZlcjogMCxcbiAgICAgICAgICBjb25zdGFudDogMCxcbiAgICAgICAgICBjb25zdGFudG9mZnNldDogMFxuICAgICAgICB9O1xuICAgICAgICB2YXIgdXNlQlNRRm9yT3V0cHV0RGltID0gIW9wdGlvbnMucmV0dXJuUGl4ZWxJbnRlcmxlYXZlZERpbXM7XG4gICAgICAgIGlmIChoZWFkZXJJbmZvLm51bVZhbGlkUGl4ZWwgIT09IDApIHtcbiAgICAgICAgICAvL25vdCB0ZXN0ZWRcbiAgICAgICAgICBpZiAoaGVhZGVySW5mby56TWF4ID09PSBoZWFkZXJJbmZvLnpNaW4pIC8vY29uc3RhbnQgc3VyZmFjZVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIExlcmMySGVscGVycy5jb25zdHJ1Y3RDb25zdGFudFN1cmZhY2UoZGF0YSwgdXNlQlNRRm9yT3V0cHV0RGltKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoZmlsZVZlcnNpb24gPj0gNCAmJiBMZXJjMkhlbHBlcnMuY2hlY2tNaW5NYXhSYW5nZXMoaW5wdXQsIGRhdGEpKSB7XG4gICAgICAgICAgICBMZXJjMkhlbHBlcnMuY29uc3RydWN0Q29uc3RhbnRTdXJmYWNlKGRhdGEsIHVzZUJTUUZvck91dHB1dERpbSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcoaW5wdXQsIGRhdGEucHRyLCAyKTtcbiAgICAgICAgICAgIHZhciBiUmVhZERhdGFPbmVTd2VlcCA9IHZpZXcuZ2V0VWludDgoMCk7XG4gICAgICAgICAgICBkYXRhLnB0cisrO1xuICAgICAgICAgICAgaWYgKGJSZWFkRGF0YU9uZVN3ZWVwKSB7XG4gICAgICAgICAgICAgIC8vY29uc29sZS5kZWJ1ZyhcIk9uZVN3ZWVwXCIpO1xuICAgICAgICAgICAgICBMZXJjMkhlbHBlcnMucmVhZERhdGFPbmVTd2VlcChpbnB1dCwgZGF0YSwgT3V0UGl4ZWxUeXBlQXJyYXksIHVzZUJTUUZvck91dHB1dERpbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy9sZXJjMi4xOiAvL2JpdHN0dWZmaW5nICsgbHV0XG4gICAgICAgICAgICAgIC8vbGVyYzIuMjogLy9iaXRzdHVmZmluZyArIGx1dCArIGh1ZmZtYW5cbiAgICAgICAgICAgICAgLy9sZXJjMi4zOiBuZXcgYml0c3R1ZmZlclxuICAgICAgICAgICAgICBpZiAoZmlsZVZlcnNpb24gPiAxICYmIGhlYWRlckluZm8uaW1hZ2VUeXBlIDw9IDEgJiYgTWF0aC5hYnMoaGVhZGVySW5mby5tYXhaRXJyb3IgLSAwLjUpIDwgMC4wMDAwMSkge1xuICAgICAgICAgICAgICAgIC8vdGhpcyBpcyAyLnggcGx1cyA4IGJpdCAodW5zaWduZWQgYW5kIHNpZ25lZCkgZGF0YSwgcG9zc2libGl0eSBvZiBIdWZmbWFuXG4gICAgICAgICAgICAgICAgdmFyIGZsYWdIdWZmbWFuID0gdmlldy5nZXRVaW50OCgxKTtcbiAgICAgICAgICAgICAgICBkYXRhLnB0cisrO1xuICAgICAgICAgICAgICAgIGRhdGEuZW5jb2RlTW9kZSA9IGZsYWdIdWZmbWFuO1xuICAgICAgICAgICAgICAgIGlmIChmbGFnSHVmZm1hbiA+IDIgfHwgKGZpbGVWZXJzaW9uIDwgNCAmJiBmbGFnSHVmZm1hbiA+IDEpKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBcIkludmFsaWQgSHVmZm1hbiBmbGFnIFwiICsgZmxhZ0h1ZmZtYW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmbGFnSHVmZm1hbikgey8vMSAtIGRlbHRhIEh1ZmZtYW4sIDIgLSBIdWZmbWFuXG4gICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiSHVmZm1hblwiKTtcbiAgICAgICAgICAgICAgICAgIExlcmMySGVscGVycy5yZWFkSHVmZm1hbihpbnB1dCwgZGF0YSwgT3V0UGl4ZWxUeXBlQXJyYXksIHVzZUJTUUZvck91dHB1dERpbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlRpbGVzXCIpO1xuICAgICAgICAgICAgICAgICAgTGVyYzJIZWxwZXJzLnJlYWRUaWxlcyhpbnB1dCwgZGF0YSwgT3V0UGl4ZWxUeXBlQXJyYXksIHVzZUJTUUZvck91dHB1dERpbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgeyAvL2xlcmMyLnggbm9uLTggYml0IGRhdGFcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiVGlsZXNcIik7XG4gICAgICAgICAgICAgICAgTGVyYzJIZWxwZXJzLnJlYWRUaWxlcyhpbnB1dCwgZGF0YSwgT3V0UGl4ZWxUeXBlQXJyYXksIHVzZUJTUUZvck91dHB1dERpbSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLmVvZk9mZnNldCA9IGRhdGEucHRyO1xuICAgICAgICB2YXIgZGlmZjtcbiAgICAgICAgaWYgKG9wdGlvbnMuaW5wdXRPZmZzZXQpIHtcbiAgICAgICAgICBkaWZmID0gZGF0YS5oZWFkZXJJbmZvLmJsb2JTaXplICsgb3B0aW9ucy5pbnB1dE9mZnNldCAtIGRhdGEucHRyO1xuICAgICAgICAgIGlmIChNYXRoLmFicyhkaWZmKSA+PSAxKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUuZGVidWcoXCJpbmNvcnJlY3QgZW9mOiBkYXRhcHRyIFwiICsgZGF0YS5wdHIgKyBcIiBvZmZzZXQgXCIgKyBvcHRpb25zLmlucHV0T2Zmc2V0ICsgXCIgYmxvYnNpemUgXCIgKyBkYXRhLmhlYWRlckluZm8uYmxvYlNpemUgKyBcIiBkaWZmOiBcIiArIGRpZmYpO1xuICAgICAgICAgICAgZGF0YS5lb2ZPZmZzZXQgPSBvcHRpb25zLmlucHV0T2Zmc2V0ICsgZGF0YS5oZWFkZXJJbmZvLmJsb2JTaXplO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkaWZmID0gZGF0YS5oZWFkZXJJbmZvLmJsb2JTaXplIC0gZGF0YS5wdHI7XG4gICAgICAgICAgaWYgKE1hdGguYWJzKGRpZmYpID49IDEpIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5kZWJ1ZyhcImluY29ycmVjdCBmaXJzdCBiYW5kIGVvZjogZGF0YXB0ciBcIiArIGRhdGEucHRyICsgXCIgYmxvYnNpemUgXCIgKyBkYXRhLmhlYWRlckluZm8uYmxvYlNpemUgKyBcIiBkaWZmOiBcIiArIGRpZmYpO1xuICAgICAgICAgICAgZGF0YS5lb2ZPZmZzZXQgPSBkYXRhLmhlYWRlckluZm8uYmxvYlNpemU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICB3aWR0aDogaGVhZGVySW5mby53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlYWRlckluZm8uaGVpZ2h0LFxuICAgICAgICAgIHBpeGVsRGF0YTogZGF0YS5waXhlbHMucmVzdWx0UGl4ZWxzLFxuICAgICAgICAgIG1pblZhbHVlOiBoZWFkZXJJbmZvLnpNaW4sXG4gICAgICAgICAgbWF4VmFsdWU6IGhlYWRlckluZm8uek1heCxcbiAgICAgICAgICB2YWxpZFBpeGVsQ291bnQ6IGhlYWRlckluZm8ubnVtVmFsaWRQaXhlbCxcbiAgICAgICAgICBkaW1Db3VudDogaGVhZGVySW5mby5udW1EaW1zLFxuICAgICAgICAgIGRpbVN0YXRzOiB7XG4gICAgICAgICAgICBtaW5WYWx1ZXM6IGhlYWRlckluZm8ubWluVmFsdWVzLFxuICAgICAgICAgICAgbWF4VmFsdWVzOiBoZWFkZXJJbmZvLm1heFZhbHVlc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbWFza0RhdGE6IGRhdGEucGl4ZWxzLnJlc3VsdE1hc2tcbiAgICAgICAgICAvL25vRGF0YVZhbHVlOiBub0RhdGFWYWx1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vd2Ugc2hvdWxkIHJlbW92ZSB0aGlzIGlmIHRoZXJlJ3Mgbm8gZXhpc3RpbmcgY2xpZW50XG4gICAgICAgIC8vb3B0aW9uYWwgbm9EYXRhVmFsdWUgcHJvY2Vzc2luZywgaXQncyB1c2VyJ3MgcmVzcG9uc2libGl0eVxuICAgICAgICBpZiAoZGF0YS5waXhlbHMucmVzdWx0TWFzayAmJiBMZXJjMkhlbHBlcnMuaXNWYWxpZFBpeGVsVmFsdWUoaGVhZGVySW5mby5pbWFnZVR5cGUsIG5vRGF0YVZhbHVlKSkge1xuICAgICAgICAgIHZhciBtYXNrID0gZGF0YS5waXhlbHMucmVzdWx0TWFzaztcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtUGl4ZWxzOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghbWFza1tpXSkge1xuICAgICAgICAgICAgICByZXN1bHQucGl4ZWxEYXRhW2ldID0gbm9EYXRhVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5ub0RhdGFWYWx1ZSA9IG5vRGF0YVZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEubm9EYXRhVmFsdWUgPSBub0RhdGFWYWx1ZTtcbiAgICAgICAgaWYgKG9wdGlvbnMucmV0dXJuRmlsZUluZm8pIHtcbiAgICAgICAgICByZXN1bHQuZmlsZUluZm8gPSBMZXJjMkhlbHBlcnMuZm9ybWF0RmlsZUluZm8oZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sXG5cbiAgICAgIGdldEJhbmRDb3VudDogZnVuY3Rpb24oLypieXRlIGFycmF5Ki8gaW5wdXQpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgdGVtcCA9IHt9O1xuICAgICAgICB0ZW1wLnB0ciA9IDA7XG4gICAgICAgIHRlbXAucGl4ZWxzID0ge307XG4gICAgICAgIHdoaWxlIChpIDwgaW5wdXQuYnl0ZUxlbmd0aCAtIDU4KSB7XG4gICAgICAgICAgTGVyYzJIZWxwZXJzLnJlYWRIZWFkZXJJbmZvKGlucHV0LCB0ZW1wKTtcbiAgICAgICAgICBpICs9IHRlbXAuaGVhZGVySW5mby5ibG9iU2l6ZTtcbiAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgIHRlbXAucHRyID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBMZXJjMkRlY29kZTtcbiAgfSkoKTtcblxuICB2YXIgaXNQbGF0Zm9ybUxpdHRsZUVuZGlhbiA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgYSA9IG5ldyBBcnJheUJ1ZmZlcig0KTtcbiAgICB2YXIgYiA9IG5ldyBVaW50OEFycmF5KGEpO1xuICAgIHZhciBjID0gbmV3IFVpbnQzMkFycmF5KGEpO1xuICAgIGNbMF0gPSAxO1xuICAgIHJldHVybiBiWzBdID09PSAxO1xuICB9KSgpO1xuXG4gIHZhciBMZXJjID0ge1xuICAgIC8qKioqKioqKioqKip3cmFwcGVyKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAvKipcbiAgICAgKiBBIHdyYXBwZXIgZm9yIGRlY29kaW5nIGJvdGggTEVSQzEgYW5kIExFUkMyIGJ5dGUgc3RyZWFtcyBjYXBhYmxlIG9mIGhhbmRsaW5nIG11bHRpYmFuZCBwaXhlbCBibG9ja3MgZm9yIHZhcmlvdXMgcGl4ZWwgdHlwZXMuXG4gICAgICpcbiAgICAgKiBAYWxpYXMgbW9kdWxlOkxlcmNcbiAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBpbnB1dCBUaGUgTEVSQyBpbnB1dCBieXRlIHN0cmVhbVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gVGhlIGRlY29kaW5nIG9wdGlvbnMgYmVsb3cgYXJlIG9wdGlvbmFsLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5pbnB1dE9mZnNldF0gVGhlIG51bWJlciBvZiBieXRlcyB0byBza2lwIGluIHRoZSBpbnB1dCBieXRlIHN0cmVhbS4gQSB2YWxpZCBMZXJjIGZpbGUgaXMgZXhwZWN0ZWQgYXQgdGhhdCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGl4ZWxUeXBlXSAoTEVSQzEgb25seSkgRGVmYXVsdCB2YWx1ZSBpcyBGMzIuIFZhbGlkIHBpeGVsIHR5cGVzIGZvciBpbnB1dCBhcmUgVTgvUzgvUzE2L1UxNi9TMzIvVTMyL0YzMi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubm9EYXRhVmFsdWVdIChMRVJDMSBvbmx5KS4gSXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIHRoZSByZXR1cm5lZCBtYXNrIGluc3RlYWQgb2Ygc2V0dGluZyB0aGlzIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmV0dXJuUGl4ZWxJbnRlcmxlYXZlZERpbXNdIChuRGltIExFUkMyIG9ubHkpIElmIHRydWUsIHJldHVybmVkIGRpbWVuc2lvbnMgYXJlIHBpeGVsLWludGVybGVhdmVkLCBhLmsuYSBbcDFfZGltMCwgcDFfZGltMSwgcDFfZGltbiwgcDJfZGltMC4uLl0sIGRlZmF1bHQgaXMgW3AxX2RpbTAsIHAyX2RpbTAsIC4uLiwgcDFfZGltMSwgcDJfZGltMS4uLl1cbiAgICAgKiBAcmV0dXJucyB7e3dpZHRoLCBoZWlnaHQsIHBpeGVscywgcGl4ZWxUeXBlLCBtYXNrLCBzdGF0aXN0aWNzfX1cbiAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB3aWR0aCBXaWR0aCBvZiBkZWNvZGVkIGltYWdlLlxuICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGhlaWdodCBIZWlnaHQgb2YgZGVjb2RlZCBpbWFnZS5cbiAgICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9IHBpeGVscyBbYmFuZDEsIGJhbmQyLCDigKZdIEVhY2ggYmFuZCBpcyBhIHR5cGVkIGFycmF5IG9mIHdpZHRoKmhlaWdodC5cbiAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwaXhlbFR5cGUgVGhlIHR5cGUgb2YgcGl4ZWxzIHJlcHJlc2VudGVkIGluIHRoZSBvdXRwdXQuXG4gICAgICAgKiBAcHJvcGVydHkge21hc2t9IG1hc2sgVHlwZWQgYXJyYXkgd2l0aCBhIHNpemUgb2Ygd2lkdGgqaGVpZ2h0LCBvciBudWxsIGlmIGFsbCBwaXhlbHMgYXJlIHZhbGlkLlxuICAgICAgICogQHByb3BlcnR5IHthcnJheX0gc3RhdGlzdGljcyBbc3RhdGlzdGljc19iYW5kMSwgc3RhdGlzdGljc19iYW5kMiwg4oCmXSBFYWNoIGVsZW1lbnQgaXMgYSBzdGF0aXN0aWNzIG9iamVjdCByZXByZXNlbnRpbmcgbWluIGFuZCBtYXggdmFsdWVzXG4gICAgKiovXG4gICAgZGVjb2RlOiBmdW5jdGlvbihlbmNvZGVkRGF0YSwgb3B0aW9ucykge1xuICAgICAgaWYgKCFpc1BsYXRmb3JtTGl0dGxlRW5kaWFuKSB7XG4gICAgICAgIHRocm93IFwiQmlnIGVuZGlhbiBzeXN0ZW0gaXMgbm90IHN1cHBvcnRlZC5cIjtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgdmFyIGlucHV0T2Zmc2V0ID0gb3B0aW9ucy5pbnB1dE9mZnNldCB8fCAwO1xuICAgICAgdmFyIGZpbGVJZFZpZXcgPSBuZXcgVWludDhBcnJheShlbmNvZGVkRGF0YSwgaW5wdXRPZmZzZXQsIDEwKTtcbiAgICAgIHZhciBmaWxlSWRlbnRpZmllclN0cmluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgZmlsZUlkVmlldyk7XG4gICAgICB2YXIgbGVyYywgbWFqb3JWZXJzaW9uO1xuICAgICAgaWYgKGZpbGVJZGVudGlmaWVyU3RyaW5nLnRyaW0oKSA9PT0gXCJDbnRaSW1hZ2VcIikge1xuICAgICAgICBsZXJjID0gTGVyY0RlY29kZTtcbiAgICAgICAgbWFqb3JWZXJzaW9uID0gMTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGZpbGVJZGVudGlmaWVyU3RyaW5nLnN1YnN0cmluZygwLCA1KSA9PT0gXCJMZXJjMlwiKSB7XG4gICAgICAgIGxlcmMgPSBMZXJjMkRlY29kZTtcbiAgICAgICAgbWFqb3JWZXJzaW9uID0gMjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBcIlVuZXhwZWN0ZWQgZmlsZSBpZGVudGlmaWVyIHN0cmluZzogXCIgKyBmaWxlSWRlbnRpZmllclN0cmluZztcbiAgICAgIH1cblxuICAgICAgdmFyIGlQbGFuZSA9IDAsIGVvZiA9IGVuY29kZWREYXRhLmJ5dGVMZW5ndGggLSAxMCwgZW5jb2RlZE1hc2tEYXRhLCBiYW5kTWFza3MgPSBbXSwgYmFuZE1hc2ssIG1hc2tEYXRhO1xuICAgICAgdmFyIGRlY29kZWRQaXhlbEJsb2NrID0ge1xuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICBwaXhlbHM6IFtdLFxuICAgICAgICBwaXhlbFR5cGU6IG9wdGlvbnMucGl4ZWxUeXBlLFxuICAgICAgICBtYXNrOiBudWxsLFxuICAgICAgICBzdGF0aXN0aWNzOiBbXVxuICAgICAgfTtcbiAgICAgIHZhciB1bmlxdWVCYW5kTWFza0NvdW50ID0gMDtcblxuICAgICAgd2hpbGUgKGlucHV0T2Zmc2V0IDwgZW9mKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBsZXJjLmRlY29kZShlbmNvZGVkRGF0YSwge1xuICAgICAgICAgIGlucHV0T2Zmc2V0OiBpbnB1dE9mZnNldCwvL2ZvciBib3RoIGxlcmMxIGFuZCBsZXJjMlxuICAgICAgICAgIGVuY29kZWRNYXNrRGF0YTogZW5jb2RlZE1hc2tEYXRhLC8vbGVyYzEgb25seVxuICAgICAgICAgIG1hc2tEYXRhOiBtYXNrRGF0YSwvL2xlcmMyIG9ubHlcbiAgICAgICAgICByZXR1cm5NYXNrOiBpUGxhbmUgPT09IDAgPyB0cnVlIDogZmFsc2UsLy9sZXJjMSBvbmx5XG4gICAgICAgICAgcmV0dXJuRW5jb2RlZE1hc2s6IGlQbGFuZSA9PT0gMCA/IHRydWUgOiBmYWxzZSwvL2xlcmMxIG9ubHlcbiAgICAgICAgICByZXR1cm5GaWxlSW5mbzogdHJ1ZSwvL2ZvciBib3RoIGxlcmMxIGFuZCBsZXJjMlxuICAgICAgICAgIHJldHVyblBpeGVsSW50ZXJsZWF2ZWREaW1zOiBvcHRpb25zLnJldHVyblBpeGVsSW50ZXJsZWF2ZWREaW1zLC8vZm9yIG5kaW0gbGVyYzIgb25seVxuICAgICAgICAgIHBpeGVsVHlwZTogb3B0aW9ucy5waXhlbFR5cGUgfHwgbnVsbCwvL2xlcmMxIG9ubHlcbiAgICAgICAgICBub0RhdGFWYWx1ZTogb3B0aW9ucy5ub0RhdGFWYWx1ZSB8fCBudWxsLy9sZXJjMSBvbmx5XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlucHV0T2Zmc2V0ID0gcmVzdWx0LmZpbGVJbmZvLmVvZk9mZnNldDtcbiAgICAgICAgbWFza0RhdGEgPSByZXN1bHQubWFza0RhdGE7Ly9sZXJjMlxuICAgICAgICBpZiAoaVBsYW5lID09PSAwKSB7XG4gICAgICAgICAgZW5jb2RlZE1hc2tEYXRhID0gcmVzdWx0LmVuY29kZWRNYXNrRGF0YTsvL2xlcmMxXG4gICAgICAgICAgZGVjb2RlZFBpeGVsQmxvY2sud2lkdGggPSByZXN1bHQud2lkdGg7XG4gICAgICAgICAgZGVjb2RlZFBpeGVsQmxvY2suaGVpZ2h0ID0gcmVzdWx0LmhlaWdodDtcbiAgICAgICAgICBkZWNvZGVkUGl4ZWxCbG9jay5kaW1Db3VudCA9IHJlc3VsdC5kaW1Db3VudCB8fCAxO1xuICAgICAgICAgIC8vZGVjb2RlZFBpeGVsQmxvY2suZGltU3RhdHMgPSBkZWNvZGVkUGl4ZWxCbG9jay5kaW1TdGF0cztcbiAgICAgICAgICBkZWNvZGVkUGl4ZWxCbG9jay5waXhlbFR5cGUgPSByZXN1bHQucGl4ZWxUeXBlIHx8IHJlc3VsdC5maWxlSW5mby5waXhlbFR5cGU7XG4gICAgICAgICAgZGVjb2RlZFBpeGVsQmxvY2subWFzayA9IG1hc2tEYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYWpvclZlcnNpb24gPiAxKSB7XG4gICAgICAgICAgaWYgKG1hc2tEYXRhKSB7XG4gICAgICAgICAgICBiYW5kTWFza3MucHVzaChtYXNrRGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQuZmlsZUluZm8ubWFzayAmJiByZXN1bHQuZmlsZUluZm8ubWFzay5udW1CeXRlcyA+IDApIHtcbiAgICAgICAgICAgIHVuaXF1ZUJhbmRNYXNrQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpUGxhbmUrKztcbiAgICAgICAgZGVjb2RlZFBpeGVsQmxvY2sucGl4ZWxzLnB1c2gocmVzdWx0LnBpeGVsRGF0YSk7XG4gICAgICAgIGRlY29kZWRQaXhlbEJsb2NrLnN0YXRpc3RpY3MucHVzaCh7XG4gICAgICAgICAgbWluVmFsdWU6IHJlc3VsdC5taW5WYWx1ZSxcbiAgICAgICAgICBtYXhWYWx1ZTogcmVzdWx0Lm1heFZhbHVlLFxuICAgICAgICAgIG5vRGF0YVZhbHVlOiByZXN1bHQubm9EYXRhVmFsdWUsXG4gICAgICAgICAgZGltU3RhdHM6IHJlc3VsdC5kaW1TdGF0c1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHZhciBpLCBqLCBudW1QaXhlbHM7XG4gICAgICBpZiAobWFqb3JWZXJzaW9uID4gMSAmJiB1bmlxdWVCYW5kTWFza0NvdW50ID4gMSkge1xuICAgICAgICBudW1QaXhlbHMgPSBkZWNvZGVkUGl4ZWxCbG9jay53aWR0aCAqIGRlY29kZWRQaXhlbEJsb2NrLmhlaWdodDtcbiAgICAgICAgZGVjb2RlZFBpeGVsQmxvY2suYmFuZE1hc2tzID0gYmFuZE1hc2tzO1xuICAgICAgICBtYXNrRGF0YSA9IG5ldyBVaW50OEFycmF5KG51bVBpeGVscyk7XG4gICAgICAgIG1hc2tEYXRhLnNldChiYW5kTWFza3NbMF0pO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgYmFuZE1hc2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYmFuZE1hc2sgPSBiYW5kTWFza3NbaV07XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IG51bVBpeGVsczsgaisrKSB7XG4gICAgICAgICAgICBtYXNrRGF0YVtqXSA9IG1hc2tEYXRhW2pdICYgYmFuZE1hc2tbal07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlY29kZWRQaXhlbEJsb2NrLm1hc2tEYXRhID0gbWFza0RhdGE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZWNvZGVkUGl4ZWxCbG9jaztcbiAgICB9XG4gIH07XG5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7LyoganNoaW50IGlnbm9yZTpsaW5lICovXG4gICAgLy9hbWQgbG9hZGVycyBzdWNoIGFzIGRvam8gYW5kIHJlcXVpcmVKU1xuICAgIC8vaHR0cDovL3dpa2kuY29tbW9uanMub3JnL3dpa2kvTW9kdWxlcy9Bc3luY2hyb25vdXNEZWZpbml0aW9uXG4gICAgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHsgcmV0dXJuIExlcmM7IH0pOy8qIGpzaGludCBpZ25vcmU6bGluZSAqL1xuICB9XG4gIGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHMpIHsvKiBqc2hpbnQgaWdub3JlOmxpbmUgKi9cbiAgICAvL2NvbW1vbkpTIG1vZHVsZSAxLjAvMS4xLzEuMS4xIHN5c3RlbXMsIHN1Y2ggYXMgbm9kZUpTXG4gICAgLy9odHRwOi8vd2lraS5jb21tb25qcy5vcmcvd2lraS9Nb2R1bGVzXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBMZXJjOy8qIGpzaGludCBpZ25vcmU6bGluZSAqL1xuICB9XG4gIGVsc2Uge1xuICAgIC8vYXNzaWduIHRvIHRoaXMsIG1vc3QgbGlrZWx5IHdpbmRvd1xuICAgIHRoaXMuTGVyYyA9IExlcmM7XG4gIH1cblxufSkoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==
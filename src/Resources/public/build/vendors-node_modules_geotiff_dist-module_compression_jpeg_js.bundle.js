"use strict";
(self["webpackChunkmapsbundle"] = self["webpackChunkmapsbundle"] || []).push([["vendors-node_modules_geotiff_dist-module_compression_jpeg_js"],{

/***/ "./node_modules/geotiff/dist-module/compression/jpeg.js":
/*!**************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/compression/jpeg.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ JpegDecoder)
/* harmony export */ });
/* harmony import */ var _basedecoder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basedecoder.js */ "./node_modules/geotiff/dist-module/compression/basedecoder.js");


/* -*- tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/*
   Copyright 2011 notmasteryet
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
       http://www.apache.org/licenses/LICENSE-2.0
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

// - The JPEG specification can be found in the ITU CCITT Recommendation T.81
//   (www.w3.org/Graphics/JPEG/itu-t81.pdf)
// - The JFIF specification can be found in the JPEG File Interchange Format
//   (www.w3.org/Graphics/JPEG/jfif3.pdf)
// - The Adobe Application-Specific JPEG markers in the Supporting the DCT Filters
//   in PostScript Level 2, Technical Note #5116
//   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)

const dctZigZag = new Int32Array([
  0,
  1, 8,
  16, 9, 2,
  3, 10, 17, 24,
  32, 25, 18, 11, 4,
  5, 12, 19, 26, 33, 40,
  48, 41, 34, 27, 20, 13, 6,
  7, 14, 21, 28, 35, 42, 49, 56,
  57, 50, 43, 36, 29, 22, 15,
  23, 30, 37, 44, 51, 58,
  59, 52, 45, 38, 31,
  39, 46, 53, 60,
  61, 54, 47,
  55, 62,
  63,
]);

const dctCos1 = 4017; // cos(pi/16)
const dctSin1 = 799; // sin(pi/16)
const dctCos3 = 3406; // cos(3*pi/16)
const dctSin3 = 2276; // sin(3*pi/16)
const dctCos6 = 1567; // cos(6*pi/16)
const dctSin6 = 3784; // sin(6*pi/16)
const dctSqrt2 = 5793; // sqrt(2)
const dctSqrt1d2 = 2896;// sqrt(2) / 2

function buildHuffmanTable(codeLengths, values) {
  let k = 0;
  const code = [];
  let length = 16;
  while (length > 0 && !codeLengths[length - 1]) {
    --length;
  }
  code.push({ children: [], index: 0 });

  let p = code[0];
  let q;
  for (let i = 0; i < length; i++) {
    for (let j = 0; j < codeLengths[i]; j++) {
      p = code.pop();
      p.children[p.index] = values[k];
      while (p.index > 0) {
        p = code.pop();
      }
      p.index++;
      code.push(p);
      while (code.length <= i) {
        code.push(q = { children: [], index: 0 });
        p.children[p.index] = q.children;
        p = q;
      }
      k++;
    }
    if (i + 1 < length) {
      // p here points to last code
      code.push(q = { children: [], index: 0 });
      p.children[p.index] = q.children;
      p = q;
    }
  }
  return code[0].children;
}

function decodeScan(data, initialOffset,
  frame, components, resetInterval,
  spectralStart, spectralEnd,
  successivePrev, successive) {
  const { mcusPerLine, progressive } = frame;

  const startOffset = initialOffset;
  let offset = initialOffset;
  let bitsData = 0;
  let bitsCount = 0;
  function readBit() {
    if (bitsCount > 0) {
      bitsCount--;
      return (bitsData >> bitsCount) & 1;
    }
    bitsData = data[offset++];
    if (bitsData === 0xFF) {
      const nextByte = data[offset++];
      if (nextByte) {
        throw new Error(`unexpected marker: ${((bitsData << 8) | nextByte).toString(16)}`);
      }
      // unstuff 0
    }
    bitsCount = 7;
    return bitsData >>> 7;
  }
  function decodeHuffman(tree) {
    let node = tree;
    let bit;
    while ((bit = readBit()) !== null) { // eslint-disable-line no-cond-assign
      node = node[bit];
      if (typeof node === 'number') {
        return node;
      }
      if (typeof node !== 'object') {
        throw new Error('invalid huffman sequence');
      }
    }
    return null;
  }
  function receive(initialLength) {
    let length = initialLength;
    let n = 0;
    while (length > 0) {
      const bit = readBit();
      if (bit === null) {
        return undefined;
      }
      n = (n << 1) | bit;
      --length;
    }
    return n;
  }
  function receiveAndExtend(length) {
    const n = receive(length);
    if (n >= 1 << (length - 1)) {
      return n;
    }
    return n + (-1 << length) + 1;
  }
  function decodeBaseline(component, zz) {
    const t = decodeHuffman(component.huffmanTableDC);
    const diff = t === 0 ? 0 : receiveAndExtend(t);
    component.pred += diff;
    zz[0] = component.pred;
    let k = 1;
    while (k < 64) {
      const rs = decodeHuffman(component.huffmanTableAC);
      const s = rs & 15;
      const r = rs >> 4;
      if (s === 0) {
        if (r < 15) {
          break;
        }
        k += 16;
      } else {
        k += r;
        const z = dctZigZag[k];
        zz[z] = receiveAndExtend(s);
        k++;
      }
    }
  }
  function decodeDCFirst(component, zz) {
    const t = decodeHuffman(component.huffmanTableDC);
    const diff = t === 0 ? 0 : (receiveAndExtend(t) << successive);
    component.pred += diff;
    zz[0] = component.pred;
  }
  function decodeDCSuccessive(component, zz) {
    zz[0] |= readBit() << successive;
  }
  let eobrun = 0;
  function decodeACFirst(component, zz) {
    if (eobrun > 0) {
      eobrun--;
      return;
    }
    let k = spectralStart;
    const e = spectralEnd;
    while (k <= e) {
      const rs = decodeHuffman(component.huffmanTableAC);
      const s = rs & 15;
      const r = rs >> 4;
      if (s === 0) {
        if (r < 15) {
          eobrun = receive(r) + (1 << r) - 1;
          break;
        }
        k += 16;
      } else {
        k += r;
        const z = dctZigZag[k];
        zz[z] = receiveAndExtend(s) * (1 << successive);
        k++;
      }
    }
  }
  let successiveACState = 0;
  let successiveACNextValue;
  function decodeACSuccessive(component, zz) {
    let k = spectralStart;
    const e = spectralEnd;
    let r = 0;
    while (k <= e) {
      const z = dctZigZag[k];
      const direction = zz[z] < 0 ? -1 : 1;
      switch (successiveACState) {
        case 0: { // initial state
          const rs = decodeHuffman(component.huffmanTableAC);
          const s = rs & 15;
          r = rs >> 4;
          if (s === 0) {
            if (r < 15) {
              eobrun = receive(r) + (1 << r);
              successiveACState = 4;
            } else {
              r = 16;
              successiveACState = 1;
            }
          } else {
            if (s !== 1) {
              throw new Error('invalid ACn encoding');
            }
            successiveACNextValue = receiveAndExtend(s);
            successiveACState = r ? 2 : 3;
          }
          continue; // eslint-disable-line no-continue
        }
        case 1: // skipping r zero items
        case 2:
          if (zz[z]) {
            zz[z] += (readBit() << successive) * direction;
          } else {
            r--;
            if (r === 0) {
              successiveACState = successiveACState === 2 ? 3 : 0;
            }
          }
          break;
        case 3: // set value for a zero item
          if (zz[z]) {
            zz[z] += (readBit() << successive) * direction;
          } else {
            zz[z] = successiveACNextValue << successive;
            successiveACState = 0;
          }
          break;
        case 4: // eob
          if (zz[z]) {
            zz[z] += (readBit() << successive) * direction;
          }
          break;
        default:
          break;
      }
      k++;
    }
    if (successiveACState === 4) {
      eobrun--;
      if (eobrun === 0) {
        successiveACState = 0;
      }
    }
  }
  function decodeMcu(component, decodeFunction, mcu, row, col) {
    const mcuRow = (mcu / mcusPerLine) | 0;
    const mcuCol = mcu % mcusPerLine;
    const blockRow = (mcuRow * component.v) + row;
    const blockCol = (mcuCol * component.h) + col;
    decodeFunction(component, component.blocks[blockRow][blockCol]);
  }
  function decodeBlock(component, decodeFunction, mcu) {
    const blockRow = (mcu / component.blocksPerLine) | 0;
    const blockCol = mcu % component.blocksPerLine;
    decodeFunction(component, component.blocks[blockRow][blockCol]);
  }

  const componentsLength = components.length;
  let component;
  let i;
  let j;
  let k;
  let n;
  let decodeFn;
  if (progressive) {
    if (spectralStart === 0) {
      decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
    } else {
      decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
    }
  } else {
    decodeFn = decodeBaseline;
  }

  let mcu = 0;
  let marker;
  let mcuExpected;
  if (componentsLength === 1) {
    mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
  } else {
    mcuExpected = mcusPerLine * frame.mcusPerColumn;
  }

  const usedResetInterval = resetInterval || mcuExpected;

  while (mcu < mcuExpected) {
    // reset interval stuff
    for (i = 0; i < componentsLength; i++) {
      components[i].pred = 0;
    }
    eobrun = 0;

    if (componentsLength === 1) {
      component = components[0];
      for (n = 0; n < usedResetInterval; n++) {
        decodeBlock(component, decodeFn, mcu);
        mcu++;
      }
    } else {
      for (n = 0; n < usedResetInterval; n++) {
        for (i = 0; i < componentsLength; i++) {
          component = components[i];
          const { h, v } = component;
          for (j = 0; j < v; j++) {
            for (k = 0; k < h; k++) {
              decodeMcu(component, decodeFn, mcu, j, k);
            }
          }
        }
        mcu++;

        // If we've reached our expected MCU's, stop decoding
        if (mcu === mcuExpected) {
          break;
        }
      }
    }

    // find marker
    bitsCount = 0;
    marker = (data[offset] << 8) | data[offset + 1];
    if (marker < 0xFF00) {
      throw new Error('marker was not found');
    }

    if (marker >= 0xFFD0 && marker <= 0xFFD7) { // RSTx
      offset += 2;
    } else {
      break;
    }
  }

  return offset - startOffset;
}

function buildComponentData(frame, component) {
  const lines = [];
  const { blocksPerLine, blocksPerColumn } = component;
  const samplesPerLine = blocksPerLine << 3;
  const R = new Int32Array(64);
  const r = new Uint8Array(64);

  // A port of poppler's IDCT method which in turn is taken from:
  //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,
  //   "Practical Fast 1-D DCT Algorithms with 11 Multiplications",
  //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,
  //   988-991.
  function quantizeAndInverse(zz, dataOut, dataIn) {
    const qt = component.quantizationTable;
    let v0;
    let v1;
    let v2;
    let v3;
    let v4;
    let v5;
    let v6;
    let v7;
    let t;
    const p = dataIn;
    let i;

    // dequant
    for (i = 0; i < 64; i++) {
      p[i] = zz[i] * qt[i];
    }

    // inverse DCT on rows
    for (i = 0; i < 8; ++i) {
      const row = 8 * i;

      // check for all-zero AC coefficients
      if (p[1 + row] === 0 && p[2 + row] === 0 && p[3 + row] === 0
        && p[4 + row] === 0 && p[5 + row] === 0 && p[6 + row] === 0
        && p[7 + row] === 0) {
        t = ((dctSqrt2 * p[0 + row]) + 512) >> 10;
        p[0 + row] = t;
        p[1 + row] = t;
        p[2 + row] = t;
        p[3 + row] = t;
        p[4 + row] = t;
        p[5 + row] = t;
        p[6 + row] = t;
        p[7 + row] = t;
        continue; // eslint-disable-line no-continue
      }

      // stage 4
      v0 = ((dctSqrt2 * p[0 + row]) + 128) >> 8;
      v1 = ((dctSqrt2 * p[4 + row]) + 128) >> 8;
      v2 = p[2 + row];
      v3 = p[6 + row];
      v4 = ((dctSqrt1d2 * (p[1 + row] - p[7 + row])) + 128) >> 8;
      v7 = ((dctSqrt1d2 * (p[1 + row] + p[7 + row])) + 128) >> 8;
      v5 = p[3 + row] << 4;
      v6 = p[5 + row] << 4;

      // stage 3
      t = (v0 - v1 + 1) >> 1;
      v0 = (v0 + v1 + 1) >> 1;
      v1 = t;
      t = ((v2 * dctSin6) + (v3 * dctCos6) + 128) >> 8;
      v2 = ((v2 * dctCos6) - (v3 * dctSin6) + 128) >> 8;
      v3 = t;
      t = (v4 - v6 + 1) >> 1;
      v4 = (v4 + v6 + 1) >> 1;
      v6 = t;
      t = (v7 + v5 + 1) >> 1;
      v5 = (v7 - v5 + 1) >> 1;
      v7 = t;

      // stage 2
      t = (v0 - v3 + 1) >> 1;
      v0 = (v0 + v3 + 1) >> 1;
      v3 = t;
      t = (v1 - v2 + 1) >> 1;
      v1 = (v1 + v2 + 1) >> 1;
      v2 = t;
      t = ((v4 * dctSin3) + (v7 * dctCos3) + 2048) >> 12;
      v4 = ((v4 * dctCos3) - (v7 * dctSin3) + 2048) >> 12;
      v7 = t;
      t = ((v5 * dctSin1) + (v6 * dctCos1) + 2048) >> 12;
      v5 = ((v5 * dctCos1) - (v6 * dctSin1) + 2048) >> 12;
      v6 = t;

      // stage 1
      p[0 + row] = v0 + v7;
      p[7 + row] = v0 - v7;
      p[1 + row] = v1 + v6;
      p[6 + row] = v1 - v6;
      p[2 + row] = v2 + v5;
      p[5 + row] = v2 - v5;
      p[3 + row] = v3 + v4;
      p[4 + row] = v3 - v4;
    }

    // inverse DCT on columns
    for (i = 0; i < 8; ++i) {
      const col = i;

      // check for all-zero AC coefficients
      if (p[(1 * 8) + col] === 0 && p[(2 * 8) + col] === 0 && p[(3 * 8) + col] === 0
        && p[(4 * 8) + col] === 0 && p[(5 * 8) + col] === 0 && p[(6 * 8) + col] === 0
        && p[(7 * 8) + col] === 0) {
        t = ((dctSqrt2 * dataIn[i + 0]) + 8192) >> 14;
        p[(0 * 8) + col] = t;
        p[(1 * 8) + col] = t;
        p[(2 * 8) + col] = t;
        p[(3 * 8) + col] = t;
        p[(4 * 8) + col] = t;
        p[(5 * 8) + col] = t;
        p[(6 * 8) + col] = t;
        p[(7 * 8) + col] = t;
        continue; // eslint-disable-line no-continue
      }

      // stage 4
      v0 = ((dctSqrt2 * p[(0 * 8) + col]) + 2048) >> 12;
      v1 = ((dctSqrt2 * p[(4 * 8) + col]) + 2048) >> 12;
      v2 = p[(2 * 8) + col];
      v3 = p[(6 * 8) + col];
      v4 = ((dctSqrt1d2 * (p[(1 * 8) + col] - p[(7 * 8) + col])) + 2048) >> 12;
      v7 = ((dctSqrt1d2 * (p[(1 * 8) + col] + p[(7 * 8) + col])) + 2048) >> 12;
      v5 = p[(3 * 8) + col];
      v6 = p[(5 * 8) + col];

      // stage 3
      t = (v0 - v1 + 1) >> 1;
      v0 = (v0 + v1 + 1) >> 1;
      v1 = t;
      t = ((v2 * dctSin6) + (v3 * dctCos6) + 2048) >> 12;
      v2 = ((v2 * dctCos6) - (v3 * dctSin6) + 2048) >> 12;
      v3 = t;
      t = (v4 - v6 + 1) >> 1;
      v4 = (v4 + v6 + 1) >> 1;
      v6 = t;
      t = (v7 + v5 + 1) >> 1;
      v5 = (v7 - v5 + 1) >> 1;
      v7 = t;

      // stage 2
      t = (v0 - v3 + 1) >> 1;
      v0 = (v0 + v3 + 1) >> 1;
      v3 = t;
      t = (v1 - v2 + 1) >> 1;
      v1 = (v1 + v2 + 1) >> 1;
      v2 = t;
      t = ((v4 * dctSin3) + (v7 * dctCos3) + 2048) >> 12;
      v4 = ((v4 * dctCos3) - (v7 * dctSin3) + 2048) >> 12;
      v7 = t;
      t = ((v5 * dctSin1) + (v6 * dctCos1) + 2048) >> 12;
      v5 = ((v5 * dctCos1) - (v6 * dctSin1) + 2048) >> 12;
      v6 = t;

      // stage 1
      p[(0 * 8) + col] = v0 + v7;
      p[(7 * 8) + col] = v0 - v7;
      p[(1 * 8) + col] = v1 + v6;
      p[(6 * 8) + col] = v1 - v6;
      p[(2 * 8) + col] = v2 + v5;
      p[(5 * 8) + col] = v2 - v5;
      p[(3 * 8) + col] = v3 + v4;
      p[(4 * 8) + col] = v3 - v4;
    }

    // convert to 8-bit integers
    for (i = 0; i < 64; ++i) {
      const sample = 128 + ((p[i] + 8) >> 4);
      if (sample < 0) {
        dataOut[i] = 0;
      } else if (sample > 0XFF) {
        dataOut[i] = 0xFF;
      } else {
        dataOut[i] = sample;
      }
    }
  }

  for (let blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
    const scanLine = blockRow << 3;
    for (let i = 0; i < 8; i++) {
      lines.push(new Uint8Array(samplesPerLine));
    }
    for (let blockCol = 0; blockCol < blocksPerLine; blockCol++) {
      quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);

      let offset = 0;
      const sample = blockCol << 3;
      for (let j = 0; j < 8; j++) {
        const line = lines[scanLine + j];
        for (let i = 0; i < 8; i++) {
          line[sample + i] = r[offset++];
        }
      }
    }
  }
  return lines;
}

class JpegStreamReader {
  constructor() {
    this.jfif = null;
    this.adobe = null;

    this.quantizationTables = [];
    this.huffmanTablesAC = [];
    this.huffmanTablesDC = [];
    this.resetFrames();
  }

  resetFrames() {
    this.frames = [];
  }

  parse(data) {
    let offset = 0;
    // const { length } = data;
    function readUint16() {
      const value = (data[offset] << 8) | data[offset + 1];
      offset += 2;
      return value;
    }
    function readDataBlock() {
      const length = readUint16();
      const array = data.subarray(offset, offset + length - 2);
      offset += array.length;
      return array;
    }
    function prepareComponents(frame) {
      let maxH = 0;
      let maxV = 0;
      let component;
      let componentId;
      for (componentId in frame.components) {
        if (frame.components.hasOwnProperty(componentId)) {
          component = frame.components[componentId];
          if (maxH < component.h) {
            maxH = component.h;
          }
          if (maxV < component.v) {
            maxV = component.v;
          }
        }
      }
      const mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / maxH);
      const mcusPerColumn = Math.ceil(frame.scanLines / 8 / maxV);
      for (componentId in frame.components) {
        if (frame.components.hasOwnProperty(componentId)) {
          component = frame.components[componentId];
          const blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / maxH);
          const blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines / 8) * component.v / maxV);
          const blocksPerLineForMcu = mcusPerLine * component.h;
          const blocksPerColumnForMcu = mcusPerColumn * component.v;
          const blocks = [];
          for (let i = 0; i < blocksPerColumnForMcu; i++) {
            const row = [];
            for (let j = 0; j < blocksPerLineForMcu; j++) {
              row.push(new Int32Array(64));
            }
            blocks.push(row);
          }
          component.blocksPerLine = blocksPerLine;
          component.blocksPerColumn = blocksPerColumn;
          component.blocks = blocks;
        }
      }
      frame.maxH = maxH;
      frame.maxV = maxV;
      frame.mcusPerLine = mcusPerLine;
      frame.mcusPerColumn = mcusPerColumn;
    }

    let fileMarker = readUint16();
    if (fileMarker !== 0xFFD8) { // SOI (Start of Image)
      throw new Error('SOI not found');
    }

    fileMarker = readUint16();
    while (fileMarker !== 0xFFD9) { // EOI (End of image)
      switch (fileMarker) {
        case 0xFF00: break;
        case 0xFFE0: // APP0 (Application Specific)
        case 0xFFE1: // APP1
        case 0xFFE2: // APP2
        case 0xFFE3: // APP3
        case 0xFFE4: // APP4
        case 0xFFE5: // APP5
        case 0xFFE6: // APP6
        case 0xFFE7: // APP7
        case 0xFFE8: // APP8
        case 0xFFE9: // APP9
        case 0xFFEA: // APP10
        case 0xFFEB: // APP11
        case 0xFFEC: // APP12
        case 0xFFED: // APP13
        case 0xFFEE: // APP14
        case 0xFFEF: // APP15
        case 0xFFFE: { // COM (Comment)
          const appData = readDataBlock();

          if (fileMarker === 0xFFE0) {
            if (appData[0] === 0x4A && appData[1] === 0x46 && appData[2] === 0x49
              && appData[3] === 0x46 && appData[4] === 0) { // 'JFIF\x00'
              this.jfif = {
                version: { major: appData[5], minor: appData[6] },
                densityUnits: appData[7],
                xDensity: (appData[8] << 8) | appData[9],
                yDensity: (appData[10] << 8) | appData[11],
                thumbWidth: appData[12],
                thumbHeight: appData[13],
                thumbData: appData.subarray(14, 14 + (3 * appData[12] * appData[13])),
              };
            }
          }
          // TODO APP1 - Exif
          if (fileMarker === 0xFFEE) {
            if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6F
              && appData[3] === 0x62 && appData[4] === 0x65 && appData[5] === 0) { // 'Adobe\x00'
              this.adobe = {
                version: appData[6],
                flags0: (appData[7] << 8) | appData[8],
                flags1: (appData[9] << 8) | appData[10],
                transformCode: appData[11],
              };
            }
          }
          break;
        }

        case 0xFFDB: { // DQT (Define Quantization Tables)
          const quantizationTablesLength = readUint16();
          const quantizationTablesEnd = quantizationTablesLength + offset - 2;
          while (offset < quantizationTablesEnd) {
            const quantizationTableSpec = data[offset++];
            const tableData = new Int32Array(64);
            if ((quantizationTableSpec >> 4) === 0) { // 8 bit values
              for (let j = 0; j < 64; j++) {
                const z = dctZigZag[j];
                tableData[z] = data[offset++];
              }
            } else if ((quantizationTableSpec >> 4) === 1) { // 16 bit
              for (let j = 0; j < 64; j++) {
                const z = dctZigZag[j];
                tableData[z] = readUint16();
              }
            } else {
              throw new Error('DQT: invalid table spec');
            }
            this.quantizationTables[quantizationTableSpec & 15] = tableData;
          }
          break;
        }

        case 0xFFC0: // SOF0 (Start of Frame, Baseline DCT)
        case 0xFFC1: // SOF1 (Start of Frame, Extended DCT)
        case 0xFFC2: { // SOF2 (Start of Frame, Progressive DCT)
          readUint16(); // skip data length
          const frame = {
            extended: (fileMarker === 0xFFC1),
            progressive: (fileMarker === 0xFFC2),
            precision: data[offset++],
            scanLines: readUint16(),
            samplesPerLine: readUint16(),
            components: {},
            componentsOrder: [],
          };

          const componentsCount = data[offset++];
          let componentId;
          // let maxH = 0;
          // let maxV = 0;
          for (let i = 0; i < componentsCount; i++) {
            componentId = data[offset];
            const h = data[offset + 1] >> 4;
            const v = data[offset + 1] & 15;
            const qId = data[offset + 2];
            frame.componentsOrder.push(componentId);
            frame.components[componentId] = {
              h,
              v,
              quantizationIdx: qId,
            };
            offset += 3;
          }
          prepareComponents(frame);
          this.frames.push(frame);
          break;
        }

        case 0xFFC4: { // DHT (Define Huffman Tables)
          const huffmanLength = readUint16();
          for (let i = 2; i < huffmanLength;) {
            const huffmanTableSpec = data[offset++];
            const codeLengths = new Uint8Array(16);
            let codeLengthSum = 0;
            for (let j = 0; j < 16; j++, offset++) {
              codeLengths[j] = data[offset];
              codeLengthSum += codeLengths[j];
            }
            const huffmanValues = new Uint8Array(codeLengthSum);
            for (let j = 0; j < codeLengthSum; j++, offset++) {
              huffmanValues[j] = data[offset];
            }
            i += 17 + codeLengthSum;

            if ((huffmanTableSpec >> 4) === 0) {
              this.huffmanTablesDC[huffmanTableSpec & 15] = buildHuffmanTable(
                codeLengths, huffmanValues,
              );
            } else {
              this.huffmanTablesAC[huffmanTableSpec & 15] = buildHuffmanTable(
                codeLengths, huffmanValues,
              );
            }
          }
          break;
        }

        case 0xFFDD: // DRI (Define Restart Interval)
          readUint16(); // skip data length
          this.resetInterval = readUint16();
          break;

        case 0xFFDA: { // SOS (Start of Scan)
          readUint16(); // skip length
          const selectorsCount = data[offset++];
          const components = [];
          const frame = this.frames[0];
          for (let i = 0; i < selectorsCount; i++) {
            const component = frame.components[data[offset++]];
            const tableSpec = data[offset++];
            component.huffmanTableDC = this.huffmanTablesDC[tableSpec >> 4];
            component.huffmanTableAC = this.huffmanTablesAC[tableSpec & 15];
            components.push(component);
          }
          const spectralStart = data[offset++];
          const spectralEnd = data[offset++];
          const successiveApproximation = data[offset++];
          const processed = decodeScan(data, offset,
            frame, components, this.resetInterval,
            spectralStart, spectralEnd,
            successiveApproximation >> 4, successiveApproximation & 15);
          offset += processed;
          break;
        }

        case 0xFFFF: // Fill bytes
          if (data[offset] !== 0xFF) { // Avoid skipping a valid marker.
            offset--;
          }
          break;

        default:
          if (data[offset - 3] === 0xFF
            && data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {
            // could be incorrect encoding -- last 0xFF byte of the previous
            // block was eaten by the encoder
            offset -= 3;
            break;
          }
          throw new Error(`unknown JPEG marker ${fileMarker.toString(16)}`);
      }
      fileMarker = readUint16();
    }
  }

  getResult() {
    const { frames } = this;
    if (this.frames.length === 0) {
      throw new Error('no frames were decoded');
    } else if (this.frames.length > 1) {
      console.warn('more than one frame is not supported');
    }

    // set each frame's components quantization table
    for (let i = 0; i < this.frames.length; i++) {
      const cp = this.frames[i].components;
      for (const j of Object.keys(cp)) {
        cp[j].quantizationTable = this.quantizationTables[cp[j].quantizationIdx];
        delete cp[j].quantizationIdx;
      }
    }

    const frame = frames[0];
    const { components, componentsOrder } = frame;
    const outComponents = [];
    const width = frame.samplesPerLine;
    const height = frame.scanLines;

    for (let i = 0; i < componentsOrder.length; i++) {
      const component = components[componentsOrder[i]];
      outComponents.push({
        lines: buildComponentData(frame, component),
        scaleX: component.h / frame.maxH,
        scaleY: component.v / frame.maxV,
      });
    }

    const out = new Uint8Array(width * height * outComponents.length);
    let oi = 0;
    for (let y = 0; y < height; ++y) {
      for (let x = 0; x < width; ++x) {
        for (let i = 0; i < outComponents.length; ++i) {
          const component = outComponents[i];
          out[oi] = component.lines[0 | y * component.scaleY][0 | x * component.scaleX];
          ++oi;
        }
      }
    }
    return out;
  }
}

class JpegDecoder extends _basedecoder_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(fileDirectory) {
    super();
    this.reader = new JpegStreamReader();
    if (fileDirectory.JPEGTables) {
      this.reader.parse(fileDirectory.JPEGTables);
    }
  }

  decodeBlock(buffer) {
    this.reader.resetFrames();
    this.reader.parse(new Uint8Array(buffer));
    return this.reader.getResult().buffer;
  }
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfZ2VvdGlmZl9kaXN0LW1vZHVsZV9jb21wcmVzc2lvbl9qcGVnX2pzLmJ1bmRsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUEyQzs7QUFFM0MscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QixxQkFBcUI7QUFDckIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLHVCQUF1QjtBQUN2Qix3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx3QkFBd0I7O0FBRXRDO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QixvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDJCQUEyQjs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsMENBQTBDO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvQkFBb0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsd0JBQXdCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSw4QkFBOEI7QUFDMUM7QUFDQTtBQUNBOztBQUVBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEMsc0JBQXNCLFdBQVc7QUFDakMsd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWUsMEJBQTBCLHVEQUFXO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21hcHNidW5kbGUvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9jb21wcmVzc2lvbi9qcGVnLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCYXNlRGVjb2RlciBmcm9tICcuL2Jhc2VkZWNvZGVyLmpzJztcblxuLyogLSotIHRhYi13aWR0aDogMjsgaW5kZW50LXRhYnMtbW9kZTogbmlsOyBjLWJhc2ljLW9mZnNldDogMiAtKi0gL1xuLyogdmltOiBzZXQgc2hpZnR3aWR0aD0yIHRhYnN0b3A9MiBhdXRvaW5kZW50IGNpbmRlbnQgZXhwYW5kdGFiOiAqL1xuLypcbiAgIENvcHlyaWdodCAyMDExIG5vdG1hc3RlcnlldFxuICAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbi8vIC0gVGhlIEpQRUcgc3BlY2lmaWNhdGlvbiBjYW4gYmUgZm91bmQgaW4gdGhlIElUVSBDQ0lUVCBSZWNvbW1lbmRhdGlvbiBULjgxXG4vLyAgICh3d3cudzMub3JnL0dyYXBoaWNzL0pQRUcvaXR1LXQ4MS5wZGYpXG4vLyAtIFRoZSBKRklGIHNwZWNpZmljYXRpb24gY2FuIGJlIGZvdW5kIGluIHRoZSBKUEVHIEZpbGUgSW50ZXJjaGFuZ2UgRm9ybWF0XG4vLyAgICh3d3cudzMub3JnL0dyYXBoaWNzL0pQRUcvamZpZjMucGRmKVxuLy8gLSBUaGUgQWRvYmUgQXBwbGljYXRpb24tU3BlY2lmaWMgSlBFRyBtYXJrZXJzIGluIHRoZSBTdXBwb3J0aW5nIHRoZSBEQ1QgRmlsdGVyc1xuLy8gICBpbiBQb3N0U2NyaXB0IExldmVsIDIsIFRlY2huaWNhbCBOb3RlICM1MTE2XG4vLyAgIChwYXJ0bmVycy5hZG9iZS5jb20vcHVibGljL2RldmVsb3Blci9lbi9wcy9zZGsvNTExNi5EQ1RfRmlsdGVyLnBkZilcblxuY29uc3QgZGN0WmlnWmFnID0gbmV3IEludDMyQXJyYXkoW1xuICAwLFxuICAxLCA4LFxuICAxNiwgOSwgMixcbiAgMywgMTAsIDE3LCAyNCxcbiAgMzIsIDI1LCAxOCwgMTEsIDQsXG4gIDUsIDEyLCAxOSwgMjYsIDMzLCA0MCxcbiAgNDgsIDQxLCAzNCwgMjcsIDIwLCAxMywgNixcbiAgNywgMTQsIDIxLCAyOCwgMzUsIDQyLCA0OSwgNTYsXG4gIDU3LCA1MCwgNDMsIDM2LCAyOSwgMjIsIDE1LFxuICAyMywgMzAsIDM3LCA0NCwgNTEsIDU4LFxuICA1OSwgNTIsIDQ1LCAzOCwgMzEsXG4gIDM5LCA0NiwgNTMsIDYwLFxuICA2MSwgNTQsIDQ3LFxuICA1NSwgNjIsXG4gIDYzLFxuXSk7XG5cbmNvbnN0IGRjdENvczEgPSA0MDE3OyAvLyBjb3MocGkvMTYpXG5jb25zdCBkY3RTaW4xID0gNzk5OyAvLyBzaW4ocGkvMTYpXG5jb25zdCBkY3RDb3MzID0gMzQwNjsgLy8gY29zKDMqcGkvMTYpXG5jb25zdCBkY3RTaW4zID0gMjI3NjsgLy8gc2luKDMqcGkvMTYpXG5jb25zdCBkY3RDb3M2ID0gMTU2NzsgLy8gY29zKDYqcGkvMTYpXG5jb25zdCBkY3RTaW42ID0gMzc4NDsgLy8gc2luKDYqcGkvMTYpXG5jb25zdCBkY3RTcXJ0MiA9IDU3OTM7IC8vIHNxcnQoMilcbmNvbnN0IGRjdFNxcnQxZDIgPSAyODk2Oy8vIHNxcnQoMikgLyAyXG5cbmZ1bmN0aW9uIGJ1aWxkSHVmZm1hblRhYmxlKGNvZGVMZW5ndGhzLCB2YWx1ZXMpIHtcbiAgbGV0IGsgPSAwO1xuICBjb25zdCBjb2RlID0gW107XG4gIGxldCBsZW5ndGggPSAxNjtcbiAgd2hpbGUgKGxlbmd0aCA+IDAgJiYgIWNvZGVMZW5ndGhzW2xlbmd0aCAtIDFdKSB7XG4gICAgLS1sZW5ndGg7XG4gIH1cbiAgY29kZS5wdXNoKHsgY2hpbGRyZW46IFtdLCBpbmRleDogMCB9KTtcblxuICBsZXQgcCA9IGNvZGVbMF07XG4gIGxldCBxO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2RlTGVuZ3Roc1tpXTsgaisrKSB7XG4gICAgICBwID0gY29kZS5wb3AoKTtcbiAgICAgIHAuY2hpbGRyZW5bcC5pbmRleF0gPSB2YWx1ZXNba107XG4gICAgICB3aGlsZSAocC5pbmRleCA+IDApIHtcbiAgICAgICAgcCA9IGNvZGUucG9wKCk7XG4gICAgICB9XG4gICAgICBwLmluZGV4Kys7XG4gICAgICBjb2RlLnB1c2gocCk7XG4gICAgICB3aGlsZSAoY29kZS5sZW5ndGggPD0gaSkge1xuICAgICAgICBjb2RlLnB1c2gocSA9IHsgY2hpbGRyZW46IFtdLCBpbmRleDogMCB9KTtcbiAgICAgICAgcC5jaGlsZHJlbltwLmluZGV4XSA9IHEuY2hpbGRyZW47XG4gICAgICAgIHAgPSBxO1xuICAgICAgfVxuICAgICAgaysrO1xuICAgIH1cbiAgICBpZiAoaSArIDEgPCBsZW5ndGgpIHtcbiAgICAgIC8vIHAgaGVyZSBwb2ludHMgdG8gbGFzdCBjb2RlXG4gICAgICBjb2RlLnB1c2gocSA9IHsgY2hpbGRyZW46IFtdLCBpbmRleDogMCB9KTtcbiAgICAgIHAuY2hpbGRyZW5bcC5pbmRleF0gPSBxLmNoaWxkcmVuO1xuICAgICAgcCA9IHE7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb2RlWzBdLmNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVTY2FuKGRhdGEsIGluaXRpYWxPZmZzZXQsXG4gIGZyYW1lLCBjb21wb25lbnRzLCByZXNldEludGVydmFsLFxuICBzcGVjdHJhbFN0YXJ0LCBzcGVjdHJhbEVuZCxcbiAgc3VjY2Vzc2l2ZVByZXYsIHN1Y2Nlc3NpdmUpIHtcbiAgY29uc3QgeyBtY3VzUGVyTGluZSwgcHJvZ3Jlc3NpdmUgfSA9IGZyYW1lO1xuXG4gIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gaW5pdGlhbE9mZnNldDtcbiAgbGV0IG9mZnNldCA9IGluaXRpYWxPZmZzZXQ7XG4gIGxldCBiaXRzRGF0YSA9IDA7XG4gIGxldCBiaXRzQ291bnQgPSAwO1xuICBmdW5jdGlvbiByZWFkQml0KCkge1xuICAgIGlmIChiaXRzQ291bnQgPiAwKSB7XG4gICAgICBiaXRzQ291bnQtLTtcbiAgICAgIHJldHVybiAoYml0c0RhdGEgPj4gYml0c0NvdW50KSAmIDE7XG4gICAgfVxuICAgIGJpdHNEYXRhID0gZGF0YVtvZmZzZXQrK107XG4gICAgaWYgKGJpdHNEYXRhID09PSAweEZGKSB7XG4gICAgICBjb25zdCBuZXh0Qnl0ZSA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgaWYgKG5leHRCeXRlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5leHBlY3RlZCBtYXJrZXI6ICR7KChiaXRzRGF0YSA8PCA4KSB8IG5leHRCeXRlKS50b1N0cmluZygxNil9YCk7XG4gICAgICB9XG4gICAgICAvLyB1bnN0dWZmIDBcbiAgICB9XG4gICAgYml0c0NvdW50ID0gNztcbiAgICByZXR1cm4gYml0c0RhdGEgPj4+IDc7XG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlSHVmZm1hbih0cmVlKSB7XG4gICAgbGV0IG5vZGUgPSB0cmVlO1xuICAgIGxldCBiaXQ7XG4gICAgd2hpbGUgKChiaXQgPSByZWFkQml0KCkpICE9PSBudWxsKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgICAgIG5vZGUgPSBub2RlW2JpdF07XG4gICAgICBpZiAodHlwZW9mIG5vZGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaHVmZm1hbiBzZXF1ZW5jZScpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiByZWNlaXZlKGluaXRpYWxMZW5ndGgpIHtcbiAgICBsZXQgbGVuZ3RoID0gaW5pdGlhbExlbmd0aDtcbiAgICBsZXQgbiA9IDA7XG4gICAgd2hpbGUgKGxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGJpdCA9IHJlYWRCaXQoKTtcbiAgICAgIGlmIChiaXQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIG4gPSAobiA8PCAxKSB8IGJpdDtcbiAgICAgIC0tbGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfVxuICBmdW5jdGlvbiByZWNlaXZlQW5kRXh0ZW5kKGxlbmd0aCkge1xuICAgIGNvbnN0IG4gPSByZWNlaXZlKGxlbmd0aCk7XG4gICAgaWYgKG4gPj0gMSA8PCAobGVuZ3RoIC0gMSkpIHtcbiAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgICByZXR1cm4gbiArICgtMSA8PCBsZW5ndGgpICsgMTtcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGVCYXNlbGluZShjb21wb25lbnQsIHp6KSB7XG4gICAgY29uc3QgdCA9IGRlY29kZUh1ZmZtYW4oY29tcG9uZW50Lmh1ZmZtYW5UYWJsZURDKTtcbiAgICBjb25zdCBkaWZmID0gdCA9PT0gMCA/IDAgOiByZWNlaXZlQW5kRXh0ZW5kKHQpO1xuICAgIGNvbXBvbmVudC5wcmVkICs9IGRpZmY7XG4gICAgenpbMF0gPSBjb21wb25lbnQucHJlZDtcbiAgICBsZXQgayA9IDE7XG4gICAgd2hpbGUgKGsgPCA2NCkge1xuICAgICAgY29uc3QgcnMgPSBkZWNvZGVIdWZmbWFuKGNvbXBvbmVudC5odWZmbWFuVGFibGVBQyk7XG4gICAgICBjb25zdCBzID0gcnMgJiAxNTtcbiAgICAgIGNvbnN0IHIgPSBycyA+PiA0O1xuICAgICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgaWYgKHIgPCAxNSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGsgKz0gMTY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrICs9IHI7XG4gICAgICAgIGNvbnN0IHogPSBkY3RaaWdaYWdba107XG4gICAgICAgIHp6W3pdID0gcmVjZWl2ZUFuZEV4dGVuZChzKTtcbiAgICAgICAgaysrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkZWNvZGVEQ0ZpcnN0KGNvbXBvbmVudCwgenopIHtcbiAgICBjb25zdCB0ID0gZGVjb2RlSHVmZm1hbihjb21wb25lbnQuaHVmZm1hblRhYmxlREMpO1xuICAgIGNvbnN0IGRpZmYgPSB0ID09PSAwID8gMCA6IChyZWNlaXZlQW5kRXh0ZW5kKHQpIDw8IHN1Y2Nlc3NpdmUpO1xuICAgIGNvbXBvbmVudC5wcmVkICs9IGRpZmY7XG4gICAgenpbMF0gPSBjb21wb25lbnQucHJlZDtcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGVEQ1N1Y2Nlc3NpdmUoY29tcG9uZW50LCB6eikge1xuICAgIHp6WzBdIHw9IHJlYWRCaXQoKSA8PCBzdWNjZXNzaXZlO1xuICB9XG4gIGxldCBlb2JydW4gPSAwO1xuICBmdW5jdGlvbiBkZWNvZGVBQ0ZpcnN0KGNvbXBvbmVudCwgenopIHtcbiAgICBpZiAoZW9icnVuID4gMCkge1xuICAgICAgZW9icnVuLS07XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBrID0gc3BlY3RyYWxTdGFydDtcbiAgICBjb25zdCBlID0gc3BlY3RyYWxFbmQ7XG4gICAgd2hpbGUgKGsgPD0gZSkge1xuICAgICAgY29uc3QgcnMgPSBkZWNvZGVIdWZmbWFuKGNvbXBvbmVudC5odWZmbWFuVGFibGVBQyk7XG4gICAgICBjb25zdCBzID0gcnMgJiAxNTtcbiAgICAgIGNvbnN0IHIgPSBycyA+PiA0O1xuICAgICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgaWYgKHIgPCAxNSkge1xuICAgICAgICAgIGVvYnJ1biA9IHJlY2VpdmUocikgKyAoMSA8PCByKSAtIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgayArPSAxNjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGsgKz0gcjtcbiAgICAgICAgY29uc3QgeiA9IGRjdFppZ1phZ1trXTtcbiAgICAgICAgenpbel0gPSByZWNlaXZlQW5kRXh0ZW5kKHMpICogKDEgPDwgc3VjY2Vzc2l2ZSk7XG4gICAgICAgIGsrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGV0IHN1Y2Nlc3NpdmVBQ1N0YXRlID0gMDtcbiAgbGV0IHN1Y2Nlc3NpdmVBQ05leHRWYWx1ZTtcbiAgZnVuY3Rpb24gZGVjb2RlQUNTdWNjZXNzaXZlKGNvbXBvbmVudCwgenopIHtcbiAgICBsZXQgayA9IHNwZWN0cmFsU3RhcnQ7XG4gICAgY29uc3QgZSA9IHNwZWN0cmFsRW5kO1xuICAgIGxldCByID0gMDtcbiAgICB3aGlsZSAoayA8PSBlKSB7XG4gICAgICBjb25zdCB6ID0gZGN0WmlnWmFnW2tdO1xuICAgICAgY29uc3QgZGlyZWN0aW9uID0genpbel0gPCAwID8gLTEgOiAxO1xuICAgICAgc3dpdGNoIChzdWNjZXNzaXZlQUNTdGF0ZSkge1xuICAgICAgICBjYXNlIDA6IHsgLy8gaW5pdGlhbCBzdGF0ZVxuICAgICAgICAgIGNvbnN0IHJzID0gZGVjb2RlSHVmZm1hbihjb21wb25lbnQuaHVmZm1hblRhYmxlQUMpO1xuICAgICAgICAgIGNvbnN0IHMgPSBycyAmIDE1O1xuICAgICAgICAgIHIgPSBycyA+PiA0O1xuICAgICAgICAgIGlmIChzID09PSAwKSB7XG4gICAgICAgICAgICBpZiAociA8IDE1KSB7XG4gICAgICAgICAgICAgIGVvYnJ1biA9IHJlY2VpdmUocikgKyAoMSA8PCByKTtcbiAgICAgICAgICAgICAgc3VjY2Vzc2l2ZUFDU3RhdGUgPSA0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgciA9IDE2O1xuICAgICAgICAgICAgICBzdWNjZXNzaXZlQUNTdGF0ZSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzICE9PSAxKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBBQ24gZW5jb2RpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1Y2Nlc3NpdmVBQ05leHRWYWx1ZSA9IHJlY2VpdmVBbmRFeHRlbmQocyk7XG4gICAgICAgICAgICBzdWNjZXNzaXZlQUNTdGF0ZSA9IHIgPyAyIDogMztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29udGludWVcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDE6IC8vIHNraXBwaW5nIHIgemVybyBpdGVtc1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgaWYgKHp6W3pdKSB7XG4gICAgICAgICAgICB6elt6XSArPSAocmVhZEJpdCgpIDw8IHN1Y2Nlc3NpdmUpICogZGlyZWN0aW9uO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByLS07XG4gICAgICAgICAgICBpZiAociA9PT0gMCkge1xuICAgICAgICAgICAgICBzdWNjZXNzaXZlQUNTdGF0ZSA9IHN1Y2Nlc3NpdmVBQ1N0YXRlID09PSAyID8gMyA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6IC8vIHNldCB2YWx1ZSBmb3IgYSB6ZXJvIGl0ZW1cbiAgICAgICAgICBpZiAoenpbel0pIHtcbiAgICAgICAgICAgIHp6W3pdICs9IChyZWFkQml0KCkgPDwgc3VjY2Vzc2l2ZSkgKiBkaXJlY3Rpb247XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHp6W3pdID0gc3VjY2Vzc2l2ZUFDTmV4dFZhbHVlIDw8IHN1Y2Nlc3NpdmU7XG4gICAgICAgICAgICBzdWNjZXNzaXZlQUNTdGF0ZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6IC8vIGVvYlxuICAgICAgICAgIGlmICh6elt6XSkge1xuICAgICAgICAgICAgenpbel0gKz0gKHJlYWRCaXQoKSA8PCBzdWNjZXNzaXZlKSAqIGRpcmVjdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBrKys7XG4gICAgfVxuICAgIGlmIChzdWNjZXNzaXZlQUNTdGF0ZSA9PT0gNCkge1xuICAgICAgZW9icnVuLS07XG4gICAgICBpZiAoZW9icnVuID09PSAwKSB7XG4gICAgICAgIHN1Y2Nlc3NpdmVBQ1N0YXRlID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlTWN1KGNvbXBvbmVudCwgZGVjb2RlRnVuY3Rpb24sIG1jdSwgcm93LCBjb2wpIHtcbiAgICBjb25zdCBtY3VSb3cgPSAobWN1IC8gbWN1c1BlckxpbmUpIHwgMDtcbiAgICBjb25zdCBtY3VDb2wgPSBtY3UgJSBtY3VzUGVyTGluZTtcbiAgICBjb25zdCBibG9ja1JvdyA9IChtY3VSb3cgKiBjb21wb25lbnQudikgKyByb3c7XG4gICAgY29uc3QgYmxvY2tDb2wgPSAobWN1Q29sICogY29tcG9uZW50LmgpICsgY29sO1xuICAgIGRlY29kZUZ1bmN0aW9uKGNvbXBvbmVudCwgY29tcG9uZW50LmJsb2Nrc1tibG9ja1Jvd11bYmxvY2tDb2xdKTtcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGVCbG9jayhjb21wb25lbnQsIGRlY29kZUZ1bmN0aW9uLCBtY3UpIHtcbiAgICBjb25zdCBibG9ja1JvdyA9IChtY3UgLyBjb21wb25lbnQuYmxvY2tzUGVyTGluZSkgfCAwO1xuICAgIGNvbnN0IGJsb2NrQ29sID0gbWN1ICUgY29tcG9uZW50LmJsb2Nrc1BlckxpbmU7XG4gICAgZGVjb2RlRnVuY3Rpb24oY29tcG9uZW50LCBjb21wb25lbnQuYmxvY2tzW2Jsb2NrUm93XVtibG9ja0NvbF0pO1xuICB9XG5cbiAgY29uc3QgY29tcG9uZW50c0xlbmd0aCA9IGNvbXBvbmVudHMubGVuZ3RoO1xuICBsZXQgY29tcG9uZW50O1xuICBsZXQgaTtcbiAgbGV0IGo7XG4gIGxldCBrO1xuICBsZXQgbjtcbiAgbGV0IGRlY29kZUZuO1xuICBpZiAocHJvZ3Jlc3NpdmUpIHtcbiAgICBpZiAoc3BlY3RyYWxTdGFydCA9PT0gMCkge1xuICAgICAgZGVjb2RlRm4gPSBzdWNjZXNzaXZlUHJldiA9PT0gMCA/IGRlY29kZURDRmlyc3QgOiBkZWNvZGVEQ1N1Y2Nlc3NpdmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlY29kZUZuID0gc3VjY2Vzc2l2ZVByZXYgPT09IDAgPyBkZWNvZGVBQ0ZpcnN0IDogZGVjb2RlQUNTdWNjZXNzaXZlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkZWNvZGVGbiA9IGRlY29kZUJhc2VsaW5lO1xuICB9XG5cbiAgbGV0IG1jdSA9IDA7XG4gIGxldCBtYXJrZXI7XG4gIGxldCBtY3VFeHBlY3RlZDtcbiAgaWYgKGNvbXBvbmVudHNMZW5ndGggPT09IDEpIHtcbiAgICBtY3VFeHBlY3RlZCA9IGNvbXBvbmVudHNbMF0uYmxvY2tzUGVyTGluZSAqIGNvbXBvbmVudHNbMF0uYmxvY2tzUGVyQ29sdW1uO1xuICB9IGVsc2Uge1xuICAgIG1jdUV4cGVjdGVkID0gbWN1c1BlckxpbmUgKiBmcmFtZS5tY3VzUGVyQ29sdW1uO1xuICB9XG5cbiAgY29uc3QgdXNlZFJlc2V0SW50ZXJ2YWwgPSByZXNldEludGVydmFsIHx8IG1jdUV4cGVjdGVkO1xuXG4gIHdoaWxlIChtY3UgPCBtY3VFeHBlY3RlZCkge1xuICAgIC8vIHJlc2V0IGludGVydmFsIHN0dWZmXG4gICAgZm9yIChpID0gMDsgaSA8IGNvbXBvbmVudHNMZW5ndGg7IGkrKykge1xuICAgICAgY29tcG9uZW50c1tpXS5wcmVkID0gMDtcbiAgICB9XG4gICAgZW9icnVuID0gMDtcblxuICAgIGlmIChjb21wb25lbnRzTGVuZ3RoID09PSAxKSB7XG4gICAgICBjb21wb25lbnQgPSBjb21wb25lbnRzWzBdO1xuICAgICAgZm9yIChuID0gMDsgbiA8IHVzZWRSZXNldEludGVydmFsOyBuKyspIHtcbiAgICAgICAgZGVjb2RlQmxvY2soY29tcG9uZW50LCBkZWNvZGVGbiwgbWN1KTtcbiAgICAgICAgbWN1Kys7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobiA9IDA7IG4gPCB1c2VkUmVzZXRJbnRlcnZhbDsgbisrKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb21wb25lbnRzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb21wb25lbnQgPSBjb21wb25lbnRzW2ldO1xuICAgICAgICAgIGNvbnN0IHsgaCwgdiB9ID0gY29tcG9uZW50O1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB2OyBqKyspIHtcbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBoOyBrKyspIHtcbiAgICAgICAgICAgICAgZGVjb2RlTWN1KGNvbXBvbmVudCwgZGVjb2RlRm4sIG1jdSwgaiwgayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1jdSsrO1xuXG4gICAgICAgIC8vIElmIHdlJ3ZlIHJlYWNoZWQgb3VyIGV4cGVjdGVkIE1DVSdzLCBzdG9wIGRlY29kaW5nXG4gICAgICAgIGlmIChtY3UgPT09IG1jdUV4cGVjdGVkKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmaW5kIG1hcmtlclxuICAgIGJpdHNDb3VudCA9IDA7XG4gICAgbWFya2VyID0gKGRhdGFbb2Zmc2V0XSA8PCA4KSB8IGRhdGFbb2Zmc2V0ICsgMV07XG4gICAgaWYgKG1hcmtlciA8IDB4RkYwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXJrZXIgd2FzIG5vdCBmb3VuZCcpO1xuICAgIH1cblxuICAgIGlmIChtYXJrZXIgPj0gMHhGRkQwICYmIG1hcmtlciA8PSAweEZGRDcpIHsgLy8gUlNUeFxuICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgLSBzdGFydE9mZnNldDtcbn1cblxuZnVuY3Rpb24gYnVpbGRDb21wb25lbnREYXRhKGZyYW1lLCBjb21wb25lbnQpIHtcbiAgY29uc3QgbGluZXMgPSBbXTtcbiAgY29uc3QgeyBibG9ja3NQZXJMaW5lLCBibG9ja3NQZXJDb2x1bW4gfSA9IGNvbXBvbmVudDtcbiAgY29uc3Qgc2FtcGxlc1BlckxpbmUgPSBibG9ja3NQZXJMaW5lIDw8IDM7XG4gIGNvbnN0IFIgPSBuZXcgSW50MzJBcnJheSg2NCk7XG4gIGNvbnN0IHIgPSBuZXcgVWludDhBcnJheSg2NCk7XG5cbiAgLy8gQSBwb3J0IG9mIHBvcHBsZXIncyBJRENUIG1ldGhvZCB3aGljaCBpbiB0dXJuIGlzIHRha2VuIGZyb206XG4gIC8vICAgQ2hyaXN0b3BoIExvZWZmbGVyLCBBZHJpYWFuIExpZ3RlbmJlcmcsIEdlb3JnZSBTLiBNb3NjaHl0eixcbiAgLy8gICBcIlByYWN0aWNhbCBGYXN0IDEtRCBEQ1QgQWxnb3JpdGhtcyB3aXRoIDExIE11bHRpcGxpY2F0aW9uc1wiLFxuICAvLyAgIElFRUUgSW50bC4gQ29uZi4gb24gQWNvdXN0aWNzLCBTcGVlY2ggJiBTaWduYWwgUHJvY2Vzc2luZywgMTk4OSxcbiAgLy8gICA5ODgtOTkxLlxuICBmdW5jdGlvbiBxdWFudGl6ZUFuZEludmVyc2UoenosIGRhdGFPdXQsIGRhdGFJbikge1xuICAgIGNvbnN0IHF0ID0gY29tcG9uZW50LnF1YW50aXphdGlvblRhYmxlO1xuICAgIGxldCB2MDtcbiAgICBsZXQgdjE7XG4gICAgbGV0IHYyO1xuICAgIGxldCB2MztcbiAgICBsZXQgdjQ7XG4gICAgbGV0IHY1O1xuICAgIGxldCB2NjtcbiAgICBsZXQgdjc7XG4gICAgbGV0IHQ7XG4gICAgY29uc3QgcCA9IGRhdGFJbjtcbiAgICBsZXQgaTtcblxuICAgIC8vIGRlcXVhbnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgcFtpXSA9IHp6W2ldICogcXRbaV07XG4gICAgfVxuXG4gICAgLy8gaW52ZXJzZSBEQ1Qgb24gcm93c1xuICAgIGZvciAoaSA9IDA7IGkgPCA4OyArK2kpIHtcbiAgICAgIGNvbnN0IHJvdyA9IDggKiBpO1xuXG4gICAgICAvLyBjaGVjayBmb3IgYWxsLXplcm8gQUMgY29lZmZpY2llbnRzXG4gICAgICBpZiAocFsxICsgcm93XSA9PT0gMCAmJiBwWzIgKyByb3ddID09PSAwICYmIHBbMyArIHJvd10gPT09IDBcbiAgICAgICAgJiYgcFs0ICsgcm93XSA9PT0gMCAmJiBwWzUgKyByb3ddID09PSAwICYmIHBbNiArIHJvd10gPT09IDBcbiAgICAgICAgJiYgcFs3ICsgcm93XSA9PT0gMCkge1xuICAgICAgICB0ID0gKChkY3RTcXJ0MiAqIHBbMCArIHJvd10pICsgNTEyKSA+PiAxMDtcbiAgICAgICAgcFswICsgcm93XSA9IHQ7XG4gICAgICAgIHBbMSArIHJvd10gPSB0O1xuICAgICAgICBwWzIgKyByb3ddID0gdDtcbiAgICAgICAgcFszICsgcm93XSA9IHQ7XG4gICAgICAgIHBbNCArIHJvd10gPSB0O1xuICAgICAgICBwWzUgKyByb3ddID0gdDtcbiAgICAgICAgcFs2ICsgcm93XSA9IHQ7XG4gICAgICAgIHBbNyArIHJvd10gPSB0O1xuICAgICAgICBjb250aW51ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyBzdGFnZSA0XG4gICAgICB2MCA9ICgoZGN0U3FydDIgKiBwWzAgKyByb3ddKSArIDEyOCkgPj4gODtcbiAgICAgIHYxID0gKChkY3RTcXJ0MiAqIHBbNCArIHJvd10pICsgMTI4KSA+PiA4O1xuICAgICAgdjIgPSBwWzIgKyByb3ddO1xuICAgICAgdjMgPSBwWzYgKyByb3ddO1xuICAgICAgdjQgPSAoKGRjdFNxcnQxZDIgKiAocFsxICsgcm93XSAtIHBbNyArIHJvd10pKSArIDEyOCkgPj4gODtcbiAgICAgIHY3ID0gKChkY3RTcXJ0MWQyICogKHBbMSArIHJvd10gKyBwWzcgKyByb3ddKSkgKyAxMjgpID4+IDg7XG4gICAgICB2NSA9IHBbMyArIHJvd10gPDwgNDtcbiAgICAgIHY2ID0gcFs1ICsgcm93XSA8PCA0O1xuXG4gICAgICAvLyBzdGFnZSAzXG4gICAgICB0ID0gKHYwIC0gdjEgKyAxKSA+PiAxO1xuICAgICAgdjAgPSAodjAgKyB2MSArIDEpID4+IDE7XG4gICAgICB2MSA9IHQ7XG4gICAgICB0ID0gKCh2MiAqIGRjdFNpbjYpICsgKHYzICogZGN0Q29zNikgKyAxMjgpID4+IDg7XG4gICAgICB2MiA9ICgodjIgKiBkY3RDb3M2KSAtICh2MyAqIGRjdFNpbjYpICsgMTI4KSA+PiA4O1xuICAgICAgdjMgPSB0O1xuICAgICAgdCA9ICh2NCAtIHY2ICsgMSkgPj4gMTtcbiAgICAgIHY0ID0gKHY0ICsgdjYgKyAxKSA+PiAxO1xuICAgICAgdjYgPSB0O1xuICAgICAgdCA9ICh2NyArIHY1ICsgMSkgPj4gMTtcbiAgICAgIHY1ID0gKHY3IC0gdjUgKyAxKSA+PiAxO1xuICAgICAgdjcgPSB0O1xuXG4gICAgICAvLyBzdGFnZSAyXG4gICAgICB0ID0gKHYwIC0gdjMgKyAxKSA+PiAxO1xuICAgICAgdjAgPSAodjAgKyB2MyArIDEpID4+IDE7XG4gICAgICB2MyA9IHQ7XG4gICAgICB0ID0gKHYxIC0gdjIgKyAxKSA+PiAxO1xuICAgICAgdjEgPSAodjEgKyB2MiArIDEpID4+IDE7XG4gICAgICB2MiA9IHQ7XG4gICAgICB0ID0gKCh2NCAqIGRjdFNpbjMpICsgKHY3ICogZGN0Q29zMykgKyAyMDQ4KSA+PiAxMjtcbiAgICAgIHY0ID0gKCh2NCAqIGRjdENvczMpIC0gKHY3ICogZGN0U2luMykgKyAyMDQ4KSA+PiAxMjtcbiAgICAgIHY3ID0gdDtcbiAgICAgIHQgPSAoKHY1ICogZGN0U2luMSkgKyAodjYgKiBkY3RDb3MxKSArIDIwNDgpID4+IDEyO1xuICAgICAgdjUgPSAoKHY1ICogZGN0Q29zMSkgLSAodjYgKiBkY3RTaW4xKSArIDIwNDgpID4+IDEyO1xuICAgICAgdjYgPSB0O1xuXG4gICAgICAvLyBzdGFnZSAxXG4gICAgICBwWzAgKyByb3ddID0gdjAgKyB2NztcbiAgICAgIHBbNyArIHJvd10gPSB2MCAtIHY3O1xuICAgICAgcFsxICsgcm93XSA9IHYxICsgdjY7XG4gICAgICBwWzYgKyByb3ddID0gdjEgLSB2NjtcbiAgICAgIHBbMiArIHJvd10gPSB2MiArIHY1O1xuICAgICAgcFs1ICsgcm93XSA9IHYyIC0gdjU7XG4gICAgICBwWzMgKyByb3ddID0gdjMgKyB2NDtcbiAgICAgIHBbNCArIHJvd10gPSB2MyAtIHY0O1xuICAgIH1cblxuICAgIC8vIGludmVyc2UgRENUIG9uIGNvbHVtbnNcbiAgICBmb3IgKGkgPSAwOyBpIDwgODsgKytpKSB7XG4gICAgICBjb25zdCBjb2wgPSBpO1xuXG4gICAgICAvLyBjaGVjayBmb3IgYWxsLXplcm8gQUMgY29lZmZpY2llbnRzXG4gICAgICBpZiAocFsoMSAqIDgpICsgY29sXSA9PT0gMCAmJiBwWygyICogOCkgKyBjb2xdID09PSAwICYmIHBbKDMgKiA4KSArIGNvbF0gPT09IDBcbiAgICAgICAgJiYgcFsoNCAqIDgpICsgY29sXSA9PT0gMCAmJiBwWyg1ICogOCkgKyBjb2xdID09PSAwICYmIHBbKDYgKiA4KSArIGNvbF0gPT09IDBcbiAgICAgICAgJiYgcFsoNyAqIDgpICsgY29sXSA9PT0gMCkge1xuICAgICAgICB0ID0gKChkY3RTcXJ0MiAqIGRhdGFJbltpICsgMF0pICsgODE5MikgPj4gMTQ7XG4gICAgICAgIHBbKDAgKiA4KSArIGNvbF0gPSB0O1xuICAgICAgICBwWygxICogOCkgKyBjb2xdID0gdDtcbiAgICAgICAgcFsoMiAqIDgpICsgY29sXSA9IHQ7XG4gICAgICAgIHBbKDMgKiA4KSArIGNvbF0gPSB0O1xuICAgICAgICBwWyg0ICogOCkgKyBjb2xdID0gdDtcbiAgICAgICAgcFsoNSAqIDgpICsgY29sXSA9IHQ7XG4gICAgICAgIHBbKDYgKiA4KSArIGNvbF0gPSB0O1xuICAgICAgICBwWyg3ICogOCkgKyBjb2xdID0gdDtcbiAgICAgICAgY29udGludWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gc3RhZ2UgNFxuICAgICAgdjAgPSAoKGRjdFNxcnQyICogcFsoMCAqIDgpICsgY29sXSkgKyAyMDQ4KSA+PiAxMjtcbiAgICAgIHYxID0gKChkY3RTcXJ0MiAqIHBbKDQgKiA4KSArIGNvbF0pICsgMjA0OCkgPj4gMTI7XG4gICAgICB2MiA9IHBbKDIgKiA4KSArIGNvbF07XG4gICAgICB2MyA9IHBbKDYgKiA4KSArIGNvbF07XG4gICAgICB2NCA9ICgoZGN0U3FydDFkMiAqIChwWygxICogOCkgKyBjb2xdIC0gcFsoNyAqIDgpICsgY29sXSkpICsgMjA0OCkgPj4gMTI7XG4gICAgICB2NyA9ICgoZGN0U3FydDFkMiAqIChwWygxICogOCkgKyBjb2xdICsgcFsoNyAqIDgpICsgY29sXSkpICsgMjA0OCkgPj4gMTI7XG4gICAgICB2NSA9IHBbKDMgKiA4KSArIGNvbF07XG4gICAgICB2NiA9IHBbKDUgKiA4KSArIGNvbF07XG5cbiAgICAgIC8vIHN0YWdlIDNcbiAgICAgIHQgPSAodjAgLSB2MSArIDEpID4+IDE7XG4gICAgICB2MCA9ICh2MCArIHYxICsgMSkgPj4gMTtcbiAgICAgIHYxID0gdDtcbiAgICAgIHQgPSAoKHYyICogZGN0U2luNikgKyAodjMgKiBkY3RDb3M2KSArIDIwNDgpID4+IDEyO1xuICAgICAgdjIgPSAoKHYyICogZGN0Q29zNikgLSAodjMgKiBkY3RTaW42KSArIDIwNDgpID4+IDEyO1xuICAgICAgdjMgPSB0O1xuICAgICAgdCA9ICh2NCAtIHY2ICsgMSkgPj4gMTtcbiAgICAgIHY0ID0gKHY0ICsgdjYgKyAxKSA+PiAxO1xuICAgICAgdjYgPSB0O1xuICAgICAgdCA9ICh2NyArIHY1ICsgMSkgPj4gMTtcbiAgICAgIHY1ID0gKHY3IC0gdjUgKyAxKSA+PiAxO1xuICAgICAgdjcgPSB0O1xuXG4gICAgICAvLyBzdGFnZSAyXG4gICAgICB0ID0gKHYwIC0gdjMgKyAxKSA+PiAxO1xuICAgICAgdjAgPSAodjAgKyB2MyArIDEpID4+IDE7XG4gICAgICB2MyA9IHQ7XG4gICAgICB0ID0gKHYxIC0gdjIgKyAxKSA+PiAxO1xuICAgICAgdjEgPSAodjEgKyB2MiArIDEpID4+IDE7XG4gICAgICB2MiA9IHQ7XG4gICAgICB0ID0gKCh2NCAqIGRjdFNpbjMpICsgKHY3ICogZGN0Q29zMykgKyAyMDQ4KSA+PiAxMjtcbiAgICAgIHY0ID0gKCh2NCAqIGRjdENvczMpIC0gKHY3ICogZGN0U2luMykgKyAyMDQ4KSA+PiAxMjtcbiAgICAgIHY3ID0gdDtcbiAgICAgIHQgPSAoKHY1ICogZGN0U2luMSkgKyAodjYgKiBkY3RDb3MxKSArIDIwNDgpID4+IDEyO1xuICAgICAgdjUgPSAoKHY1ICogZGN0Q29zMSkgLSAodjYgKiBkY3RTaW4xKSArIDIwNDgpID4+IDEyO1xuICAgICAgdjYgPSB0O1xuXG4gICAgICAvLyBzdGFnZSAxXG4gICAgICBwWygwICogOCkgKyBjb2xdID0gdjAgKyB2NztcbiAgICAgIHBbKDcgKiA4KSArIGNvbF0gPSB2MCAtIHY3O1xuICAgICAgcFsoMSAqIDgpICsgY29sXSA9IHYxICsgdjY7XG4gICAgICBwWyg2ICogOCkgKyBjb2xdID0gdjEgLSB2NjtcbiAgICAgIHBbKDIgKiA4KSArIGNvbF0gPSB2MiArIHY1O1xuICAgICAgcFsoNSAqIDgpICsgY29sXSA9IHYyIC0gdjU7XG4gICAgICBwWygzICogOCkgKyBjb2xdID0gdjMgKyB2NDtcbiAgICAgIHBbKDQgKiA4KSArIGNvbF0gPSB2MyAtIHY0O1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgdG8gOC1iaXQgaW50ZWdlcnNcbiAgICBmb3IgKGkgPSAwOyBpIDwgNjQ7ICsraSkge1xuICAgICAgY29uc3Qgc2FtcGxlID0gMTI4ICsgKChwW2ldICsgOCkgPj4gNCk7XG4gICAgICBpZiAoc2FtcGxlIDwgMCkge1xuICAgICAgICBkYXRhT3V0W2ldID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoc2FtcGxlID4gMFhGRikge1xuICAgICAgICBkYXRhT3V0W2ldID0gMHhGRjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGFPdXRbaV0gPSBzYW1wbGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yIChsZXQgYmxvY2tSb3cgPSAwOyBibG9ja1JvdyA8IGJsb2Nrc1BlckNvbHVtbjsgYmxvY2tSb3crKykge1xuICAgIGNvbnN0IHNjYW5MaW5lID0gYmxvY2tSb3cgPDwgMztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgICAgbGluZXMucHVzaChuZXcgVWludDhBcnJheShzYW1wbGVzUGVyTGluZSkpO1xuICAgIH1cbiAgICBmb3IgKGxldCBibG9ja0NvbCA9IDA7IGJsb2NrQ29sIDwgYmxvY2tzUGVyTGluZTsgYmxvY2tDb2wrKykge1xuICAgICAgcXVhbnRpemVBbmRJbnZlcnNlKGNvbXBvbmVudC5ibG9ja3NbYmxvY2tSb3ddW2Jsb2NrQ29sXSwgciwgUik7XG5cbiAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgY29uc3Qgc2FtcGxlID0gYmxvY2tDb2wgPDwgMztcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgODsgaisrKSB7XG4gICAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tzY2FuTGluZSArIGpdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgICAgICAgIGxpbmVbc2FtcGxlICsgaV0gPSByW29mZnNldCsrXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbGluZXM7XG59XG5cbmNsYXNzIEpwZWdTdHJlYW1SZWFkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmpmaWYgPSBudWxsO1xuICAgIHRoaXMuYWRvYmUgPSBudWxsO1xuXG4gICAgdGhpcy5xdWFudGl6YXRpb25UYWJsZXMgPSBbXTtcbiAgICB0aGlzLmh1ZmZtYW5UYWJsZXNBQyA9IFtdO1xuICAgIHRoaXMuaHVmZm1hblRhYmxlc0RDID0gW107XG4gICAgdGhpcy5yZXNldEZyYW1lcygpO1xuICB9XG5cbiAgcmVzZXRGcmFtZXMoKSB7XG4gICAgdGhpcy5mcmFtZXMgPSBbXTtcbiAgfVxuXG4gIHBhcnNlKGRhdGEpIHtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAvLyBjb25zdCB7IGxlbmd0aCB9ID0gZGF0YTtcbiAgICBmdW5jdGlvbiByZWFkVWludDE2KCkge1xuICAgICAgY29uc3QgdmFsdWUgPSAoZGF0YVtvZmZzZXRdIDw8IDgpIHwgZGF0YVtvZmZzZXQgKyAxXTtcbiAgICAgIG9mZnNldCArPSAyO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWFkRGF0YUJsb2NrKCkge1xuICAgICAgY29uc3QgbGVuZ3RoID0gcmVhZFVpbnQxNigpO1xuICAgICAgY29uc3QgYXJyYXkgPSBkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoIC0gMik7XG4gICAgICBvZmZzZXQgKz0gYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVwYXJlQ29tcG9uZW50cyhmcmFtZSkge1xuICAgICAgbGV0IG1heEggPSAwO1xuICAgICAgbGV0IG1heFYgPSAwO1xuICAgICAgbGV0IGNvbXBvbmVudDtcbiAgICAgIGxldCBjb21wb25lbnRJZDtcbiAgICAgIGZvciAoY29tcG9uZW50SWQgaW4gZnJhbWUuY29tcG9uZW50cykge1xuICAgICAgICBpZiAoZnJhbWUuY29tcG9uZW50cy5oYXNPd25Qcm9wZXJ0eShjb21wb25lbnRJZCkpIHtcbiAgICAgICAgICBjb21wb25lbnQgPSBmcmFtZS5jb21wb25lbnRzW2NvbXBvbmVudElkXTtcbiAgICAgICAgICBpZiAobWF4SCA8IGNvbXBvbmVudC5oKSB7XG4gICAgICAgICAgICBtYXhIID0gY29tcG9uZW50Lmg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtYXhWIDwgY29tcG9uZW50LnYpIHtcbiAgICAgICAgICAgIG1heFYgPSBjb21wb25lbnQudjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IG1jdXNQZXJMaW5lID0gTWF0aC5jZWlsKGZyYW1lLnNhbXBsZXNQZXJMaW5lIC8gOCAvIG1heEgpO1xuICAgICAgY29uc3QgbWN1c1BlckNvbHVtbiA9IE1hdGguY2VpbChmcmFtZS5zY2FuTGluZXMgLyA4IC8gbWF4Vik7XG4gICAgICBmb3IgKGNvbXBvbmVudElkIGluIGZyYW1lLmNvbXBvbmVudHMpIHtcbiAgICAgICAgaWYgKGZyYW1lLmNvbXBvbmVudHMuaGFzT3duUHJvcGVydHkoY29tcG9uZW50SWQpKSB7XG4gICAgICAgICAgY29tcG9uZW50ID0gZnJhbWUuY29tcG9uZW50c1tjb21wb25lbnRJZF07XG4gICAgICAgICAgY29uc3QgYmxvY2tzUGVyTGluZSA9IE1hdGguY2VpbChNYXRoLmNlaWwoZnJhbWUuc2FtcGxlc1BlckxpbmUgLyA4KSAqIGNvbXBvbmVudC5oIC8gbWF4SCk7XG4gICAgICAgICAgY29uc3QgYmxvY2tzUGVyQ29sdW1uID0gTWF0aC5jZWlsKE1hdGguY2VpbChmcmFtZS5zY2FuTGluZXMgLyA4KSAqIGNvbXBvbmVudC52IC8gbWF4Vik7XG4gICAgICAgICAgY29uc3QgYmxvY2tzUGVyTGluZUZvck1jdSA9IG1jdXNQZXJMaW5lICogY29tcG9uZW50Lmg7XG4gICAgICAgICAgY29uc3QgYmxvY2tzUGVyQ29sdW1uRm9yTWN1ID0gbWN1c1BlckNvbHVtbiAqIGNvbXBvbmVudC52O1xuICAgICAgICAgIGNvbnN0IGJsb2NrcyA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tzUGVyQ29sdW1uRm9yTWN1OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJvdyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBibG9ja3NQZXJMaW5lRm9yTWN1OyBqKyspIHtcbiAgICAgICAgICAgICAgcm93LnB1c2gobmV3IEludDMyQXJyYXkoNjQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJsb2Nrcy5wdXNoKHJvdyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbXBvbmVudC5ibG9ja3NQZXJMaW5lID0gYmxvY2tzUGVyTGluZTtcbiAgICAgICAgICBjb21wb25lbnQuYmxvY2tzUGVyQ29sdW1uID0gYmxvY2tzUGVyQ29sdW1uO1xuICAgICAgICAgIGNvbXBvbmVudC5ibG9ja3MgPSBibG9ja3M7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZyYW1lLm1heEggPSBtYXhIO1xuICAgICAgZnJhbWUubWF4ViA9IG1heFY7XG4gICAgICBmcmFtZS5tY3VzUGVyTGluZSA9IG1jdXNQZXJMaW5lO1xuICAgICAgZnJhbWUubWN1c1BlckNvbHVtbiA9IG1jdXNQZXJDb2x1bW47XG4gICAgfVxuXG4gICAgbGV0IGZpbGVNYXJrZXIgPSByZWFkVWludDE2KCk7XG4gICAgaWYgKGZpbGVNYXJrZXIgIT09IDB4RkZEOCkgeyAvLyBTT0kgKFN0YXJ0IG9mIEltYWdlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTT0kgbm90IGZvdW5kJyk7XG4gICAgfVxuXG4gICAgZmlsZU1hcmtlciA9IHJlYWRVaW50MTYoKTtcbiAgICB3aGlsZSAoZmlsZU1hcmtlciAhPT0gMHhGRkQ5KSB7IC8vIEVPSSAoRW5kIG9mIGltYWdlKVxuICAgICAgc3dpdGNoIChmaWxlTWFya2VyKSB7XG4gICAgICAgIGNhc2UgMHhGRjAwOiBicmVhaztcbiAgICAgICAgY2FzZSAweEZGRTA6IC8vIEFQUDAgKEFwcGxpY2F0aW9uIFNwZWNpZmljKVxuICAgICAgICBjYXNlIDB4RkZFMTogLy8gQVBQMVxuICAgICAgICBjYXNlIDB4RkZFMjogLy8gQVBQMlxuICAgICAgICBjYXNlIDB4RkZFMzogLy8gQVBQM1xuICAgICAgICBjYXNlIDB4RkZFNDogLy8gQVBQNFxuICAgICAgICBjYXNlIDB4RkZFNTogLy8gQVBQNVxuICAgICAgICBjYXNlIDB4RkZFNjogLy8gQVBQNlxuICAgICAgICBjYXNlIDB4RkZFNzogLy8gQVBQN1xuICAgICAgICBjYXNlIDB4RkZFODogLy8gQVBQOFxuICAgICAgICBjYXNlIDB4RkZFOTogLy8gQVBQOVxuICAgICAgICBjYXNlIDB4RkZFQTogLy8gQVBQMTBcbiAgICAgICAgY2FzZSAweEZGRUI6IC8vIEFQUDExXG4gICAgICAgIGNhc2UgMHhGRkVDOiAvLyBBUFAxMlxuICAgICAgICBjYXNlIDB4RkZFRDogLy8gQVBQMTNcbiAgICAgICAgY2FzZSAweEZGRUU6IC8vIEFQUDE0XG4gICAgICAgIGNhc2UgMHhGRkVGOiAvLyBBUFAxNVxuICAgICAgICBjYXNlIDB4RkZGRTogeyAvLyBDT00gKENvbW1lbnQpXG4gICAgICAgICAgY29uc3QgYXBwRGF0YSA9IHJlYWREYXRhQmxvY2soKTtcblxuICAgICAgICAgIGlmIChmaWxlTWFya2VyID09PSAweEZGRTApIHtcbiAgICAgICAgICAgIGlmIChhcHBEYXRhWzBdID09PSAweDRBICYmIGFwcERhdGFbMV0gPT09IDB4NDYgJiYgYXBwRGF0YVsyXSA9PT0gMHg0OVxuICAgICAgICAgICAgICAmJiBhcHBEYXRhWzNdID09PSAweDQ2ICYmIGFwcERhdGFbNF0gPT09IDApIHsgLy8gJ0pGSUZcXHgwMCdcbiAgICAgICAgICAgICAgdGhpcy5qZmlmID0ge1xuICAgICAgICAgICAgICAgIHZlcnNpb246IHsgbWFqb3I6IGFwcERhdGFbNV0sIG1pbm9yOiBhcHBEYXRhWzZdIH0sXG4gICAgICAgICAgICAgICAgZGVuc2l0eVVuaXRzOiBhcHBEYXRhWzddLFxuICAgICAgICAgICAgICAgIHhEZW5zaXR5OiAoYXBwRGF0YVs4XSA8PCA4KSB8IGFwcERhdGFbOV0sXG4gICAgICAgICAgICAgICAgeURlbnNpdHk6IChhcHBEYXRhWzEwXSA8PCA4KSB8IGFwcERhdGFbMTFdLFxuICAgICAgICAgICAgICAgIHRodW1iV2lkdGg6IGFwcERhdGFbMTJdLFxuICAgICAgICAgICAgICAgIHRodW1iSGVpZ2h0OiBhcHBEYXRhWzEzXSxcbiAgICAgICAgICAgICAgICB0aHVtYkRhdGE6IGFwcERhdGEuc3ViYXJyYXkoMTQsIDE0ICsgKDMgKiBhcHBEYXRhWzEyXSAqIGFwcERhdGFbMTNdKSksXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFRPRE8gQVBQMSAtIEV4aWZcbiAgICAgICAgICBpZiAoZmlsZU1hcmtlciA9PT0gMHhGRkVFKSB7XG4gICAgICAgICAgICBpZiAoYXBwRGF0YVswXSA9PT0gMHg0MSAmJiBhcHBEYXRhWzFdID09PSAweDY0ICYmIGFwcERhdGFbMl0gPT09IDB4NkZcbiAgICAgICAgICAgICAgJiYgYXBwRGF0YVszXSA9PT0gMHg2MiAmJiBhcHBEYXRhWzRdID09PSAweDY1ICYmIGFwcERhdGFbNV0gPT09IDApIHsgLy8gJ0Fkb2JlXFx4MDAnXG4gICAgICAgICAgICAgIHRoaXMuYWRvYmUgPSB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogYXBwRGF0YVs2XSxcbiAgICAgICAgICAgICAgICBmbGFnczA6IChhcHBEYXRhWzddIDw8IDgpIHwgYXBwRGF0YVs4XSxcbiAgICAgICAgICAgICAgICBmbGFnczE6IChhcHBEYXRhWzldIDw8IDgpIHwgYXBwRGF0YVsxMF0sXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtQ29kZTogYXBwRGF0YVsxMV0sXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAweEZGREI6IHsgLy8gRFFUIChEZWZpbmUgUXVhbnRpemF0aW9uIFRhYmxlcylcbiAgICAgICAgICBjb25zdCBxdWFudGl6YXRpb25UYWJsZXNMZW5ndGggPSByZWFkVWludDE2KCk7XG4gICAgICAgICAgY29uc3QgcXVhbnRpemF0aW9uVGFibGVzRW5kID0gcXVhbnRpemF0aW9uVGFibGVzTGVuZ3RoICsgb2Zmc2V0IC0gMjtcbiAgICAgICAgICB3aGlsZSAob2Zmc2V0IDwgcXVhbnRpemF0aW9uVGFibGVzRW5kKSB7XG4gICAgICAgICAgICBjb25zdCBxdWFudGl6YXRpb25UYWJsZVNwZWMgPSBkYXRhW29mZnNldCsrXTtcbiAgICAgICAgICAgIGNvbnN0IHRhYmxlRGF0YSA9IG5ldyBJbnQzMkFycmF5KDY0KTtcbiAgICAgICAgICAgIGlmICgocXVhbnRpemF0aW9uVGFibGVTcGVjID4+IDQpID09PSAwKSB7IC8vIDggYml0IHZhbHVlc1xuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDY0OyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB6ID0gZGN0WmlnWmFnW2pdO1xuICAgICAgICAgICAgICAgIHRhYmxlRGF0YVt6XSA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChxdWFudGl6YXRpb25UYWJsZVNwZWMgPj4gNCkgPT09IDEpIHsgLy8gMTYgYml0XG4gICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgNjQ7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHogPSBkY3RaaWdaYWdbal07XG4gICAgICAgICAgICAgICAgdGFibGVEYXRhW3pdID0gcmVhZFVpbnQxNigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RRVDogaW52YWxpZCB0YWJsZSBzcGVjJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnF1YW50aXphdGlvblRhYmxlc1txdWFudGl6YXRpb25UYWJsZVNwZWMgJiAxNV0gPSB0YWJsZURhdGE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAweEZGQzA6IC8vIFNPRjAgKFN0YXJ0IG9mIEZyYW1lLCBCYXNlbGluZSBEQ1QpXG4gICAgICAgIGNhc2UgMHhGRkMxOiAvLyBTT0YxIChTdGFydCBvZiBGcmFtZSwgRXh0ZW5kZWQgRENUKVxuICAgICAgICBjYXNlIDB4RkZDMjogeyAvLyBTT0YyIChTdGFydCBvZiBGcmFtZSwgUHJvZ3Jlc3NpdmUgRENUKVxuICAgICAgICAgIHJlYWRVaW50MTYoKTsgLy8gc2tpcCBkYXRhIGxlbmd0aFxuICAgICAgICAgIGNvbnN0IGZyYW1lID0ge1xuICAgICAgICAgICAgZXh0ZW5kZWQ6IChmaWxlTWFya2VyID09PSAweEZGQzEpLFxuICAgICAgICAgICAgcHJvZ3Jlc3NpdmU6IChmaWxlTWFya2VyID09PSAweEZGQzIpLFxuICAgICAgICAgICAgcHJlY2lzaW9uOiBkYXRhW29mZnNldCsrXSxcbiAgICAgICAgICAgIHNjYW5MaW5lczogcmVhZFVpbnQxNigpLFxuICAgICAgICAgICAgc2FtcGxlc1BlckxpbmU6IHJlYWRVaW50MTYoKSxcbiAgICAgICAgICAgIGNvbXBvbmVudHM6IHt9LFxuICAgICAgICAgICAgY29tcG9uZW50c09yZGVyOiBbXSxcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY29uc3QgY29tcG9uZW50c0NvdW50ID0gZGF0YVtvZmZzZXQrK107XG4gICAgICAgICAgbGV0IGNvbXBvbmVudElkO1xuICAgICAgICAgIC8vIGxldCBtYXhIID0gMDtcbiAgICAgICAgICAvLyBsZXQgbWF4ViA9IDA7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb21wb25lbnRzQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29tcG9uZW50SWQgPSBkYXRhW29mZnNldF07XG4gICAgICAgICAgICBjb25zdCBoID0gZGF0YVtvZmZzZXQgKyAxXSA+PiA0O1xuICAgICAgICAgICAgY29uc3QgdiA9IGRhdGFbb2Zmc2V0ICsgMV0gJiAxNTtcbiAgICAgICAgICAgIGNvbnN0IHFJZCA9IGRhdGFbb2Zmc2V0ICsgMl07XG4gICAgICAgICAgICBmcmFtZS5jb21wb25lbnRzT3JkZXIucHVzaChjb21wb25lbnRJZCk7XG4gICAgICAgICAgICBmcmFtZS5jb21wb25lbnRzW2NvbXBvbmVudElkXSA9IHtcbiAgICAgICAgICAgICAgaCxcbiAgICAgICAgICAgICAgdixcbiAgICAgICAgICAgICAgcXVhbnRpemF0aW9uSWR4OiBxSWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByZXBhcmVDb21wb25lbnRzKGZyYW1lKTtcbiAgICAgICAgICB0aGlzLmZyYW1lcy5wdXNoKGZyYW1lKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgMHhGRkM0OiB7IC8vIERIVCAoRGVmaW5lIEh1ZmZtYW4gVGFibGVzKVxuICAgICAgICAgIGNvbnN0IGh1ZmZtYW5MZW5ndGggPSByZWFkVWludDE2KCk7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCBodWZmbWFuTGVuZ3RoOykge1xuICAgICAgICAgICAgY29uc3QgaHVmZm1hblRhYmxlU3BlYyA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgICAgICAgY29uc3QgY29kZUxlbmd0aHMgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgICAgICAgICBsZXQgY29kZUxlbmd0aFN1bSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDE2OyBqKyssIG9mZnNldCsrKSB7XG4gICAgICAgICAgICAgIGNvZGVMZW5ndGhzW2pdID0gZGF0YVtvZmZzZXRdO1xuICAgICAgICAgICAgICBjb2RlTGVuZ3RoU3VtICs9IGNvZGVMZW5ndGhzW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaHVmZm1hblZhbHVlcyA9IG5ldyBVaW50OEFycmF5KGNvZGVMZW5ndGhTdW0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2RlTGVuZ3RoU3VtOyBqKyssIG9mZnNldCsrKSB7XG4gICAgICAgICAgICAgIGh1ZmZtYW5WYWx1ZXNbal0gPSBkYXRhW29mZnNldF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpICs9IDE3ICsgY29kZUxlbmd0aFN1bTtcblxuICAgICAgICAgICAgaWYgKChodWZmbWFuVGFibGVTcGVjID4+IDQpID09PSAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuaHVmZm1hblRhYmxlc0RDW2h1ZmZtYW5UYWJsZVNwZWMgJiAxNV0gPSBidWlsZEh1ZmZtYW5UYWJsZShcbiAgICAgICAgICAgICAgICBjb2RlTGVuZ3RocywgaHVmZm1hblZhbHVlcyxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuaHVmZm1hblRhYmxlc0FDW2h1ZmZtYW5UYWJsZVNwZWMgJiAxNV0gPSBidWlsZEh1ZmZtYW5UYWJsZShcbiAgICAgICAgICAgICAgICBjb2RlTGVuZ3RocywgaHVmZm1hblZhbHVlcyxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjYXNlIDB4RkZERDogLy8gRFJJIChEZWZpbmUgUmVzdGFydCBJbnRlcnZhbClcbiAgICAgICAgICByZWFkVWludDE2KCk7IC8vIHNraXAgZGF0YSBsZW5ndGhcbiAgICAgICAgICB0aGlzLnJlc2V0SW50ZXJ2YWwgPSByZWFkVWludDE2KCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAweEZGREE6IHsgLy8gU09TIChTdGFydCBvZiBTY2FuKVxuICAgICAgICAgIHJlYWRVaW50MTYoKTsgLy8gc2tpcCBsZW5ndGhcbiAgICAgICAgICBjb25zdCBzZWxlY3RvcnNDb3VudCA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgICBjb25zdCBmcmFtZSA9IHRoaXMuZnJhbWVzWzBdO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZWN0b3JzQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gZnJhbWUuY29tcG9uZW50c1tkYXRhW29mZnNldCsrXV07XG4gICAgICAgICAgICBjb25zdCB0YWJsZVNwZWMgPSBkYXRhW29mZnNldCsrXTtcbiAgICAgICAgICAgIGNvbXBvbmVudC5odWZmbWFuVGFibGVEQyA9IHRoaXMuaHVmZm1hblRhYmxlc0RDW3RhYmxlU3BlYyA+PiA0XTtcbiAgICAgICAgICAgIGNvbXBvbmVudC5odWZmbWFuVGFibGVBQyA9IHRoaXMuaHVmZm1hblRhYmxlc0FDW3RhYmxlU3BlYyAmIDE1XTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzcGVjdHJhbFN0YXJ0ID0gZGF0YVtvZmZzZXQrK107XG4gICAgICAgICAgY29uc3Qgc3BlY3RyYWxFbmQgPSBkYXRhW29mZnNldCsrXTtcbiAgICAgICAgICBjb25zdCBzdWNjZXNzaXZlQXBwcm94aW1hdGlvbiA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZCA9IGRlY29kZVNjYW4oZGF0YSwgb2Zmc2V0LFxuICAgICAgICAgICAgZnJhbWUsIGNvbXBvbmVudHMsIHRoaXMucmVzZXRJbnRlcnZhbCxcbiAgICAgICAgICAgIHNwZWN0cmFsU3RhcnQsIHNwZWN0cmFsRW5kLFxuICAgICAgICAgICAgc3VjY2Vzc2l2ZUFwcHJveGltYXRpb24gPj4gNCwgc3VjY2Vzc2l2ZUFwcHJveGltYXRpb24gJiAxNSk7XG4gICAgICAgICAgb2Zmc2V0ICs9IHByb2Nlc3NlZDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgMHhGRkZGOiAvLyBGaWxsIGJ5dGVzXG4gICAgICAgICAgaWYgKGRhdGFbb2Zmc2V0XSAhPT0gMHhGRikgeyAvLyBBdm9pZCBza2lwcGluZyBhIHZhbGlkIG1hcmtlci5cbiAgICAgICAgICAgIG9mZnNldC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChkYXRhW29mZnNldCAtIDNdID09PSAweEZGXG4gICAgICAgICAgICAmJiBkYXRhW29mZnNldCAtIDJdID49IDB4QzAgJiYgZGF0YVtvZmZzZXQgLSAyXSA8PSAweEZFKSB7XG4gICAgICAgICAgICAvLyBjb3VsZCBiZSBpbmNvcnJlY3QgZW5jb2RpbmcgLS0gbGFzdCAweEZGIGJ5dGUgb2YgdGhlIHByZXZpb3VzXG4gICAgICAgICAgICAvLyBibG9jayB3YXMgZWF0ZW4gYnkgdGhlIGVuY29kZXJcbiAgICAgICAgICAgIG9mZnNldCAtPSAzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biBKUEVHIG1hcmtlciAke2ZpbGVNYXJrZXIudG9TdHJpbmcoMTYpfWApO1xuICAgICAgfVxuICAgICAgZmlsZU1hcmtlciA9IHJlYWRVaW50MTYoKTtcbiAgICB9XG4gIH1cblxuICBnZXRSZXN1bHQoKSB7XG4gICAgY29uc3QgeyBmcmFtZXMgfSA9IHRoaXM7XG4gICAgaWYgKHRoaXMuZnJhbWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBmcmFtZXMgd2VyZSBkZWNvZGVkJyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmZyYW1lcy5sZW5ndGggPiAxKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ21vcmUgdGhhbiBvbmUgZnJhbWUgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cblxuICAgIC8vIHNldCBlYWNoIGZyYW1lJ3MgY29tcG9uZW50cyBxdWFudGl6YXRpb24gdGFibGVcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZnJhbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjcCA9IHRoaXMuZnJhbWVzW2ldLmNvbXBvbmVudHM7XG4gICAgICBmb3IgKGNvbnN0IGogb2YgT2JqZWN0LmtleXMoY3ApKSB7XG4gICAgICAgIGNwW2pdLnF1YW50aXphdGlvblRhYmxlID0gdGhpcy5xdWFudGl6YXRpb25UYWJsZXNbY3Bbal0ucXVhbnRpemF0aW9uSWR4XTtcbiAgICAgICAgZGVsZXRlIGNwW2pdLnF1YW50aXphdGlvbklkeDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBmcmFtZSA9IGZyYW1lc1swXTtcbiAgICBjb25zdCB7IGNvbXBvbmVudHMsIGNvbXBvbmVudHNPcmRlciB9ID0gZnJhbWU7XG4gICAgY29uc3Qgb3V0Q29tcG9uZW50cyA9IFtdO1xuICAgIGNvbnN0IHdpZHRoID0gZnJhbWUuc2FtcGxlc1BlckxpbmU7XG4gICAgY29uc3QgaGVpZ2h0ID0gZnJhbWUuc2NhbkxpbmVzO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb21wb25lbnRzT3JkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGNvbXBvbmVudHNbY29tcG9uZW50c09yZGVyW2ldXTtcbiAgICAgIG91dENvbXBvbmVudHMucHVzaCh7XG4gICAgICAgIGxpbmVzOiBidWlsZENvbXBvbmVudERhdGEoZnJhbWUsIGNvbXBvbmVudCksXG4gICAgICAgIHNjYWxlWDogY29tcG9uZW50LmggLyBmcmFtZS5tYXhILFxuICAgICAgICBzY2FsZVk6IGNvbXBvbmVudC52IC8gZnJhbWUubWF4VixcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KHdpZHRoICogaGVpZ2h0ICogb3V0Q29tcG9uZW50cy5sZW5ndGgpO1xuICAgIGxldCBvaSA9IDA7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7ICsreSkge1xuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgKyt4KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0Q29tcG9uZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IG91dENvbXBvbmVudHNbaV07XG4gICAgICAgICAgb3V0W29pXSA9IGNvbXBvbmVudC5saW5lc1swIHwgeSAqIGNvbXBvbmVudC5zY2FsZVldWzAgfCB4ICogY29tcG9uZW50LnNjYWxlWF07XG4gICAgICAgICAgKytvaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEpwZWdEZWNvZGVyIGV4dGVuZHMgQmFzZURlY29kZXIge1xuICBjb25zdHJ1Y3RvcihmaWxlRGlyZWN0b3J5KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnJlYWRlciA9IG5ldyBKcGVnU3RyZWFtUmVhZGVyKCk7XG4gICAgaWYgKGZpbGVEaXJlY3RvcnkuSlBFR1RhYmxlcykge1xuICAgICAgdGhpcy5yZWFkZXIucGFyc2UoZmlsZURpcmVjdG9yeS5KUEVHVGFibGVzKTtcbiAgICB9XG4gIH1cblxuICBkZWNvZGVCbG9jayhidWZmZXIpIHtcbiAgICB0aGlzLnJlYWRlci5yZXNldEZyYW1lcygpO1xuICAgIHRoaXMucmVhZGVyLnBhcnNlKG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpO1xuICAgIHJldHVybiB0aGlzLnJlYWRlci5nZXRSZXN1bHQoKS5idWZmZXI7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==
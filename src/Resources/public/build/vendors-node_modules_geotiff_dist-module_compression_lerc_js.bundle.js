(self["webpackChunkmapsbundle"] = self["webpackChunkmapsbundle"] || []).push([["vendors-node_modules_geotiff_dist-module_compression_lerc_js"],{

/***/ "./node_modules/geotiff/node_modules/lerc/LercDecode.js":
/*!**************************************************************!*\
  !*** ./node_modules/geotiff/node_modules/lerc/LercDecode.js ***!
  \**************************************************************/
/***/ ((module, exports) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;ï»¿/* jshint forin: false, bitwise: false */
/*
Copyright 2015-2021 Esri

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

A copy of the license and additional notices are located with the
source distribution at:

http://github.com/Esri/lerc/

Contributors:  Johannes Schmid, (LERC v1)
               Chayanika Khatua, (LERC v1)
               Wenxue Ju (LERC v1, v2.x)
*/

/* Copyright 2015-2021 Esri. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 @preserve */

/**
 * a module for decoding LERC blobs
 * @module Lerc
 */
(function() {
  //this decoder supports all lerc versions, each version has its own class (LercDecode and Lerc2Decode). 
  //the exported module handles format variation autoamtically.

  //the original LercDecode for Version 1
  var LercDecode = (function() {

    // Note: currently, this module only has an implementation for decoding LERC data, not encoding. The name of
    // the class was chosen to be future proof.

    var CntZImage = {};

    CntZImage.defaultNoDataValue = -3.4027999387901484e+38; // smallest Float32 value

    /**
     * Decode a LERC byte stream and return an object containing the pixel data and some required and optional
     * information about it, such as the image's width and height.
     *
     * @param {ArrayBuffer} input The LERC input byte stream
     * @param {object} [options] Decoding options, containing any of the following properties:
     * @config {number} [inputOffset = 0]
     *        Skip the first inputOffset bytes of the input byte stream. A valid LERC file is expected at that position.
     * @config {Uint8Array} [encodedMask = null]
     *        If specified, the decoder will not read mask information from the input and use the specified encoded
     *        mask data instead. Mask header/data must not be present in the LERC byte stream in this case.
     * @config {number} [noDataValue = LercCode.defaultNoDataValue]
     *        Pixel value to use for masked pixels.
     * @config {ArrayBufferView|Array} [pixelType = Float32Array]
     *        The desired type of the pixelData array in the return value. Note that it is the caller's responsibility to
     *        provide an appropriate noDataValue if the default pixelType is overridden.
     * @config {boolean} [returnMask = false]
     *        If true, the return value will contain a maskData property of type Uint8Array which has one element per
     *        pixel, the value of which is 1 or 0 depending on whether that pixel's data is present or masked. If the
     *        input LERC data does not contain a mask, maskData will not be returned.
     * @config {boolean} [returnEncodedMask = false]
     *        If true, the return value will contain a encodedMaskData property, which can be passed into encode() as
     *        encodedMask.
     * @config {boolean} [returnFileInfo = false]
     *        If true, the return value will have a fileInfo property that contains metadata obtained from the
     *        LERC headers and the decoding process.
     * @config {boolean} [computeUsedBitDepths = false]
     *        If true, the fileInfo property in the return value will contain the set of all block bit depths
     *        encountered during decoding. Will only have an effect if returnFileInfo option is true.
     * @returns {{width, height, pixelData, minValue, maxValue, noDataValue, maskData, encodedMaskData, fileInfo}}
     */
    CntZImage.decode = function(input, options) {
      options = options || {};

      var skipMask = options.encodedMaskData || (options.encodedMaskData === null);
      var parsedData = parse(input, options.inputOffset || 0, skipMask);

      var noDataValue = (options.noDataValue !== null) ? options.noDataValue : CntZImage.defaultNoDataValue;

      var uncompressedData = uncompressPixelValues(parsedData, options.pixelType || Float32Array,
        options.encodedMaskData, noDataValue, options.returnMask);

      var result = {
        width: parsedData.width,
        height: parsedData.height,
        pixelData: uncompressedData.resultPixels,
        minValue: uncompressedData.minValue,
        maxValue: parsedData.pixels.maxValue,
        noDataValue: noDataValue
      };

      if (uncompressedData.resultMask) {
        result.maskData = uncompressedData.resultMask;
      }

      if (options.returnEncodedMask && parsedData.mask) {
        result.encodedMaskData = parsedData.mask.bitset ? parsedData.mask.bitset : null;
      }

      if (options.returnFileInfo) {
        result.fileInfo = formatFileInfo(parsedData);
        if (options.computeUsedBitDepths) {
          result.fileInfo.bitDepths = computeUsedBitDepths(parsedData);
        }
      }

      return result;
    };

    var uncompressPixelValues = function(data, TypedArrayClass, maskBitset, noDataValue, storeDecodedMask) {
      var blockIdx = 0;
      var numX = data.pixels.numBlocksX;
      var numY = data.pixels.numBlocksY;
      var blockWidth = Math.floor(data.width / numX);
      var blockHeight = Math.floor(data.height / numY);
      var scale = 2 * data.maxZError;
      var minValue = Number.MAX_VALUE, currentValue;
      maskBitset = maskBitset || ((data.mask) ? data.mask.bitset : null);

      var resultPixels, resultMask;
      resultPixels = new TypedArrayClass(data.width * data.height);
      if (storeDecodedMask && maskBitset) {
        resultMask = new Uint8Array(data.width * data.height);
      }
      var blockDataBuffer = new Float32Array(blockWidth * blockHeight);

      var xx, yy;
      for (var y = 0; y <= numY; y++) {
        var thisBlockHeight = (y !== numY) ? blockHeight : (data.height % numY);
        if (thisBlockHeight === 0) {
          continue;
        }
        for (var x = 0; x <= numX; x++) {
          var thisBlockWidth = (x !== numX) ? blockWidth : (data.width % numX);
          if (thisBlockWidth === 0) {
            continue;
          }

          var outPtr = y * data.width * blockHeight + x * blockWidth;
          var outStride = data.width - thisBlockWidth;

          var block = data.pixels.blocks[blockIdx];

          var blockData, blockPtr, constValue;
          if (block.encoding < 2) {
            // block is either uncompressed or bit-stuffed (encodings 0 and 1)
            if (block.encoding === 0) {
              // block is uncompressed
              blockData = block.rawData;
            } else {
              // block is bit-stuffed
              unstuff(block.stuffedData, block.bitsPerPixel, block.numValidPixels, block.offset, scale, blockDataBuffer, data.pixels.maxValue);
              blockData = blockDataBuffer;
            }
            blockPtr = 0;
          }
          else if (block.encoding === 2) {
            // block is all 0
            constValue = 0;
          }
          else {
            // block has constant value (encoding === 3)
            constValue = block.offset;
          }

          var maskByte;
          if (maskBitset) {
            for (yy = 0; yy < thisBlockHeight; yy++) {
              if (outPtr & 7) {
                //
                maskByte = maskBitset[outPtr >> 3];
                maskByte <<= outPtr & 7;
              }
              for (xx = 0; xx < thisBlockWidth; xx++) {
                if (!(outPtr & 7)) {
                  // read next byte from mask
                  maskByte = maskBitset[outPtr >> 3];
                }
                if (maskByte & 128) {
                  // pixel data present
                  if (resultMask) {
                    resultMask[outPtr] = 1;
                  }
                  currentValue = (block.encoding < 2) ? blockData[blockPtr++] : constValue;
                  minValue = minValue > currentValue ? currentValue : minValue;
                  resultPixels[outPtr++] = currentValue;
                } else {
                  // pixel data not present
                  if (resultMask) {
                    resultMask[outPtr] = 0;
                  }
                  resultPixels[outPtr++] = noDataValue;
                }
                maskByte <<= 1;
              }
              outPtr += outStride;
            }
          } else {
            // mask not present, simply copy block over
            if (block.encoding < 2) {
              // duplicating this code block for performance reasons
              // blockData case:
              for (yy = 0; yy < thisBlockHeight; yy++) {
                for (xx = 0; xx < thisBlockWidth; xx++) {
                  currentValue = blockData[blockPtr++];
                  minValue = minValue > currentValue ? currentValue : minValue;
                  resultPixels[outPtr++] = currentValue;
                }
                outPtr += outStride;
              }
            }
            else {
              // constValue case:
              minValue = minValue > constValue ? constValue : minValue;
              for (yy = 0; yy < thisBlockHeight; yy++) {
                for (xx = 0; xx < thisBlockWidth; xx++) {
                  resultPixels[outPtr++] = constValue;
                }
                outPtr += outStride;
              }
            }
          }
          if ((block.encoding === 1) && (blockPtr !== block.numValidPixels)) {
            throw "Block and Mask do not match";
          }
          blockIdx++;
        }
      }

      return {
        resultPixels: resultPixels,
        resultMask: resultMask,
        minValue: minValue
      };
    };

    var formatFileInfo = function(data) {
      return {
        "fileIdentifierString": data.fileIdentifierString,
        "fileVersion": data.fileVersion,
        "imageType": data.imageType,
        "height": data.height,
        "width": data.width,
        "maxZError": data.maxZError,
        "eofOffset": data.eofOffset,
        "mask": data.mask ? {
          "numBlocksX": data.mask.numBlocksX,
          "numBlocksY": data.mask.numBlocksY,
          "numBytes": data.mask.numBytes,
          "maxValue": data.mask.maxValue
        } : null,
        "pixels": {
          "numBlocksX": data.pixels.numBlocksX,
          "numBlocksY": data.pixels.numBlocksY,
          "numBytes": data.pixels.numBytes,
          "maxValue": data.pixels.maxValue,
          "noDataValue": data.noDataValue
        }
      };
    };

    var computeUsedBitDepths = function(data) {
      var numBlocks = data.pixels.numBlocksX * data.pixels.numBlocksY;
      var bitDepths = {};
      for (var i = 0; i < numBlocks; i++) {
        var block = data.pixels.blocks[i];
        if (block.encoding === 0) {
          bitDepths.float32 = true;
        } else if (block.encoding === 1) {
          bitDepths[block.bitsPerPixel] = true;
        } else {
          bitDepths[0] = true;
        }
      }

      return Object.keys(bitDepths);
    };

    var parse = function(input, fp, skipMask) {
      var data = {};

      // File header
      var fileIdView = new Uint8Array(input, fp, 10);
      data.fileIdentifierString = String.fromCharCode.apply(null, fileIdView);
      if (data.fileIdentifierString.trim() !== "CntZImage") {
        throw "Unexpected file identifier string: " + data.fileIdentifierString;
      }
      fp += 10;
      var view = new DataView(input, fp, 24);
      data.fileVersion = view.getInt32(0, true);
      data.imageType = view.getInt32(4, true);
      data.height = view.getUint32(8, true);
      data.width = view.getUint32(12, true);
      data.maxZError = view.getFloat64(16, true);
      fp += 24;

      // Mask Header
      if (!skipMask) {
        view = new DataView(input, fp, 16);
        data.mask = {};
        data.mask.numBlocksY = view.getUint32(0, true);
        data.mask.numBlocksX = view.getUint32(4, true);
        data.mask.numBytes = view.getUint32(8, true);
        data.mask.maxValue = view.getFloat32(12, true);
        fp += 16;

        // Mask Data
        if (data.mask.numBytes > 0) {
          var bitset = new Uint8Array(Math.ceil(data.width * data.height / 8));
          view = new DataView(input, fp, data.mask.numBytes);
          var cnt = view.getInt16(0, true);
          var ip = 2, op = 0;
          do {
            if (cnt > 0) {
              while (cnt--) { bitset[op++] = view.getUint8(ip++); }
            } else {
              var val = view.getUint8(ip++);
              cnt = -cnt;
              while (cnt--) { bitset[op++] = val; }
            }
            cnt = view.getInt16(ip, true);
            ip += 2;
          } while (ip < data.mask.numBytes);
          if ((cnt !== -32768) || (op < bitset.length)) {
            throw "Unexpected end of mask RLE encoding";
          }
          data.mask.bitset = bitset;
          fp += data.mask.numBytes;
        }
        else if ((data.mask.numBytes | data.mask.numBlocksY | data.mask.maxValue) === 0) {  // Special case, all nodata
          data.mask.bitset = new Uint8Array(Math.ceil(data.width * data.height / 8));
        }
      }

      // Pixel Header
      view = new DataView(input, fp, 16);
      data.pixels = {};
      data.pixels.numBlocksY = view.getUint32(0, true);
      data.pixels.numBlocksX = view.getUint32(4, true);
      data.pixels.numBytes = view.getUint32(8, true);
      data.pixels.maxValue = view.getFloat32(12, true);
      fp += 16;

      var numBlocksX = data.pixels.numBlocksX;
      var numBlocksY = data.pixels.numBlocksY;
      // the number of blocks specified in the header does not take into account the blocks at the end of
      // each row/column with a special width/height that make the image complete in case the width is not
      // evenly divisible by the number of blocks.
      var actualNumBlocksX = numBlocksX + ((data.width % numBlocksX) > 0 ? 1 : 0);
      var actualNumBlocksY = numBlocksY + ((data.height % numBlocksY) > 0 ? 1 : 0);
      data.pixels.blocks = new Array(actualNumBlocksX * actualNumBlocksY);
      var blockI = 0;
      for (var blockY = 0; blockY < actualNumBlocksY; blockY++) {
        for (var blockX = 0; blockX < actualNumBlocksX; blockX++) {

          // Block
          var size = 0;
          var bytesLeft = input.byteLength - fp;
          view = new DataView(input, fp, Math.min(10, bytesLeft));
          var block = {};
          data.pixels.blocks[blockI++] = block;
          var headerByte = view.getUint8(0); size++;
          block.encoding = headerByte & 63;
          if (block.encoding > 3) {
            throw "Invalid block encoding (" + block.encoding + ")";
          }
          if (block.encoding === 2) {
            fp++;
            continue;
          }
          if ((headerByte !== 0) && (headerByte !== 2)) {
            headerByte >>= 6;
            block.offsetType = headerByte;
            if (headerByte === 2) {
              block.offset = view.getInt8(1); size++;
            } else if (headerByte === 1) {
              block.offset = view.getInt16(1, true); size += 2;
            } else if (headerByte === 0) {
              block.offset = view.getFloat32(1, true); size += 4;
            } else {
              throw "Invalid block offset type";
            }

            if (block.encoding === 1) {
              headerByte = view.getUint8(size); size++;
              block.bitsPerPixel = headerByte & 63;
              headerByte >>= 6;
              block.numValidPixelsType = headerByte;
              if (headerByte === 2) {
                block.numValidPixels = view.getUint8(size); size++;
              } else if (headerByte === 1) {
                block.numValidPixels = view.getUint16(size, true); size += 2;
              } else if (headerByte === 0) {
                block.numValidPixels = view.getUint32(size, true); size += 4;
              } else {
                throw "Invalid valid pixel count type";
              }
            }
          }
          fp += size;

          if (block.encoding === 3) {
            continue;
          }

          var arrayBuf, store8;
          if (block.encoding === 0) {
            var numPixels = (data.pixels.numBytes - 1) / 4;
            if (numPixels !== Math.floor(numPixels)) {
              throw "uncompressed block has invalid length";
            }
            arrayBuf = new ArrayBuffer(numPixels * 4);
            store8 = new Uint8Array(arrayBuf);
            store8.set(new Uint8Array(input, fp, numPixels * 4));
            var rawData = new Float32Array(arrayBuf);
            block.rawData = rawData;
            fp += numPixels * 4;
          } else if (block.encoding === 1) {
            var dataBytes = Math.ceil(block.numValidPixels * block.bitsPerPixel / 8);
            var dataWords = Math.ceil(dataBytes / 4);
            arrayBuf = new ArrayBuffer(dataWords * 4);
            store8 = new Uint8Array(arrayBuf);
            store8.set(new Uint8Array(input, fp, dataBytes));
            block.stuffedData = new Uint32Array(arrayBuf);
            fp += dataBytes;
          }
        }
      }
      data.eofOffset = fp;
      return data;
    };

    var unstuff = function(src, bitsPerPixel, numPixels, offset, scale, dest, maxValue) {
      var bitMask = (1 << bitsPerPixel) - 1;
      var i = 0, o;
      var bitsLeft = 0;
      var n, buffer;
      var nmax = Math.ceil((maxValue - offset) / scale);
      // get rid of trailing bytes that are already part of next block
      var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);
      src[src.length - 1] <<= 8 * numInvalidTailBytes;

      for (o = 0; o < numPixels; o++) {
        if (bitsLeft === 0) {
          buffer = src[i++];
          bitsLeft = 32;
        }
        if (bitsLeft >= bitsPerPixel) {
          n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;
          bitsLeft -= bitsPerPixel;
        } else {
          var missingBits = (bitsPerPixel - bitsLeft);
          n = ((buffer & bitMask) << missingBits) & bitMask;
          buffer = src[i++];
          bitsLeft = 32 - missingBits;
          n += (buffer >>> bitsLeft);
        }
        //pixel values may exceed max due to quantization
        dest[o] = n < nmax ? offset + n * scale : maxValue;
      }
      return dest;
    };

    return CntZImage;
  })();

  //version 2. Supports 2.1, 2.2, 2.3
  var Lerc2Decode = (function() {
    "use strict";
    // Note: currently, this module only has an implementation for decoding LERC data, not encoding. The name of
    // the class was chosen to be future proof, following LercDecode.

    /*****************************************
    * private static class bitsutffer used by Lerc2Decode
    *******************************************/
    var BitStuffer = {
      //methods ending with 2 are for the new byte order used by Lerc2.3 and above.
      //originalUnstuff is used to unpack Huffman code table. code is duplicated to unstuffx for performance reasons.
      unstuff: function(src, dest, bitsPerPixel, numPixels, lutArr, offset, scale, maxValue) {
        var bitMask = (1 << bitsPerPixel) - 1;
        var i = 0, o;
        var bitsLeft = 0;
        var n, buffer, missingBits, nmax;

        // get rid of trailing bytes that are already part of next block
        var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);
        src[src.length - 1] <<= 8 * numInvalidTailBytes;
        if (lutArr) {
          for (o = 0; o < numPixels; o++) {
            if (bitsLeft === 0) {
              buffer = src[i++];
              bitsLeft = 32;
            }
            if (bitsLeft >= bitsPerPixel) {
              n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;
              bitsLeft -= bitsPerPixel;
            }
            else {
              missingBits = (bitsPerPixel - bitsLeft);
              n = ((buffer & bitMask) << missingBits) & bitMask;
              buffer = src[i++];
              bitsLeft = 32 - missingBits;
              n += (buffer >>> bitsLeft);
            }
            dest[o] = lutArr[n];//offset + lutArr[n] * scale;
          }
        }
        else {
          nmax = Math.ceil((maxValue - offset) / scale);
          for (o = 0; o < numPixels; o++) {
            if (bitsLeft === 0) {
              buffer = src[i++];
              bitsLeft = 32;
            }
            if (bitsLeft >= bitsPerPixel) {
              n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;
              bitsLeft -= bitsPerPixel;
            }
            else {
              missingBits = (bitsPerPixel - bitsLeft);
              n = ((buffer & bitMask) << missingBits) & bitMask;
              buffer = src[i++];
              bitsLeft = 32 - missingBits;
              n += (buffer >>> bitsLeft);
            }
            //pixel values may exceed max due to quantization
            dest[o] = n < nmax ? offset + n * scale : maxValue;
          }
        }
      },

      unstuffLUT: function(src, bitsPerPixel, numPixels, offset, scale, maxValue) {
        var bitMask = (1 << bitsPerPixel) - 1;
        var i = 0, o = 0, missingBits = 0, bitsLeft = 0, n = 0;
        var buffer;
        var dest = [];

        // get rid of trailing bytes that are already part of next block
        var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);
        src[src.length - 1] <<= 8 * numInvalidTailBytes;

        var nmax = Math.ceil((maxValue - offset) / scale);
        for (o = 0; o < numPixels; o++) {
          if (bitsLeft === 0) {
            buffer = src[i++];
            bitsLeft = 32;
          }
          if (bitsLeft >= bitsPerPixel) {
            n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;
            bitsLeft -= bitsPerPixel;
          } else {
            missingBits = (bitsPerPixel - bitsLeft);
            n = ((buffer & bitMask) << missingBits) & bitMask;
            buffer = src[i++];
            bitsLeft = 32 - missingBits;
            n += (buffer >>> bitsLeft);
          }
          //dest.push(n);
          dest[o] = n < nmax ? offset + n * scale : maxValue;
        }
        dest.unshift(offset);//1st one
        return dest;
      },

      unstuff2: function(src, dest, bitsPerPixel, numPixels, lutArr, offset, scale, maxValue) {
        var bitMask = (1 << bitsPerPixel) - 1;
        var i = 0, o;
        var bitsLeft = 0, bitPos = 0;
        var n, buffer, missingBits;
        if (lutArr) {
          for (o = 0; o < numPixels; o++) {
            if (bitsLeft === 0) {
              buffer = src[i++];
              bitsLeft = 32;
              bitPos = 0;
            }
            if (bitsLeft >= bitsPerPixel) {
              n = ((buffer >>> bitPos) & bitMask);
              bitsLeft -= bitsPerPixel;
              bitPos += bitsPerPixel;
            } else {
              missingBits = (bitsPerPixel - bitsLeft);
              n = (buffer >>> bitPos) & bitMask;
              buffer = src[i++];
              bitsLeft = 32 - missingBits;
              n |= (buffer & ((1 << missingBits) - 1)) << (bitsPerPixel - missingBits);
              bitPos = missingBits;
            }
            dest[o] = lutArr[n];
          }
        }
        else {
          var nmax = Math.ceil((maxValue - offset) / scale);
          for (o = 0; o < numPixels; o++) {
            if (bitsLeft === 0) {
              buffer = src[i++];
              bitsLeft = 32;
              bitPos = 0;
            }
            if (bitsLeft >= bitsPerPixel) {
              //no unsigned left shift
              n = ((buffer >>> bitPos) & bitMask);
              bitsLeft -= bitsPerPixel;
              bitPos += bitsPerPixel;
            } else {
              missingBits = (bitsPerPixel - bitsLeft);
              n = (buffer >>> bitPos) & bitMask;//((buffer & bitMask) << missingBits) & bitMask;
              buffer = src[i++];
              bitsLeft = 32 - missingBits;
              n |= (buffer & ((1 << missingBits) - 1)) << (bitsPerPixel - missingBits);
              bitPos = missingBits;
            }
            //pixel values may exceed max due to quantization
            dest[o] = n < nmax ? offset + n * scale : maxValue;
          }
        }
        return dest;
      },

      unstuffLUT2: function(src, bitsPerPixel, numPixels, offset, scale, maxValue) {
        var bitMask = (1 << bitsPerPixel) - 1;
        var i = 0, o = 0, missingBits = 0, bitsLeft = 0, n = 0, bitPos = 0;
        var buffer;
        var dest = [];
        var nmax = Math.ceil((maxValue - offset) / scale);
        for (o = 0; o < numPixels; o++) {
          if (bitsLeft === 0) {
            buffer = src[i++];
            bitsLeft = 32;
            bitPos = 0;
          }
          if (bitsLeft >= bitsPerPixel) {
            //no unsigned left shift
            n = ((buffer >>> bitPos) & bitMask);
            bitsLeft -= bitsPerPixel;
            bitPos += bitsPerPixel;
          } else {
            missingBits = (bitsPerPixel - bitsLeft);
            n = (buffer >>> bitPos) & bitMask;//((buffer & bitMask) << missingBits) & bitMask;
            buffer = src[i++];
            bitsLeft = 32 - missingBits;
            n |= (buffer & ((1 << missingBits) - 1)) << (bitsPerPixel - missingBits);
            bitPos = missingBits;
          }
          //dest.push(n);
          dest[o] = n < nmax ? offset + n * scale : maxValue;
        }
        dest.unshift(offset);
        return dest;
      },

      originalUnstuff: function(src, dest, bitsPerPixel, numPixels) {
        var bitMask = (1 << bitsPerPixel) - 1;
        var i = 0, o;
        var bitsLeft = 0;
        var n, buffer, missingBits;

        // get rid of trailing bytes that are already part of next block
        var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);
        src[src.length - 1] <<= 8 * numInvalidTailBytes;

        for (o = 0; o < numPixels; o++) {
          if (bitsLeft === 0) {
            buffer = src[i++];
            bitsLeft = 32;
          }
          if (bitsLeft >= bitsPerPixel) {
            n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;
            bitsLeft -= bitsPerPixel;
          }
          else {
            missingBits = (bitsPerPixel - bitsLeft);
            n = ((buffer & bitMask) << missingBits) & bitMask;
            buffer = src[i++];
            bitsLeft = 32 - missingBits;
            n += (buffer >>> bitsLeft);
          }
          dest[o] = n;
        }
        return dest;
      },

      originalUnstuff2: function(src, dest, bitsPerPixel, numPixels) {
        var bitMask = (1 << bitsPerPixel) - 1;
        var i = 0, o;
        var bitsLeft = 0, bitPos = 0;
        var n, buffer, missingBits;
        //micro-optimizations
        for (o = 0; o < numPixels; o++) {
          if (bitsLeft === 0) {
            buffer = src[i++];
            bitsLeft = 32;
            bitPos = 0;
          }
          if (bitsLeft >= bitsPerPixel) {
            //no unsigned left shift
            n = ((buffer >>> bitPos) & bitMask);
            bitsLeft -= bitsPerPixel;
            bitPos += bitsPerPixel;
          } else {
            missingBits = (bitsPerPixel - bitsLeft);
            n = (buffer >>> bitPos) & bitMask;//((buffer & bitMask) << missingBits) & bitMask;
            buffer = src[i++];
            bitsLeft = 32 - missingBits;
            n |= (buffer & ((1 << missingBits) - 1)) << (bitsPerPixel - missingBits);
            bitPos = missingBits;
          }
          dest[o] = n;
        }
        return dest;
      }
    };

    /*****************************************
    *private static class used by Lerc2Decode
    ******************************************/
    var Lerc2Helpers = {
      HUFFMAN_LUT_BITS_MAX: 12, //use 2^12 lut, treat it like constant
      computeChecksumFletcher32: function(input) {

        var sum1 = 0xffff, sum2 = 0xffff;
        var len = input.length;
        var words = Math.floor(len / 2);
        var i = 0;
        while (words) {
          var tlen = (words >= 359) ? 359 : words;
          words -= tlen;
          do {
            sum1 += (input[i++] << 8);
            sum2 += sum1 += input[i++];
          } while (--tlen);

          sum1 = (sum1 & 0xffff) + (sum1 >>> 16);
          sum2 = (sum2 & 0xffff) + (sum2 >>> 16);
        }

        // add the straggler byte if it exists
        if (len & 1) {
          sum2 += sum1 += (input[i] << 8);
        }
        // second reduction step to reduce sums to 16 bits
        sum1 = (sum1 & 0xffff) + (sum1 >>> 16);
        sum2 = (sum2 & 0xffff) + (sum2 >>> 16);

        return (sum2 << 16 | sum1) >>> 0;
      },

      readHeaderInfo: function(input, data) {
        var ptr = data.ptr;
        var fileIdView = new Uint8Array(input, ptr, 6);
        var headerInfo = {};
        headerInfo.fileIdentifierString = String.fromCharCode.apply(null, fileIdView);
        if (headerInfo.fileIdentifierString.lastIndexOf("Lerc2", 0) !== 0) {
          throw "Unexpected file identifier string (expect Lerc2 ): " + headerInfo.fileIdentifierString;
        }
        ptr += 6;
        var view = new DataView(input, ptr, 8);
        var fileVersion = view.getInt32(0, true);
        headerInfo.fileVersion = fileVersion;
        ptr += 4;
        if (fileVersion >= 3) {
          headerInfo.checksum = view.getUint32(4, true); //nrows
          ptr += 4;
        }

        //keys start from here
        view = new DataView(input, ptr, 12);
        headerInfo.height = view.getUint32(0, true); //nrows
        headerInfo.width = view.getUint32(4, true); //ncols
        ptr += 8;
        if (fileVersion >= 4) {
          headerInfo.numDims = view.getUint32(8, true);
          ptr += 4;
        }
        else {
          headerInfo.numDims = 1;
        }

        view = new DataView(input, ptr, 40);
        headerInfo.numValidPixel = view.getUint32(0, true);
        headerInfo.microBlockSize = view.getInt32(4, true);
        headerInfo.blobSize = view.getInt32(8, true);
        headerInfo.imageType = view.getInt32(12, true);

        headerInfo.maxZError = view.getFloat64(16, true);
        headerInfo.zMin = view.getFloat64(24, true);
        headerInfo.zMax = view.getFloat64(32, true);
        ptr += 40;
        data.headerInfo = headerInfo;
        data.ptr = ptr;

        var checksum, keyLength;
        if (fileVersion >= 3) {
          keyLength = fileVersion >= 4 ? 52 : 48;
          checksum = this.computeChecksumFletcher32(new Uint8Array(input, ptr - keyLength, headerInfo.blobSize - 14));
          if (checksum !== headerInfo.checksum) {
            throw "Checksum failed.";
          }
        }
        return true;
      },

      checkMinMaxRanges: function(input, data) {
        var headerInfo = data.headerInfo;
        var OutPixelTypeArray = this.getDataTypeArray(headerInfo.imageType);
        var rangeBytes = headerInfo.numDims * this.getDataTypeSize(headerInfo.imageType);
        var minValues = this.readSubArray(input, data.ptr, OutPixelTypeArray, rangeBytes);
        var maxValues = this.readSubArray(input, data.ptr + rangeBytes, OutPixelTypeArray, rangeBytes);
        data.ptr += (2 * rangeBytes);
        var i, equal = true;
        for (i = 0; i < headerInfo.numDims; i++) {
          if (minValues[i] !== maxValues[i]) {
            equal = false;
            break;
          }
        }
        headerInfo.minValues = minValues;
        headerInfo.maxValues = maxValues;
        return equal;
      },

      readSubArray: function(input, ptr, OutPixelTypeArray, numBytes) {
        var rawData;
        if (OutPixelTypeArray === Uint8Array) {
          rawData = new Uint8Array(input, ptr, numBytes);
        }
        else {
          var arrayBuf = new ArrayBuffer(numBytes);
          var store8 = new Uint8Array(arrayBuf);
          store8.set(new Uint8Array(input, ptr, numBytes));
          rawData = new OutPixelTypeArray(arrayBuf);
        }
        return rawData;
      },

      readMask: function(input, data) {
        var ptr = data.ptr;
        var headerInfo = data.headerInfo;
        var numPixels = headerInfo.width * headerInfo.height;
        var numValidPixel = headerInfo.numValidPixel;

        var view = new DataView(input, ptr, 4);
        var mask = {};
        mask.numBytes = view.getUint32(0, true);
        ptr += 4;

        // Mask Data
        if ((0 === numValidPixel || numPixels === numValidPixel) && 0 !== mask.numBytes) {
          throw ("invalid mask");
        }
        var bitset, resultMask;
        if (numValidPixel === 0) {
          bitset = new Uint8Array(Math.ceil(numPixels / 8));
          mask.bitset = bitset;
          resultMask = new Uint8Array(numPixels);
          data.pixels.resultMask = resultMask;
          ptr += mask.numBytes;
        }// ????? else if (data.mask.numBytes > 0 && data.mask.numBytes< data.numValidPixel) {
        else if (mask.numBytes > 0) {
          bitset = new Uint8Array(Math.ceil(numPixels / 8));
          view = new DataView(input, ptr, mask.numBytes);
          var cnt = view.getInt16(0, true);
          var ip = 2, op = 0, val = 0;
          do {
            if (cnt > 0) {
              while (cnt--) { bitset[op++] = view.getUint8(ip++); }
            } else {
              val = view.getUint8(ip++);
              cnt = -cnt;
              while (cnt--) { bitset[op++] = val; }
            }
            cnt = view.getInt16(ip, true);
            ip += 2;
          } while (ip < mask.numBytes);
          if ((cnt !== -32768) || (op < bitset.length)) {
            throw "Unexpected end of mask RLE encoding";
          }

          resultMask = new Uint8Array(numPixels);
          var mb = 0, k = 0;

          for (k = 0; k < numPixels; k++) {
            if (k & 7) {
              mb = bitset[k >> 3];
              mb <<= k & 7;
            }
            else {
              mb = bitset[k >> 3];
            }
            if (mb & 128) {
              resultMask[k] = 1;
            }
          }
          data.pixels.resultMask = resultMask;

          mask.bitset = bitset;
          ptr += mask.numBytes;
        }
        data.ptr = ptr;
        data.mask = mask;
        return true;
      },

      readDataOneSweep: function(input, data, OutPixelTypeArray, useBSQForOutputDim) {
        var ptr = data.ptr;
        var headerInfo = data.headerInfo;
        var numDims = headerInfo.numDims;
        var numPixels = headerInfo.width * headerInfo.height;
        var imageType = headerInfo.imageType;
        var numBytes = headerInfo.numValidPixel * Lerc2Helpers.getDataTypeSize(imageType) * numDims;
        //data.pixels.numBytes = numBytes;
        var rawData;
        var mask = data.pixels.resultMask;
        if (OutPixelTypeArray === Uint8Array) {
          rawData = new Uint8Array(input, ptr, numBytes);
        }
        else {
          var arrayBuf = new ArrayBuffer(numBytes);
          var store8 = new Uint8Array(arrayBuf);
          store8.set(new Uint8Array(input, ptr, numBytes));
          rawData = new OutPixelTypeArray(arrayBuf);
        }
        if (rawData.length === numPixels * numDims) {
          if (useBSQForOutputDim) {
            data.pixels.resultPixels = Lerc2Helpers.swapDimensionOrder(rawData, numPixels, numDims, OutPixelTypeArray, true);
          }
          else {
            data.pixels.resultPixels = rawData;
          }
        }
        else  //mask
        {
          data.pixels.resultPixels = new OutPixelTypeArray(numPixels * numDims);
          var z = 0, k = 0, i = 0, nStart = 0;
          if (numDims > 1) {
            if (useBSQForOutputDim) {
              for (k = 0; k < numPixels; k++) {
                if (mask[k]) {
                  nStart = k;
                  for (i = 0; i < numDims; i++, nStart+=numPixels) {
                    data.pixels.resultPixels[nStart] = rawData[z++];
                  }
                }
              }
            }
            else {
              for (k = 0; k < numPixels; k++) {
                if (mask[k]) {
                  nStart = k * numDims;
                  for (i = 0; i < numDims; i++) {
                    data.pixels.resultPixels[nStart + i] = rawData[z++];
                  }
                }
              }
            }
          }
          else {
            for (k = 0; k < numPixels; k++) {
              if (mask[k]) {
                data.pixels.resultPixels[k] = rawData[z++];
              }
            }
          }
        }
        ptr += numBytes;
        data.ptr = ptr;       //return data;
        return true;
      },

      readHuffmanTree: function(input, data) {
        var BITS_MAX = this.HUFFMAN_LUT_BITS_MAX; //8 is slow for the large test image
        //var size_max = 1 << BITS_MAX;
        /* ************************
        * reading code table
        *************************/
        var view = new DataView(input, data.ptr, 16);
        data.ptr += 16;
        var version = view.getInt32(0, true);
        if (version < 2) {
          throw "unsupported Huffman version";
        }
        var size = view.getInt32(4, true);
        var i0 = view.getInt32(8, true);
        var i1 = view.getInt32(12, true);
        if (i0 >= i1) {
          return false;
        }
        var blockDataBuffer = new Uint32Array(i1 - i0);
        Lerc2Helpers.decodeBits(input, data, blockDataBuffer);
        var codeTable = []; //size
        var i, j, k, len;

        for (i = i0; i < i1; i++) {
          j = i - (i < size ? 0 : size);//wrap around
          codeTable[j] = { first: blockDataBuffer[i - i0], second: null };
        }

        var dataBytes = input.byteLength - data.ptr;
        var dataWords = Math.ceil(dataBytes / 4);
        var arrayBuf = new ArrayBuffer(dataWords * 4);
        var store8 = new Uint8Array(arrayBuf);
        store8.set(new Uint8Array(input, data.ptr, dataBytes));
        var stuffedData = new Uint32Array(arrayBuf); //must start from x*4
        var bitPos = 0, word, srcPtr = 0;
        word = stuffedData[0];
        for (i = i0; i < i1; i++) {
          j = i - (i < size ? 0 : size);//wrap around
          len = codeTable[j].first;
          if (len > 0) {
            codeTable[j].second = (word << bitPos) >>> (32 - len);

            if (32 - bitPos >= len) {
              bitPos += len;
              if (bitPos === 32) {
                bitPos = 0;
                srcPtr++;
                word = stuffedData[srcPtr];
              }
            }
            else {
              bitPos += len - 32;
              srcPtr++;
              word = stuffedData[srcPtr];
              codeTable[j].second |= word >>> (32 - bitPos);
            }
          }
        }

        //finished reading code table

        /* ************************
        * building lut
        *************************/
        var numBitsLUT = 0, numBitsLUTQick = 0;
        var tree = new TreeNode();
        for (i = 0; i < codeTable.length; i++) {
          if (codeTable[i] !== undefined) {
            numBitsLUT = Math.max(numBitsLUT, codeTable[i].first);
          }
        }
        if (numBitsLUT >= BITS_MAX) {
          numBitsLUTQick = BITS_MAX;
        }
        else {
          numBitsLUTQick = numBitsLUT;
        }
        // for debugging purpose
        // if (numBitsLUT >= 30) {
        //   console.log("WARning, large NUM LUT BITS IS " + numBitsLUT);
        // }
        var decodeLut = [], entry, code, numEntries, jj, currentBit, node;
        for (i = i0; i < i1; i++) {
          j = i - (i < size ? 0 : size);//wrap around
          len = codeTable[j].first;
          if (len > 0) {
            entry = [len, j];
            if (len <= numBitsLUTQick) {
              code = codeTable[j].second << (numBitsLUTQick - len);
              numEntries = 1 << (numBitsLUTQick - len);
              for (k = 0; k < numEntries; k++) {
                decodeLut[code | k] = entry;
              }
            }
            else {
              //build tree
              code = codeTable[j].second;
              node = tree;
              for (jj = len - 1; jj >= 0; jj--) {
                currentBit = code >>> jj & 1; //no left shift as length could be 30,31
                if (currentBit) {
                  if (!node.right) {
                    node.right = new TreeNode();
                  }
                  node = node.right;
                }
                else {
                  if (!node.left) {
                    node.left = new TreeNode();
                  }
                  node = node.left;
                }
                if (jj === 0 && !node.val) {
                  node.val = entry[1];
                }
              }
            }
          }
        }
        return {
          decodeLut: decodeLut,
          numBitsLUTQick: numBitsLUTQick,
          numBitsLUT: numBitsLUT,
          tree: tree,
          stuffedData: stuffedData,
          srcPtr: srcPtr,
          bitPos: bitPos
        };
      },

      readHuffman: function(input, data, OutPixelTypeArray, useBSQForOutputDim) {
        var headerInfo = data.headerInfo;
        var numDims = headerInfo.numDims;
        var height = data.headerInfo.height;
        var width = data.headerInfo.width;
        var numPixels = width * height;
        //var size_max = 1 << BITS_MAX;
        /* ************************
        * reading huffman structure info
        *************************/
        var huffmanInfo = this.readHuffmanTree(input, data);
        var decodeLut = huffmanInfo.decodeLut;
        var tree = huffmanInfo.tree;
        //stuffedData includes huffman headers
        var stuffedData = huffmanInfo.stuffedData;
        var srcPtr = huffmanInfo.srcPtr;
        var bitPos = huffmanInfo.bitPos;
        var numBitsLUTQick = huffmanInfo.numBitsLUTQick;
        var numBitsLUT = huffmanInfo.numBitsLUT;
        var offset = data.headerInfo.imageType === 0 ? 128 : 0;
        /*************************
        *  decode
        ***************************/
        var node, val, delta, mask = data.pixels.resultMask, valTmp, valTmpQuick, currentBit;
        var i, j, k, ii;
        var prevVal = 0;
        if (bitPos > 0) {
          srcPtr++;
          bitPos = 0;
        }
        var word = stuffedData[srcPtr];
        var deltaEncode = data.encodeMode === 1;
        var resultPixelsAllDim = new OutPixelTypeArray(numPixels * numDims);
        var resultPixels = resultPixelsAllDim;
        var iDim;
        // TODO: reevaluate the need to keep inlined decoding code as IE support is phasing out
        if (numDims < 2 || deltaEncode) {
          for (iDim = 0; iDim < numDims; iDim++) {
            if (numDims > 1) {
              //get the mem block of current dimension
              resultPixels = new OutPixelTypeArray(resultPixelsAllDim.buffer, numPixels * iDim, numPixels);
              prevVal = 0;
            }
            if (data.headerInfo.numValidPixel === width * height) { //all valid
              for (k = 0, i = 0; i < height; i++) {
                for (j = 0; j < width; j++, k++) {
                  val = 0;
                  valTmp = (word << bitPos) >>> (32 - numBitsLUTQick);
                  valTmpQuick = valTmp;// >>> deltaBits;
                  if (32 - bitPos < numBitsLUTQick) {
                    valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUTQick));
                    valTmpQuick = valTmp;// >>> deltaBits;
                  }
                  if (decodeLut[valTmpQuick])    // if there, move the correct number of bits and done
                  {
                    val = decodeLut[valTmpQuick][1];
                    bitPos += decodeLut[valTmpQuick][0];
                  }
                  else {
                    valTmp = (word << bitPos) >>> (32 - numBitsLUT);
                    valTmpQuick = valTmp;// >>> deltaBits;
                    if (32 - bitPos < numBitsLUT) {
                      valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUT));
                      valTmpQuick = valTmp;// >>> deltaBits;
                    }
                    node = tree;
                    for (ii = 0; ii < numBitsLUT; ii++) {
                      currentBit = valTmp >>> (numBitsLUT - ii - 1) & 1;
                      node = currentBit ? node.right : node.left;
                      if (!(node.left || node.right)) {
                        val = node.val;
                        bitPos = bitPos + ii + 1;
                        break;
                      }
                    }
                  }
    
                  if (bitPos >= 32) {
                    bitPos -= 32;
                    srcPtr++;
                    word = stuffedData[srcPtr];
                  }
    
                  delta = val - offset;
                  if (deltaEncode) {
                    if (j > 0) {
                      delta += prevVal;    // use overflow
                    }
                    else if (i > 0) {
                      delta += resultPixels[k - width];
                    }
                    else {
                      delta += prevVal;
                    }
                    delta &= 0xFF; //overflow
                    resultPixels[k] = delta;//overflow
                    prevVal = delta;
                  }
                  else {
                    resultPixels[k] = delta;
                  }
                }
              }
            }
            else { //not all valid, use mask
              for (k = 0, i = 0; i < height; i++) {
                for (j = 0; j < width; j++, k++) {
                  if (mask[k]) {
                    val = 0;
                    valTmp = (word << bitPos) >>> (32 - numBitsLUTQick);
                    valTmpQuick = valTmp;// >>> deltaBits;
                    if (32 - bitPos < numBitsLUTQick) {
                      valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUTQick));
                      valTmpQuick = valTmp;// >>> deltaBits;
                    }
                    if (decodeLut[valTmpQuick])    // if there, move the correct number of bits and done
                    {
                      val = decodeLut[valTmpQuick][1];
                      bitPos += decodeLut[valTmpQuick][0];
                    }
                    else {
                      valTmp = (word << bitPos) >>> (32 - numBitsLUT);
                      valTmpQuick = valTmp;// >>> deltaBits;
                      if (32 - bitPos < numBitsLUT) {
                        valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUT));
                        valTmpQuick = valTmp;// >>> deltaBits;
                      }
                      node = tree;
                      for (ii = 0; ii < numBitsLUT; ii++) {
                        currentBit = valTmp >>> (numBitsLUT - ii - 1) & 1;
                        node = currentBit ? node.right : node.left;
                        if (!(node.left || node.right)) {
                          val = node.val;
                          bitPos = bitPos + ii + 1;
                          break;
                        }
                      }
                    }
    
                    if (bitPos >= 32) {
                      bitPos -= 32;
                      srcPtr++;
                      word = stuffedData[srcPtr];
                    }
    
                    delta = val - offset;
                    if (deltaEncode) {
                      if (j > 0 && mask[k - 1]) {
                        delta += prevVal;    // use overflow
                      }
                      else if (i > 0 && mask[k - width]) {
                        delta += resultPixels[k - width];
                      }
                      else {
                        delta += prevVal;
                      }
    
                      delta &= 0xFF; //overflow
                      resultPixels[k] = delta;//overflow
                      prevVal = delta;
                    }
                    else {
                      resultPixels[k] = delta;
                    }
                  }
                }
              }
            }
          }
        }
        else {
          for (k = 0, i = 0; i < height; i++) {
            for (j = 0; j < width; j++) {
              k = i * width + j;
              if (!mask || mask[k]) {
                for (iDim = 0; iDim < numDims; iDim++, k+=numPixels) {
                  val = 0;
                  valTmp = (word << bitPos) >>> (32 - numBitsLUTQick);
                  valTmpQuick = valTmp;
                  if (32 - bitPos < numBitsLUTQick) {
                    valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUTQick));
                    valTmpQuick = valTmp;
                  }
                  if (decodeLut[valTmpQuick])
                  {
                    val = decodeLut[valTmpQuick][1];
                    bitPos += decodeLut[valTmpQuick][0];
                  }
                  else {
                    valTmp = (word << bitPos) >>> (32 - numBitsLUT);
                    valTmpQuick = valTmp;
                    if (32 - bitPos < numBitsLUT) {
                      valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUT));
                      valTmpQuick = valTmp;
                    }
                    node = tree;
                    for (ii = 0; ii < numBitsLUT; ii++) {
                      currentBit = valTmp >>> (numBitsLUT - ii - 1) & 1;
                      node = currentBit ? node.right : node.left;
                      if (!(node.left || node.right)) {
                        val = node.val;
                        bitPos = bitPos + ii + 1;
                        break;
                      }
                    }
                  }

                  if (bitPos >= 32) {
                    bitPos -= 32;
                    srcPtr++;
                    word = stuffedData[srcPtr];
                  }

                  delta = val - offset;
                  resultPixels[k] = delta;
                }
              }
            }
          }
        }
        data.ptr = data.ptr + (srcPtr + 1) * 4 + (bitPos > 0 ? 4 : 0);
        data.pixels.resultPixels = resultPixelsAllDim;
        //swap for BIP layout
        if (numDims > 1 && !useBSQForOutputDim) {
          data.pixels.resultPixels = Lerc2Helpers.swapDimensionOrder(resultPixelsAllDim, numPixels, numDims, OutPixelTypeArray);
        }
      },

      decodeBits: function(input, data, blockDataBuffer, offset, iDim) {
        {
          //bitstuff encoding is 3
          var headerInfo = data.headerInfo;
          var fileVersion = headerInfo.fileVersion;
          //var block = {};
          var blockPtr = 0;
          var viewByteLength = ((input.byteLength - data.ptr) >= 5) ? 5 : (input.byteLength - data.ptr);
          var view = new DataView(input, data.ptr, viewByteLength);
          var headerByte = view.getUint8(0);
          blockPtr++;
          var bits67 = headerByte >> 6;
          var n = (bits67 === 0) ? 4 : 3 - bits67;
          var doLut = (headerByte & 32) > 0 ? true : false;//5th bit
          var numBits = headerByte & 31;
          var numElements = 0;
          if (n === 1) {
            numElements = view.getUint8(blockPtr); blockPtr++;
          } else if (n === 2) {
            numElements = view.getUint16(blockPtr, true); blockPtr += 2;
          } else if (n === 4) {
            numElements = view.getUint32(blockPtr, true); blockPtr += 4;
          } else {
            throw "Invalid valid pixel count type";
          }
          //fix: huffman codes are bit stuffed, but not bound by data's max value, so need to use originalUnstuff
          //offset = offset || 0;
          var scale = 2 * headerInfo.maxZError;
          var stuffedData, arrayBuf, store8, dataBytes, dataWords;
          var lutArr, lutData, lutBytes, lutBitsPerElement, bitsPerPixel;
          var zMax = headerInfo.numDims > 1 ? headerInfo.maxValues[iDim] : headerInfo.zMax;
          if (doLut) {
            data.counter.lut++;
            lutBytes = view.getUint8(blockPtr);
            lutBitsPerElement = numBits;
            blockPtr++;
            dataBytes = Math.ceil((lutBytes - 1) * numBits / 8);
            dataWords = Math.ceil(dataBytes / 4);
            arrayBuf = new ArrayBuffer(dataWords * 4);
            store8 = new Uint8Array(arrayBuf);

            data.ptr += blockPtr;
            store8.set(new Uint8Array(input, data.ptr, dataBytes));

            lutData = new Uint32Array(arrayBuf);
            data.ptr += dataBytes;

            bitsPerPixel = 0;
            while ((lutBytes - 1) >>> bitsPerPixel) {
              bitsPerPixel++;
            }
            dataBytes = Math.ceil(numElements * bitsPerPixel / 8);
            dataWords = Math.ceil(dataBytes / 4);
            arrayBuf = new ArrayBuffer(dataWords * 4);
            store8 = new Uint8Array(arrayBuf);
            store8.set(new Uint8Array(input, data.ptr, dataBytes));
            stuffedData = new Uint32Array(arrayBuf);
            data.ptr += dataBytes;
            if (fileVersion >= 3) {
              lutArr = BitStuffer.unstuffLUT2(lutData, numBits, lutBytes - 1, offset, scale, zMax);
            }
            else {
              lutArr = BitStuffer.unstuffLUT(lutData, numBits, lutBytes - 1, offset, scale, zMax);
            }
            //lutArr.unshift(0);
            if (fileVersion >= 3) {
              //BitStuffer.unstuff2(block, blockDataBuffer, headerInfo.zMax);
              BitStuffer.unstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements, lutArr);
            }
            else {
              BitStuffer.unstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements, lutArr);
            }
          }
          else {
            //console.debug("bitstuffer");
            data.counter.bitstuffer++;
            bitsPerPixel = numBits;
            data.ptr += blockPtr;
            if (bitsPerPixel > 0) {
              dataBytes = Math.ceil(numElements * bitsPerPixel / 8);
              dataWords = Math.ceil(dataBytes / 4);
              arrayBuf = new ArrayBuffer(dataWords * 4);
              store8 = new Uint8Array(arrayBuf);
              store8.set(new Uint8Array(input, data.ptr, dataBytes));
              stuffedData = new Uint32Array(arrayBuf);
              data.ptr += dataBytes;
              if (fileVersion >= 3) {
                if (offset == null) {
                  BitStuffer.originalUnstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements);
                }
                else {
                  BitStuffer.unstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements, false, offset, scale, zMax);
                }
              }
              else {
                if (offset == null) {
                  BitStuffer.originalUnstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements);
                }
                else {
                  BitStuffer.unstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements, false, offset, scale, zMax);
                }
              }
            }
          }
        }

      },

      readTiles: function(input, data, OutPixelTypeArray, useBSQForOutputDim) {
        var headerInfo = data.headerInfo;
        var width = headerInfo.width;
        var height = headerInfo.height;
        var numPixels = width * height;
        var microBlockSize = headerInfo.microBlockSize;
        var imageType = headerInfo.imageType;
        var dataTypeSize = Lerc2Helpers.getDataTypeSize(imageType);
        var numBlocksX = Math.ceil(width / microBlockSize);
        var numBlocksY = Math.ceil(height / microBlockSize);
        data.pixels.numBlocksY = numBlocksY;
        data.pixels.numBlocksX = numBlocksX;
        data.pixels.ptr = 0;
        var row = 0, col = 0, blockY = 0, blockX = 0, thisBlockHeight = 0, thisBlockWidth = 0, bytesLeft = 0, headerByte = 0, bits67 = 0, testCode = 0, outPtr = 0, outStride = 0, numBytes = 0, bytesleft = 0, z = 0, blockPtr = 0;
        var view, block, arrayBuf, store8, rawData;
        var blockEncoding;
        var blockDataBuffer = new OutPixelTypeArray(microBlockSize * microBlockSize);
        var lastBlockHeight = (height % microBlockSize) || microBlockSize;
        var lastBlockWidth = (width % microBlockSize) || microBlockSize;
        var offsetType, offset;
        var numDims = headerInfo.numDims, iDim;
        var mask = data.pixels.resultMask;
        var resultPixels = data.pixels.resultPixels;
        var fileVersion = headerInfo.fileVersion;
        var fileVersionCheckNum = fileVersion >= 5 ? 14 : 15;
        var isDiffEncoding;
        var zMax = headerInfo.zMax;
        //var resultPixelsAllDim = resultPixels;
        var resultPixelsPrevDim;
        for (blockY = 0; blockY < numBlocksY; blockY++) {
          thisBlockHeight = (blockY !== numBlocksY - 1) ? microBlockSize : lastBlockHeight;
          for (blockX = 0; blockX < numBlocksX; blockX++) {
            //console.debug("y" + blockY + " x" + blockX);
            thisBlockWidth = (blockX !== numBlocksX - 1) ? microBlockSize : lastBlockWidth;

            outPtr = blockY * width * microBlockSize + blockX * microBlockSize;
            outStride = width - thisBlockWidth;

            for (iDim = 0; iDim < numDims; iDim++) {
              if (numDims > 1) {
                resultPixelsPrevDim = resultPixels;
                outPtr = blockY * width * microBlockSize + blockX * microBlockSize;
                resultPixels = new OutPixelTypeArray(data.pixels.resultPixels.buffer, numPixels * iDim * dataTypeSize, numPixels);
                zMax = headerInfo.maxValues[iDim];
              } else {
                resultPixelsPrevDim = null;
              }
              bytesLeft = input.byteLength - data.ptr;
              view = new DataView(input, data.ptr, Math.min(10, bytesLeft));
              block = {};
              blockPtr = 0;
              headerByte = view.getUint8(0);
              blockPtr++;
              isDiffEncoding = headerInfo.fileVersion >= 5 ? headerByte & 4 : 0;
              bits67 = (headerByte >> 6) & 0xFF;
              testCode = (headerByte >> 2) & fileVersionCheckNum;    // use bits 2345 for integrity check
              if (testCode !== (((blockX * microBlockSize) >> 3) & fileVersionCheckNum)) {
                throw "integrity issue";
              }

              if (isDiffEncoding && iDim === 0) {
                throw "integrity issue";
              }

              blockEncoding = headerByte & 3;
              if (blockEncoding > 3) {
                data.ptr += blockPtr;
                throw "Invalid block encoding (" + blockEncoding + ")";
              }
              else if (blockEncoding === 2) { //constant 0
                if (isDiffEncoding) {
                  if (mask) {
                    for (row = 0; row < thisBlockHeight; row++) {
                      for (col = 0; col < thisBlockWidth; col++) {
                        if (mask[outPtr]) {
                          resultPixels[outPtr] = resultPixelsPrevDim[outPtr];
                        }
                        outPtr++;
                      }
                    }
                  }
                  else {
                    for (row = 0; row < thisBlockHeight; row++) {
                      for (col = 0; col < thisBlockWidth; col++) {
                        resultPixels[outPtr] = resultPixelsPrevDim[outPtr];
                        outPtr++;
                      }
                    }
                  }
                }
                data.counter.constant++;
                data.ptr += blockPtr;
                continue;
              }
              else if (blockEncoding === 0) {  //uncompressed
                if (isDiffEncoding) {
                  // doesn't make sense, should not happen
                  throw "integrity issue";
                }
                data.counter.uncompressed++;
                data.ptr += blockPtr;
                numBytes = thisBlockHeight * thisBlockWidth * dataTypeSize;
                bytesleft = input.byteLength - data.ptr;
                numBytes = numBytes < bytesleft ? numBytes : bytesleft;
                //bit alignment
                arrayBuf = new ArrayBuffer((numBytes % dataTypeSize) === 0 ? numBytes : (numBytes + dataTypeSize - numBytes % dataTypeSize));
                store8 = new Uint8Array(arrayBuf);
                store8.set(new Uint8Array(input, data.ptr, numBytes));
                rawData = new OutPixelTypeArray(arrayBuf);
                z = 0;
                if (mask) {
                  for (row = 0; row < thisBlockHeight; row++) {
                    for (col = 0; col < thisBlockWidth; col++) {
                      if (mask[outPtr]) {
                        resultPixels[outPtr] = rawData[z++];
                      }
                      outPtr++;
                    }
                    outPtr += outStride;
                  }
                }
                else {//all valid
                  for (row = 0; row < thisBlockHeight; row++) {
                    for (col = 0; col < thisBlockWidth; col++) {
                      resultPixels[outPtr++] = rawData[z++];
                    }
                    outPtr += outStride;
                  }
                }
                data.ptr += z * dataTypeSize;
              }
              else { //1 or 3
                offsetType = Lerc2Helpers.getDataTypeUsed((isDiffEncoding && imageType < 6) ? 4 : imageType, bits67);
                offset = Lerc2Helpers.getOnePixel(block, blockPtr, offsetType, view);
                blockPtr += Lerc2Helpers.getDataTypeSize(offsetType);
                if (blockEncoding === 3) //constant offset value
                {
                  data.ptr += blockPtr;
                  data.counter.constantoffset++;
                  //you can delete the following resultMask case in favor of performance because val is constant and users use nodata mask, otherwise nodatavalue post processing handles it too.
                  //while the above statement is true, we're not doing it as we want to keep invalid pixel value at 0 rather than arbitrary values
                  if (mask) {
                    for (row = 0; row < thisBlockHeight; row++) {
                      for (col = 0; col < thisBlockWidth; col++) {
                        if (mask[outPtr]) {
                          resultPixels[outPtr] = isDiffEncoding ? Math.min(zMax, resultPixelsPrevDim[outPtr] + offset) : offset;
                        }
                        outPtr++;
                      }
                      outPtr += outStride;
                    }
                  }
                  else {
                    for (row = 0; row < thisBlockHeight; row++) {
                      for (col = 0; col < thisBlockWidth; col++) {
                        resultPixels[outPtr] = isDiffEncoding ? Math.min(zMax, resultPixelsPrevDim[outPtr] + offset) : offset;
                        outPtr++;
                      }
                      outPtr += outStride;
                    }
                  }
                }
                else { //bitstuff encoding is 3
                  data.ptr += blockPtr;
                  //heavy lifting
                  Lerc2Helpers.decodeBits(input, data, blockDataBuffer, offset, iDim);
                  blockPtr = 0;
                  // duplicate code to favor performance, diff encoding is for multidimension only
                  if (isDiffEncoding) {
                    if (mask) {
                      for (row = 0; row < thisBlockHeight; row++) {
                        for (col = 0; col < thisBlockWidth; col++) {
                          if (mask[outPtr]) {
                            resultPixels[outPtr] = blockDataBuffer[blockPtr++] + resultPixelsPrevDim[outPtr];
                          }
                          outPtr++;
                        }
                        outPtr += outStride;
                      }
                    }
                    else {
                      for (row = 0; row < thisBlockHeight; row++) {
                        for (col = 0; col < thisBlockWidth; col++) {
                          resultPixels[outPtr] = blockDataBuffer[blockPtr++] + resultPixelsPrevDim[outPtr];
                          outPtr++;
                        }
                        outPtr += outStride;
                      }
                    }
                  }
                  else if (mask) {
                    for (row = 0; row < thisBlockHeight; row++) {
                      for (col = 0; col < thisBlockWidth; col++) {
                        if (mask[outPtr]) {
                          resultPixels[outPtr] = blockDataBuffer[blockPtr++];
                        }
                        outPtr++;
                      }
                      outPtr += outStride;
                    }
                  }
                  else {
                    for (row = 0; row < thisBlockHeight; row++) {
                      for (col = 0; col < thisBlockWidth; col++) {
                        resultPixels[outPtr++] = blockDataBuffer[blockPtr++];
                      }
                      outPtr += outStride;
                    }
                  }
                }
              }
            }
          }
        }
        //swap for BIP: it's always easier for clients to handle BSQ so we keep existing logic and introduce a swap here to minimze changes
        if (numDims > 1 && !useBSQForOutputDim) {
          data.pixels.resultPixels = Lerc2Helpers.swapDimensionOrder(data.pixels.resultPixels, numPixels, numDims, OutPixelTypeArray);
        }
      },

      /*****************
      *  private methods (helper methods)
      *****************/

      formatFileInfo: function(data) {
        return {
          "fileIdentifierString": data.headerInfo.fileIdentifierString,
          "fileVersion": data.headerInfo.fileVersion,
          "imageType": data.headerInfo.imageType,
          "height": data.headerInfo.height,
          "width": data.headerInfo.width,
          "numValidPixel": data.headerInfo.numValidPixel,
          "microBlockSize": data.headerInfo.microBlockSize,
          "blobSize": data.headerInfo.blobSize,
          "maxZError": data.headerInfo.maxZError,
          "pixelType": Lerc2Helpers.getPixelType(data.headerInfo.imageType),
          "eofOffset": data.eofOffset,
          "mask": data.mask ? {
            "numBytes": data.mask.numBytes
          } : null,
          "pixels": {
            "numBlocksX": data.pixels.numBlocksX,
            "numBlocksY": data.pixels.numBlocksY,
            //"numBytes": data.pixels.numBytes,
            "maxValue": data.headerInfo.zMax,
            "minValue": data.headerInfo.zMin,
            "noDataValue": data.noDataValue
          }
        };
      },

      constructConstantSurface: function(data, useBSQForOutputDim) {
        var val = data.headerInfo.zMax;
        var valMin = data.headerInfo.zMin;
        var maxValues = data.headerInfo.maxValues;
        var numDims = data.headerInfo.numDims;
        var numPixels = data.headerInfo.height * data.headerInfo.width;
        var i = 0, k = 0, nStart = 0;
        var mask = data.pixels.resultMask;
        var resultPixels = data.pixels.resultPixels;
        if (mask) {
          if (numDims > 1) {
            if (useBSQForOutputDim) {
              for (i = 0; i < numDims; i++) {
                nStart = i * numPixels;
                val = maxValues[i];
                for (k = 0; k < numPixels; k++) {
                  if (mask[k]) {
                    resultPixels[nStart + k] = val;
                  }
                }
              }  
            }
            else {
              for (k = 0; k < numPixels; k++) {
                if (mask[k]) {
                  nStart = k * numDims;
                  for (i = 0; i < numDims; i++) {
                    resultPixels[nStart + numDims] = maxValues[i];
                  }
                }
              }
            }
          }
          else {
            for (k = 0; k < numPixels; k++) {
              if (mask[k]) {
                resultPixels[k] = val;
              }
            }
          }
        }
        else {
          if (numDims > 1 && valMin !== val) {
            if (useBSQForOutputDim) {
              for (i = 0; i < numDims; i++) {
                nStart = i * numPixels;
                val = maxValues[i];
                for (k = 0; k < numPixels; k++) {
                  resultPixels[nStart + k] = val;
                }
              }
            }
            else {
              for (k = 0; k < numPixels; k++) {
                nStart = k * numDims;
                for (i = 0; i < numDims; i++) {
                  resultPixels[nStart + i] = maxValues[i];
                }
              }
            }
          }
          else {
            for (k = 0; k < numPixels * numDims; k++) {
              resultPixels[k] = val;
            }
          }
        }
        return;
      },

      getDataTypeArray: function(t) {
        var tp;
        switch (t) {
          case 0: //char
            tp = Int8Array;
            break;
          case 1: //byte
            tp = Uint8Array;
            break;
          case 2: //short
            tp = Int16Array;
            break;
          case 3: //ushort
            tp = Uint16Array;
            break;
          case 4:
            tp = Int32Array;
            break;
          case 5:
            tp = Uint32Array;
            break;
          case 6:
            tp = Float32Array;
            break;
          case 7:
            tp = Float64Array;
            break;
          default:
            tp = Float32Array;
        }
        return tp;
      },

      getPixelType: function(t) {
        var tp;
        switch (t) {
          case 0: //char
            tp = "S8";
            break;
          case 1: //byte
            tp = "U8";
            break;
          case 2: //short
            tp = "S16";
            break;
          case 3: //ushort
            tp = "U16";
            break;
          case 4:
            tp = "S32";
            break;
          case 5:
            tp = "U32";
            break;
          case 6:
            tp = "F32";
            break;
          case 7:
            tp = "F64";
            break;
          default:
            tp = "F32";
        }
        return tp;
      },

      isValidPixelValue: function(t, val) {
        if (val == null) {
          return false;
        }
        var isValid;
        switch (t) {
          case 0: //char
            isValid = val >= -128 && val <= 127;
            break;
          case 1: //byte  (unsigned char)
            isValid = val >= 0 && val <= 255;
            break;
          case 2: //short
            isValid = val >= -32768 && val <= 32767;
            break;
          case 3: //ushort
            isValid = val >= 0 && val <= 65536;
            break;
          case 4: //int 32
            isValid = val >= -2147483648 && val <= 2147483647;
            break;
          case 5: //uinit 32
            isValid = val >= 0 && val <= 4294967296;
            break;
          case 6:
            isValid = val >= -3.4027999387901484e+38 && val <= 3.4027999387901484e+38;
            break;
          case 7:
            isValid = val >= -1.7976931348623157e+308 && val <= 1.7976931348623157e+308;
            break;
          default:
            isValid = false;
        }
        return isValid;
      },

      getDataTypeSize: function(t) {
        var s = 0;
        switch (t) {
          case 0: //ubyte
          case 1: //byte
            s = 1;
            break;
          case 2: //short
          case 3: //ushort
            s = 2;
            break;
          case 4:
          case 5:
          case 6:
            s = 4;
            break;
          case 7:
            s = 8;
            break;
          default:
            s = t;
        }
        return s;
      },

      getDataTypeUsed: function(dt, tc) {
        var t = dt;
        switch (dt) {
          case 2: //short
          case 4: //long
            t = dt - tc;
            break;
          case 3: //ushort
          case 5: //ulong
            t = dt - 2 * tc;
            break;
          case 6: //float
            if (0 === tc) {
              t = dt;
            }
            else if (1 === tc) {
              t = 2;
            }
            else {
              t = 1;//byte
            }
            break;
          case 7: //double
            if (0 === tc) {
              t = dt;
            }
            else {
              t = dt - 2 * tc + 1;
            }
            break;
          default:
            t = dt;
            break;
        }
        return t;
      },

      getOnePixel: function(block, blockPtr, offsetType, view) {
        var temp = 0;
        switch (offsetType) {
          case 0: //char
            temp = view.getInt8(blockPtr);
            break;
          case 1: //byte
            temp = view.getUint8(blockPtr);
            break;
          case 2:
            temp = view.getInt16(blockPtr, true);
            break;
          case 3:
            temp = view.getUint16(blockPtr, true);
            break;
          case 4:
            temp = view.getInt32(blockPtr, true);
            break;
          case 5:
            temp = view.getUInt32(blockPtr, true);
            break;
          case 6:
            temp = view.getFloat32(blockPtr, true);
            break;
          case 7:
            temp = view.getFloat64(blockPtr, true);
            break;
          default:
            throw ("the decoder does not understand this pixel type");
        }
        return temp;
      },

      swapDimensionOrder: function(pixels, numPixels, numDims, OutPixelTypeArray, inputIsBIP) {
        var i = 0, j = 0, iDim = 0, temp = 0, swap = pixels;
        if (numDims > 1) {
          swap = new OutPixelTypeArray(numPixels * numDims);
          if (inputIsBIP) {
            for (i=0; i<numPixels; i++) {
              temp = i;
              for (iDim=0; iDim < numDims; iDim++, temp += numPixels) {
                swap[temp] = pixels[j++];
              }
            }  
          }
          else {
            for (i=0; i<numPixels; i++) {
              temp = i;
              for (iDim=0; iDim < numDims; iDim++, temp += numPixels) {
                swap[j++] = pixels[temp];
              }
            }
          }
        }
        return swap;
      }
    };

    /***************************************************
    *private class for a tree node. Huffman code is in Lerc2Helpers
    ****************************************************/
    var TreeNode = function(val, left, right) {
      this.val = val;
      this.left = left;
      this.right = right;
    };

    var Lerc2Decode = {
      /*
      * ********removed options compared to LERC1. We can bring some of them back if needed.
       * removed pixel type. LERC2 is typed and doesn't require user to give pixel type
       * changed encodedMaskData to maskData. LERC2 's js version make it faster to use maskData directly.
       * removed returnMask. mask is used by LERC2 internally and is cost free. In case of user input mask, it's returned as well and has neglible cost.
       * removed nodatavalue. Because LERC2 pixels are typed, nodatavalue will sacrify a useful value for many types (8bit, 16bit) etc,
       *       user has to be knowledgable enough about raster and their data to avoid usability issues. so nodata value is simply removed now.
       *       We can add it back later if their's a clear requirement.
       * removed encodedMask. This option was not implemented in LercDecode. It can be done after decoding (less efficient)
       * removed computeUsedBitDepths.
       *
       *
       * response changes compared to LERC1
       * 1. encodedMaskData is not available
       * 2. noDataValue is optional (returns only if user's noDataValue is with in the valid data type range)
       * 3. maskData is always available
      */
      /*****************
      *  public properties
      ******************/
      //HUFFMAN_LUT_BITS_MAX: 12, //use 2^12 lut, not configurable

      /*****************
      *  public methods
      *****************/

      /**
       * Decode a LERC2 byte stream and return an object containing the pixel data and optional metadata.
       *
       * @param {ArrayBuffer} input The LERC input byte stream
       * @param {object} [options] options Decoding options
       * @param {number} [options.inputOffset] The number of bytes to skip in the input byte stream. A valid LERC file is expected at that position
       * @param {boolean} [options.returnFileInfo] If true, the return value will have a fileInfo property that contains metadata obtained from the LERC headers and the decoding process
       * @param {boolean} [options.returnPixelInterleavedDims]  If true, returned dimensions are pixel-interleaved, a.k.a [p1_dim0, p1_dim1, p1_dimn, p2_dim0...], default is [p1_dim0, p2_dim0, ..., p1_dim1, p2_dim1...]
       */
      decode: function(/*byte array*/ input, /*object*/ options) {
        //currently there's a bug in the sparse array, so please do not set to false
        options = options || {};
        var noDataValue = options.noDataValue;

        //initialize
        var i = 0, data = {};
        data.ptr = options.inputOffset || 0;
        data.pixels = {};

        // File header
        if (!Lerc2Helpers.readHeaderInfo(input, data)) {
          return;
        }

        var headerInfo = data.headerInfo;
        var fileVersion = headerInfo.fileVersion;
        var OutPixelTypeArray = Lerc2Helpers.getDataTypeArray(headerInfo.imageType);

        // version check
        if (fileVersion > 5) {
          throw "unsupported lerc version 2." + fileVersion;
        }

        // Mask Header
        Lerc2Helpers.readMask(input, data);
        if (headerInfo.numValidPixel !== headerInfo.width * headerInfo.height && !data.pixels.resultMask) {
          data.pixels.resultMask = options.maskData;
        }

        var numPixels = headerInfo.width * headerInfo.height;
        data.pixels.resultPixels = new OutPixelTypeArray(numPixels * headerInfo.numDims);

        data.counter = {
          onesweep: 0,
          uncompressed: 0,
          lut: 0,
          bitstuffer: 0,
          constant: 0,
          constantoffset: 0
        };
        var useBSQForOutputDim = !options.returnPixelInterleavedDims;
        if (headerInfo.numValidPixel !== 0) {
          //not tested
          if (headerInfo.zMax === headerInfo.zMin) //constant surface
          {
            Lerc2Helpers.constructConstantSurface(data, useBSQForOutputDim);
          }
          else if (fileVersion >= 4 && Lerc2Helpers.checkMinMaxRanges(input, data)) {
            Lerc2Helpers.constructConstantSurface(data, useBSQForOutputDim);
          }
          else {
            var view = new DataView(input, data.ptr, 2);
            var bReadDataOneSweep = view.getUint8(0);
            data.ptr++;
            if (bReadDataOneSweep) {
              //console.debug("OneSweep");
              Lerc2Helpers.readDataOneSweep(input, data, OutPixelTypeArray, useBSQForOutputDim);
            }
            else {
              //lerc2.1: //bitstuffing + lut
              //lerc2.2: //bitstuffing + lut + huffman
              //lerc2.3: new bitstuffer
              if (fileVersion > 1 && headerInfo.imageType <= 1 && Math.abs(headerInfo.maxZError - 0.5) < 0.00001) {
                //this is 2.x plus 8 bit (unsigned and signed) data, possiblity of Huffman
                var flagHuffman = view.getUint8(1);
                data.ptr++;
                data.encodeMode = flagHuffman;
                if (flagHuffman > 2 || (fileVersion < 4 && flagHuffman > 1)) {
                  throw "Invalid Huffman flag " + flagHuffman;
                }
                if (flagHuffman) {//1 - delta Huffman, 2 - Huffman
                  //console.log("Huffman");
                  Lerc2Helpers.readHuffman(input, data, OutPixelTypeArray, useBSQForOutputDim);
                }
                else {
                  //console.log("Tiles");
                  Lerc2Helpers.readTiles(input, data, OutPixelTypeArray, useBSQForOutputDim);
                }
              }
              else { //lerc2.x non-8 bit data
                //console.log("Tiles");
                Lerc2Helpers.readTiles(input, data, OutPixelTypeArray, useBSQForOutputDim);
              }
            }
          }
        }

        data.eofOffset = data.ptr;
        var diff;
        if (options.inputOffset) {
          diff = data.headerInfo.blobSize + options.inputOffset - data.ptr;
          if (Math.abs(diff) >= 1) {
            //console.debug("incorrect eof: dataptr " + data.ptr + " offset " + options.inputOffset + " blobsize " + data.headerInfo.blobSize + " diff: " + diff);
            data.eofOffset = options.inputOffset + data.headerInfo.blobSize;
          }
        }
        else {
          diff = data.headerInfo.blobSize - data.ptr;
          if (Math.abs(diff) >= 1) {
            //console.debug("incorrect first band eof: dataptr " + data.ptr + " blobsize " + data.headerInfo.blobSize + " diff: " + diff);
            data.eofOffset = data.headerInfo.blobSize;
          }
        }

        var result = {
          width: headerInfo.width,
          height: headerInfo.height,
          pixelData: data.pixels.resultPixels,
          minValue: headerInfo.zMin,
          maxValue: headerInfo.zMax,
          validPixelCount: headerInfo.numValidPixel,
          dimCount: headerInfo.numDims,
          dimStats: {
            minValues: headerInfo.minValues,
            maxValues: headerInfo.maxValues
          },
          maskData: data.pixels.resultMask
          //noDataValue: noDataValue
        };

        //we should remove this if there's no existing client
        //optional noDataValue processing, it's user's responsiblity
        if (data.pixels.resultMask && Lerc2Helpers.isValidPixelValue(headerInfo.imageType, noDataValue)) {
          var mask = data.pixels.resultMask;
          for (i = 0; i < numPixels; i++) {
            if (!mask[i]) {
              result.pixelData[i] = noDataValue;
            }
          }
          result.noDataValue = noDataValue;
        }
        data.noDataValue = noDataValue;
        if (options.returnFileInfo) {
          result.fileInfo = Lerc2Helpers.formatFileInfo(data);
        }
        return result;
      },

      getBandCount: function(/*byte array*/ input) {
        var count = 0;
        var i = 0;
        var temp = {};
        temp.ptr = 0;
        temp.pixels = {};
        while (i < input.byteLength - 58) {
          Lerc2Helpers.readHeaderInfo(input, temp);
          i += temp.headerInfo.blobSize;
          count++;
          temp.ptr = i;
        }
        return count;
      }
    };

    return Lerc2Decode;
  })();

  var isPlatformLittleEndian = (function() {
    var a = new ArrayBuffer(4);
    var b = new Uint8Array(a);
    var c = new Uint32Array(a);
    c[0] = 1;
    return b[0] === 1;
  })();

  var Lerc = {
    /************wrapper**********************************************/
    /**
     * A wrapper for decoding both LERC1 and LERC2 byte streams capable of handling multiband pixel blocks for various pixel types.
     *
     * @alias module:Lerc
     * @param {ArrayBuffer} input The LERC input byte stream
     * @param {object} [options] The decoding options below are optional.
     * @param {number} [options.inputOffset] The number of bytes to skip in the input byte stream. A valid Lerc file is expected at that position.
     * @param {string} [options.pixelType] (LERC1 only) Default value is F32. Valid pixel types for input are U8/S8/S16/U16/S32/U32/F32.
     * @param {number} [options.noDataValue] (LERC1 only). It is recommended to use the returned mask instead of setting this value.
     * @param {boolean} [options.returnPixelInterleavedDims] (nDim LERC2 only) If true, returned dimensions are pixel-interleaved, a.k.a [p1_dim0, p1_dim1, p1_dimn, p2_dim0...], default is [p1_dim0, p2_dim0, ..., p1_dim1, p2_dim1...]
     * @returns {{width, height, pixels, pixelType, mask, statistics}}
       * @property {number} width Width of decoded image.
       * @property {number} height Height of decoded image.
       * @property {array} pixels [band1, band2, â¦] Each band is a typed array of width*height.
       * @property {string} pixelType The type of pixels represented in the output.
       * @property {mask} mask Typed array with a size of width*height, or null if all pixels are valid.
       * @property {array} statistics [statistics_band1, statistics_band2, â¦] Each element is a statistics object representing min and max values
    **/
    decode: function(encodedData, options) {
      if (!isPlatformLittleEndian) {
        throw "Big endian system is not supported.";
      }
      options = options || {};
      var inputOffset = options.inputOffset || 0;
      var fileIdView = new Uint8Array(encodedData, inputOffset, 10);
      var fileIdentifierString = String.fromCharCode.apply(null, fileIdView);
      var lerc, majorVersion;
      if (fileIdentifierString.trim() === "CntZImage") {
        lerc = LercDecode;
        majorVersion = 1;
      }
      else if (fileIdentifierString.substring(0, 5) === "Lerc2") {
        lerc = Lerc2Decode;
        majorVersion = 2;
      }
      else {
        throw "Unexpected file identifier string: " + fileIdentifierString;
      }

      var iPlane = 0, eof = encodedData.byteLength - 10, encodedMaskData, bandMasks = [], bandMask, maskData;
      var decodedPixelBlock = {
        width: 0,
        height: 0,
        pixels: [],
        pixelType: options.pixelType,
        mask: null,
        statistics: []
      };
      var uniqueBandMaskCount = 0;

      while (inputOffset < eof) {
        var result = lerc.decode(encodedData, {
          inputOffset: inputOffset,//for both lerc1 and lerc2
          encodedMaskData: encodedMaskData,//lerc1 only
          maskData: maskData,//lerc2 only
          returnMask: iPlane === 0 ? true : false,//lerc1 only
          returnEncodedMask: iPlane === 0 ? true : false,//lerc1 only
          returnFileInfo: true,//for both lerc1 and lerc2
          returnPixelInterleavedDims: options.returnPixelInterleavedDims,//for ndim lerc2 only
          pixelType: options.pixelType || null,//lerc1 only
          noDataValue: options.noDataValue || null//lerc1 only
        });

        inputOffset = result.fileInfo.eofOffset;
        maskData = result.maskData;//lerc2
        if (iPlane === 0) {
          encodedMaskData = result.encodedMaskData;//lerc1
          decodedPixelBlock.width = result.width;
          decodedPixelBlock.height = result.height;
          decodedPixelBlock.dimCount = result.dimCount || 1;
          //decodedPixelBlock.dimStats = decodedPixelBlock.dimStats;
          decodedPixelBlock.pixelType = result.pixelType || result.fileInfo.pixelType;
          decodedPixelBlock.mask = maskData;
        }
        if (majorVersion > 1) {
          if (maskData) {
            bandMasks.push(maskData);
          }
          if (result.fileInfo.mask && result.fileInfo.mask.numBytes > 0) {
            uniqueBandMaskCount++;
          }
        }

        iPlane++;
        decodedPixelBlock.pixels.push(result.pixelData);
        decodedPixelBlock.statistics.push({
          minValue: result.minValue,
          maxValue: result.maxValue,
          noDataValue: result.noDataValue,
          dimStats: result.dimStats
        });
      }
      var i, j, numPixels;
      if (majorVersion > 1 && uniqueBandMaskCount > 1) {
        numPixels = decodedPixelBlock.width * decodedPixelBlock.height;
        decodedPixelBlock.bandMasks = bandMasks;
        maskData = new Uint8Array(numPixels);
        maskData.set(bandMasks[0]);
        for (i = 1; i < bandMasks.length; i++) {
          bandMask = bandMasks[i];
          for (j = 0; j < numPixels; j++) {
            maskData[j] = maskData[j] & bandMask[j];
          }
        }
        decodedPixelBlock.maskData = maskData;
      }

      return decodedPixelBlock;
    }
  };

  if (true) {/* jshint ignore:line */
    //amd loaders such as dojo and requireJS
    //http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() { return Lerc; }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));/* jshint ignore:line */
  }
  else {}

})();


/***/ }),

/***/ "./node_modules/geotiff/dist-module/compression/lerc.js":
/*!**************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/compression/lerc.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LercDecoder),
/* harmony export */   zstd: () => (/* binding */ zstd)
/* harmony export */ });
/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pako */ "./node_modules/pako/dist/pako.esm.mjs");
/* harmony import */ var lerc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lerc */ "./node_modules/geotiff/node_modules/lerc/LercDecode.js");
/* harmony import */ var zstddec__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zstddec */ "./node_modules/zstddec/dist/zstddec.modern.js");
/* harmony import */ var _basedecoder_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./basedecoder.js */ "./node_modules/geotiff/dist-module/compression/basedecoder.js");
/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../globals.js */ "./node_modules/geotiff/dist-module/globals.js");






const zstd = new zstddec__WEBPACK_IMPORTED_MODULE_2__.ZSTDDecoder();

class LercDecoder extends _basedecoder_js__WEBPACK_IMPORTED_MODULE_3__["default"] {
  constructor(fileDirectory) {
    super();

    this.planarConfiguration = typeof fileDirectory.PlanarConfiguration !== 'undefined' ? fileDirectory.PlanarConfiguration : 1;
    this.samplesPerPixel = typeof fileDirectory.SamplesPerPixel !== 'undefined' ? fileDirectory.SamplesPerPixel : 1;

    this.addCompression = fileDirectory.LercParameters[_globals_js__WEBPACK_IMPORTED_MODULE_4__.LercParameters.AddCompression];
  }

  decodeBlock(buffer) {
    switch (this.addCompression) {
      case _globals_js__WEBPACK_IMPORTED_MODULE_4__.LercAddCompression.None:
        break;
      case _globals_js__WEBPACK_IMPORTED_MODULE_4__.LercAddCompression.Deflate:
        buffer = (0,pako__WEBPACK_IMPORTED_MODULE_0__.inflate)(new Uint8Array(buffer)).buffer; // eslint-disable-line no-param-reassign, prefer-destructuring
        break;
      case _globals_js__WEBPACK_IMPORTED_MODULE_4__.LercAddCompression.Zstandard:
        buffer = zstd.decode(new Uint8Array(buffer)).buffer; // eslint-disable-line no-param-reassign, prefer-destructuring
        break;
      default:
        throw new Error(`Unsupported LERC additional compression method identifier: ${this.addCompression}`);
    }

    const lercResult = lerc__WEBPACK_IMPORTED_MODULE_1__.decode(buffer, { returnPixelInterleavedDims: this.planarConfiguration === 1 });
    const lercData = lercResult.pixels[0];
    return lercData.buffer;
  }
}


/***/ }),

/***/ "./node_modules/zstddec/dist/zstddec.modern.js":
/*!*****************************************************!*\
  !*** ./node_modules/zstddec/dist/zstddec.modern.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ZSTDDecoder: () => (/* binding */ ZSTDDecoder)
/* harmony export */ });
let init;
let instance;
let heap;
const IMPORT_OBJECT = {
  env: {
    emscripten_notify_memory_growth: function (index) {
      heap = new Uint8Array(instance.exports.memory.buffer);
    }
  }
};
/**
 * ZSTD (Zstandard) decoder.
 */
class ZSTDDecoder {
  init() {
    if (init) return init;
    if (typeof fetch !== 'undefined') {
      // Web.
      init = fetch('data:application/wasm;base64,' + wasm).then(response => response.arrayBuffer()).then(arrayBuffer => WebAssembly.instantiate(arrayBuffer, IMPORT_OBJECT)).then(this._init);
    } else {
      // Node.js.
      init = WebAssembly.instantiate(Buffer.from(wasm, 'base64'), IMPORT_OBJECT).then(this._init);
    }
    return init;
  }
  _init(result) {
    instance = result.instance;
    IMPORT_OBJECT.env.emscripten_notify_memory_growth(0); // initialize heap.
  }

  decode(array, uncompressedSize = 0) {
    if (!instance) throw new Error(`ZSTDDecoder: Await .init() before decoding.`);
    // Write compressed data into WASM memory.
    const compressedSize = array.byteLength;
    const compressedPtr = instance.exports.malloc(compressedSize);
    heap.set(array, compressedPtr);
    // Decompress into WASM memory.
    uncompressedSize = uncompressedSize || Number(instance.exports.ZSTD_findDecompressedSize(compressedPtr, compressedSize));
    const uncompressedPtr = instance.exports.malloc(uncompressedSize);
    const actualSize = instance.exports.ZSTD_decompress(uncompressedPtr, uncompressedSize, compressedPtr, compressedSize);
    // Read decompressed data and free WASM memory.
    const dec = heap.slice(uncompressedPtr, uncompressedPtr + actualSize);
    instance.exports.free(compressedPtr);
    instance.exports.free(uncompressedPtr);
    return dec;
  }
}
/**
 * BSD License
 *
 * For Zstandard software
 *
 * Copyright (c) 2016-present, Yann Collet, Facebook, Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name Facebook nor the names of its contributors may be used to
 *    endorse or promote products derived from this software without specific
 *    prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
// wasm:begin
const wasm = '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IAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQh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ASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigC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C0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdB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IAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY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wOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEE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';
// wasm:end


//# sourceMappingURL=zstddec.modern.js.map


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfZ2VvdGlmZl9kaXN0LW1vZHVsZV9jb21wcmVzc2lvbl9sZXJjX2pzLmJ1bmRsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZGQUE2Rjs7QUFFN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDREQUE0RDs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0EsZ0JBQWdCLHVCQUF1QjtBQUN2QztBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QixzQkFBc0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixxQkFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRCw2QkFBNkIscUJBQXFCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRCw2QkFBNkIscUJBQXFCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixjQUFjO0FBQ2Q7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwyQkFBMkI7QUFDdEQsNkJBQTZCLDJCQUEyQjs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QyxjQUFjO0FBQ2QscURBQXFEO0FBQ3JELGNBQWM7QUFDZCx1REFBdUQ7QUFDdkQsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQsZ0JBQWdCO0FBQ2hCLG1FQUFtRTtBQUNuRSxnQkFBZ0I7QUFDaEIsbUVBQW1FO0FBQ25FLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQsb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixjQUFjO0FBQ2Q7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGVBQWU7QUFDekM7QUFDQTtBQUNBLDhCQUE4QixhQUFhO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixlQUFlO0FBQ3pDO0FBQ0E7QUFDQSw4QkFBOEIsYUFBYTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUEscUJBQXFCLFFBQVE7QUFDN0Isd0NBQXdDO0FBQ3hDLDJCQUEyQjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUTtBQUM3Qix3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0JBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFNBQVM7QUFDMUMsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQkFBZ0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRSxpQ0FBaUMsWUFBWTtBQUM3Qyw0QkFBNEIsV0FBVztBQUN2QztBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSxpQ0FBaUMsaUJBQWlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGlDQUFpQyxZQUFZO0FBQzdDLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsbUNBQW1DLGlCQUFpQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsWUFBWTtBQUN6Qyx3QkFBd0IsV0FBVztBQUNuQztBQUNBO0FBQ0EsK0JBQStCLGdCQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGlCQUFpQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25ELFlBQVk7QUFDWiwwREFBMEQ7QUFDMUQsWUFBWTtBQUNaLDBEQUEwRDtBQUMxRCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFCQUFxQjtBQUM5QztBQUNBLDJCQUEyQixxQkFBcUI7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBLGtDQUFrQyx1QkFBdUI7QUFDekQsb0NBQW9DLHNCQUFzQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHVCQUF1QjtBQUN6RCxvQ0FBb0Msc0JBQXNCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHVCQUF1QjtBQUN2RCxrQ0FBa0Msc0JBQXNCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsZ0NBQWdDLHVCQUF1QjtBQUN2RCxrQ0FBa0Msc0JBQXNCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHVCQUF1QjtBQUN6RCxvQ0FBb0Msc0JBQXNCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx1QkFBdUI7QUFDekQsb0NBQW9DLHNCQUFzQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx1QkFBdUI7QUFDM0Qsc0NBQXNDLHNCQUFzQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsdUJBQXVCO0FBQzNELHNDQUFzQyxzQkFBc0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx1QkFBdUI7QUFDekQsb0NBQW9DLHNCQUFzQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsdUJBQXVCO0FBQ3pELG9DQUFvQyxzQkFBc0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixhQUFhO0FBQ3ZDO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixlQUFlO0FBQ3pDO0FBQ0E7QUFDQSw4QkFBOEIsYUFBYTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixhQUFhO0FBQ3ZDO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGVBQWU7QUFDekM7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCLGlCQUFpQixRQUFRO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCLGlCQUFpQixTQUFTO0FBQzFCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXBzYnVuZGxlLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvbm9kZV9tb2R1bGVzL2xlcmMvTGVyY0RlY29kZS5qcyIsIndlYnBhY2s6Ly9tYXBzYnVuZGxlLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvY29tcHJlc3Npb24vbGVyYy5qcyIsIndlYnBhY2s6Ly9tYXBzYnVuZGxlLy4vbm9kZV9tb2R1bGVzL3pzdGRkZWMvZGlzdC96c3RkZGVjLm1vZGVybi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyLvu78vKiBqc2hpbnQgZm9yaW46IGZhbHNlLCBiaXR3aXNlOiBmYWxzZSAqL1xuLypcbkNvcHlyaWdodCAyMDE1LTIwMjEgRXNyaVxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbmh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5BIGNvcHkgb2YgdGhlIGxpY2Vuc2UgYW5kIGFkZGl0aW9uYWwgbm90aWNlcyBhcmUgbG9jYXRlZCB3aXRoIHRoZVxuc291cmNlIGRpc3RyaWJ1dGlvbiBhdDpcblxuaHR0cDovL2dpdGh1Yi5jb20vRXNyaS9sZXJjL1xuXG5Db250cmlidXRvcnM6ICBKb2hhbm5lcyBTY2htaWQsIChMRVJDIHYxKVxuICAgICAgICAgICAgICAgQ2hheWFuaWthIEtoYXR1YSwgKExFUkMgdjEpXG4gICAgICAgICAgICAgICBXZW54dWUgSnUgKExFUkMgdjEsIHYyLngpXG4qL1xuXG4vKiBDb3B5cmlnaHQgMjAxNS0yMDIxIEVzcmkuIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMCBAcHJlc2VydmUgKi9cblxuLyoqXG4gKiBhIG1vZHVsZSBmb3IgZGVjb2RpbmcgTEVSQyBibG9ic1xuICogQG1vZHVsZSBMZXJjXG4gKi9cbihmdW5jdGlvbigpIHtcbiAgLy90aGlzIGRlY29kZXIgc3VwcG9ydHMgYWxsIGxlcmMgdmVyc2lvbnMsIGVhY2ggdmVyc2lvbiBoYXMgaXRzIG93biBjbGFzcyAoTGVyY0RlY29kZSBhbmQgTGVyYzJEZWNvZGUpLiBcbiAgLy90aGUgZXhwb3J0ZWQgbW9kdWxlIGhhbmRsZXMgZm9ybWF0IHZhcmlhdGlvbiBhdXRvYW10aWNhbGx5LlxuXG4gIC8vdGhlIG9yaWdpbmFsIExlcmNEZWNvZGUgZm9yIFZlcnNpb24gMVxuICB2YXIgTGVyY0RlY29kZSA9IChmdW5jdGlvbigpIHtcblxuICAgIC8vIE5vdGU6IGN1cnJlbnRseSwgdGhpcyBtb2R1bGUgb25seSBoYXMgYW4gaW1wbGVtZW50YXRpb24gZm9yIGRlY29kaW5nIExFUkMgZGF0YSwgbm90IGVuY29kaW5nLiBUaGUgbmFtZSBvZlxuICAgIC8vIHRoZSBjbGFzcyB3YXMgY2hvc2VuIHRvIGJlIGZ1dHVyZSBwcm9vZi5cblxuICAgIHZhciBDbnRaSW1hZ2UgPSB7fTtcblxuICAgIENudFpJbWFnZS5kZWZhdWx0Tm9EYXRhVmFsdWUgPSAtMy40MDI3OTk5Mzg3OTAxNDg0ZSszODsgLy8gc21hbGxlc3QgRmxvYXQzMiB2YWx1ZVxuXG4gICAgLyoqXG4gICAgICogRGVjb2RlIGEgTEVSQyBieXRlIHN0cmVhbSBhbmQgcmV0dXJuIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBwaXhlbCBkYXRhIGFuZCBzb21lIHJlcXVpcmVkIGFuZCBvcHRpb25hbFxuICAgICAqIGluZm9ybWF0aW9uIGFib3V0IGl0LCBzdWNoIGFzIHRoZSBpbWFnZSdzIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBpbnB1dCBUaGUgTEVSQyBpbnB1dCBieXRlIHN0cmVhbVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gRGVjb2Rpbmcgb3B0aW9ucywgY29udGFpbmluZyBhbnkgb2YgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAqIEBjb25maWcge251bWJlcn0gW2lucHV0T2Zmc2V0ID0gMF1cbiAgICAgKiAgICAgICAgU2tpcCB0aGUgZmlyc3QgaW5wdXRPZmZzZXQgYnl0ZXMgb2YgdGhlIGlucHV0IGJ5dGUgc3RyZWFtLiBBIHZhbGlkIExFUkMgZmlsZSBpcyBleHBlY3RlZCBhdCB0aGF0IHBvc2l0aW9uLlxuICAgICAqIEBjb25maWcge1VpbnQ4QXJyYXl9IFtlbmNvZGVkTWFzayA9IG51bGxdXG4gICAgICogICAgICAgIElmIHNwZWNpZmllZCwgdGhlIGRlY29kZXIgd2lsbCBub3QgcmVhZCBtYXNrIGluZm9ybWF0aW9uIGZyb20gdGhlIGlucHV0IGFuZCB1c2UgdGhlIHNwZWNpZmllZCBlbmNvZGVkXG4gICAgICogICAgICAgIG1hc2sgZGF0YSBpbnN0ZWFkLiBNYXNrIGhlYWRlci9kYXRhIG11c3Qgbm90IGJlIHByZXNlbnQgaW4gdGhlIExFUkMgYnl0ZSBzdHJlYW0gaW4gdGhpcyBjYXNlLlxuICAgICAqIEBjb25maWcge251bWJlcn0gW25vRGF0YVZhbHVlID0gTGVyY0NvZGUuZGVmYXVsdE5vRGF0YVZhbHVlXVxuICAgICAqICAgICAgICBQaXhlbCB2YWx1ZSB0byB1c2UgZm9yIG1hc2tlZCBwaXhlbHMuXG4gICAgICogQGNvbmZpZyB7QXJyYXlCdWZmZXJWaWV3fEFycmF5fSBbcGl4ZWxUeXBlID0gRmxvYXQzMkFycmF5XVxuICAgICAqICAgICAgICBUaGUgZGVzaXJlZCB0eXBlIG9mIHRoZSBwaXhlbERhdGEgYXJyYXkgaW4gdGhlIHJldHVybiB2YWx1ZS4gTm90ZSB0aGF0IGl0IGlzIHRoZSBjYWxsZXIncyByZXNwb25zaWJpbGl0eSB0b1xuICAgICAqICAgICAgICBwcm92aWRlIGFuIGFwcHJvcHJpYXRlIG5vRGF0YVZhbHVlIGlmIHRoZSBkZWZhdWx0IHBpeGVsVHlwZSBpcyBvdmVycmlkZGVuLlxuICAgICAqIEBjb25maWcge2Jvb2xlYW59IFtyZXR1cm5NYXNrID0gZmFsc2VdXG4gICAgICogICAgICAgIElmIHRydWUsIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBjb250YWluIGEgbWFza0RhdGEgcHJvcGVydHkgb2YgdHlwZSBVaW50OEFycmF5IHdoaWNoIGhhcyBvbmUgZWxlbWVudCBwZXJcbiAgICAgKiAgICAgICAgcGl4ZWwsIHRoZSB2YWx1ZSBvZiB3aGljaCBpcyAxIG9yIDAgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhhdCBwaXhlbCdzIGRhdGEgaXMgcHJlc2VudCBvciBtYXNrZWQuIElmIHRoZVxuICAgICAqICAgICAgICBpbnB1dCBMRVJDIGRhdGEgZG9lcyBub3QgY29udGFpbiBhIG1hc2ssIG1hc2tEYXRhIHdpbGwgbm90IGJlIHJldHVybmVkLlxuICAgICAqIEBjb25maWcge2Jvb2xlYW59IFtyZXR1cm5FbmNvZGVkTWFzayA9IGZhbHNlXVxuICAgICAqICAgICAgICBJZiB0cnVlLCB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgY29udGFpbiBhIGVuY29kZWRNYXNrRGF0YSBwcm9wZXJ0eSwgd2hpY2ggY2FuIGJlIHBhc3NlZCBpbnRvIGVuY29kZSgpIGFzXG4gICAgICogICAgICAgIGVuY29kZWRNYXNrLlxuICAgICAqIEBjb25maWcge2Jvb2xlYW59IFtyZXR1cm5GaWxlSW5mbyA9IGZhbHNlXVxuICAgICAqICAgICAgICBJZiB0cnVlLCB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgaGF2ZSBhIGZpbGVJbmZvIHByb3BlcnR5IHRoYXQgY29udGFpbnMgbWV0YWRhdGEgb2J0YWluZWQgZnJvbSB0aGVcbiAgICAgKiAgICAgICAgTEVSQyBoZWFkZXJzIGFuZCB0aGUgZGVjb2RpbmcgcHJvY2Vzcy5cbiAgICAgKiBAY29uZmlnIHtib29sZWFufSBbY29tcHV0ZVVzZWRCaXREZXB0aHMgPSBmYWxzZV1cbiAgICAgKiAgICAgICAgSWYgdHJ1ZSwgdGhlIGZpbGVJbmZvIHByb3BlcnR5IGluIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBjb250YWluIHRoZSBzZXQgb2YgYWxsIGJsb2NrIGJpdCBkZXB0aHNcbiAgICAgKiAgICAgICAgZW5jb3VudGVyZWQgZHVyaW5nIGRlY29kaW5nLiBXaWxsIG9ubHkgaGF2ZSBhbiBlZmZlY3QgaWYgcmV0dXJuRmlsZUluZm8gb3B0aW9uIGlzIHRydWUuXG4gICAgICogQHJldHVybnMge3t3aWR0aCwgaGVpZ2h0LCBwaXhlbERhdGEsIG1pblZhbHVlLCBtYXhWYWx1ZSwgbm9EYXRhVmFsdWUsIG1hc2tEYXRhLCBlbmNvZGVkTWFza0RhdGEsIGZpbGVJbmZvfX1cbiAgICAgKi9cbiAgICBDbnRaSW1hZ2UuZGVjb2RlID0gZnVuY3Rpb24oaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICB2YXIgc2tpcE1hc2sgPSBvcHRpb25zLmVuY29kZWRNYXNrRGF0YSB8fCAob3B0aW9ucy5lbmNvZGVkTWFza0RhdGEgPT09IG51bGwpO1xuICAgICAgdmFyIHBhcnNlZERhdGEgPSBwYXJzZShpbnB1dCwgb3B0aW9ucy5pbnB1dE9mZnNldCB8fCAwLCBza2lwTWFzayk7XG5cbiAgICAgIHZhciBub0RhdGFWYWx1ZSA9IChvcHRpb25zLm5vRGF0YVZhbHVlICE9PSBudWxsKSA/IG9wdGlvbnMubm9EYXRhVmFsdWUgOiBDbnRaSW1hZ2UuZGVmYXVsdE5vRGF0YVZhbHVlO1xuXG4gICAgICB2YXIgdW5jb21wcmVzc2VkRGF0YSA9IHVuY29tcHJlc3NQaXhlbFZhbHVlcyhwYXJzZWREYXRhLCBvcHRpb25zLnBpeGVsVHlwZSB8fCBGbG9hdDMyQXJyYXksXG4gICAgICAgIG9wdGlvbnMuZW5jb2RlZE1hc2tEYXRhLCBub0RhdGFWYWx1ZSwgb3B0aW9ucy5yZXR1cm5NYXNrKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgd2lkdGg6IHBhcnNlZERhdGEud2lkdGgsXG4gICAgICAgIGhlaWdodDogcGFyc2VkRGF0YS5oZWlnaHQsXG4gICAgICAgIHBpeGVsRGF0YTogdW5jb21wcmVzc2VkRGF0YS5yZXN1bHRQaXhlbHMsXG4gICAgICAgIG1pblZhbHVlOiB1bmNvbXByZXNzZWREYXRhLm1pblZhbHVlLFxuICAgICAgICBtYXhWYWx1ZTogcGFyc2VkRGF0YS5waXhlbHMubWF4VmFsdWUsXG4gICAgICAgIG5vRGF0YVZhbHVlOiBub0RhdGFWYWx1ZVxuICAgICAgfTtcblxuICAgICAgaWYgKHVuY29tcHJlc3NlZERhdGEucmVzdWx0TWFzaykge1xuICAgICAgICByZXN1bHQubWFza0RhdGEgPSB1bmNvbXByZXNzZWREYXRhLnJlc3VsdE1hc2s7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnJldHVybkVuY29kZWRNYXNrICYmIHBhcnNlZERhdGEubWFzaykge1xuICAgICAgICByZXN1bHQuZW5jb2RlZE1hc2tEYXRhID0gcGFyc2VkRGF0YS5tYXNrLmJpdHNldCA/IHBhcnNlZERhdGEubWFzay5iaXRzZXQgOiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5yZXR1cm5GaWxlSW5mbykge1xuICAgICAgICByZXN1bHQuZmlsZUluZm8gPSBmb3JtYXRGaWxlSW5mbyhwYXJzZWREYXRhKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuY29tcHV0ZVVzZWRCaXREZXB0aHMpIHtcbiAgICAgICAgICByZXN1bHQuZmlsZUluZm8uYml0RGVwdGhzID0gY29tcHV0ZVVzZWRCaXREZXB0aHMocGFyc2VkRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgdmFyIHVuY29tcHJlc3NQaXhlbFZhbHVlcyA9IGZ1bmN0aW9uKGRhdGEsIFR5cGVkQXJyYXlDbGFzcywgbWFza0JpdHNldCwgbm9EYXRhVmFsdWUsIHN0b3JlRGVjb2RlZE1hc2spIHtcbiAgICAgIHZhciBibG9ja0lkeCA9IDA7XG4gICAgICB2YXIgbnVtWCA9IGRhdGEucGl4ZWxzLm51bUJsb2Nrc1g7XG4gICAgICB2YXIgbnVtWSA9IGRhdGEucGl4ZWxzLm51bUJsb2Nrc1k7XG4gICAgICB2YXIgYmxvY2tXaWR0aCA9IE1hdGguZmxvb3IoZGF0YS53aWR0aCAvIG51bVgpO1xuICAgICAgdmFyIGJsb2NrSGVpZ2h0ID0gTWF0aC5mbG9vcihkYXRhLmhlaWdodCAvIG51bVkpO1xuICAgICAgdmFyIHNjYWxlID0gMiAqIGRhdGEubWF4WkVycm9yO1xuICAgICAgdmFyIG1pblZhbHVlID0gTnVtYmVyLk1BWF9WQUxVRSwgY3VycmVudFZhbHVlO1xuICAgICAgbWFza0JpdHNldCA9IG1hc2tCaXRzZXQgfHwgKChkYXRhLm1hc2spID8gZGF0YS5tYXNrLmJpdHNldCA6IG51bGwpO1xuXG4gICAgICB2YXIgcmVzdWx0UGl4ZWxzLCByZXN1bHRNYXNrO1xuICAgICAgcmVzdWx0UGl4ZWxzID0gbmV3IFR5cGVkQXJyYXlDbGFzcyhkYXRhLndpZHRoICogZGF0YS5oZWlnaHQpO1xuICAgICAgaWYgKHN0b3JlRGVjb2RlZE1hc2sgJiYgbWFza0JpdHNldCkge1xuICAgICAgICByZXN1bHRNYXNrID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS53aWR0aCAqIGRhdGEuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHZhciBibG9ja0RhdGFCdWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KGJsb2NrV2lkdGggKiBibG9ja0hlaWdodCk7XG5cbiAgICAgIHZhciB4eCwgeXk7XG4gICAgICBmb3IgKHZhciB5ID0gMDsgeSA8PSBudW1ZOyB5KyspIHtcbiAgICAgICAgdmFyIHRoaXNCbG9ja0hlaWdodCA9ICh5ICE9PSBudW1ZKSA/IGJsb2NrSGVpZ2h0IDogKGRhdGEuaGVpZ2h0ICUgbnVtWSk7XG4gICAgICAgIGlmICh0aGlzQmxvY2tIZWlnaHQgPT09IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8PSBudW1YOyB4KyspIHtcbiAgICAgICAgICB2YXIgdGhpc0Jsb2NrV2lkdGggPSAoeCAhPT0gbnVtWCkgPyBibG9ja1dpZHRoIDogKGRhdGEud2lkdGggJSBudW1YKTtcbiAgICAgICAgICBpZiAodGhpc0Jsb2NrV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBvdXRQdHIgPSB5ICogZGF0YS53aWR0aCAqIGJsb2NrSGVpZ2h0ICsgeCAqIGJsb2NrV2lkdGg7XG4gICAgICAgICAgdmFyIG91dFN0cmlkZSA9IGRhdGEud2lkdGggLSB0aGlzQmxvY2tXaWR0aDtcblxuICAgICAgICAgIHZhciBibG9jayA9IGRhdGEucGl4ZWxzLmJsb2Nrc1tibG9ja0lkeF07XG5cbiAgICAgICAgICB2YXIgYmxvY2tEYXRhLCBibG9ja1B0ciwgY29uc3RWYWx1ZTtcbiAgICAgICAgICBpZiAoYmxvY2suZW5jb2RpbmcgPCAyKSB7XG4gICAgICAgICAgICAvLyBibG9jayBpcyBlaXRoZXIgdW5jb21wcmVzc2VkIG9yIGJpdC1zdHVmZmVkIChlbmNvZGluZ3MgMCBhbmQgMSlcbiAgICAgICAgICAgIGlmIChibG9jay5lbmNvZGluZyA9PT0gMCkge1xuICAgICAgICAgICAgICAvLyBibG9jayBpcyB1bmNvbXByZXNzZWRcbiAgICAgICAgICAgICAgYmxvY2tEYXRhID0gYmxvY2sucmF3RGF0YTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGJsb2NrIGlzIGJpdC1zdHVmZmVkXG4gICAgICAgICAgICAgIHVuc3R1ZmYoYmxvY2suc3R1ZmZlZERhdGEsIGJsb2NrLmJpdHNQZXJQaXhlbCwgYmxvY2subnVtVmFsaWRQaXhlbHMsIGJsb2NrLm9mZnNldCwgc2NhbGUsIGJsb2NrRGF0YUJ1ZmZlciwgZGF0YS5waXhlbHMubWF4VmFsdWUpO1xuICAgICAgICAgICAgICBibG9ja0RhdGEgPSBibG9ja0RhdGFCdWZmZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBibG9ja1B0ciA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGJsb2NrLmVuY29kaW5nID09PSAyKSB7XG4gICAgICAgICAgICAvLyBibG9jayBpcyBhbGwgMFxuICAgICAgICAgICAgY29uc3RWYWx1ZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gYmxvY2sgaGFzIGNvbnN0YW50IHZhbHVlIChlbmNvZGluZyA9PT0gMylcbiAgICAgICAgICAgIGNvbnN0VmFsdWUgPSBibG9jay5vZmZzZXQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG1hc2tCeXRlO1xuICAgICAgICAgIGlmIChtYXNrQml0c2V0KSB7XG4gICAgICAgICAgICBmb3IgKHl5ID0gMDsgeXkgPCB0aGlzQmxvY2tIZWlnaHQ7IHl5KyspIHtcbiAgICAgICAgICAgICAgaWYgKG91dFB0ciAmIDcpIHtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIG1hc2tCeXRlID0gbWFza0JpdHNldFtvdXRQdHIgPj4gM107XG4gICAgICAgICAgICAgICAgbWFza0J5dGUgPDw9IG91dFB0ciAmIDc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yICh4eCA9IDA7IHh4IDwgdGhpc0Jsb2NrV2lkdGg7IHh4KyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIShvdXRQdHIgJiA3KSkge1xuICAgICAgICAgICAgICAgICAgLy8gcmVhZCBuZXh0IGJ5dGUgZnJvbSBtYXNrXG4gICAgICAgICAgICAgICAgICBtYXNrQnl0ZSA9IG1hc2tCaXRzZXRbb3V0UHRyID4+IDNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWFza0J5dGUgJiAxMjgpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHBpeGVsIGRhdGEgcHJlc2VudFxuICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdE1hc2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0TWFza1tvdXRQdHJdID0gMTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IChibG9jay5lbmNvZGluZyA8IDIpID8gYmxvY2tEYXRhW2Jsb2NrUHRyKytdIDogY29uc3RWYWx1ZTtcbiAgICAgICAgICAgICAgICAgIG1pblZhbHVlID0gbWluVmFsdWUgPiBjdXJyZW50VmFsdWUgPyBjdXJyZW50VmFsdWUgOiBtaW5WYWx1ZTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1tvdXRQdHIrK10gPSBjdXJyZW50VmFsdWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIHBpeGVsIGRhdGEgbm90IHByZXNlbnRcbiAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRNYXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdE1hc2tbb3V0UHRyXSA9IDA7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXN1bHRQaXhlbHNbb3V0UHRyKytdID0gbm9EYXRhVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hc2tCeXRlIDw8PSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG91dFB0ciArPSBvdXRTdHJpZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG1hc2sgbm90IHByZXNlbnQsIHNpbXBseSBjb3B5IGJsb2NrIG92ZXJcbiAgICAgICAgICAgIGlmIChibG9jay5lbmNvZGluZyA8IDIpIHtcbiAgICAgICAgICAgICAgLy8gZHVwbGljYXRpbmcgdGhpcyBjb2RlIGJsb2NrIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG4gICAgICAgICAgICAgIC8vIGJsb2NrRGF0YSBjYXNlOlxuICAgICAgICAgICAgICBmb3IgKHl5ID0gMDsgeXkgPCB0aGlzQmxvY2tIZWlnaHQ7IHl5KyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHh4ID0gMDsgeHggPCB0aGlzQmxvY2tXaWR0aDsgeHgrKykge1xuICAgICAgICAgICAgICAgICAgY3VycmVudFZhbHVlID0gYmxvY2tEYXRhW2Jsb2NrUHRyKytdO1xuICAgICAgICAgICAgICAgICAgbWluVmFsdWUgPSBtaW5WYWx1ZSA+IGN1cnJlbnRWYWx1ZSA/IGN1cnJlbnRWYWx1ZSA6IG1pblZhbHVlO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzW291dFB0cisrXSA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0UHRyICs9IG91dFN0cmlkZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGNvbnN0VmFsdWUgY2FzZTpcbiAgICAgICAgICAgICAgbWluVmFsdWUgPSBtaW5WYWx1ZSA+IGNvbnN0VmFsdWUgPyBjb25zdFZhbHVlIDogbWluVmFsdWU7XG4gICAgICAgICAgICAgIGZvciAoeXkgPSAwOyB5eSA8IHRoaXNCbG9ja0hlaWdodDsgeXkrKykge1xuICAgICAgICAgICAgICAgIGZvciAoeHggPSAwOyB4eCA8IHRoaXNCbG9ja1dpZHRoOyB4eCsrKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHRQaXhlbHNbb3V0UHRyKytdID0gY29uc3RWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0UHRyICs9IG91dFN0cmlkZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKGJsb2NrLmVuY29kaW5nID09PSAxKSAmJiAoYmxvY2tQdHIgIT09IGJsb2NrLm51bVZhbGlkUGl4ZWxzKSkge1xuICAgICAgICAgICAgdGhyb3cgXCJCbG9jayBhbmQgTWFzayBkbyBub3QgbWF0Y2hcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYmxvY2tJZHgrKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHRQaXhlbHM6IHJlc3VsdFBpeGVscyxcbiAgICAgICAgcmVzdWx0TWFzazogcmVzdWx0TWFzayxcbiAgICAgICAgbWluVmFsdWU6IG1pblZhbHVlXG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgZm9ybWF0RmlsZUluZm8gPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBcImZpbGVJZGVudGlmaWVyU3RyaW5nXCI6IGRhdGEuZmlsZUlkZW50aWZpZXJTdHJpbmcsXG4gICAgICAgIFwiZmlsZVZlcnNpb25cIjogZGF0YS5maWxlVmVyc2lvbixcbiAgICAgICAgXCJpbWFnZVR5cGVcIjogZGF0YS5pbWFnZVR5cGUsXG4gICAgICAgIFwiaGVpZ2h0XCI6IGRhdGEuaGVpZ2h0LFxuICAgICAgICBcIndpZHRoXCI6IGRhdGEud2lkdGgsXG4gICAgICAgIFwibWF4WkVycm9yXCI6IGRhdGEubWF4WkVycm9yLFxuICAgICAgICBcImVvZk9mZnNldFwiOiBkYXRhLmVvZk9mZnNldCxcbiAgICAgICAgXCJtYXNrXCI6IGRhdGEubWFzayA/IHtcbiAgICAgICAgICBcIm51bUJsb2Nrc1hcIjogZGF0YS5tYXNrLm51bUJsb2Nrc1gsXG4gICAgICAgICAgXCJudW1CbG9ja3NZXCI6IGRhdGEubWFzay5udW1CbG9ja3NZLFxuICAgICAgICAgIFwibnVtQnl0ZXNcIjogZGF0YS5tYXNrLm51bUJ5dGVzLFxuICAgICAgICAgIFwibWF4VmFsdWVcIjogZGF0YS5tYXNrLm1heFZhbHVlXG4gICAgICAgIH0gOiBudWxsLFxuICAgICAgICBcInBpeGVsc1wiOiB7XG4gICAgICAgICAgXCJudW1CbG9ja3NYXCI6IGRhdGEucGl4ZWxzLm51bUJsb2Nrc1gsXG4gICAgICAgICAgXCJudW1CbG9ja3NZXCI6IGRhdGEucGl4ZWxzLm51bUJsb2Nrc1ksXG4gICAgICAgICAgXCJudW1CeXRlc1wiOiBkYXRhLnBpeGVscy5udW1CeXRlcyxcbiAgICAgICAgICBcIm1heFZhbHVlXCI6IGRhdGEucGl4ZWxzLm1heFZhbHVlLFxuICAgICAgICAgIFwibm9EYXRhVmFsdWVcIjogZGF0YS5ub0RhdGFWYWx1ZVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY29tcHV0ZVVzZWRCaXREZXB0aHMgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgbnVtQmxvY2tzID0gZGF0YS5waXhlbHMubnVtQmxvY2tzWCAqIGRhdGEucGl4ZWxzLm51bUJsb2Nrc1k7XG4gICAgICB2YXIgYml0RGVwdGhzID0ge307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUJsb2NrczsgaSsrKSB7XG4gICAgICAgIHZhciBibG9jayA9IGRhdGEucGl4ZWxzLmJsb2Nrc1tpXTtcbiAgICAgICAgaWYgKGJsb2NrLmVuY29kaW5nID09PSAwKSB7XG4gICAgICAgICAgYml0RGVwdGhzLmZsb2F0MzIgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGJsb2NrLmVuY29kaW5nID09PSAxKSB7XG4gICAgICAgICAgYml0RGVwdGhzW2Jsb2NrLmJpdHNQZXJQaXhlbF0gPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJpdERlcHRoc1swXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGJpdERlcHRocyk7XG4gICAgfTtcblxuICAgIHZhciBwYXJzZSA9IGZ1bmN0aW9uKGlucHV0LCBmcCwgc2tpcE1hc2spIHtcbiAgICAgIHZhciBkYXRhID0ge307XG5cbiAgICAgIC8vIEZpbGUgaGVhZGVyXG4gICAgICB2YXIgZmlsZUlkVmlldyA9IG5ldyBVaW50OEFycmF5KGlucHV0LCBmcCwgMTApO1xuICAgICAgZGF0YS5maWxlSWRlbnRpZmllclN0cmluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgZmlsZUlkVmlldyk7XG4gICAgICBpZiAoZGF0YS5maWxlSWRlbnRpZmllclN0cmluZy50cmltKCkgIT09IFwiQ250WkltYWdlXCIpIHtcbiAgICAgICAgdGhyb3cgXCJVbmV4cGVjdGVkIGZpbGUgaWRlbnRpZmllciBzdHJpbmc6IFwiICsgZGF0YS5maWxlSWRlbnRpZmllclN0cmluZztcbiAgICAgIH1cbiAgICAgIGZwICs9IDEwO1xuICAgICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcoaW5wdXQsIGZwLCAyNCk7XG4gICAgICBkYXRhLmZpbGVWZXJzaW9uID0gdmlldy5nZXRJbnQzMigwLCB0cnVlKTtcbiAgICAgIGRhdGEuaW1hZ2VUeXBlID0gdmlldy5nZXRJbnQzMig0LCB0cnVlKTtcbiAgICAgIGRhdGEuaGVpZ2h0ID0gdmlldy5nZXRVaW50MzIoOCwgdHJ1ZSk7XG4gICAgICBkYXRhLndpZHRoID0gdmlldy5nZXRVaW50MzIoMTIsIHRydWUpO1xuICAgICAgZGF0YS5tYXhaRXJyb3IgPSB2aWV3LmdldEZsb2F0NjQoMTYsIHRydWUpO1xuICAgICAgZnAgKz0gMjQ7XG5cbiAgICAgIC8vIE1hc2sgSGVhZGVyXG4gICAgICBpZiAoIXNraXBNYXNrKSB7XG4gICAgICAgIHZpZXcgPSBuZXcgRGF0YVZpZXcoaW5wdXQsIGZwLCAxNik7XG4gICAgICAgIGRhdGEubWFzayA9IHt9O1xuICAgICAgICBkYXRhLm1hc2subnVtQmxvY2tzWSA9IHZpZXcuZ2V0VWludDMyKDAsIHRydWUpO1xuICAgICAgICBkYXRhLm1hc2subnVtQmxvY2tzWCA9IHZpZXcuZ2V0VWludDMyKDQsIHRydWUpO1xuICAgICAgICBkYXRhLm1hc2subnVtQnl0ZXMgPSB2aWV3LmdldFVpbnQzMig4LCB0cnVlKTtcbiAgICAgICAgZGF0YS5tYXNrLm1heFZhbHVlID0gdmlldy5nZXRGbG9hdDMyKDEyLCB0cnVlKTtcbiAgICAgICAgZnAgKz0gMTY7XG5cbiAgICAgICAgLy8gTWFzayBEYXRhXG4gICAgICAgIGlmIChkYXRhLm1hc2subnVtQnl0ZXMgPiAwKSB7XG4gICAgICAgICAgdmFyIGJpdHNldCA9IG5ldyBVaW50OEFycmF5KE1hdGguY2VpbChkYXRhLndpZHRoICogZGF0YS5oZWlnaHQgLyA4KSk7XG4gICAgICAgICAgdmlldyA9IG5ldyBEYXRhVmlldyhpbnB1dCwgZnAsIGRhdGEubWFzay5udW1CeXRlcyk7XG4gICAgICAgICAgdmFyIGNudCA9IHZpZXcuZ2V0SW50MTYoMCwgdHJ1ZSk7XG4gICAgICAgICAgdmFyIGlwID0gMiwgb3AgPSAwO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChjbnQgPiAwKSB7XG4gICAgICAgICAgICAgIHdoaWxlIChjbnQtLSkgeyBiaXRzZXRbb3ArK10gPSB2aWV3LmdldFVpbnQ4KGlwKyspOyB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgdmFsID0gdmlldy5nZXRVaW50OChpcCsrKTtcbiAgICAgICAgICAgICAgY250ID0gLWNudDtcbiAgICAgICAgICAgICAgd2hpbGUgKGNudC0tKSB7IGJpdHNldFtvcCsrXSA9IHZhbDsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY250ID0gdmlldy5nZXRJbnQxNihpcCwgdHJ1ZSk7XG4gICAgICAgICAgICBpcCArPSAyO1xuICAgICAgICAgIH0gd2hpbGUgKGlwIDwgZGF0YS5tYXNrLm51bUJ5dGVzKTtcbiAgICAgICAgICBpZiAoKGNudCAhPT0gLTMyNzY4KSB8fCAob3AgPCBiaXRzZXQubGVuZ3RoKSkge1xuICAgICAgICAgICAgdGhyb3cgXCJVbmV4cGVjdGVkIGVuZCBvZiBtYXNrIFJMRSBlbmNvZGluZ1wiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhLm1hc2suYml0c2V0ID0gYml0c2V0O1xuICAgICAgICAgIGZwICs9IGRhdGEubWFzay5udW1CeXRlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoZGF0YS5tYXNrLm51bUJ5dGVzIHwgZGF0YS5tYXNrLm51bUJsb2Nrc1kgfCBkYXRhLm1hc2subWF4VmFsdWUpID09PSAwKSB7ICAvLyBTcGVjaWFsIGNhc2UsIGFsbCBub2RhdGFcbiAgICAgICAgICBkYXRhLm1hc2suYml0c2V0ID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKGRhdGEud2lkdGggKiBkYXRhLmhlaWdodCAvIDgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBQaXhlbCBIZWFkZXJcbiAgICAgIHZpZXcgPSBuZXcgRGF0YVZpZXcoaW5wdXQsIGZwLCAxNik7XG4gICAgICBkYXRhLnBpeGVscyA9IHt9O1xuICAgICAgZGF0YS5waXhlbHMubnVtQmxvY2tzWSA9IHZpZXcuZ2V0VWludDMyKDAsIHRydWUpO1xuICAgICAgZGF0YS5waXhlbHMubnVtQmxvY2tzWCA9IHZpZXcuZ2V0VWludDMyKDQsIHRydWUpO1xuICAgICAgZGF0YS5waXhlbHMubnVtQnl0ZXMgPSB2aWV3LmdldFVpbnQzMig4LCB0cnVlKTtcbiAgICAgIGRhdGEucGl4ZWxzLm1heFZhbHVlID0gdmlldy5nZXRGbG9hdDMyKDEyLCB0cnVlKTtcbiAgICAgIGZwICs9IDE2O1xuXG4gICAgICB2YXIgbnVtQmxvY2tzWCA9IGRhdGEucGl4ZWxzLm51bUJsb2Nrc1g7XG4gICAgICB2YXIgbnVtQmxvY2tzWSA9IGRhdGEucGl4ZWxzLm51bUJsb2Nrc1k7XG4gICAgICAvLyB0aGUgbnVtYmVyIG9mIGJsb2NrcyBzcGVjaWZpZWQgaW4gdGhlIGhlYWRlciBkb2VzIG5vdCB0YWtlIGludG8gYWNjb3VudCB0aGUgYmxvY2tzIGF0IHRoZSBlbmQgb2ZcbiAgICAgIC8vIGVhY2ggcm93L2NvbHVtbiB3aXRoIGEgc3BlY2lhbCB3aWR0aC9oZWlnaHQgdGhhdCBtYWtlIHRoZSBpbWFnZSBjb21wbGV0ZSBpbiBjYXNlIHRoZSB3aWR0aCBpcyBub3RcbiAgICAgIC8vIGV2ZW5seSBkaXZpc2libGUgYnkgdGhlIG51bWJlciBvZiBibG9ja3MuXG4gICAgICB2YXIgYWN0dWFsTnVtQmxvY2tzWCA9IG51bUJsb2Nrc1ggKyAoKGRhdGEud2lkdGggJSBudW1CbG9ja3NYKSA+IDAgPyAxIDogMCk7XG4gICAgICB2YXIgYWN0dWFsTnVtQmxvY2tzWSA9IG51bUJsb2Nrc1kgKyAoKGRhdGEuaGVpZ2h0ICUgbnVtQmxvY2tzWSkgPiAwID8gMSA6IDApO1xuICAgICAgZGF0YS5waXhlbHMuYmxvY2tzID0gbmV3IEFycmF5KGFjdHVhbE51bUJsb2Nrc1ggKiBhY3R1YWxOdW1CbG9ja3NZKTtcbiAgICAgIHZhciBibG9ja0kgPSAwO1xuICAgICAgZm9yICh2YXIgYmxvY2tZID0gMDsgYmxvY2tZIDwgYWN0dWFsTnVtQmxvY2tzWTsgYmxvY2tZKyspIHtcbiAgICAgICAgZm9yICh2YXIgYmxvY2tYID0gMDsgYmxvY2tYIDwgYWN0dWFsTnVtQmxvY2tzWDsgYmxvY2tYKyspIHtcblxuICAgICAgICAgIC8vIEJsb2NrXG4gICAgICAgICAgdmFyIHNpemUgPSAwO1xuICAgICAgICAgIHZhciBieXRlc0xlZnQgPSBpbnB1dC5ieXRlTGVuZ3RoIC0gZnA7XG4gICAgICAgICAgdmlldyA9IG5ldyBEYXRhVmlldyhpbnB1dCwgZnAsIE1hdGgubWluKDEwLCBieXRlc0xlZnQpKTtcbiAgICAgICAgICB2YXIgYmxvY2sgPSB7fTtcbiAgICAgICAgICBkYXRhLnBpeGVscy5ibG9ja3NbYmxvY2tJKytdID0gYmxvY2s7XG4gICAgICAgICAgdmFyIGhlYWRlckJ5dGUgPSB2aWV3LmdldFVpbnQ4KDApOyBzaXplKys7XG4gICAgICAgICAgYmxvY2suZW5jb2RpbmcgPSBoZWFkZXJCeXRlICYgNjM7XG4gICAgICAgICAgaWYgKGJsb2NrLmVuY29kaW5nID4gMykge1xuICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIGJsb2NrIGVuY29kaW5nIChcIiArIGJsb2NrLmVuY29kaW5nICsgXCIpXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChibG9jay5lbmNvZGluZyA9PT0gMikge1xuICAgICAgICAgICAgZnArKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKGhlYWRlckJ5dGUgIT09IDApICYmIChoZWFkZXJCeXRlICE9PSAyKSkge1xuICAgICAgICAgICAgaGVhZGVyQnl0ZSA+Pj0gNjtcbiAgICAgICAgICAgIGJsb2NrLm9mZnNldFR5cGUgPSBoZWFkZXJCeXRlO1xuICAgICAgICAgICAgaWYgKGhlYWRlckJ5dGUgPT09IDIpIHtcbiAgICAgICAgICAgICAgYmxvY2sub2Zmc2V0ID0gdmlldy5nZXRJbnQ4KDEpOyBzaXplKys7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhlYWRlckJ5dGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgYmxvY2sub2Zmc2V0ID0gdmlldy5nZXRJbnQxNigxLCB0cnVlKTsgc2l6ZSArPSAyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChoZWFkZXJCeXRlID09PSAwKSB7XG4gICAgICAgICAgICAgIGJsb2NrLm9mZnNldCA9IHZpZXcuZ2V0RmxvYXQzMigxLCB0cnVlKTsgc2l6ZSArPSA0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIGJsb2NrIG9mZnNldCB0eXBlXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChibG9jay5lbmNvZGluZyA9PT0gMSkge1xuICAgICAgICAgICAgICBoZWFkZXJCeXRlID0gdmlldy5nZXRVaW50OChzaXplKTsgc2l6ZSsrO1xuICAgICAgICAgICAgICBibG9jay5iaXRzUGVyUGl4ZWwgPSBoZWFkZXJCeXRlICYgNjM7XG4gICAgICAgICAgICAgIGhlYWRlckJ5dGUgPj49IDY7XG4gICAgICAgICAgICAgIGJsb2NrLm51bVZhbGlkUGl4ZWxzVHlwZSA9IGhlYWRlckJ5dGU7XG4gICAgICAgICAgICAgIGlmIChoZWFkZXJCeXRlID09PSAyKSB7XG4gICAgICAgICAgICAgICAgYmxvY2subnVtVmFsaWRQaXhlbHMgPSB2aWV3LmdldFVpbnQ4KHNpemUpOyBzaXplKys7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGVhZGVyQnl0ZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGJsb2NrLm51bVZhbGlkUGl4ZWxzID0gdmlldy5nZXRVaW50MTYoc2l6ZSwgdHJ1ZSk7IHNpemUgKz0gMjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChoZWFkZXJCeXRlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYmxvY2subnVtVmFsaWRQaXhlbHMgPSB2aWV3LmdldFVpbnQzMihzaXplLCB0cnVlKTsgc2l6ZSArPSA0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IFwiSW52YWxpZCB2YWxpZCBwaXhlbCBjb3VudCB0eXBlXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZnAgKz0gc2l6ZTtcblxuICAgICAgICAgIGlmIChibG9jay5lbmNvZGluZyA9PT0gMykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGFycmF5QnVmLCBzdG9yZTg7XG4gICAgICAgICAgaWYgKGJsb2NrLmVuY29kaW5nID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgbnVtUGl4ZWxzID0gKGRhdGEucGl4ZWxzLm51bUJ5dGVzIC0gMSkgLyA0O1xuICAgICAgICAgICAgaWYgKG51bVBpeGVscyAhPT0gTWF0aC5mbG9vcihudW1QaXhlbHMpKSB7XG4gICAgICAgICAgICAgIHRocm93IFwidW5jb21wcmVzc2VkIGJsb2NrIGhhcyBpbnZhbGlkIGxlbmd0aFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJyYXlCdWYgPSBuZXcgQXJyYXlCdWZmZXIobnVtUGl4ZWxzICogNCk7XG4gICAgICAgICAgICBzdG9yZTggPSBuZXcgVWludDhBcnJheShhcnJheUJ1Zik7XG4gICAgICAgICAgICBzdG9yZTguc2V0KG5ldyBVaW50OEFycmF5KGlucHV0LCBmcCwgbnVtUGl4ZWxzICogNCkpO1xuICAgICAgICAgICAgdmFyIHJhd0RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGFycmF5QnVmKTtcbiAgICAgICAgICAgIGJsb2NrLnJhd0RhdGEgPSByYXdEYXRhO1xuICAgICAgICAgICAgZnAgKz0gbnVtUGl4ZWxzICogNDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGJsb2NrLmVuY29kaW5nID09PSAxKSB7XG4gICAgICAgICAgICB2YXIgZGF0YUJ5dGVzID0gTWF0aC5jZWlsKGJsb2NrLm51bVZhbGlkUGl4ZWxzICogYmxvY2suYml0c1BlclBpeGVsIC8gOCk7XG4gICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gTWF0aC5jZWlsKGRhdGFCeXRlcyAvIDQpO1xuICAgICAgICAgICAgYXJyYXlCdWYgPSBuZXcgQXJyYXlCdWZmZXIoZGF0YVdvcmRzICogNCk7XG4gICAgICAgICAgICBzdG9yZTggPSBuZXcgVWludDhBcnJheShhcnJheUJ1Zik7XG4gICAgICAgICAgICBzdG9yZTguc2V0KG5ldyBVaW50OEFycmF5KGlucHV0LCBmcCwgZGF0YUJ5dGVzKSk7XG4gICAgICAgICAgICBibG9jay5zdHVmZmVkRGF0YSA9IG5ldyBVaW50MzJBcnJheShhcnJheUJ1Zik7XG4gICAgICAgICAgICBmcCArPSBkYXRhQnl0ZXM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkYXRhLmVvZk9mZnNldCA9IGZwO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcblxuICAgIHZhciB1bnN0dWZmID0gZnVuY3Rpb24oc3JjLCBiaXRzUGVyUGl4ZWwsIG51bVBpeGVscywgb2Zmc2V0LCBzY2FsZSwgZGVzdCwgbWF4VmFsdWUpIHtcbiAgICAgIHZhciBiaXRNYXNrID0gKDEgPDwgYml0c1BlclBpeGVsKSAtIDE7XG4gICAgICB2YXIgaSA9IDAsIG87XG4gICAgICB2YXIgYml0c0xlZnQgPSAwO1xuICAgICAgdmFyIG4sIGJ1ZmZlcjtcbiAgICAgIHZhciBubWF4ID0gTWF0aC5jZWlsKChtYXhWYWx1ZSAtIG9mZnNldCkgLyBzY2FsZSk7XG4gICAgICAvLyBnZXQgcmlkIG9mIHRyYWlsaW5nIGJ5dGVzIHRoYXQgYXJlIGFscmVhZHkgcGFydCBvZiBuZXh0IGJsb2NrXG4gICAgICB2YXIgbnVtSW52YWxpZFRhaWxCeXRlcyA9IHNyYy5sZW5ndGggKiA0IC0gTWF0aC5jZWlsKGJpdHNQZXJQaXhlbCAqIG51bVBpeGVscyAvIDgpO1xuICAgICAgc3JjW3NyYy5sZW5ndGggLSAxXSA8PD0gOCAqIG51bUludmFsaWRUYWlsQnl0ZXM7XG5cbiAgICAgIGZvciAobyA9IDA7IG8gPCBudW1QaXhlbHM7IG8rKykge1xuICAgICAgICBpZiAoYml0c0xlZnQgPT09IDApIHtcbiAgICAgICAgICBidWZmZXIgPSBzcmNbaSsrXTtcbiAgICAgICAgICBiaXRzTGVmdCA9IDMyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiaXRzTGVmdCA+PSBiaXRzUGVyUGl4ZWwpIHtcbiAgICAgICAgICBuID0gKGJ1ZmZlciA+Pj4gKGJpdHNMZWZ0IC0gYml0c1BlclBpeGVsKSkgJiBiaXRNYXNrO1xuICAgICAgICAgIGJpdHNMZWZ0IC09IGJpdHNQZXJQaXhlbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbWlzc2luZ0JpdHMgPSAoYml0c1BlclBpeGVsIC0gYml0c0xlZnQpO1xuICAgICAgICAgIG4gPSAoKGJ1ZmZlciAmIGJpdE1hc2spIDw8IG1pc3NpbmdCaXRzKSAmIGJpdE1hc2s7XG4gICAgICAgICAgYnVmZmVyID0gc3JjW2krK107XG4gICAgICAgICAgYml0c0xlZnQgPSAzMiAtIG1pc3NpbmdCaXRzO1xuICAgICAgICAgIG4gKz0gKGJ1ZmZlciA+Pj4gYml0c0xlZnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vcGl4ZWwgdmFsdWVzIG1heSBleGNlZWQgbWF4IGR1ZSB0byBxdWFudGl6YXRpb25cbiAgICAgICAgZGVzdFtvXSA9IG4gPCBubWF4ID8gb2Zmc2V0ICsgbiAqIHNjYWxlIDogbWF4VmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVzdDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENudFpJbWFnZTtcbiAgfSkoKTtcblxuICAvL3ZlcnNpb24gMi4gU3VwcG9ydHMgMi4xLCAyLjIsIDIuM1xuICB2YXIgTGVyYzJEZWNvZGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgLy8gTm90ZTogY3VycmVudGx5LCB0aGlzIG1vZHVsZSBvbmx5IGhhcyBhbiBpbXBsZW1lbnRhdGlvbiBmb3IgZGVjb2RpbmcgTEVSQyBkYXRhLCBub3QgZW5jb2RpbmcuIFRoZSBuYW1lIG9mXG4gICAgLy8gdGhlIGNsYXNzIHdhcyBjaG9zZW4gdG8gYmUgZnV0dXJlIHByb29mLCBmb2xsb3dpbmcgTGVyY0RlY29kZS5cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICogcHJpdmF0ZSBzdGF0aWMgY2xhc3MgYml0c3V0ZmZlciB1c2VkIGJ5IExlcmMyRGVjb2RlXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICB2YXIgQml0U3R1ZmZlciA9IHtcbiAgICAgIC8vbWV0aG9kcyBlbmRpbmcgd2l0aCAyIGFyZSBmb3IgdGhlIG5ldyBieXRlIG9yZGVyIHVzZWQgYnkgTGVyYzIuMyBhbmQgYWJvdmUuXG4gICAgICAvL29yaWdpbmFsVW5zdHVmZiBpcyB1c2VkIHRvIHVucGFjayBIdWZmbWFuIGNvZGUgdGFibGUuIGNvZGUgaXMgZHVwbGljYXRlZCB0byB1bnN0dWZmeCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy5cbiAgICAgIHVuc3R1ZmY6IGZ1bmN0aW9uKHNyYywgZGVzdCwgYml0c1BlclBpeGVsLCBudW1QaXhlbHMsIGx1dEFyciwgb2Zmc2V0LCBzY2FsZSwgbWF4VmFsdWUpIHtcbiAgICAgICAgdmFyIGJpdE1hc2sgPSAoMSA8PCBiaXRzUGVyUGl4ZWwpIC0gMTtcbiAgICAgICAgdmFyIGkgPSAwLCBvO1xuICAgICAgICB2YXIgYml0c0xlZnQgPSAwO1xuICAgICAgICB2YXIgbiwgYnVmZmVyLCBtaXNzaW5nQml0cywgbm1heDtcblxuICAgICAgICAvLyBnZXQgcmlkIG9mIHRyYWlsaW5nIGJ5dGVzIHRoYXQgYXJlIGFscmVhZHkgcGFydCBvZiBuZXh0IGJsb2NrXG4gICAgICAgIHZhciBudW1JbnZhbGlkVGFpbEJ5dGVzID0gc3JjLmxlbmd0aCAqIDQgLSBNYXRoLmNlaWwoYml0c1BlclBpeGVsICogbnVtUGl4ZWxzIC8gOCk7XG4gICAgICAgIHNyY1tzcmMubGVuZ3RoIC0gMV0gPDw9IDggKiBudW1JbnZhbGlkVGFpbEJ5dGVzO1xuICAgICAgICBpZiAobHV0QXJyKSB7XG4gICAgICAgICAgZm9yIChvID0gMDsgbyA8IG51bVBpeGVsczsgbysrKSB7XG4gICAgICAgICAgICBpZiAoYml0c0xlZnQgPT09IDApIHtcbiAgICAgICAgICAgICAgYnVmZmVyID0gc3JjW2krK107XG4gICAgICAgICAgICAgIGJpdHNMZWZ0ID0gMzI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYml0c0xlZnQgPj0gYml0c1BlclBpeGVsKSB7XG4gICAgICAgICAgICAgIG4gPSAoYnVmZmVyID4+PiAoYml0c0xlZnQgLSBiaXRzUGVyUGl4ZWwpKSAmIGJpdE1hc2s7XG4gICAgICAgICAgICAgIGJpdHNMZWZ0IC09IGJpdHNQZXJQaXhlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBtaXNzaW5nQml0cyA9IChiaXRzUGVyUGl4ZWwgLSBiaXRzTGVmdCk7XG4gICAgICAgICAgICAgIG4gPSAoKGJ1ZmZlciAmIGJpdE1hc2spIDw8IG1pc3NpbmdCaXRzKSAmIGJpdE1hc2s7XG4gICAgICAgICAgICAgIGJ1ZmZlciA9IHNyY1tpKytdO1xuICAgICAgICAgICAgICBiaXRzTGVmdCA9IDMyIC0gbWlzc2luZ0JpdHM7XG4gICAgICAgICAgICAgIG4gKz0gKGJ1ZmZlciA+Pj4gYml0c0xlZnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVzdFtvXSA9IGx1dEFycltuXTsvL29mZnNldCArIGx1dEFycltuXSAqIHNjYWxlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBubWF4ID0gTWF0aC5jZWlsKChtYXhWYWx1ZSAtIG9mZnNldCkgLyBzY2FsZSk7XG4gICAgICAgICAgZm9yIChvID0gMDsgbyA8IG51bVBpeGVsczsgbysrKSB7XG4gICAgICAgICAgICBpZiAoYml0c0xlZnQgPT09IDApIHtcbiAgICAgICAgICAgICAgYnVmZmVyID0gc3JjW2krK107XG4gICAgICAgICAgICAgIGJpdHNMZWZ0ID0gMzI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYml0c0xlZnQgPj0gYml0c1BlclBpeGVsKSB7XG4gICAgICAgICAgICAgIG4gPSAoYnVmZmVyID4+PiAoYml0c0xlZnQgLSBiaXRzUGVyUGl4ZWwpKSAmIGJpdE1hc2s7XG4gICAgICAgICAgICAgIGJpdHNMZWZ0IC09IGJpdHNQZXJQaXhlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBtaXNzaW5nQml0cyA9IChiaXRzUGVyUGl4ZWwgLSBiaXRzTGVmdCk7XG4gICAgICAgICAgICAgIG4gPSAoKGJ1ZmZlciAmIGJpdE1hc2spIDw8IG1pc3NpbmdCaXRzKSAmIGJpdE1hc2s7XG4gICAgICAgICAgICAgIGJ1ZmZlciA9IHNyY1tpKytdO1xuICAgICAgICAgICAgICBiaXRzTGVmdCA9IDMyIC0gbWlzc2luZ0JpdHM7XG4gICAgICAgICAgICAgIG4gKz0gKGJ1ZmZlciA+Pj4gYml0c0xlZnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9waXhlbCB2YWx1ZXMgbWF5IGV4Y2VlZCBtYXggZHVlIHRvIHF1YW50aXphdGlvblxuICAgICAgICAgICAgZGVzdFtvXSA9IG4gPCBubWF4ID8gb2Zmc2V0ICsgbiAqIHNjYWxlIDogbWF4VmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB1bnN0dWZmTFVUOiBmdW5jdGlvbihzcmMsIGJpdHNQZXJQaXhlbCwgbnVtUGl4ZWxzLCBvZmZzZXQsIHNjYWxlLCBtYXhWYWx1ZSkge1xuICAgICAgICB2YXIgYml0TWFzayA9ICgxIDw8IGJpdHNQZXJQaXhlbCkgLSAxO1xuICAgICAgICB2YXIgaSA9IDAsIG8gPSAwLCBtaXNzaW5nQml0cyA9IDAsIGJpdHNMZWZ0ID0gMCwgbiA9IDA7XG4gICAgICAgIHZhciBidWZmZXI7XG4gICAgICAgIHZhciBkZXN0ID0gW107XG5cbiAgICAgICAgLy8gZ2V0IHJpZCBvZiB0cmFpbGluZyBieXRlcyB0aGF0IGFyZSBhbHJlYWR5IHBhcnQgb2YgbmV4dCBibG9ja1xuICAgICAgICB2YXIgbnVtSW52YWxpZFRhaWxCeXRlcyA9IHNyYy5sZW5ndGggKiA0IC0gTWF0aC5jZWlsKGJpdHNQZXJQaXhlbCAqIG51bVBpeGVscyAvIDgpO1xuICAgICAgICBzcmNbc3JjLmxlbmd0aCAtIDFdIDw8PSA4ICogbnVtSW52YWxpZFRhaWxCeXRlcztcblxuICAgICAgICB2YXIgbm1heCA9IE1hdGguY2VpbCgobWF4VmFsdWUgLSBvZmZzZXQpIC8gc2NhbGUpO1xuICAgICAgICBmb3IgKG8gPSAwOyBvIDwgbnVtUGl4ZWxzOyBvKyspIHtcbiAgICAgICAgICBpZiAoYml0c0xlZnQgPT09IDApIHtcbiAgICAgICAgICAgIGJ1ZmZlciA9IHNyY1tpKytdO1xuICAgICAgICAgICAgYml0c0xlZnQgPSAzMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJpdHNMZWZ0ID49IGJpdHNQZXJQaXhlbCkge1xuICAgICAgICAgICAgbiA9IChidWZmZXIgPj4+IChiaXRzTGVmdCAtIGJpdHNQZXJQaXhlbCkpICYgYml0TWFzaztcbiAgICAgICAgICAgIGJpdHNMZWZ0IC09IGJpdHNQZXJQaXhlbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWlzc2luZ0JpdHMgPSAoYml0c1BlclBpeGVsIC0gYml0c0xlZnQpO1xuICAgICAgICAgICAgbiA9ICgoYnVmZmVyICYgYml0TWFzaykgPDwgbWlzc2luZ0JpdHMpICYgYml0TWFzaztcbiAgICAgICAgICAgIGJ1ZmZlciA9IHNyY1tpKytdO1xuICAgICAgICAgICAgYml0c0xlZnQgPSAzMiAtIG1pc3NpbmdCaXRzO1xuICAgICAgICAgICAgbiArPSAoYnVmZmVyID4+PiBiaXRzTGVmdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vZGVzdC5wdXNoKG4pO1xuICAgICAgICAgIGRlc3Rbb10gPSBuIDwgbm1heCA/IG9mZnNldCArIG4gKiBzY2FsZSA6IG1heFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGRlc3QudW5zaGlmdChvZmZzZXQpOy8vMXN0IG9uZVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgIH0sXG5cbiAgICAgIHVuc3R1ZmYyOiBmdW5jdGlvbihzcmMsIGRlc3QsIGJpdHNQZXJQaXhlbCwgbnVtUGl4ZWxzLCBsdXRBcnIsIG9mZnNldCwgc2NhbGUsIG1heFZhbHVlKSB7XG4gICAgICAgIHZhciBiaXRNYXNrID0gKDEgPDwgYml0c1BlclBpeGVsKSAtIDE7XG4gICAgICAgIHZhciBpID0gMCwgbztcbiAgICAgICAgdmFyIGJpdHNMZWZ0ID0gMCwgYml0UG9zID0gMDtcbiAgICAgICAgdmFyIG4sIGJ1ZmZlciwgbWlzc2luZ0JpdHM7XG4gICAgICAgIGlmIChsdXRBcnIpIHtcbiAgICAgICAgICBmb3IgKG8gPSAwOyBvIDwgbnVtUGl4ZWxzOyBvKyspIHtcbiAgICAgICAgICAgIGlmIChiaXRzTGVmdCA9PT0gMCkge1xuICAgICAgICAgICAgICBidWZmZXIgPSBzcmNbaSsrXTtcbiAgICAgICAgICAgICAgYml0c0xlZnQgPSAzMjtcbiAgICAgICAgICAgICAgYml0UG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiaXRzTGVmdCA+PSBiaXRzUGVyUGl4ZWwpIHtcbiAgICAgICAgICAgICAgbiA9ICgoYnVmZmVyID4+PiBiaXRQb3MpICYgYml0TWFzayk7XG4gICAgICAgICAgICAgIGJpdHNMZWZ0IC09IGJpdHNQZXJQaXhlbDtcbiAgICAgICAgICAgICAgYml0UG9zICs9IGJpdHNQZXJQaXhlbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1pc3NpbmdCaXRzID0gKGJpdHNQZXJQaXhlbCAtIGJpdHNMZWZ0KTtcbiAgICAgICAgICAgICAgbiA9IChidWZmZXIgPj4+IGJpdFBvcykgJiBiaXRNYXNrO1xuICAgICAgICAgICAgICBidWZmZXIgPSBzcmNbaSsrXTtcbiAgICAgICAgICAgICAgYml0c0xlZnQgPSAzMiAtIG1pc3NpbmdCaXRzO1xuICAgICAgICAgICAgICBuIHw9IChidWZmZXIgJiAoKDEgPDwgbWlzc2luZ0JpdHMpIC0gMSkpIDw8IChiaXRzUGVyUGl4ZWwgLSBtaXNzaW5nQml0cyk7XG4gICAgICAgICAgICAgIGJpdFBvcyA9IG1pc3NpbmdCaXRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVzdFtvXSA9IGx1dEFycltuXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIG5tYXggPSBNYXRoLmNlaWwoKG1heFZhbHVlIC0gb2Zmc2V0KSAvIHNjYWxlKTtcbiAgICAgICAgICBmb3IgKG8gPSAwOyBvIDwgbnVtUGl4ZWxzOyBvKyspIHtcbiAgICAgICAgICAgIGlmIChiaXRzTGVmdCA9PT0gMCkge1xuICAgICAgICAgICAgICBidWZmZXIgPSBzcmNbaSsrXTtcbiAgICAgICAgICAgICAgYml0c0xlZnQgPSAzMjtcbiAgICAgICAgICAgICAgYml0UG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiaXRzTGVmdCA+PSBiaXRzUGVyUGl4ZWwpIHtcbiAgICAgICAgICAgICAgLy9ubyB1bnNpZ25lZCBsZWZ0IHNoaWZ0XG4gICAgICAgICAgICAgIG4gPSAoKGJ1ZmZlciA+Pj4gYml0UG9zKSAmIGJpdE1hc2spO1xuICAgICAgICAgICAgICBiaXRzTGVmdCAtPSBiaXRzUGVyUGl4ZWw7XG4gICAgICAgICAgICAgIGJpdFBvcyArPSBiaXRzUGVyUGl4ZWw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtaXNzaW5nQml0cyA9IChiaXRzUGVyUGl4ZWwgLSBiaXRzTGVmdCk7XG4gICAgICAgICAgICAgIG4gPSAoYnVmZmVyID4+PiBiaXRQb3MpICYgYml0TWFzazsvLygoYnVmZmVyICYgYml0TWFzaykgPDwgbWlzc2luZ0JpdHMpICYgYml0TWFzaztcbiAgICAgICAgICAgICAgYnVmZmVyID0gc3JjW2krK107XG4gICAgICAgICAgICAgIGJpdHNMZWZ0ID0gMzIgLSBtaXNzaW5nQml0cztcbiAgICAgICAgICAgICAgbiB8PSAoYnVmZmVyICYgKCgxIDw8IG1pc3NpbmdCaXRzKSAtIDEpKSA8PCAoYml0c1BlclBpeGVsIC0gbWlzc2luZ0JpdHMpO1xuICAgICAgICAgICAgICBiaXRQb3MgPSBtaXNzaW5nQml0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vcGl4ZWwgdmFsdWVzIG1heSBleGNlZWQgbWF4IGR1ZSB0byBxdWFudGl6YXRpb25cbiAgICAgICAgICAgIGRlc3Rbb10gPSBuIDwgbm1heCA/IG9mZnNldCArIG4gKiBzY2FsZSA6IG1heFZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgIH0sXG5cbiAgICAgIHVuc3R1ZmZMVVQyOiBmdW5jdGlvbihzcmMsIGJpdHNQZXJQaXhlbCwgbnVtUGl4ZWxzLCBvZmZzZXQsIHNjYWxlLCBtYXhWYWx1ZSkge1xuICAgICAgICB2YXIgYml0TWFzayA9ICgxIDw8IGJpdHNQZXJQaXhlbCkgLSAxO1xuICAgICAgICB2YXIgaSA9IDAsIG8gPSAwLCBtaXNzaW5nQml0cyA9IDAsIGJpdHNMZWZ0ID0gMCwgbiA9IDAsIGJpdFBvcyA9IDA7XG4gICAgICAgIHZhciBidWZmZXI7XG4gICAgICAgIHZhciBkZXN0ID0gW107XG4gICAgICAgIHZhciBubWF4ID0gTWF0aC5jZWlsKChtYXhWYWx1ZSAtIG9mZnNldCkgLyBzY2FsZSk7XG4gICAgICAgIGZvciAobyA9IDA7IG8gPCBudW1QaXhlbHM7IG8rKykge1xuICAgICAgICAgIGlmIChiaXRzTGVmdCA9PT0gMCkge1xuICAgICAgICAgICAgYnVmZmVyID0gc3JjW2krK107XG4gICAgICAgICAgICBiaXRzTGVmdCA9IDMyO1xuICAgICAgICAgICAgYml0UG9zID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJpdHNMZWZ0ID49IGJpdHNQZXJQaXhlbCkge1xuICAgICAgICAgICAgLy9ubyB1bnNpZ25lZCBsZWZ0IHNoaWZ0XG4gICAgICAgICAgICBuID0gKChidWZmZXIgPj4+IGJpdFBvcykgJiBiaXRNYXNrKTtcbiAgICAgICAgICAgIGJpdHNMZWZ0IC09IGJpdHNQZXJQaXhlbDtcbiAgICAgICAgICAgIGJpdFBvcyArPSBiaXRzUGVyUGl4ZWw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1pc3NpbmdCaXRzID0gKGJpdHNQZXJQaXhlbCAtIGJpdHNMZWZ0KTtcbiAgICAgICAgICAgIG4gPSAoYnVmZmVyID4+PiBiaXRQb3MpICYgYml0TWFzazsvLygoYnVmZmVyICYgYml0TWFzaykgPDwgbWlzc2luZ0JpdHMpICYgYml0TWFzaztcbiAgICAgICAgICAgIGJ1ZmZlciA9IHNyY1tpKytdO1xuICAgICAgICAgICAgYml0c0xlZnQgPSAzMiAtIG1pc3NpbmdCaXRzO1xuICAgICAgICAgICAgbiB8PSAoYnVmZmVyICYgKCgxIDw8IG1pc3NpbmdCaXRzKSAtIDEpKSA8PCAoYml0c1BlclBpeGVsIC0gbWlzc2luZ0JpdHMpO1xuICAgICAgICAgICAgYml0UG9zID0gbWlzc2luZ0JpdHM7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vZGVzdC5wdXNoKG4pO1xuICAgICAgICAgIGRlc3Rbb10gPSBuIDwgbm1heCA/IG9mZnNldCArIG4gKiBzY2FsZSA6IG1heFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGRlc3QudW5zaGlmdChvZmZzZXQpO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgIH0sXG5cbiAgICAgIG9yaWdpbmFsVW5zdHVmZjogZnVuY3Rpb24oc3JjLCBkZXN0LCBiaXRzUGVyUGl4ZWwsIG51bVBpeGVscykge1xuICAgICAgICB2YXIgYml0TWFzayA9ICgxIDw8IGJpdHNQZXJQaXhlbCkgLSAxO1xuICAgICAgICB2YXIgaSA9IDAsIG87XG4gICAgICAgIHZhciBiaXRzTGVmdCA9IDA7XG4gICAgICAgIHZhciBuLCBidWZmZXIsIG1pc3NpbmdCaXRzO1xuXG4gICAgICAgIC8vIGdldCByaWQgb2YgdHJhaWxpbmcgYnl0ZXMgdGhhdCBhcmUgYWxyZWFkeSBwYXJ0IG9mIG5leHQgYmxvY2tcbiAgICAgICAgdmFyIG51bUludmFsaWRUYWlsQnl0ZXMgPSBzcmMubGVuZ3RoICogNCAtIE1hdGguY2VpbChiaXRzUGVyUGl4ZWwgKiBudW1QaXhlbHMgLyA4KTtcbiAgICAgICAgc3JjW3NyYy5sZW5ndGggLSAxXSA8PD0gOCAqIG51bUludmFsaWRUYWlsQnl0ZXM7XG5cbiAgICAgICAgZm9yIChvID0gMDsgbyA8IG51bVBpeGVsczsgbysrKSB7XG4gICAgICAgICAgaWYgKGJpdHNMZWZ0ID09PSAwKSB7XG4gICAgICAgICAgICBidWZmZXIgPSBzcmNbaSsrXTtcbiAgICAgICAgICAgIGJpdHNMZWZ0ID0gMzI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChiaXRzTGVmdCA+PSBiaXRzUGVyUGl4ZWwpIHtcbiAgICAgICAgICAgIG4gPSAoYnVmZmVyID4+PiAoYml0c0xlZnQgLSBiaXRzUGVyUGl4ZWwpKSAmIGJpdE1hc2s7XG4gICAgICAgICAgICBiaXRzTGVmdCAtPSBiaXRzUGVyUGl4ZWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWlzc2luZ0JpdHMgPSAoYml0c1BlclBpeGVsIC0gYml0c0xlZnQpO1xuICAgICAgICAgICAgbiA9ICgoYnVmZmVyICYgYml0TWFzaykgPDwgbWlzc2luZ0JpdHMpICYgYml0TWFzaztcbiAgICAgICAgICAgIGJ1ZmZlciA9IHNyY1tpKytdO1xuICAgICAgICAgICAgYml0c0xlZnQgPSAzMiAtIG1pc3NpbmdCaXRzO1xuICAgICAgICAgICAgbiArPSAoYnVmZmVyID4+PiBiaXRzTGVmdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlc3Rbb10gPSBuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgfSxcblxuICAgICAgb3JpZ2luYWxVbnN0dWZmMjogZnVuY3Rpb24oc3JjLCBkZXN0LCBiaXRzUGVyUGl4ZWwsIG51bVBpeGVscykge1xuICAgICAgICB2YXIgYml0TWFzayA9ICgxIDw8IGJpdHNQZXJQaXhlbCkgLSAxO1xuICAgICAgICB2YXIgaSA9IDAsIG87XG4gICAgICAgIHZhciBiaXRzTGVmdCA9IDAsIGJpdFBvcyA9IDA7XG4gICAgICAgIHZhciBuLCBidWZmZXIsIG1pc3NpbmdCaXRzO1xuICAgICAgICAvL21pY3JvLW9wdGltaXphdGlvbnNcbiAgICAgICAgZm9yIChvID0gMDsgbyA8IG51bVBpeGVsczsgbysrKSB7XG4gICAgICAgICAgaWYgKGJpdHNMZWZ0ID09PSAwKSB7XG4gICAgICAgICAgICBidWZmZXIgPSBzcmNbaSsrXTtcbiAgICAgICAgICAgIGJpdHNMZWZ0ID0gMzI7XG4gICAgICAgICAgICBiaXRQb3MgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYml0c0xlZnQgPj0gYml0c1BlclBpeGVsKSB7XG4gICAgICAgICAgICAvL25vIHVuc2lnbmVkIGxlZnQgc2hpZnRcbiAgICAgICAgICAgIG4gPSAoKGJ1ZmZlciA+Pj4gYml0UG9zKSAmIGJpdE1hc2spO1xuICAgICAgICAgICAgYml0c0xlZnQgLT0gYml0c1BlclBpeGVsO1xuICAgICAgICAgICAgYml0UG9zICs9IGJpdHNQZXJQaXhlbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWlzc2luZ0JpdHMgPSAoYml0c1BlclBpeGVsIC0gYml0c0xlZnQpO1xuICAgICAgICAgICAgbiA9IChidWZmZXIgPj4+IGJpdFBvcykgJiBiaXRNYXNrOy8vKChidWZmZXIgJiBiaXRNYXNrKSA8PCBtaXNzaW5nQml0cykgJiBiaXRNYXNrO1xuICAgICAgICAgICAgYnVmZmVyID0gc3JjW2krK107XG4gICAgICAgICAgICBiaXRzTGVmdCA9IDMyIC0gbWlzc2luZ0JpdHM7XG4gICAgICAgICAgICBuIHw9IChidWZmZXIgJiAoKDEgPDwgbWlzc2luZ0JpdHMpIC0gMSkpIDw8IChiaXRzUGVyUGl4ZWwgLSBtaXNzaW5nQml0cyk7XG4gICAgICAgICAgICBiaXRQb3MgPSBtaXNzaW5nQml0cztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVzdFtvXSA9IG47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICpwcml2YXRlIHN0YXRpYyBjbGFzcyB1c2VkIGJ5IExlcmMyRGVjb2RlXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgIHZhciBMZXJjMkhlbHBlcnMgPSB7XG4gICAgICBIVUZGTUFOX0xVVF9CSVRTX01BWDogMTIsIC8vdXNlIDJeMTIgbHV0LCB0cmVhdCBpdCBsaWtlIGNvbnN0YW50XG4gICAgICBjb21wdXRlQ2hlY2tzdW1GbGV0Y2hlcjMyOiBmdW5jdGlvbihpbnB1dCkge1xuXG4gICAgICAgIHZhciBzdW0xID0gMHhmZmZmLCBzdW0yID0gMHhmZmZmO1xuICAgICAgICB2YXIgbGVuID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICB2YXIgd29yZHMgPSBNYXRoLmZsb29yKGxlbiAvIDIpO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlICh3b3Jkcykge1xuICAgICAgICAgIHZhciB0bGVuID0gKHdvcmRzID49IDM1OSkgPyAzNTkgOiB3b3JkcztcbiAgICAgICAgICB3b3JkcyAtPSB0bGVuO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIHN1bTEgKz0gKGlucHV0W2krK10gPDwgOCk7XG4gICAgICAgICAgICBzdW0yICs9IHN1bTEgKz0gaW5wdXRbaSsrXTtcbiAgICAgICAgICB9IHdoaWxlICgtLXRsZW4pO1xuXG4gICAgICAgICAgc3VtMSA9IChzdW0xICYgMHhmZmZmKSArIChzdW0xID4+PiAxNik7XG4gICAgICAgICAgc3VtMiA9IChzdW0yICYgMHhmZmZmKSArIChzdW0yID4+PiAxNik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgdGhlIHN0cmFnZ2xlciBieXRlIGlmIGl0IGV4aXN0c1xuICAgICAgICBpZiAobGVuICYgMSkge1xuICAgICAgICAgIHN1bTIgKz0gc3VtMSArPSAoaW5wdXRbaV0gPDwgOCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2Vjb25kIHJlZHVjdGlvbiBzdGVwIHRvIHJlZHVjZSBzdW1zIHRvIDE2IGJpdHNcbiAgICAgICAgc3VtMSA9IChzdW0xICYgMHhmZmZmKSArIChzdW0xID4+PiAxNik7XG4gICAgICAgIHN1bTIgPSAoc3VtMiAmIDB4ZmZmZikgKyAoc3VtMiA+Pj4gMTYpO1xuXG4gICAgICAgIHJldHVybiAoc3VtMiA8PCAxNiB8IHN1bTEpID4+PiAwO1xuICAgICAgfSxcblxuICAgICAgcmVhZEhlYWRlckluZm86IGZ1bmN0aW9uKGlucHV0LCBkYXRhKSB7XG4gICAgICAgIHZhciBwdHIgPSBkYXRhLnB0cjtcbiAgICAgICAgdmFyIGZpbGVJZFZpZXcgPSBuZXcgVWludDhBcnJheShpbnB1dCwgcHRyLCA2KTtcbiAgICAgICAgdmFyIGhlYWRlckluZm8gPSB7fTtcbiAgICAgICAgaGVhZGVySW5mby5maWxlSWRlbnRpZmllclN0cmluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgZmlsZUlkVmlldyk7XG4gICAgICAgIGlmIChoZWFkZXJJbmZvLmZpbGVJZGVudGlmaWVyU3RyaW5nLmxhc3RJbmRleE9mKFwiTGVyYzJcIiwgMCkgIT09IDApIHtcbiAgICAgICAgICB0aHJvdyBcIlVuZXhwZWN0ZWQgZmlsZSBpZGVudGlmaWVyIHN0cmluZyAoZXhwZWN0IExlcmMyICk6IFwiICsgaGVhZGVySW5mby5maWxlSWRlbnRpZmllclN0cmluZztcbiAgICAgICAgfVxuICAgICAgICBwdHIgKz0gNjtcbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcoaW5wdXQsIHB0ciwgOCk7XG4gICAgICAgIHZhciBmaWxlVmVyc2lvbiA9IHZpZXcuZ2V0SW50MzIoMCwgdHJ1ZSk7XG4gICAgICAgIGhlYWRlckluZm8uZmlsZVZlcnNpb24gPSBmaWxlVmVyc2lvbjtcbiAgICAgICAgcHRyICs9IDQ7XG4gICAgICAgIGlmIChmaWxlVmVyc2lvbiA+PSAzKSB7XG4gICAgICAgICAgaGVhZGVySW5mby5jaGVja3N1bSA9IHZpZXcuZ2V0VWludDMyKDQsIHRydWUpOyAvL25yb3dzXG4gICAgICAgICAgcHRyICs9IDQ7XG4gICAgICAgIH1cblxuICAgICAgICAvL2tleXMgc3RhcnQgZnJvbSBoZXJlXG4gICAgICAgIHZpZXcgPSBuZXcgRGF0YVZpZXcoaW5wdXQsIHB0ciwgMTIpO1xuICAgICAgICBoZWFkZXJJbmZvLmhlaWdodCA9IHZpZXcuZ2V0VWludDMyKDAsIHRydWUpOyAvL25yb3dzXG4gICAgICAgIGhlYWRlckluZm8ud2lkdGggPSB2aWV3LmdldFVpbnQzMig0LCB0cnVlKTsgLy9uY29sc1xuICAgICAgICBwdHIgKz0gODtcbiAgICAgICAgaWYgKGZpbGVWZXJzaW9uID49IDQpIHtcbiAgICAgICAgICBoZWFkZXJJbmZvLm51bURpbXMgPSB2aWV3LmdldFVpbnQzMig4LCB0cnVlKTtcbiAgICAgICAgICBwdHIgKz0gNDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBoZWFkZXJJbmZvLm51bURpbXMgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmlldyA9IG5ldyBEYXRhVmlldyhpbnB1dCwgcHRyLCA0MCk7XG4gICAgICAgIGhlYWRlckluZm8ubnVtVmFsaWRQaXhlbCA9IHZpZXcuZ2V0VWludDMyKDAsIHRydWUpO1xuICAgICAgICBoZWFkZXJJbmZvLm1pY3JvQmxvY2tTaXplID0gdmlldy5nZXRJbnQzMig0LCB0cnVlKTtcbiAgICAgICAgaGVhZGVySW5mby5ibG9iU2l6ZSA9IHZpZXcuZ2V0SW50MzIoOCwgdHJ1ZSk7XG4gICAgICAgIGhlYWRlckluZm8uaW1hZ2VUeXBlID0gdmlldy5nZXRJbnQzMigxMiwgdHJ1ZSk7XG5cbiAgICAgICAgaGVhZGVySW5mby5tYXhaRXJyb3IgPSB2aWV3LmdldEZsb2F0NjQoMTYsIHRydWUpO1xuICAgICAgICBoZWFkZXJJbmZvLnpNaW4gPSB2aWV3LmdldEZsb2F0NjQoMjQsIHRydWUpO1xuICAgICAgICBoZWFkZXJJbmZvLnpNYXggPSB2aWV3LmdldEZsb2F0NjQoMzIsIHRydWUpO1xuICAgICAgICBwdHIgKz0gNDA7XG4gICAgICAgIGRhdGEuaGVhZGVySW5mbyA9IGhlYWRlckluZm87XG4gICAgICAgIGRhdGEucHRyID0gcHRyO1xuXG4gICAgICAgIHZhciBjaGVja3N1bSwga2V5TGVuZ3RoO1xuICAgICAgICBpZiAoZmlsZVZlcnNpb24gPj0gMykge1xuICAgICAgICAgIGtleUxlbmd0aCA9IGZpbGVWZXJzaW9uID49IDQgPyA1MiA6IDQ4O1xuICAgICAgICAgIGNoZWNrc3VtID0gdGhpcy5jb21wdXRlQ2hlY2tzdW1GbGV0Y2hlcjMyKG5ldyBVaW50OEFycmF5KGlucHV0LCBwdHIgLSBrZXlMZW5ndGgsIGhlYWRlckluZm8uYmxvYlNpemUgLSAxNCkpO1xuICAgICAgICAgIGlmIChjaGVja3N1bSAhPT0gaGVhZGVySW5mby5jaGVja3N1bSkge1xuICAgICAgICAgICAgdGhyb3cgXCJDaGVja3N1bSBmYWlsZWQuXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcblxuICAgICAgY2hlY2tNaW5NYXhSYW5nZXM6IGZ1bmN0aW9uKGlucHV0LCBkYXRhKSB7XG4gICAgICAgIHZhciBoZWFkZXJJbmZvID0gZGF0YS5oZWFkZXJJbmZvO1xuICAgICAgICB2YXIgT3V0UGl4ZWxUeXBlQXJyYXkgPSB0aGlzLmdldERhdGFUeXBlQXJyYXkoaGVhZGVySW5mby5pbWFnZVR5cGUpO1xuICAgICAgICB2YXIgcmFuZ2VCeXRlcyA9IGhlYWRlckluZm8ubnVtRGltcyAqIHRoaXMuZ2V0RGF0YVR5cGVTaXplKGhlYWRlckluZm8uaW1hZ2VUeXBlKTtcbiAgICAgICAgdmFyIG1pblZhbHVlcyA9IHRoaXMucmVhZFN1YkFycmF5KGlucHV0LCBkYXRhLnB0ciwgT3V0UGl4ZWxUeXBlQXJyYXksIHJhbmdlQnl0ZXMpO1xuICAgICAgICB2YXIgbWF4VmFsdWVzID0gdGhpcy5yZWFkU3ViQXJyYXkoaW5wdXQsIGRhdGEucHRyICsgcmFuZ2VCeXRlcywgT3V0UGl4ZWxUeXBlQXJyYXksIHJhbmdlQnl0ZXMpO1xuICAgICAgICBkYXRhLnB0ciArPSAoMiAqIHJhbmdlQnl0ZXMpO1xuICAgICAgICB2YXIgaSwgZXF1YWwgPSB0cnVlO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaGVhZGVySW5mby5udW1EaW1zOyBpKyspIHtcbiAgICAgICAgICBpZiAobWluVmFsdWVzW2ldICE9PSBtYXhWYWx1ZXNbaV0pIHtcbiAgICAgICAgICAgIGVxdWFsID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaGVhZGVySW5mby5taW5WYWx1ZXMgPSBtaW5WYWx1ZXM7XG4gICAgICAgIGhlYWRlckluZm8ubWF4VmFsdWVzID0gbWF4VmFsdWVzO1xuICAgICAgICByZXR1cm4gZXF1YWw7XG4gICAgICB9LFxuXG4gICAgICByZWFkU3ViQXJyYXk6IGZ1bmN0aW9uKGlucHV0LCBwdHIsIE91dFBpeGVsVHlwZUFycmF5LCBudW1CeXRlcykge1xuICAgICAgICB2YXIgcmF3RGF0YTtcbiAgICAgICAgaWYgKE91dFBpeGVsVHlwZUFycmF5ID09PSBVaW50OEFycmF5KSB7XG4gICAgICAgICAgcmF3RGF0YSA9IG5ldyBVaW50OEFycmF5KGlucHV0LCBwdHIsIG51bUJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgYXJyYXlCdWYgPSBuZXcgQXJyYXlCdWZmZXIobnVtQnl0ZXMpO1xuICAgICAgICAgIHZhciBzdG9yZTggPSBuZXcgVWludDhBcnJheShhcnJheUJ1Zik7XG4gICAgICAgICAgc3RvcmU4LnNldChuZXcgVWludDhBcnJheShpbnB1dCwgcHRyLCBudW1CeXRlcykpO1xuICAgICAgICAgIHJhd0RhdGEgPSBuZXcgT3V0UGl4ZWxUeXBlQXJyYXkoYXJyYXlCdWYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYXdEYXRhO1xuICAgICAgfSxcblxuICAgICAgcmVhZE1hc2s6IGZ1bmN0aW9uKGlucHV0LCBkYXRhKSB7XG4gICAgICAgIHZhciBwdHIgPSBkYXRhLnB0cjtcbiAgICAgICAgdmFyIGhlYWRlckluZm8gPSBkYXRhLmhlYWRlckluZm87XG4gICAgICAgIHZhciBudW1QaXhlbHMgPSBoZWFkZXJJbmZvLndpZHRoICogaGVhZGVySW5mby5oZWlnaHQ7XG4gICAgICAgIHZhciBudW1WYWxpZFBpeGVsID0gaGVhZGVySW5mby5udW1WYWxpZFBpeGVsO1xuXG4gICAgICAgIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KGlucHV0LCBwdHIsIDQpO1xuICAgICAgICB2YXIgbWFzayA9IHt9O1xuICAgICAgICBtYXNrLm51bUJ5dGVzID0gdmlldy5nZXRVaW50MzIoMCwgdHJ1ZSk7XG4gICAgICAgIHB0ciArPSA0O1xuXG4gICAgICAgIC8vIE1hc2sgRGF0YVxuICAgICAgICBpZiAoKDAgPT09IG51bVZhbGlkUGl4ZWwgfHwgbnVtUGl4ZWxzID09PSBudW1WYWxpZFBpeGVsKSAmJiAwICE9PSBtYXNrLm51bUJ5dGVzKSB7XG4gICAgICAgICAgdGhyb3cgKFwiaW52YWxpZCBtYXNrXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiaXRzZXQsIHJlc3VsdE1hc2s7XG4gICAgICAgIGlmIChudW1WYWxpZFBpeGVsID09PSAwKSB7XG4gICAgICAgICAgYml0c2V0ID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKG51bVBpeGVscyAvIDgpKTtcbiAgICAgICAgICBtYXNrLmJpdHNldCA9IGJpdHNldDtcbiAgICAgICAgICByZXN1bHRNYXNrID0gbmV3IFVpbnQ4QXJyYXkobnVtUGl4ZWxzKTtcbiAgICAgICAgICBkYXRhLnBpeGVscy5yZXN1bHRNYXNrID0gcmVzdWx0TWFzaztcbiAgICAgICAgICBwdHIgKz0gbWFzay5udW1CeXRlcztcbiAgICAgICAgfS8vID8/Pz8/IGVsc2UgaWYgKGRhdGEubWFzay5udW1CeXRlcyA+IDAgJiYgZGF0YS5tYXNrLm51bUJ5dGVzPCBkYXRhLm51bVZhbGlkUGl4ZWwpIHtcbiAgICAgICAgZWxzZSBpZiAobWFzay5udW1CeXRlcyA+IDApIHtcbiAgICAgICAgICBiaXRzZXQgPSBuZXcgVWludDhBcnJheShNYXRoLmNlaWwobnVtUGl4ZWxzIC8gOCkpO1xuICAgICAgICAgIHZpZXcgPSBuZXcgRGF0YVZpZXcoaW5wdXQsIHB0ciwgbWFzay5udW1CeXRlcyk7XG4gICAgICAgICAgdmFyIGNudCA9IHZpZXcuZ2V0SW50MTYoMCwgdHJ1ZSk7XG4gICAgICAgICAgdmFyIGlwID0gMiwgb3AgPSAwLCB2YWwgPSAwO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChjbnQgPiAwKSB7XG4gICAgICAgICAgICAgIHdoaWxlIChjbnQtLSkgeyBiaXRzZXRbb3ArK10gPSB2aWV3LmdldFVpbnQ4KGlwKyspOyB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YWwgPSB2aWV3LmdldFVpbnQ4KGlwKyspO1xuICAgICAgICAgICAgICBjbnQgPSAtY250O1xuICAgICAgICAgICAgICB3aGlsZSAoY250LS0pIHsgYml0c2V0W29wKytdID0gdmFsOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbnQgPSB2aWV3LmdldEludDE2KGlwLCB0cnVlKTtcbiAgICAgICAgICAgIGlwICs9IDI7XG4gICAgICAgICAgfSB3aGlsZSAoaXAgPCBtYXNrLm51bUJ5dGVzKTtcbiAgICAgICAgICBpZiAoKGNudCAhPT0gLTMyNzY4KSB8fCAob3AgPCBiaXRzZXQubGVuZ3RoKSkge1xuICAgICAgICAgICAgdGhyb3cgXCJVbmV4cGVjdGVkIGVuZCBvZiBtYXNrIFJMRSBlbmNvZGluZ1wiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc3VsdE1hc2sgPSBuZXcgVWludDhBcnJheShudW1QaXhlbHMpO1xuICAgICAgICAgIHZhciBtYiA9IDAsIGsgPSAwO1xuXG4gICAgICAgICAgZm9yIChrID0gMDsgayA8IG51bVBpeGVsczsgaysrKSB7XG4gICAgICAgICAgICBpZiAoayAmIDcpIHtcbiAgICAgICAgICAgICAgbWIgPSBiaXRzZXRbayA+PiAzXTtcbiAgICAgICAgICAgICAgbWIgPDw9IGsgJiA3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIG1iID0gYml0c2V0W2sgPj4gM107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWIgJiAxMjgpIHtcbiAgICAgICAgICAgICAgcmVzdWx0TWFza1trXSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGEucGl4ZWxzLnJlc3VsdE1hc2sgPSByZXN1bHRNYXNrO1xuXG4gICAgICAgICAgbWFzay5iaXRzZXQgPSBiaXRzZXQ7XG4gICAgICAgICAgcHRyICs9IG1hc2subnVtQnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YS5wdHIgPSBwdHI7XG4gICAgICAgIGRhdGEubWFzayA9IG1hc2s7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcblxuICAgICAgcmVhZERhdGFPbmVTd2VlcDogZnVuY3Rpb24oaW5wdXQsIGRhdGEsIE91dFBpeGVsVHlwZUFycmF5LCB1c2VCU1FGb3JPdXRwdXREaW0pIHtcbiAgICAgICAgdmFyIHB0ciA9IGRhdGEucHRyO1xuICAgICAgICB2YXIgaGVhZGVySW5mbyA9IGRhdGEuaGVhZGVySW5mbztcbiAgICAgICAgdmFyIG51bURpbXMgPSBoZWFkZXJJbmZvLm51bURpbXM7XG4gICAgICAgIHZhciBudW1QaXhlbHMgPSBoZWFkZXJJbmZvLndpZHRoICogaGVhZGVySW5mby5oZWlnaHQ7XG4gICAgICAgIHZhciBpbWFnZVR5cGUgPSBoZWFkZXJJbmZvLmltYWdlVHlwZTtcbiAgICAgICAgdmFyIG51bUJ5dGVzID0gaGVhZGVySW5mby5udW1WYWxpZFBpeGVsICogTGVyYzJIZWxwZXJzLmdldERhdGFUeXBlU2l6ZShpbWFnZVR5cGUpICogbnVtRGltcztcbiAgICAgICAgLy9kYXRhLnBpeGVscy5udW1CeXRlcyA9IG51bUJ5dGVzO1xuICAgICAgICB2YXIgcmF3RGF0YTtcbiAgICAgICAgdmFyIG1hc2sgPSBkYXRhLnBpeGVscy5yZXN1bHRNYXNrO1xuICAgICAgICBpZiAoT3V0UGl4ZWxUeXBlQXJyYXkgPT09IFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICByYXdEYXRhID0gbmV3IFVpbnQ4QXJyYXkoaW5wdXQsIHB0ciwgbnVtQnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBhcnJheUJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcihudW1CeXRlcyk7XG4gICAgICAgICAgdmFyIHN0b3JlOCA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmKTtcbiAgICAgICAgICBzdG9yZTguc2V0KG5ldyBVaW50OEFycmF5KGlucHV0LCBwdHIsIG51bUJ5dGVzKSk7XG4gICAgICAgICAgcmF3RGF0YSA9IG5ldyBPdXRQaXhlbFR5cGVBcnJheShhcnJheUJ1Zik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJhd0RhdGEubGVuZ3RoID09PSBudW1QaXhlbHMgKiBudW1EaW1zKSB7XG4gICAgICAgICAgaWYgKHVzZUJTUUZvck91dHB1dERpbSkge1xuICAgICAgICAgICAgZGF0YS5waXhlbHMucmVzdWx0UGl4ZWxzID0gTGVyYzJIZWxwZXJzLnN3YXBEaW1lbnNpb25PcmRlcihyYXdEYXRhLCBudW1QaXhlbHMsIG51bURpbXMsIE91dFBpeGVsVHlwZUFycmF5LCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhLnBpeGVscy5yZXN1bHRQaXhlbHMgPSByYXdEYXRhO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlICAvL21hc2tcbiAgICAgICAge1xuICAgICAgICAgIGRhdGEucGl4ZWxzLnJlc3VsdFBpeGVscyA9IG5ldyBPdXRQaXhlbFR5cGVBcnJheShudW1QaXhlbHMgKiBudW1EaW1zKTtcbiAgICAgICAgICB2YXIgeiA9IDAsIGsgPSAwLCBpID0gMCwgblN0YXJ0ID0gMDtcbiAgICAgICAgICBpZiAobnVtRGltcyA+IDEpIHtcbiAgICAgICAgICAgIGlmICh1c2VCU1FGb3JPdXRwdXREaW0pIHtcbiAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IG51bVBpeGVsczsgaysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hc2tba10pIHtcbiAgICAgICAgICAgICAgICAgIG5TdGFydCA9IGs7XG4gICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtRGltczsgaSsrLCBuU3RhcnQrPW51bVBpeGVscykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnBpeGVscy5yZXN1bHRQaXhlbHNbblN0YXJ0XSA9IHJhd0RhdGFbeisrXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbnVtUGl4ZWxzOyBrKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobWFza1trXSkge1xuICAgICAgICAgICAgICAgICAgblN0YXJ0ID0gayAqIG51bURpbXM7XG4gICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtRGltczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEucGl4ZWxzLnJlc3VsdFBpeGVsc1tuU3RhcnQgKyBpXSA9IHJhd0RhdGFbeisrXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbnVtUGl4ZWxzOyBrKyspIHtcbiAgICAgICAgICAgICAgaWYgKG1hc2tba10pIHtcbiAgICAgICAgICAgICAgICBkYXRhLnBpeGVscy5yZXN1bHRQaXhlbHNba10gPSByYXdEYXRhW3orK107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHRyICs9IG51bUJ5dGVzO1xuICAgICAgICBkYXRhLnB0ciA9IHB0cjsgICAgICAgLy9yZXR1cm4gZGF0YTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9LFxuXG4gICAgICByZWFkSHVmZm1hblRyZWU6IGZ1bmN0aW9uKGlucHV0LCBkYXRhKSB7XG4gICAgICAgIHZhciBCSVRTX01BWCA9IHRoaXMuSFVGRk1BTl9MVVRfQklUU19NQVg7IC8vOCBpcyBzbG93IGZvciB0aGUgbGFyZ2UgdGVzdCBpbWFnZVxuICAgICAgICAvL3ZhciBzaXplX21heCA9IDEgPDwgQklUU19NQVg7XG4gICAgICAgIC8qICoqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAqIHJlYWRpbmcgY29kZSB0YWJsZVxuICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhpbnB1dCwgZGF0YS5wdHIsIDE2KTtcbiAgICAgICAgZGF0YS5wdHIgKz0gMTY7XG4gICAgICAgIHZhciB2ZXJzaW9uID0gdmlldy5nZXRJbnQzMigwLCB0cnVlKTtcbiAgICAgICAgaWYgKHZlcnNpb24gPCAyKSB7XG4gICAgICAgICAgdGhyb3cgXCJ1bnN1cHBvcnRlZCBIdWZmbWFuIHZlcnNpb25cIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2l6ZSA9IHZpZXcuZ2V0SW50MzIoNCwgdHJ1ZSk7XG4gICAgICAgIHZhciBpMCA9IHZpZXcuZ2V0SW50MzIoOCwgdHJ1ZSk7XG4gICAgICAgIHZhciBpMSA9IHZpZXcuZ2V0SW50MzIoMTIsIHRydWUpO1xuICAgICAgICBpZiAoaTAgPj0gaTEpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJsb2NrRGF0YUJ1ZmZlciA9IG5ldyBVaW50MzJBcnJheShpMSAtIGkwKTtcbiAgICAgICAgTGVyYzJIZWxwZXJzLmRlY29kZUJpdHMoaW5wdXQsIGRhdGEsIGJsb2NrRGF0YUJ1ZmZlcik7XG4gICAgICAgIHZhciBjb2RlVGFibGUgPSBbXTsgLy9zaXplXG4gICAgICAgIHZhciBpLCBqLCBrLCBsZW47XG5cbiAgICAgICAgZm9yIChpID0gaTA7IGkgPCBpMTsgaSsrKSB7XG4gICAgICAgICAgaiA9IGkgLSAoaSA8IHNpemUgPyAwIDogc2l6ZSk7Ly93cmFwIGFyb3VuZFxuICAgICAgICAgIGNvZGVUYWJsZVtqXSA9IHsgZmlyc3Q6IGJsb2NrRGF0YUJ1ZmZlcltpIC0gaTBdLCBzZWNvbmQ6IG51bGwgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXRhQnl0ZXMgPSBpbnB1dC5ieXRlTGVuZ3RoIC0gZGF0YS5wdHI7XG4gICAgICAgIHZhciBkYXRhV29yZHMgPSBNYXRoLmNlaWwoZGF0YUJ5dGVzIC8gNCk7XG4gICAgICAgIHZhciBhcnJheUJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcihkYXRhV29yZHMgKiA0KTtcbiAgICAgICAgdmFyIHN0b3JlOCA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmKTtcbiAgICAgICAgc3RvcmU4LnNldChuZXcgVWludDhBcnJheShpbnB1dCwgZGF0YS5wdHIsIGRhdGFCeXRlcykpO1xuICAgICAgICB2YXIgc3R1ZmZlZERhdGEgPSBuZXcgVWludDMyQXJyYXkoYXJyYXlCdWYpOyAvL211c3Qgc3RhcnQgZnJvbSB4KjRcbiAgICAgICAgdmFyIGJpdFBvcyA9IDAsIHdvcmQsIHNyY1B0ciA9IDA7XG4gICAgICAgIHdvcmQgPSBzdHVmZmVkRGF0YVswXTtcbiAgICAgICAgZm9yIChpID0gaTA7IGkgPCBpMTsgaSsrKSB7XG4gICAgICAgICAgaiA9IGkgLSAoaSA8IHNpemUgPyAwIDogc2l6ZSk7Ly93cmFwIGFyb3VuZFxuICAgICAgICAgIGxlbiA9IGNvZGVUYWJsZVtqXS5maXJzdDtcbiAgICAgICAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAgICAgY29kZVRhYmxlW2pdLnNlY29uZCA9ICh3b3JkIDw8IGJpdFBvcykgPj4+ICgzMiAtIGxlbik7XG5cbiAgICAgICAgICAgIGlmICgzMiAtIGJpdFBvcyA+PSBsZW4pIHtcbiAgICAgICAgICAgICAgYml0UG9zICs9IGxlbjtcbiAgICAgICAgICAgICAgaWYgKGJpdFBvcyA9PT0gMzIpIHtcbiAgICAgICAgICAgICAgICBiaXRQb3MgPSAwO1xuICAgICAgICAgICAgICAgIHNyY1B0cisrO1xuICAgICAgICAgICAgICAgIHdvcmQgPSBzdHVmZmVkRGF0YVtzcmNQdHJdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgYml0UG9zICs9IGxlbiAtIDMyO1xuICAgICAgICAgICAgICBzcmNQdHIrKztcbiAgICAgICAgICAgICAgd29yZCA9IHN0dWZmZWREYXRhW3NyY1B0cl07XG4gICAgICAgICAgICAgIGNvZGVUYWJsZVtqXS5zZWNvbmQgfD0gd29yZCA+Pj4gKDMyIC0gYml0UG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL2ZpbmlzaGVkIHJlYWRpbmcgY29kZSB0YWJsZVxuXG4gICAgICAgIC8qICoqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAqIGJ1aWxkaW5nIGx1dFxuICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICB2YXIgbnVtQml0c0xVVCA9IDAsIG51bUJpdHNMVVRRaWNrID0gMDtcbiAgICAgICAgdmFyIHRyZWUgPSBuZXcgVHJlZU5vZGUoKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvZGVUYWJsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChjb2RlVGFibGVbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbnVtQml0c0xVVCA9IE1hdGgubWF4KG51bUJpdHNMVVQsIGNvZGVUYWJsZVtpXS5maXJzdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChudW1CaXRzTFVUID49IEJJVFNfTUFYKSB7XG4gICAgICAgICAgbnVtQml0c0xVVFFpY2sgPSBCSVRTX01BWDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBudW1CaXRzTFVUUWljayA9IG51bUJpdHNMVVQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZm9yIGRlYnVnZ2luZyBwdXJwb3NlXG4gICAgICAgIC8vIGlmIChudW1CaXRzTFVUID49IDMwKSB7XG4gICAgICAgIC8vICAgY29uc29sZS5sb2coXCJXQVJuaW5nLCBsYXJnZSBOVU0gTFVUIEJJVFMgSVMgXCIgKyBudW1CaXRzTFVUKTtcbiAgICAgICAgLy8gfVxuICAgICAgICB2YXIgZGVjb2RlTHV0ID0gW10sIGVudHJ5LCBjb2RlLCBudW1FbnRyaWVzLCBqaiwgY3VycmVudEJpdCwgbm9kZTtcbiAgICAgICAgZm9yIChpID0gaTA7IGkgPCBpMTsgaSsrKSB7XG4gICAgICAgICAgaiA9IGkgLSAoaSA8IHNpemUgPyAwIDogc2l6ZSk7Ly93cmFwIGFyb3VuZFxuICAgICAgICAgIGxlbiA9IGNvZGVUYWJsZVtqXS5maXJzdDtcbiAgICAgICAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAgICAgZW50cnkgPSBbbGVuLCBqXTtcbiAgICAgICAgICAgIGlmIChsZW4gPD0gbnVtQml0c0xVVFFpY2spIHtcbiAgICAgICAgICAgICAgY29kZSA9IGNvZGVUYWJsZVtqXS5zZWNvbmQgPDwgKG51bUJpdHNMVVRRaWNrIC0gbGVuKTtcbiAgICAgICAgICAgICAgbnVtRW50cmllcyA9IDEgPDwgKG51bUJpdHNMVVRRaWNrIC0gbGVuKTtcbiAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IG51bUVudHJpZXM7IGsrKykge1xuICAgICAgICAgICAgICAgIGRlY29kZUx1dFtjb2RlIHwga10gPSBlbnRyeTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vYnVpbGQgdHJlZVxuICAgICAgICAgICAgICBjb2RlID0gY29kZVRhYmxlW2pdLnNlY29uZDtcbiAgICAgICAgICAgICAgbm9kZSA9IHRyZWU7XG4gICAgICAgICAgICAgIGZvciAoamogPSBsZW4gLSAxOyBqaiA+PSAwOyBqai0tKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJpdCA9IGNvZGUgPj4+IGpqICYgMTsgLy9ubyBsZWZ0IHNoaWZ0IGFzIGxlbmd0aCBjb3VsZCBiZSAzMCwzMVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Qml0KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIW5vZGUucmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5yaWdodCA9IG5ldyBUcmVlTm9kZSgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLmxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5sZWZ0ID0gbmV3IFRyZWVOb2RlKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoamogPT09IDAgJiYgIW5vZGUudmFsKSB7XG4gICAgICAgICAgICAgICAgICBub2RlLnZhbCA9IGVudHJ5WzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRlY29kZUx1dDogZGVjb2RlTHV0LFxuICAgICAgICAgIG51bUJpdHNMVVRRaWNrOiBudW1CaXRzTFVUUWljayxcbiAgICAgICAgICBudW1CaXRzTFVUOiBudW1CaXRzTFVULFxuICAgICAgICAgIHRyZWU6IHRyZWUsXG4gICAgICAgICAgc3R1ZmZlZERhdGE6IHN0dWZmZWREYXRhLFxuICAgICAgICAgIHNyY1B0cjogc3JjUHRyLFxuICAgICAgICAgIGJpdFBvczogYml0UG9zXG4gICAgICAgIH07XG4gICAgICB9LFxuXG4gICAgICByZWFkSHVmZm1hbjogZnVuY3Rpb24oaW5wdXQsIGRhdGEsIE91dFBpeGVsVHlwZUFycmF5LCB1c2VCU1FGb3JPdXRwdXREaW0pIHtcbiAgICAgICAgdmFyIGhlYWRlckluZm8gPSBkYXRhLmhlYWRlckluZm87XG4gICAgICAgIHZhciBudW1EaW1zID0gaGVhZGVySW5mby5udW1EaW1zO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gZGF0YS5oZWFkZXJJbmZvLmhlaWdodDtcbiAgICAgICAgdmFyIHdpZHRoID0gZGF0YS5oZWFkZXJJbmZvLndpZHRoO1xuICAgICAgICB2YXIgbnVtUGl4ZWxzID0gd2lkdGggKiBoZWlnaHQ7XG4gICAgICAgIC8vdmFyIHNpemVfbWF4ID0gMSA8PCBCSVRTX01BWDtcbiAgICAgICAgLyogKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICogcmVhZGluZyBodWZmbWFuIHN0cnVjdHVyZSBpbmZvXG4gICAgICAgICoqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIHZhciBodWZmbWFuSW5mbyA9IHRoaXMucmVhZEh1ZmZtYW5UcmVlKGlucHV0LCBkYXRhKTtcbiAgICAgICAgdmFyIGRlY29kZUx1dCA9IGh1ZmZtYW5JbmZvLmRlY29kZUx1dDtcbiAgICAgICAgdmFyIHRyZWUgPSBodWZmbWFuSW5mby50cmVlO1xuICAgICAgICAvL3N0dWZmZWREYXRhIGluY2x1ZGVzIGh1ZmZtYW4gaGVhZGVyc1xuICAgICAgICB2YXIgc3R1ZmZlZERhdGEgPSBodWZmbWFuSW5mby5zdHVmZmVkRGF0YTtcbiAgICAgICAgdmFyIHNyY1B0ciA9IGh1ZmZtYW5JbmZvLnNyY1B0cjtcbiAgICAgICAgdmFyIGJpdFBvcyA9IGh1ZmZtYW5JbmZvLmJpdFBvcztcbiAgICAgICAgdmFyIG51bUJpdHNMVVRRaWNrID0gaHVmZm1hbkluZm8ubnVtQml0c0xVVFFpY2s7XG4gICAgICAgIHZhciBudW1CaXRzTFVUID0gaHVmZm1hbkluZm8ubnVtQml0c0xVVDtcbiAgICAgICAgdmFyIG9mZnNldCA9IGRhdGEuaGVhZGVySW5mby5pbWFnZVR5cGUgPT09IDAgPyAxMjggOiAwO1xuICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAqICBkZWNvZGVcbiAgICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICB2YXIgbm9kZSwgdmFsLCBkZWx0YSwgbWFzayA9IGRhdGEucGl4ZWxzLnJlc3VsdE1hc2ssIHZhbFRtcCwgdmFsVG1wUXVpY2ssIGN1cnJlbnRCaXQ7XG4gICAgICAgIHZhciBpLCBqLCBrLCBpaTtcbiAgICAgICAgdmFyIHByZXZWYWwgPSAwO1xuICAgICAgICBpZiAoYml0UG9zID4gMCkge1xuICAgICAgICAgIHNyY1B0cisrO1xuICAgICAgICAgIGJpdFBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdvcmQgPSBzdHVmZmVkRGF0YVtzcmNQdHJdO1xuICAgICAgICB2YXIgZGVsdGFFbmNvZGUgPSBkYXRhLmVuY29kZU1vZGUgPT09IDE7XG4gICAgICAgIHZhciByZXN1bHRQaXhlbHNBbGxEaW0gPSBuZXcgT3V0UGl4ZWxUeXBlQXJyYXkobnVtUGl4ZWxzICogbnVtRGltcyk7XG4gICAgICAgIHZhciByZXN1bHRQaXhlbHMgPSByZXN1bHRQaXhlbHNBbGxEaW07XG4gICAgICAgIHZhciBpRGltO1xuICAgICAgICAvLyBUT0RPOiByZWV2YWx1YXRlIHRoZSBuZWVkIHRvIGtlZXAgaW5saW5lZCBkZWNvZGluZyBjb2RlIGFzIElFIHN1cHBvcnQgaXMgcGhhc2luZyBvdXRcbiAgICAgICAgaWYgKG51bURpbXMgPCAyIHx8IGRlbHRhRW5jb2RlKSB7XG4gICAgICAgICAgZm9yIChpRGltID0gMDsgaURpbSA8IG51bURpbXM7IGlEaW0rKykge1xuICAgICAgICAgICAgaWYgKG51bURpbXMgPiAxKSB7XG4gICAgICAgICAgICAgIC8vZ2V0IHRoZSBtZW0gYmxvY2sgb2YgY3VycmVudCBkaW1lbnNpb25cbiAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzID0gbmV3IE91dFBpeGVsVHlwZUFycmF5KHJlc3VsdFBpeGVsc0FsbERpbS5idWZmZXIsIG51bVBpeGVscyAqIGlEaW0sIG51bVBpeGVscyk7XG4gICAgICAgICAgICAgIHByZXZWYWwgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEuaGVhZGVySW5mby5udW1WYWxpZFBpeGVsID09PSB3aWR0aCAqIGhlaWdodCkgeyAvL2FsbCB2YWxpZFxuICAgICAgICAgICAgICBmb3IgKGsgPSAwLCBpID0gMDsgaSA8IGhlaWdodDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHdpZHRoOyBqKyssIGsrKykge1xuICAgICAgICAgICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgICAgICAgICAgIHZhbFRtcCA9ICh3b3JkIDw8IGJpdFBvcykgPj4+ICgzMiAtIG51bUJpdHNMVVRRaWNrKTtcbiAgICAgICAgICAgICAgICAgIHZhbFRtcFF1aWNrID0gdmFsVG1wOy8vID4+PiBkZWx0YUJpdHM7XG4gICAgICAgICAgICAgICAgICBpZiAoMzIgLSBiaXRQb3MgPCBudW1CaXRzTFVUUWljaykge1xuICAgICAgICAgICAgICAgICAgICB2YWxUbXAgfD0gKChzdHVmZmVkRGF0YVtzcmNQdHIgKyAxXSkgPj4+ICg2NCAtIGJpdFBvcyAtIG51bUJpdHNMVVRRaWNrKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbFRtcFF1aWNrID0gdmFsVG1wOy8vID4+PiBkZWx0YUJpdHM7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoZGVjb2RlTHV0W3ZhbFRtcFF1aWNrXSkgICAgLy8gaWYgdGhlcmUsIG1vdmUgdGhlIGNvcnJlY3QgbnVtYmVyIG9mIGJpdHMgYW5kIGRvbmVcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gZGVjb2RlTHV0W3ZhbFRtcFF1aWNrXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgYml0UG9zICs9IGRlY29kZUx1dFt2YWxUbXBRdWlja11bMF07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsVG1wID0gKHdvcmQgPDwgYml0UG9zKSA+Pj4gKDMyIC0gbnVtQml0c0xVVCk7XG4gICAgICAgICAgICAgICAgICAgIHZhbFRtcFF1aWNrID0gdmFsVG1wOy8vID4+PiBkZWx0YUJpdHM7XG4gICAgICAgICAgICAgICAgICAgIGlmICgzMiAtIGJpdFBvcyA8IG51bUJpdHNMVVQpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YWxUbXAgfD0gKChzdHVmZmVkRGF0YVtzcmNQdHIgKyAxXSkgPj4+ICg2NCAtIGJpdFBvcyAtIG51bUJpdHNMVVQpKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YWxUbXBRdWljayA9IHZhbFRtcDsvLyA+Pj4gZGVsdGFCaXRzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSB0cmVlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGlpID0gMDsgaWkgPCBudW1CaXRzTFVUOyBpaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVudEJpdCA9IHZhbFRtcCA+Pj4gKG51bUJpdHNMVVQgLSBpaSAtIDEpICYgMTtcbiAgICAgICAgICAgICAgICAgICAgICBub2RlID0gY3VycmVudEJpdCA/IG5vZGUucmlnaHQgOiBub2RlLmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCEobm9kZS5sZWZ0IHx8IG5vZGUucmlnaHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBub2RlLnZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpdFBvcyA9IGJpdFBvcyArIGlpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgaWYgKGJpdFBvcyA+PSAzMikge1xuICAgICAgICAgICAgICAgICAgICBiaXRQb3MgLT0gMzI7XG4gICAgICAgICAgICAgICAgICAgIHNyY1B0cisrO1xuICAgICAgICAgICAgICAgICAgICB3b3JkID0gc3R1ZmZlZERhdGFbc3JjUHRyXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgIGRlbHRhID0gdmFsIC0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgaWYgKGRlbHRhRW5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIGRlbHRhICs9IHByZXZWYWw7ICAgIC8vIHVzZSBvdmVyZmxvd1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGVsdGEgKz0gcmVzdWx0UGl4ZWxzW2sgLSB3aWR0aF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGVsdGEgKz0gcHJldlZhbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWx0YSAmPSAweEZGOyAvL292ZXJmbG93XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1trXSA9IGRlbHRhOy8vb3ZlcmZsb3dcbiAgICAgICAgICAgICAgICAgICAgcHJldlZhbCA9IGRlbHRhO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1trXSA9IGRlbHRhO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7IC8vbm90IGFsbCB2YWxpZCwgdXNlIG1hc2tcbiAgICAgICAgICAgICAgZm9yIChrID0gMCwgaSA9IDA7IGkgPCBoZWlnaHQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB3aWR0aDsgaisrLCBrKyspIHtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXNrW2tdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhbFRtcCA9ICh3b3JkIDw8IGJpdFBvcykgPj4+ICgzMiAtIG51bUJpdHNMVVRRaWNrKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsVG1wUXVpY2sgPSB2YWxUbXA7Ly8gPj4+IGRlbHRhQml0cztcbiAgICAgICAgICAgICAgICAgICAgaWYgKDMyIC0gYml0UG9zIDwgbnVtQml0c0xVVFFpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YWxUbXAgfD0gKChzdHVmZmVkRGF0YVtzcmNQdHIgKyAxXSkgPj4+ICg2NCAtIGJpdFBvcyAtIG51bUJpdHNMVVRRaWNrKSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsVG1wUXVpY2sgPSB2YWxUbXA7Ly8gPj4+IGRlbHRhQml0cztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVjb2RlTHV0W3ZhbFRtcFF1aWNrXSkgICAgLy8gaWYgdGhlcmUsIG1vdmUgdGhlIGNvcnJlY3QgbnVtYmVyIG9mIGJpdHMgYW5kIGRvbmVcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGRlY29kZUx1dFt2YWxUbXBRdWlja11bMV07XG4gICAgICAgICAgICAgICAgICAgICAgYml0UG9zICs9IGRlY29kZUx1dFt2YWxUbXBRdWlja11bMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsVG1wID0gKHdvcmQgPDwgYml0UG9zKSA+Pj4gKDMyIC0gbnVtQml0c0xVVCk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsVG1wUXVpY2sgPSB2YWxUbXA7Ly8gPj4+IGRlbHRhQml0cztcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoMzIgLSBiaXRQb3MgPCBudW1CaXRzTFVUKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxUbXAgfD0gKChzdHVmZmVkRGF0YVtzcmNQdHIgKyAxXSkgPj4+ICg2NCAtIGJpdFBvcyAtIG51bUJpdHNMVVQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbFRtcFF1aWNrID0gdmFsVG1wOy8vID4+PiBkZWx0YUJpdHM7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSB0cmVlO1xuICAgICAgICAgICAgICAgICAgICAgIGZvciAoaWkgPSAwOyBpaSA8IG51bUJpdHNMVVQ7IGlpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRCaXQgPSB2YWxUbXAgPj4+IChudW1CaXRzTFVUIC0gaWkgLSAxKSAmIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gY3VycmVudEJpdCA/IG5vZGUucmlnaHQgOiBub2RlLmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShub2RlLmxlZnQgfHwgbm9kZS5yaWdodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gbm9kZS52YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJpdFBvcyA9IGJpdFBvcyArIGlpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChiaXRQb3MgPj0gMzIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBiaXRQb3MgLT0gMzI7XG4gICAgICAgICAgICAgICAgICAgICAgc3JjUHRyKys7XG4gICAgICAgICAgICAgICAgICAgICAgd29yZCA9IHN0dWZmZWREYXRhW3NyY1B0cl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgZGVsdGEgPSB2YWwgLSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWx0YUVuY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChqID4gMCAmJiBtYXNrW2sgLSAxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGEgKz0gcHJldlZhbDsgICAgLy8gdXNlIG92ZXJmbG93XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGkgPiAwICYmIG1hc2tbayAtIHdpZHRoXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGEgKz0gcmVzdWx0UGl4ZWxzW2sgLSB3aWR0aF07XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGEgKz0gcHJldlZhbDtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgZGVsdGEgJj0gMHhGRjsgLy9vdmVyZmxvd1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1trXSA9IGRlbHRhOy8vb3ZlcmZsb3dcbiAgICAgICAgICAgICAgICAgICAgICBwcmV2VmFsID0gZGVsdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzW2tdID0gZGVsdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZm9yIChrID0gMCwgaSA9IDA7IGkgPCBoZWlnaHQ7IGkrKykge1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHdpZHRoOyBqKyspIHtcbiAgICAgICAgICAgICAgayA9IGkgKiB3aWR0aCArIGo7XG4gICAgICAgICAgICAgIGlmICghbWFzayB8fCBtYXNrW2tdKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpRGltID0gMDsgaURpbSA8IG51bURpbXM7IGlEaW0rKywgays9bnVtUGl4ZWxzKSB7XG4gICAgICAgICAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICAgICAgICAgICAgdmFsVG1wID0gKHdvcmQgPDwgYml0UG9zKSA+Pj4gKDMyIC0gbnVtQml0c0xVVFFpY2spO1xuICAgICAgICAgICAgICAgICAgdmFsVG1wUXVpY2sgPSB2YWxUbXA7XG4gICAgICAgICAgICAgICAgICBpZiAoMzIgLSBiaXRQb3MgPCBudW1CaXRzTFVUUWljaykge1xuICAgICAgICAgICAgICAgICAgICB2YWxUbXAgfD0gKChzdHVmZmVkRGF0YVtzcmNQdHIgKyAxXSkgPj4+ICg2NCAtIGJpdFBvcyAtIG51bUJpdHNMVVRRaWNrKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbFRtcFF1aWNrID0gdmFsVG1wO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGRlY29kZUx1dFt2YWxUbXBRdWlja10pXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IGRlY29kZUx1dFt2YWxUbXBRdWlja11bMV07XG4gICAgICAgICAgICAgICAgICAgIGJpdFBvcyArPSBkZWNvZGVMdXRbdmFsVG1wUXVpY2tdWzBdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbFRtcCA9ICh3b3JkIDw8IGJpdFBvcykgPj4+ICgzMiAtIG51bUJpdHNMVVQpO1xuICAgICAgICAgICAgICAgICAgICB2YWxUbXBRdWljayA9IHZhbFRtcDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKDMyIC0gYml0UG9zIDwgbnVtQml0c0xVVCkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhbFRtcCB8PSAoKHN0dWZmZWREYXRhW3NyY1B0ciArIDFdKSA+Pj4gKDY0IC0gYml0UG9zIC0gbnVtQml0c0xVVCkpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhbFRtcFF1aWNrID0gdmFsVG1wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSB0cmVlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGlpID0gMDsgaWkgPCBudW1CaXRzTFVUOyBpaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVudEJpdCA9IHZhbFRtcCA+Pj4gKG51bUJpdHNMVVQgLSBpaSAtIDEpICYgMTtcbiAgICAgICAgICAgICAgICAgICAgICBub2RlID0gY3VycmVudEJpdCA/IG5vZGUucmlnaHQgOiBub2RlLmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCEobm9kZS5sZWZ0IHx8IG5vZGUucmlnaHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBub2RlLnZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpdFBvcyA9IGJpdFBvcyArIGlpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAoYml0UG9zID49IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgIGJpdFBvcyAtPSAzMjtcbiAgICAgICAgICAgICAgICAgICAgc3JjUHRyKys7XG4gICAgICAgICAgICAgICAgICAgIHdvcmQgPSBzdHVmZmVkRGF0YVtzcmNQdHJdO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBkZWx0YSA9IHZhbCAtIG9mZnNldDtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1trXSA9IGRlbHRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkYXRhLnB0ciA9IGRhdGEucHRyICsgKHNyY1B0ciArIDEpICogNCArIChiaXRQb3MgPiAwID8gNCA6IDApO1xuICAgICAgICBkYXRhLnBpeGVscy5yZXN1bHRQaXhlbHMgPSByZXN1bHRQaXhlbHNBbGxEaW07XG4gICAgICAgIC8vc3dhcCBmb3IgQklQIGxheW91dFxuICAgICAgICBpZiAobnVtRGltcyA+IDEgJiYgIXVzZUJTUUZvck91dHB1dERpbSkge1xuICAgICAgICAgIGRhdGEucGl4ZWxzLnJlc3VsdFBpeGVscyA9IExlcmMySGVscGVycy5zd2FwRGltZW5zaW9uT3JkZXIocmVzdWx0UGl4ZWxzQWxsRGltLCBudW1QaXhlbHMsIG51bURpbXMsIE91dFBpeGVsVHlwZUFycmF5KTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZGVjb2RlQml0czogZnVuY3Rpb24oaW5wdXQsIGRhdGEsIGJsb2NrRGF0YUJ1ZmZlciwgb2Zmc2V0LCBpRGltKSB7XG4gICAgICAgIHtcbiAgICAgICAgICAvL2JpdHN0dWZmIGVuY29kaW5nIGlzIDNcbiAgICAgICAgICB2YXIgaGVhZGVySW5mbyA9IGRhdGEuaGVhZGVySW5mbztcbiAgICAgICAgICB2YXIgZmlsZVZlcnNpb24gPSBoZWFkZXJJbmZvLmZpbGVWZXJzaW9uO1xuICAgICAgICAgIC8vdmFyIGJsb2NrID0ge307XG4gICAgICAgICAgdmFyIGJsb2NrUHRyID0gMDtcbiAgICAgICAgICB2YXIgdmlld0J5dGVMZW5ndGggPSAoKGlucHV0LmJ5dGVMZW5ndGggLSBkYXRhLnB0cikgPj0gNSkgPyA1IDogKGlucHV0LmJ5dGVMZW5ndGggLSBkYXRhLnB0cik7XG4gICAgICAgICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcoaW5wdXQsIGRhdGEucHRyLCB2aWV3Qnl0ZUxlbmd0aCk7XG4gICAgICAgICAgdmFyIGhlYWRlckJ5dGUgPSB2aWV3LmdldFVpbnQ4KDApO1xuICAgICAgICAgIGJsb2NrUHRyKys7XG4gICAgICAgICAgdmFyIGJpdHM2NyA9IGhlYWRlckJ5dGUgPj4gNjtcbiAgICAgICAgICB2YXIgbiA9IChiaXRzNjcgPT09IDApID8gNCA6IDMgLSBiaXRzNjc7XG4gICAgICAgICAgdmFyIGRvTHV0ID0gKGhlYWRlckJ5dGUgJiAzMikgPiAwID8gdHJ1ZSA6IGZhbHNlOy8vNXRoIGJpdFxuICAgICAgICAgIHZhciBudW1CaXRzID0gaGVhZGVyQnl0ZSAmIDMxO1xuICAgICAgICAgIHZhciBudW1FbGVtZW50cyA9IDA7XG4gICAgICAgICAgaWYgKG4gPT09IDEpIHtcbiAgICAgICAgICAgIG51bUVsZW1lbnRzID0gdmlldy5nZXRVaW50OChibG9ja1B0cik7IGJsb2NrUHRyKys7XG4gICAgICAgICAgfSBlbHNlIGlmIChuID09PSAyKSB7XG4gICAgICAgICAgICBudW1FbGVtZW50cyA9IHZpZXcuZ2V0VWludDE2KGJsb2NrUHRyLCB0cnVlKTsgYmxvY2tQdHIgKz0gMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKG4gPT09IDQpIHtcbiAgICAgICAgICAgIG51bUVsZW1lbnRzID0gdmlldy5nZXRVaW50MzIoYmxvY2tQdHIsIHRydWUpOyBibG9ja1B0ciArPSA0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBcIkludmFsaWQgdmFsaWQgcGl4ZWwgY291bnQgdHlwZVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvL2ZpeDogaHVmZm1hbiBjb2RlcyBhcmUgYml0IHN0dWZmZWQsIGJ1dCBub3QgYm91bmQgYnkgZGF0YSdzIG1heCB2YWx1ZSwgc28gbmVlZCB0byB1c2Ugb3JpZ2luYWxVbnN0dWZmXG4gICAgICAgICAgLy9vZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgICAgICAgICB2YXIgc2NhbGUgPSAyICogaGVhZGVySW5mby5tYXhaRXJyb3I7XG4gICAgICAgICAgdmFyIHN0dWZmZWREYXRhLCBhcnJheUJ1Ziwgc3RvcmU4LCBkYXRhQnl0ZXMsIGRhdGFXb3JkcztcbiAgICAgICAgICB2YXIgbHV0QXJyLCBsdXREYXRhLCBsdXRCeXRlcywgbHV0Qml0c1BlckVsZW1lbnQsIGJpdHNQZXJQaXhlbDtcbiAgICAgICAgICB2YXIgek1heCA9IGhlYWRlckluZm8ubnVtRGltcyA+IDEgPyBoZWFkZXJJbmZvLm1heFZhbHVlc1tpRGltXSA6IGhlYWRlckluZm8uek1heDtcbiAgICAgICAgICBpZiAoZG9MdXQpIHtcbiAgICAgICAgICAgIGRhdGEuY291bnRlci5sdXQrKztcbiAgICAgICAgICAgIGx1dEJ5dGVzID0gdmlldy5nZXRVaW50OChibG9ja1B0cik7XG4gICAgICAgICAgICBsdXRCaXRzUGVyRWxlbWVudCA9IG51bUJpdHM7XG4gICAgICAgICAgICBibG9ja1B0cisrO1xuICAgICAgICAgICAgZGF0YUJ5dGVzID0gTWF0aC5jZWlsKChsdXRCeXRlcyAtIDEpICogbnVtQml0cyAvIDgpO1xuICAgICAgICAgICAgZGF0YVdvcmRzID0gTWF0aC5jZWlsKGRhdGFCeXRlcyAvIDQpO1xuICAgICAgICAgICAgYXJyYXlCdWYgPSBuZXcgQXJyYXlCdWZmZXIoZGF0YVdvcmRzICogNCk7XG4gICAgICAgICAgICBzdG9yZTggPSBuZXcgVWludDhBcnJheShhcnJheUJ1Zik7XG5cbiAgICAgICAgICAgIGRhdGEucHRyICs9IGJsb2NrUHRyO1xuICAgICAgICAgICAgc3RvcmU4LnNldChuZXcgVWludDhBcnJheShpbnB1dCwgZGF0YS5wdHIsIGRhdGFCeXRlcykpO1xuXG4gICAgICAgICAgICBsdXREYXRhID0gbmV3IFVpbnQzMkFycmF5KGFycmF5QnVmKTtcbiAgICAgICAgICAgIGRhdGEucHRyICs9IGRhdGFCeXRlcztcblxuICAgICAgICAgICAgYml0c1BlclBpeGVsID0gMDtcbiAgICAgICAgICAgIHdoaWxlICgobHV0Qnl0ZXMgLSAxKSA+Pj4gYml0c1BlclBpeGVsKSB7XG4gICAgICAgICAgICAgIGJpdHNQZXJQaXhlbCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YUJ5dGVzID0gTWF0aC5jZWlsKG51bUVsZW1lbnRzICogYml0c1BlclBpeGVsIC8gOCk7XG4gICAgICAgICAgICBkYXRhV29yZHMgPSBNYXRoLmNlaWwoZGF0YUJ5dGVzIC8gNCk7XG4gICAgICAgICAgICBhcnJheUJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcihkYXRhV29yZHMgKiA0KTtcbiAgICAgICAgICAgIHN0b3JlOCA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmKTtcbiAgICAgICAgICAgIHN0b3JlOC5zZXQobmV3IFVpbnQ4QXJyYXkoaW5wdXQsIGRhdGEucHRyLCBkYXRhQnl0ZXMpKTtcbiAgICAgICAgICAgIHN0dWZmZWREYXRhID0gbmV3IFVpbnQzMkFycmF5KGFycmF5QnVmKTtcbiAgICAgICAgICAgIGRhdGEucHRyICs9IGRhdGFCeXRlcztcbiAgICAgICAgICAgIGlmIChmaWxlVmVyc2lvbiA+PSAzKSB7XG4gICAgICAgICAgICAgIGx1dEFyciA9IEJpdFN0dWZmZXIudW5zdHVmZkxVVDIobHV0RGF0YSwgbnVtQml0cywgbHV0Qnl0ZXMgLSAxLCBvZmZzZXQsIHNjYWxlLCB6TWF4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBsdXRBcnIgPSBCaXRTdHVmZmVyLnVuc3R1ZmZMVVQobHV0RGF0YSwgbnVtQml0cywgbHV0Qnl0ZXMgLSAxLCBvZmZzZXQsIHNjYWxlLCB6TWF4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vbHV0QXJyLnVuc2hpZnQoMCk7XG4gICAgICAgICAgICBpZiAoZmlsZVZlcnNpb24gPj0gMykge1xuICAgICAgICAgICAgICAvL0JpdFN0dWZmZXIudW5zdHVmZjIoYmxvY2ssIGJsb2NrRGF0YUJ1ZmZlciwgaGVhZGVySW5mby56TWF4KTtcbiAgICAgICAgICAgICAgQml0U3R1ZmZlci51bnN0dWZmMihzdHVmZmVkRGF0YSwgYmxvY2tEYXRhQnVmZmVyLCBiaXRzUGVyUGl4ZWwsIG51bUVsZW1lbnRzLCBsdXRBcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIEJpdFN0dWZmZXIudW5zdHVmZihzdHVmZmVkRGF0YSwgYmxvY2tEYXRhQnVmZmVyLCBiaXRzUGVyUGl4ZWwsIG51bUVsZW1lbnRzLCBsdXRBcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5kZWJ1ZyhcImJpdHN0dWZmZXJcIik7XG4gICAgICAgICAgICBkYXRhLmNvdW50ZXIuYml0c3R1ZmZlcisrO1xuICAgICAgICAgICAgYml0c1BlclBpeGVsID0gbnVtQml0cztcbiAgICAgICAgICAgIGRhdGEucHRyICs9IGJsb2NrUHRyO1xuICAgICAgICAgICAgaWYgKGJpdHNQZXJQaXhlbCA+IDApIHtcbiAgICAgICAgICAgICAgZGF0YUJ5dGVzID0gTWF0aC5jZWlsKG51bUVsZW1lbnRzICogYml0c1BlclBpeGVsIC8gOCk7XG4gICAgICAgICAgICAgIGRhdGFXb3JkcyA9IE1hdGguY2VpbChkYXRhQnl0ZXMgLyA0KTtcbiAgICAgICAgICAgICAgYXJyYXlCdWYgPSBuZXcgQXJyYXlCdWZmZXIoZGF0YVdvcmRzICogNCk7XG4gICAgICAgICAgICAgIHN0b3JlOCA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmKTtcbiAgICAgICAgICAgICAgc3RvcmU4LnNldChuZXcgVWludDhBcnJheShpbnB1dCwgZGF0YS5wdHIsIGRhdGFCeXRlcykpO1xuICAgICAgICAgICAgICBzdHVmZmVkRGF0YSA9IG5ldyBVaW50MzJBcnJheShhcnJheUJ1Zik7XG4gICAgICAgICAgICAgIGRhdGEucHRyICs9IGRhdGFCeXRlcztcbiAgICAgICAgICAgICAgaWYgKGZpbGVWZXJzaW9uID49IDMpIHtcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIEJpdFN0dWZmZXIub3JpZ2luYWxVbnN0dWZmMihzdHVmZmVkRGF0YSwgYmxvY2tEYXRhQnVmZmVyLCBiaXRzUGVyUGl4ZWwsIG51bUVsZW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBCaXRTdHVmZmVyLnVuc3R1ZmYyKHN0dWZmZWREYXRhLCBibG9ja0RhdGFCdWZmZXIsIGJpdHNQZXJQaXhlbCwgbnVtRWxlbWVudHMsIGZhbHNlLCBvZmZzZXQsIHNjYWxlLCB6TWF4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBCaXRTdHVmZmVyLm9yaWdpbmFsVW5zdHVmZihzdHVmZmVkRGF0YSwgYmxvY2tEYXRhQnVmZmVyLCBiaXRzUGVyUGl4ZWwsIG51bUVsZW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBCaXRTdHVmZmVyLnVuc3R1ZmYoc3R1ZmZlZERhdGEsIGJsb2NrRGF0YUJ1ZmZlciwgYml0c1BlclBpeGVsLCBudW1FbGVtZW50cywgZmFsc2UsIG9mZnNldCwgc2NhbGUsIHpNYXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICB9LFxuXG4gICAgICByZWFkVGlsZXM6IGZ1bmN0aW9uKGlucHV0LCBkYXRhLCBPdXRQaXhlbFR5cGVBcnJheSwgdXNlQlNRRm9yT3V0cHV0RGltKSB7XG4gICAgICAgIHZhciBoZWFkZXJJbmZvID0gZGF0YS5oZWFkZXJJbmZvO1xuICAgICAgICB2YXIgd2lkdGggPSBoZWFkZXJJbmZvLndpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gaGVhZGVySW5mby5oZWlnaHQ7XG4gICAgICAgIHZhciBudW1QaXhlbHMgPSB3aWR0aCAqIGhlaWdodDtcbiAgICAgICAgdmFyIG1pY3JvQmxvY2tTaXplID0gaGVhZGVySW5mby5taWNyb0Jsb2NrU2l6ZTtcbiAgICAgICAgdmFyIGltYWdlVHlwZSA9IGhlYWRlckluZm8uaW1hZ2VUeXBlO1xuICAgICAgICB2YXIgZGF0YVR5cGVTaXplID0gTGVyYzJIZWxwZXJzLmdldERhdGFUeXBlU2l6ZShpbWFnZVR5cGUpO1xuICAgICAgICB2YXIgbnVtQmxvY2tzWCA9IE1hdGguY2VpbCh3aWR0aCAvIG1pY3JvQmxvY2tTaXplKTtcbiAgICAgICAgdmFyIG51bUJsb2Nrc1kgPSBNYXRoLmNlaWwoaGVpZ2h0IC8gbWljcm9CbG9ja1NpemUpO1xuICAgICAgICBkYXRhLnBpeGVscy5udW1CbG9ja3NZID0gbnVtQmxvY2tzWTtcbiAgICAgICAgZGF0YS5waXhlbHMubnVtQmxvY2tzWCA9IG51bUJsb2Nrc1g7XG4gICAgICAgIGRhdGEucGl4ZWxzLnB0ciA9IDA7XG4gICAgICAgIHZhciByb3cgPSAwLCBjb2wgPSAwLCBibG9ja1kgPSAwLCBibG9ja1ggPSAwLCB0aGlzQmxvY2tIZWlnaHQgPSAwLCB0aGlzQmxvY2tXaWR0aCA9IDAsIGJ5dGVzTGVmdCA9IDAsIGhlYWRlckJ5dGUgPSAwLCBiaXRzNjcgPSAwLCB0ZXN0Q29kZSA9IDAsIG91dFB0ciA9IDAsIG91dFN0cmlkZSA9IDAsIG51bUJ5dGVzID0gMCwgYnl0ZXNsZWZ0ID0gMCwgeiA9IDAsIGJsb2NrUHRyID0gMDtcbiAgICAgICAgdmFyIHZpZXcsIGJsb2NrLCBhcnJheUJ1Ziwgc3RvcmU4LCByYXdEYXRhO1xuICAgICAgICB2YXIgYmxvY2tFbmNvZGluZztcbiAgICAgICAgdmFyIGJsb2NrRGF0YUJ1ZmZlciA9IG5ldyBPdXRQaXhlbFR5cGVBcnJheShtaWNyb0Jsb2NrU2l6ZSAqIG1pY3JvQmxvY2tTaXplKTtcbiAgICAgICAgdmFyIGxhc3RCbG9ja0hlaWdodCA9IChoZWlnaHQgJSBtaWNyb0Jsb2NrU2l6ZSkgfHwgbWljcm9CbG9ja1NpemU7XG4gICAgICAgIHZhciBsYXN0QmxvY2tXaWR0aCA9ICh3aWR0aCAlIG1pY3JvQmxvY2tTaXplKSB8fCBtaWNyb0Jsb2NrU2l6ZTtcbiAgICAgICAgdmFyIG9mZnNldFR5cGUsIG9mZnNldDtcbiAgICAgICAgdmFyIG51bURpbXMgPSBoZWFkZXJJbmZvLm51bURpbXMsIGlEaW07XG4gICAgICAgIHZhciBtYXNrID0gZGF0YS5waXhlbHMucmVzdWx0TWFzaztcbiAgICAgICAgdmFyIHJlc3VsdFBpeGVscyA9IGRhdGEucGl4ZWxzLnJlc3VsdFBpeGVscztcbiAgICAgICAgdmFyIGZpbGVWZXJzaW9uID0gaGVhZGVySW5mby5maWxlVmVyc2lvbjtcbiAgICAgICAgdmFyIGZpbGVWZXJzaW9uQ2hlY2tOdW0gPSBmaWxlVmVyc2lvbiA+PSA1ID8gMTQgOiAxNTtcbiAgICAgICAgdmFyIGlzRGlmZkVuY29kaW5nO1xuICAgICAgICB2YXIgek1heCA9IGhlYWRlckluZm8uek1heDtcbiAgICAgICAgLy92YXIgcmVzdWx0UGl4ZWxzQWxsRGltID0gcmVzdWx0UGl4ZWxzO1xuICAgICAgICB2YXIgcmVzdWx0UGl4ZWxzUHJldkRpbTtcbiAgICAgICAgZm9yIChibG9ja1kgPSAwOyBibG9ja1kgPCBudW1CbG9ja3NZOyBibG9ja1krKykge1xuICAgICAgICAgIHRoaXNCbG9ja0hlaWdodCA9IChibG9ja1kgIT09IG51bUJsb2Nrc1kgLSAxKSA/IG1pY3JvQmxvY2tTaXplIDogbGFzdEJsb2NrSGVpZ2h0O1xuICAgICAgICAgIGZvciAoYmxvY2tYID0gMDsgYmxvY2tYIDwgbnVtQmxvY2tzWDsgYmxvY2tYKyspIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5kZWJ1ZyhcInlcIiArIGJsb2NrWSArIFwiIHhcIiArIGJsb2NrWCk7XG4gICAgICAgICAgICB0aGlzQmxvY2tXaWR0aCA9IChibG9ja1ggIT09IG51bUJsb2Nrc1ggLSAxKSA/IG1pY3JvQmxvY2tTaXplIDogbGFzdEJsb2NrV2lkdGg7XG5cbiAgICAgICAgICAgIG91dFB0ciA9IGJsb2NrWSAqIHdpZHRoICogbWljcm9CbG9ja1NpemUgKyBibG9ja1ggKiBtaWNyb0Jsb2NrU2l6ZTtcbiAgICAgICAgICAgIG91dFN0cmlkZSA9IHdpZHRoIC0gdGhpc0Jsb2NrV2lkdGg7XG5cbiAgICAgICAgICAgIGZvciAoaURpbSA9IDA7IGlEaW0gPCBudW1EaW1zOyBpRGltKyspIHtcbiAgICAgICAgICAgICAgaWYgKG51bURpbXMgPiAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzUHJldkRpbSA9IHJlc3VsdFBpeGVscztcbiAgICAgICAgICAgICAgICBvdXRQdHIgPSBibG9ja1kgKiB3aWR0aCAqIG1pY3JvQmxvY2tTaXplICsgYmxvY2tYICogbWljcm9CbG9ja1NpemU7XG4gICAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzID0gbmV3IE91dFBpeGVsVHlwZUFycmF5KGRhdGEucGl4ZWxzLnJlc3VsdFBpeGVscy5idWZmZXIsIG51bVBpeGVscyAqIGlEaW0gKiBkYXRhVHlwZVNpemUsIG51bVBpeGVscyk7XG4gICAgICAgICAgICAgICAgek1heCA9IGhlYWRlckluZm8ubWF4VmFsdWVzW2lEaW1dO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1ByZXZEaW0gPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJ5dGVzTGVmdCA9IGlucHV0LmJ5dGVMZW5ndGggLSBkYXRhLnB0cjtcbiAgICAgICAgICAgICAgdmlldyA9IG5ldyBEYXRhVmlldyhpbnB1dCwgZGF0YS5wdHIsIE1hdGgubWluKDEwLCBieXRlc0xlZnQpKTtcbiAgICAgICAgICAgICAgYmxvY2sgPSB7fTtcbiAgICAgICAgICAgICAgYmxvY2tQdHIgPSAwO1xuICAgICAgICAgICAgICBoZWFkZXJCeXRlID0gdmlldy5nZXRVaW50OCgwKTtcbiAgICAgICAgICAgICAgYmxvY2tQdHIrKztcbiAgICAgICAgICAgICAgaXNEaWZmRW5jb2RpbmcgPSBoZWFkZXJJbmZvLmZpbGVWZXJzaW9uID49IDUgPyBoZWFkZXJCeXRlICYgNCA6IDA7XG4gICAgICAgICAgICAgIGJpdHM2NyA9IChoZWFkZXJCeXRlID4+IDYpICYgMHhGRjtcbiAgICAgICAgICAgICAgdGVzdENvZGUgPSAoaGVhZGVyQnl0ZSA+PiAyKSAmIGZpbGVWZXJzaW9uQ2hlY2tOdW07ICAgIC8vIHVzZSBiaXRzIDIzNDUgZm9yIGludGVncml0eSBjaGVja1xuICAgICAgICAgICAgICBpZiAodGVzdENvZGUgIT09ICgoKGJsb2NrWCAqIG1pY3JvQmxvY2tTaXplKSA+PiAzKSAmIGZpbGVWZXJzaW9uQ2hlY2tOdW0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJpbnRlZ3JpdHkgaXNzdWVcIjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChpc0RpZmZFbmNvZGluZyAmJiBpRGltID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJpbnRlZ3JpdHkgaXNzdWVcIjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJsb2NrRW5jb2RpbmcgPSBoZWFkZXJCeXRlICYgMztcbiAgICAgICAgICAgICAgaWYgKGJsb2NrRW5jb2RpbmcgPiAzKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5wdHIgKz0gYmxvY2tQdHI7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIGJsb2NrIGVuY29kaW5nIChcIiArIGJsb2NrRW5jb2RpbmcgKyBcIilcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChibG9ja0VuY29kaW5nID09PSAyKSB7IC8vY29uc3RhbnQgMFxuICAgICAgICAgICAgICAgIGlmIChpc0RpZmZFbmNvZGluZykge1xuICAgICAgICAgICAgICAgICAgaWYgKG1hc2spIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPCB0aGlzQmxvY2tIZWlnaHQ7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCB0aGlzQmxvY2tXaWR0aDsgY29sKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXNrW291dFB0cl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzW291dFB0cl0gPSByZXN1bHRQaXhlbHNQcmV2RGltW291dFB0cl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRQdHIrKztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IHRoaXNCbG9ja0hlaWdodDsgcm93KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IHRoaXNCbG9ja1dpZHRoOyBjb2wrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzW291dFB0cl0gPSByZXN1bHRQaXhlbHNQcmV2RGltW291dFB0cl07XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRQdHIrKztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YS5jb3VudGVyLmNvbnN0YW50Kys7XG4gICAgICAgICAgICAgICAgZGF0YS5wdHIgKz0gYmxvY2tQdHI7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoYmxvY2tFbmNvZGluZyA9PT0gMCkgeyAgLy91bmNvbXByZXNzZWRcbiAgICAgICAgICAgICAgICBpZiAoaXNEaWZmRW5jb2RpbmcpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGRvZXNuJ3QgbWFrZSBzZW5zZSwgc2hvdWxkIG5vdCBoYXBwZW5cbiAgICAgICAgICAgICAgICAgIHRocm93IFwiaW50ZWdyaXR5IGlzc3VlXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRhdGEuY291bnRlci51bmNvbXByZXNzZWQrKztcbiAgICAgICAgICAgICAgICBkYXRhLnB0ciArPSBibG9ja1B0cjtcbiAgICAgICAgICAgICAgICBudW1CeXRlcyA9IHRoaXNCbG9ja0hlaWdodCAqIHRoaXNCbG9ja1dpZHRoICogZGF0YVR5cGVTaXplO1xuICAgICAgICAgICAgICAgIGJ5dGVzbGVmdCA9IGlucHV0LmJ5dGVMZW5ndGggLSBkYXRhLnB0cjtcbiAgICAgICAgICAgICAgICBudW1CeXRlcyA9IG51bUJ5dGVzIDwgYnl0ZXNsZWZ0ID8gbnVtQnl0ZXMgOiBieXRlc2xlZnQ7XG4gICAgICAgICAgICAgICAgLy9iaXQgYWxpZ25tZW50XG4gICAgICAgICAgICAgICAgYXJyYXlCdWYgPSBuZXcgQXJyYXlCdWZmZXIoKG51bUJ5dGVzICUgZGF0YVR5cGVTaXplKSA9PT0gMCA/IG51bUJ5dGVzIDogKG51bUJ5dGVzICsgZGF0YVR5cGVTaXplIC0gbnVtQnl0ZXMgJSBkYXRhVHlwZVNpemUpKTtcbiAgICAgICAgICAgICAgICBzdG9yZTggPSBuZXcgVWludDhBcnJheShhcnJheUJ1Zik7XG4gICAgICAgICAgICAgICAgc3RvcmU4LnNldChuZXcgVWludDhBcnJheShpbnB1dCwgZGF0YS5wdHIsIG51bUJ5dGVzKSk7XG4gICAgICAgICAgICAgICAgcmF3RGF0YSA9IG5ldyBPdXRQaXhlbFR5cGVBcnJheShhcnJheUJ1Zik7XG4gICAgICAgICAgICAgICAgeiA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKG1hc2spIHtcbiAgICAgICAgICAgICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgdGhpc0Jsb2NrSGVpZ2h0OyByb3crKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IHRoaXNCbG9ja1dpZHRoOyBjb2wrKykge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXNrW291dFB0cl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1tvdXRQdHJdID0gcmF3RGF0YVt6KytdO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBvdXRQdHIrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvdXRQdHIgKz0gb3V0U3RyaWRlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHsvL2FsbCB2YWxpZFxuICAgICAgICAgICAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPCB0aGlzQmxvY2tIZWlnaHQ7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29sID0gMDsgY29sIDwgdGhpc0Jsb2NrV2lkdGg7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzW291dFB0cisrXSA9IHJhd0RhdGFbeisrXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvdXRQdHIgKz0gb3V0U3RyaWRlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRhLnB0ciArPSB6ICogZGF0YVR5cGVTaXplO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgeyAvLzEgb3IgM1xuICAgICAgICAgICAgICAgIG9mZnNldFR5cGUgPSBMZXJjMkhlbHBlcnMuZ2V0RGF0YVR5cGVVc2VkKChpc0RpZmZFbmNvZGluZyAmJiBpbWFnZVR5cGUgPCA2KSA/IDQgOiBpbWFnZVR5cGUsIGJpdHM2Nyk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gTGVyYzJIZWxwZXJzLmdldE9uZVBpeGVsKGJsb2NrLCBibG9ja1B0ciwgb2Zmc2V0VHlwZSwgdmlldyk7XG4gICAgICAgICAgICAgICAgYmxvY2tQdHIgKz0gTGVyYzJIZWxwZXJzLmdldERhdGFUeXBlU2l6ZShvZmZzZXRUeXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tFbmNvZGluZyA9PT0gMykgLy9jb25zdGFudCBvZmZzZXQgdmFsdWVcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBkYXRhLnB0ciArPSBibG9ja1B0cjtcbiAgICAgICAgICAgICAgICAgIGRhdGEuY291bnRlci5jb25zdGFudG9mZnNldCsrO1xuICAgICAgICAgICAgICAgICAgLy95b3UgY2FuIGRlbGV0ZSB0aGUgZm9sbG93aW5nIHJlc3VsdE1hc2sgY2FzZSBpbiBmYXZvciBvZiBwZXJmb3JtYW5jZSBiZWNhdXNlIHZhbCBpcyBjb25zdGFudCBhbmQgdXNlcnMgdXNlIG5vZGF0YSBtYXNrLCBvdGhlcndpc2Ugbm9kYXRhdmFsdWUgcG9zdCBwcm9jZXNzaW5nIGhhbmRsZXMgaXQgdG9vLlxuICAgICAgICAgICAgICAgICAgLy93aGlsZSB0aGUgYWJvdmUgc3RhdGVtZW50IGlzIHRydWUsIHdlJ3JlIG5vdCBkb2luZyBpdCBhcyB3ZSB3YW50IHRvIGtlZXAgaW52YWxpZCBwaXhlbCB2YWx1ZSBhdCAwIHJhdGhlciB0aGFuIGFyYml0cmFyeSB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgIGlmIChtYXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgdGhpc0Jsb2NrSGVpZ2h0OyByb3crKykge1xuICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29sID0gMDsgY29sIDwgdGhpc0Jsb2NrV2lkdGg7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFza1tvdXRQdHJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1tvdXRQdHJdID0gaXNEaWZmRW5jb2RpbmcgPyBNYXRoLm1pbih6TWF4LCByZXN1bHRQaXhlbHNQcmV2RGltW291dFB0cl0gKyBvZmZzZXQpIDogb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0UHRyKys7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIG91dFB0ciArPSBvdXRTdHJpZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IHRoaXNCbG9ja0hlaWdodDsgcm93KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IHRoaXNCbG9ja1dpZHRoOyBjb2wrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzW291dFB0cl0gPSBpc0RpZmZFbmNvZGluZyA/IE1hdGgubWluKHpNYXgsIHJlc3VsdFBpeGVsc1ByZXZEaW1bb3V0UHRyXSArIG9mZnNldCkgOiBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRQdHIrKztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgb3V0UHRyICs9IG91dFN0cmlkZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHsgLy9iaXRzdHVmZiBlbmNvZGluZyBpcyAzXG4gICAgICAgICAgICAgICAgICBkYXRhLnB0ciArPSBibG9ja1B0cjtcbiAgICAgICAgICAgICAgICAgIC8vaGVhdnkgbGlmdGluZ1xuICAgICAgICAgICAgICAgICAgTGVyYzJIZWxwZXJzLmRlY29kZUJpdHMoaW5wdXQsIGRhdGEsIGJsb2NrRGF0YUJ1ZmZlciwgb2Zmc2V0LCBpRGltKTtcbiAgICAgICAgICAgICAgICAgIGJsb2NrUHRyID0gMDtcbiAgICAgICAgICAgICAgICAgIC8vIGR1cGxpY2F0ZSBjb2RlIHRvIGZhdm9yIHBlcmZvcm1hbmNlLCBkaWZmIGVuY29kaW5nIGlzIGZvciBtdWx0aWRpbWVuc2lvbiBvbmx5XG4gICAgICAgICAgICAgICAgICBpZiAoaXNEaWZmRW5jb2RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hc2spIHtcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IHRoaXNCbG9ja0hlaWdodDsgcm93KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29sID0gMDsgY29sIDwgdGhpc0Jsb2NrV2lkdGg7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXNrW291dFB0cl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRQaXhlbHNbb3V0UHRyXSA9IGJsb2NrRGF0YUJ1ZmZlcltibG9ja1B0cisrXSArIHJlc3VsdFBpeGVsc1ByZXZEaW1bb3V0UHRyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRQdHIrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG91dFB0ciArPSBvdXRTdHJpZGU7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgdGhpc0Jsb2NrSGVpZ2h0OyByb3crKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCB0aGlzQmxvY2tXaWR0aDsgY29sKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzW291dFB0cl0gPSBibG9ja0RhdGFCdWZmZXJbYmxvY2tQdHIrK10gKyByZXN1bHRQaXhlbHNQcmV2RGltW291dFB0cl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG91dFB0cisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0UHRyICs9IG91dFN0cmlkZTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hc2spIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPCB0aGlzQmxvY2tIZWlnaHQ7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCB0aGlzQmxvY2tXaWR0aDsgY29sKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXNrW291dFB0cl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzW291dFB0cl0gPSBibG9ja0RhdGFCdWZmZXJbYmxvY2tQdHIrK107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRQdHIrKztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgb3V0UHRyICs9IG91dFN0cmlkZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgdGhpc0Jsb2NrSGVpZ2h0OyByb3crKykge1xuICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29sID0gMDsgY29sIDwgdGhpc0Jsb2NrV2lkdGg7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRQaXhlbHNbb3V0UHRyKytdID0gYmxvY2tEYXRhQnVmZmVyW2Jsb2NrUHRyKytdO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBvdXRQdHIgKz0gb3V0U3RyaWRlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vc3dhcCBmb3IgQklQOiBpdCdzIGFsd2F5cyBlYXNpZXIgZm9yIGNsaWVudHMgdG8gaGFuZGxlIEJTUSBzbyB3ZSBrZWVwIGV4aXN0aW5nIGxvZ2ljIGFuZCBpbnRyb2R1Y2UgYSBzd2FwIGhlcmUgdG8gbWluaW16ZSBjaGFuZ2VzXG4gICAgICAgIGlmIChudW1EaW1zID4gMSAmJiAhdXNlQlNRRm9yT3V0cHV0RGltKSB7XG4gICAgICAgICAgZGF0YS5waXhlbHMucmVzdWx0UGl4ZWxzID0gTGVyYzJIZWxwZXJzLnN3YXBEaW1lbnNpb25PcmRlcihkYXRhLnBpeGVscy5yZXN1bHRQaXhlbHMsIG51bVBpeGVscywgbnVtRGltcywgT3V0UGl4ZWxUeXBlQXJyYXkpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKioqKioqKioqKioqKioqKipcbiAgICAgICogIHByaXZhdGUgbWV0aG9kcyAoaGVscGVyIG1ldGhvZHMpXG4gICAgICAqKioqKioqKioqKioqKioqKi9cblxuICAgICAgZm9ybWF0RmlsZUluZm86IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBcImZpbGVJZGVudGlmaWVyU3RyaW5nXCI6IGRhdGEuaGVhZGVySW5mby5maWxlSWRlbnRpZmllclN0cmluZyxcbiAgICAgICAgICBcImZpbGVWZXJzaW9uXCI6IGRhdGEuaGVhZGVySW5mby5maWxlVmVyc2lvbixcbiAgICAgICAgICBcImltYWdlVHlwZVwiOiBkYXRhLmhlYWRlckluZm8uaW1hZ2VUeXBlLFxuICAgICAgICAgIFwiaGVpZ2h0XCI6IGRhdGEuaGVhZGVySW5mby5oZWlnaHQsXG4gICAgICAgICAgXCJ3aWR0aFwiOiBkYXRhLmhlYWRlckluZm8ud2lkdGgsXG4gICAgICAgICAgXCJudW1WYWxpZFBpeGVsXCI6IGRhdGEuaGVhZGVySW5mby5udW1WYWxpZFBpeGVsLFxuICAgICAgICAgIFwibWljcm9CbG9ja1NpemVcIjogZGF0YS5oZWFkZXJJbmZvLm1pY3JvQmxvY2tTaXplLFxuICAgICAgICAgIFwiYmxvYlNpemVcIjogZGF0YS5oZWFkZXJJbmZvLmJsb2JTaXplLFxuICAgICAgICAgIFwibWF4WkVycm9yXCI6IGRhdGEuaGVhZGVySW5mby5tYXhaRXJyb3IsXG4gICAgICAgICAgXCJwaXhlbFR5cGVcIjogTGVyYzJIZWxwZXJzLmdldFBpeGVsVHlwZShkYXRhLmhlYWRlckluZm8uaW1hZ2VUeXBlKSxcbiAgICAgICAgICBcImVvZk9mZnNldFwiOiBkYXRhLmVvZk9mZnNldCxcbiAgICAgICAgICBcIm1hc2tcIjogZGF0YS5tYXNrID8ge1xuICAgICAgICAgICAgXCJudW1CeXRlc1wiOiBkYXRhLm1hc2subnVtQnl0ZXNcbiAgICAgICAgICB9IDogbnVsbCxcbiAgICAgICAgICBcInBpeGVsc1wiOiB7XG4gICAgICAgICAgICBcIm51bUJsb2Nrc1hcIjogZGF0YS5waXhlbHMubnVtQmxvY2tzWCxcbiAgICAgICAgICAgIFwibnVtQmxvY2tzWVwiOiBkYXRhLnBpeGVscy5udW1CbG9ja3NZLFxuICAgICAgICAgICAgLy9cIm51bUJ5dGVzXCI6IGRhdGEucGl4ZWxzLm51bUJ5dGVzLFxuICAgICAgICAgICAgXCJtYXhWYWx1ZVwiOiBkYXRhLmhlYWRlckluZm8uek1heCxcbiAgICAgICAgICAgIFwibWluVmFsdWVcIjogZGF0YS5oZWFkZXJJbmZvLnpNaW4sXG4gICAgICAgICAgICBcIm5vRGF0YVZhbHVlXCI6IGRhdGEubm9EYXRhVmFsdWVcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9LFxuXG4gICAgICBjb25zdHJ1Y3RDb25zdGFudFN1cmZhY2U6IGZ1bmN0aW9uKGRhdGEsIHVzZUJTUUZvck91dHB1dERpbSkge1xuICAgICAgICB2YXIgdmFsID0gZGF0YS5oZWFkZXJJbmZvLnpNYXg7XG4gICAgICAgIHZhciB2YWxNaW4gPSBkYXRhLmhlYWRlckluZm8uek1pbjtcbiAgICAgICAgdmFyIG1heFZhbHVlcyA9IGRhdGEuaGVhZGVySW5mby5tYXhWYWx1ZXM7XG4gICAgICAgIHZhciBudW1EaW1zID0gZGF0YS5oZWFkZXJJbmZvLm51bURpbXM7XG4gICAgICAgIHZhciBudW1QaXhlbHMgPSBkYXRhLmhlYWRlckluZm8uaGVpZ2h0ICogZGF0YS5oZWFkZXJJbmZvLndpZHRoO1xuICAgICAgICB2YXIgaSA9IDAsIGsgPSAwLCBuU3RhcnQgPSAwO1xuICAgICAgICB2YXIgbWFzayA9IGRhdGEucGl4ZWxzLnJlc3VsdE1hc2s7XG4gICAgICAgIHZhciByZXN1bHRQaXhlbHMgPSBkYXRhLnBpeGVscy5yZXN1bHRQaXhlbHM7XG4gICAgICAgIGlmIChtYXNrKSB7XG4gICAgICAgICAgaWYgKG51bURpbXMgPiAxKSB7XG4gICAgICAgICAgICBpZiAodXNlQlNRRm9yT3V0cHV0RGltKSB7XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1EaW1zOyBpKyspIHtcbiAgICAgICAgICAgICAgICBuU3RhcnQgPSBpICogbnVtUGl4ZWxzO1xuICAgICAgICAgICAgICAgIHZhbCA9IG1heFZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbnVtUGl4ZWxzOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXNrW2tdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1tuU3RhcnQgKyBrXSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBudW1QaXhlbHM7IGsrKykge1xuICAgICAgICAgICAgICAgIGlmIChtYXNrW2tdKSB7XG4gICAgICAgICAgICAgICAgICBuU3RhcnQgPSBrICogbnVtRGltcztcbiAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1EaW1zOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzW25TdGFydCArIG51bURpbXNdID0gbWF4VmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBudW1QaXhlbHM7IGsrKykge1xuICAgICAgICAgICAgICBpZiAobWFza1trXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1trXSA9IHZhbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAobnVtRGltcyA+IDEgJiYgdmFsTWluICE9PSB2YWwpIHtcbiAgICAgICAgICAgIGlmICh1c2VCU1FGb3JPdXRwdXREaW0pIHtcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bURpbXM7IGkrKykge1xuICAgICAgICAgICAgICAgIG5TdGFydCA9IGkgKiBudW1QaXhlbHM7XG4gICAgICAgICAgICAgICAgdmFsID0gbWF4VmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBudW1QaXhlbHM7IGsrKykge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzW25TdGFydCArIGtdID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBudW1QaXhlbHM7IGsrKykge1xuICAgICAgICAgICAgICAgIG5TdGFydCA9IGsgKiBudW1EaW1zO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1EaW1zOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1tuU3RhcnQgKyBpXSA9IG1heFZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbnVtUGl4ZWxzICogbnVtRGltczsgaysrKSB7XG4gICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1trXSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSxcblxuICAgICAgZ2V0RGF0YVR5cGVBcnJheTogZnVuY3Rpb24odCkge1xuICAgICAgICB2YXIgdHA7XG4gICAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICAgIGNhc2UgMDogLy9jaGFyXG4gICAgICAgICAgICB0cCA9IEludDhBcnJheTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTogLy9ieXRlXG4gICAgICAgICAgICB0cCA9IFVpbnQ4QXJyYXk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6IC8vc2hvcnRcbiAgICAgICAgICAgIHRwID0gSW50MTZBcnJheTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzogLy91c2hvcnRcbiAgICAgICAgICAgIHRwID0gVWludDE2QXJyYXk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICB0cCA9IEludDMyQXJyYXk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICB0cCA9IFVpbnQzMkFycmF5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgdHAgPSBGbG9hdDMyQXJyYXk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICB0cCA9IEZsb2F0NjRBcnJheTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0cCA9IEZsb2F0MzJBcnJheTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHA7XG4gICAgICB9LFxuXG4gICAgICBnZXRQaXhlbFR5cGU6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdmFyIHRwO1xuICAgICAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgICBjYXNlIDA6IC8vY2hhclxuICAgICAgICAgICAgdHAgPSBcIlM4XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE6IC8vYnl0ZVxuICAgICAgICAgICAgdHAgPSBcIlU4XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6IC8vc2hvcnRcbiAgICAgICAgICAgIHRwID0gXCJTMTZcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzogLy91c2hvcnRcbiAgICAgICAgICAgIHRwID0gXCJVMTZcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHRwID0gXCJTMzJcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHRwID0gXCJVMzJcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHRwID0gXCJGMzJcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHRwID0gXCJGNjRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0cCA9IFwiRjMyXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRwO1xuICAgICAgfSxcblxuICAgICAgaXNWYWxpZFBpeGVsVmFsdWU6IGZ1bmN0aW9uKHQsIHZhbCkge1xuICAgICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlzVmFsaWQ7XG4gICAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICAgIGNhc2UgMDogLy9jaGFyXG4gICAgICAgICAgICBpc1ZhbGlkID0gdmFsID49IC0xMjggJiYgdmFsIDw9IDEyNztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTogLy9ieXRlICAodW5zaWduZWQgY2hhcilcbiAgICAgICAgICAgIGlzVmFsaWQgPSB2YWwgPj0gMCAmJiB2YWwgPD0gMjU1O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOiAvL3Nob3J0XG4gICAgICAgICAgICBpc1ZhbGlkID0gdmFsID49IC0zMjc2OCAmJiB2YWwgPD0gMzI3Njc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6IC8vdXNob3J0XG4gICAgICAgICAgICBpc1ZhbGlkID0gdmFsID49IDAgJiYgdmFsIDw9IDY1NTM2O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA0OiAvL2ludCAzMlxuICAgICAgICAgICAgaXNWYWxpZCA9IHZhbCA+PSAtMjE0NzQ4MzY0OCAmJiB2YWwgPD0gMjE0NzQ4MzY0NztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNTogLy91aW5pdCAzMlxuICAgICAgICAgICAgaXNWYWxpZCA9IHZhbCA+PSAwICYmIHZhbCA8PSA0Mjk0OTY3Mjk2O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgaXNWYWxpZCA9IHZhbCA+PSAtMy40MDI3OTk5Mzg3OTAxNDg0ZSszOCAmJiB2YWwgPD0gMy40MDI3OTk5Mzg3OTAxNDg0ZSszODtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIGlzVmFsaWQgPSB2YWwgPj0gLTEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4ICYmIHZhbCA8PSAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwODtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzVmFsaWQ7XG4gICAgICB9LFxuXG4gICAgICBnZXREYXRhVHlwZVNpemU6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdmFyIHMgPSAwO1xuICAgICAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgICBjYXNlIDA6IC8vdWJ5dGVcbiAgICAgICAgICBjYXNlIDE6IC8vYnl0ZVxuICAgICAgICAgICAgcyA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6IC8vc2hvcnRcbiAgICAgICAgICBjYXNlIDM6IC8vdXNob3J0XG4gICAgICAgICAgICBzID0gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgcyA9IDQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBzID0gODtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBzID0gdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcztcbiAgICAgIH0sXG5cbiAgICAgIGdldERhdGFUeXBlVXNlZDogZnVuY3Rpb24oZHQsIHRjKSB7XG4gICAgICAgIHZhciB0ID0gZHQ7XG4gICAgICAgIHN3aXRjaCAoZHQpIHtcbiAgICAgICAgICBjYXNlIDI6IC8vc2hvcnRcbiAgICAgICAgICBjYXNlIDQ6IC8vbG9uZ1xuICAgICAgICAgICAgdCA9IGR0IC0gdGM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6IC8vdXNob3J0XG4gICAgICAgICAgY2FzZSA1OiAvL3Vsb25nXG4gICAgICAgICAgICB0ID0gZHQgLSAyICogdGM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDY6IC8vZmxvYXRcbiAgICAgICAgICAgIGlmICgwID09PSB0Yykge1xuICAgICAgICAgICAgICB0ID0gZHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgxID09PSB0Yykge1xuICAgICAgICAgICAgICB0ID0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0ID0gMTsvL2J5dGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNzogLy9kb3VibGVcbiAgICAgICAgICAgIGlmICgwID09PSB0Yykge1xuICAgICAgICAgICAgICB0ID0gZHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdCA9IGR0IC0gMiAqIHRjICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0ID0gZHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICAgIH0sXG5cbiAgICAgIGdldE9uZVBpeGVsOiBmdW5jdGlvbihibG9jaywgYmxvY2tQdHIsIG9mZnNldFR5cGUsIHZpZXcpIHtcbiAgICAgICAgdmFyIHRlbXAgPSAwO1xuICAgICAgICBzd2l0Y2ggKG9mZnNldFR5cGUpIHtcbiAgICAgICAgICBjYXNlIDA6IC8vY2hhclxuICAgICAgICAgICAgdGVtcCA9IHZpZXcuZ2V0SW50OChibG9ja1B0cik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE6IC8vYnl0ZVxuICAgICAgICAgICAgdGVtcCA9IHZpZXcuZ2V0VWludDgoYmxvY2tQdHIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdGVtcCA9IHZpZXcuZ2V0SW50MTYoYmxvY2tQdHIsIHRydWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgdGVtcCA9IHZpZXcuZ2V0VWludDE2KGJsb2NrUHRyLCB0cnVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHRlbXAgPSB2aWV3LmdldEludDMyKGJsb2NrUHRyLCB0cnVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHRlbXAgPSB2aWV3LmdldFVJbnQzMihibG9ja1B0ciwgdHJ1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICB0ZW1wID0gdmlldy5nZXRGbG9hdDMyKGJsb2NrUHRyLCB0cnVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHRlbXAgPSB2aWV3LmdldEZsb2F0NjQoYmxvY2tQdHIsIHRydWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IChcInRoZSBkZWNvZGVyIGRvZXMgbm90IHVuZGVyc3RhbmQgdGhpcyBwaXhlbCB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW1wO1xuICAgICAgfSxcblxuICAgICAgc3dhcERpbWVuc2lvbk9yZGVyOiBmdW5jdGlvbihwaXhlbHMsIG51bVBpeGVscywgbnVtRGltcywgT3V0UGl4ZWxUeXBlQXJyYXksIGlucHV0SXNCSVApIHtcbiAgICAgICAgdmFyIGkgPSAwLCBqID0gMCwgaURpbSA9IDAsIHRlbXAgPSAwLCBzd2FwID0gcGl4ZWxzO1xuICAgICAgICBpZiAobnVtRGltcyA+IDEpIHtcbiAgICAgICAgICBzd2FwID0gbmV3IE91dFBpeGVsVHlwZUFycmF5KG51bVBpeGVscyAqIG51bURpbXMpO1xuICAgICAgICAgIGlmIChpbnB1dElzQklQKSB7XG4gICAgICAgICAgICBmb3IgKGk9MDsgaTxudW1QaXhlbHM7IGkrKykge1xuICAgICAgICAgICAgICB0ZW1wID0gaTtcbiAgICAgICAgICAgICAgZm9yIChpRGltPTA7IGlEaW0gPCBudW1EaW1zOyBpRGltKyssIHRlbXAgKz0gbnVtUGl4ZWxzKSB7XG4gICAgICAgICAgICAgICAgc3dhcFt0ZW1wXSA9IHBpeGVsc1tqKytdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICBcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGk9MDsgaTxudW1QaXhlbHM7IGkrKykge1xuICAgICAgICAgICAgICB0ZW1wID0gaTtcbiAgICAgICAgICAgICAgZm9yIChpRGltPTA7IGlEaW0gPCBudW1EaW1zOyBpRGltKyssIHRlbXAgKz0gbnVtUGl4ZWxzKSB7XG4gICAgICAgICAgICAgICAgc3dhcFtqKytdID0gcGl4ZWxzW3RlbXBdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzd2FwO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgKnByaXZhdGUgY2xhc3MgZm9yIGEgdHJlZSBub2RlLiBIdWZmbWFuIGNvZGUgaXMgaW4gTGVyYzJIZWxwZXJzXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICB2YXIgVHJlZU5vZGUgPSBmdW5jdGlvbih2YWwsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICB0aGlzLnZhbCA9IHZhbDtcbiAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgfTtcblxuICAgIHZhciBMZXJjMkRlY29kZSA9IHtcbiAgICAgIC8qXG4gICAgICAqICoqKioqKioqcmVtb3ZlZCBvcHRpb25zIGNvbXBhcmVkIHRvIExFUkMxLiBXZSBjYW4gYnJpbmcgc29tZSBvZiB0aGVtIGJhY2sgaWYgbmVlZGVkLlxuICAgICAgICogcmVtb3ZlZCBwaXhlbCB0eXBlLiBMRVJDMiBpcyB0eXBlZCBhbmQgZG9lc24ndCByZXF1aXJlIHVzZXIgdG8gZ2l2ZSBwaXhlbCB0eXBlXG4gICAgICAgKiBjaGFuZ2VkIGVuY29kZWRNYXNrRGF0YSB0byBtYXNrRGF0YS4gTEVSQzIgJ3MganMgdmVyc2lvbiBtYWtlIGl0IGZhc3RlciB0byB1c2UgbWFza0RhdGEgZGlyZWN0bHkuXG4gICAgICAgKiByZW1vdmVkIHJldHVybk1hc2suIG1hc2sgaXMgdXNlZCBieSBMRVJDMiBpbnRlcm5hbGx5IGFuZCBpcyBjb3N0IGZyZWUuIEluIGNhc2Ugb2YgdXNlciBpbnB1dCBtYXNrLCBpdCdzIHJldHVybmVkIGFzIHdlbGwgYW5kIGhhcyBuZWdsaWJsZSBjb3N0LlxuICAgICAgICogcmVtb3ZlZCBub2RhdGF2YWx1ZS4gQmVjYXVzZSBMRVJDMiBwaXhlbHMgYXJlIHR5cGVkLCBub2RhdGF2YWx1ZSB3aWxsIHNhY3JpZnkgYSB1c2VmdWwgdmFsdWUgZm9yIG1hbnkgdHlwZXMgKDhiaXQsIDE2Yml0KSBldGMsXG4gICAgICAgKiAgICAgICB1c2VyIGhhcyB0byBiZSBrbm93bGVkZ2FibGUgZW5vdWdoIGFib3V0IHJhc3RlciBhbmQgdGhlaXIgZGF0YSB0byBhdm9pZCB1c2FiaWxpdHkgaXNzdWVzLiBzbyBub2RhdGEgdmFsdWUgaXMgc2ltcGx5IHJlbW92ZWQgbm93LlxuICAgICAgICogICAgICAgV2UgY2FuIGFkZCBpdCBiYWNrIGxhdGVyIGlmIHRoZWlyJ3MgYSBjbGVhciByZXF1aXJlbWVudC5cbiAgICAgICAqIHJlbW92ZWQgZW5jb2RlZE1hc2suIFRoaXMgb3B0aW9uIHdhcyBub3QgaW1wbGVtZW50ZWQgaW4gTGVyY0RlY29kZS4gSXQgY2FuIGJlIGRvbmUgYWZ0ZXIgZGVjb2RpbmcgKGxlc3MgZWZmaWNpZW50KVxuICAgICAgICogcmVtb3ZlZCBjb21wdXRlVXNlZEJpdERlcHRocy5cbiAgICAgICAqXG4gICAgICAgKlxuICAgICAgICogcmVzcG9uc2UgY2hhbmdlcyBjb21wYXJlZCB0byBMRVJDMVxuICAgICAgICogMS4gZW5jb2RlZE1hc2tEYXRhIGlzIG5vdCBhdmFpbGFibGVcbiAgICAgICAqIDIuIG5vRGF0YVZhbHVlIGlzIG9wdGlvbmFsIChyZXR1cm5zIG9ubHkgaWYgdXNlcidzIG5vRGF0YVZhbHVlIGlzIHdpdGggaW4gdGhlIHZhbGlkIGRhdGEgdHlwZSByYW5nZSlcbiAgICAgICAqIDMuIG1hc2tEYXRhIGlzIGFsd2F5cyBhdmFpbGFibGVcbiAgICAgICovXG4gICAgICAvKioqKioqKioqKioqKioqKipcbiAgICAgICogIHB1YmxpYyBwcm9wZXJ0aWVzXG4gICAgICAqKioqKioqKioqKioqKioqKiovXG4gICAgICAvL0hVRkZNQU5fTFVUX0JJVFNfTUFYOiAxMiwgLy91c2UgMl4xMiBsdXQsIG5vdCBjb25maWd1cmFibGVcblxuICAgICAgLyoqKioqKioqKioqKioqKioqXG4gICAgICAqICBwdWJsaWMgbWV0aG9kc1xuICAgICAgKioqKioqKioqKioqKioqKiovXG5cbiAgICAgIC8qKlxuICAgICAgICogRGVjb2RlIGEgTEVSQzIgYnl0ZSBzdHJlYW0gYW5kIHJldHVybiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgcGl4ZWwgZGF0YSBhbmQgb3B0aW9uYWwgbWV0YWRhdGEuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gaW5wdXQgVGhlIExFUkMgaW5wdXQgYnl0ZSBzdHJlYW1cbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gb3B0aW9ucyBEZWNvZGluZyBvcHRpb25zXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuaW5wdXRPZmZzZXRdIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBpbiB0aGUgaW5wdXQgYnl0ZSBzdHJlYW0uIEEgdmFsaWQgTEVSQyBmaWxlIGlzIGV4cGVjdGVkIGF0IHRoYXQgcG9zaXRpb25cbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmV0dXJuRmlsZUluZm9dIElmIHRydWUsIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBoYXZlIGEgZmlsZUluZm8gcHJvcGVydHkgdGhhdCBjb250YWlucyBtZXRhZGF0YSBvYnRhaW5lZCBmcm9tIHRoZSBMRVJDIGhlYWRlcnMgYW5kIHRoZSBkZWNvZGluZyBwcm9jZXNzXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJldHVyblBpeGVsSW50ZXJsZWF2ZWREaW1zXSAgSWYgdHJ1ZSwgcmV0dXJuZWQgZGltZW5zaW9ucyBhcmUgcGl4ZWwtaW50ZXJsZWF2ZWQsIGEuay5hIFtwMV9kaW0wLCBwMV9kaW0xLCBwMV9kaW1uLCBwMl9kaW0wLi4uXSwgZGVmYXVsdCBpcyBbcDFfZGltMCwgcDJfZGltMCwgLi4uLCBwMV9kaW0xLCBwMl9kaW0xLi4uXVxuICAgICAgICovXG4gICAgICBkZWNvZGU6IGZ1bmN0aW9uKC8qYnl0ZSBhcnJheSovIGlucHV0LCAvKm9iamVjdCovIG9wdGlvbnMpIHtcbiAgICAgICAgLy9jdXJyZW50bHkgdGhlcmUncyBhIGJ1ZyBpbiB0aGUgc3BhcnNlIGFycmF5LCBzbyBwbGVhc2UgZG8gbm90IHNldCB0byBmYWxzZVxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdmFyIG5vRGF0YVZhbHVlID0gb3B0aW9ucy5ub0RhdGFWYWx1ZTtcblxuICAgICAgICAvL2luaXRpYWxpemVcbiAgICAgICAgdmFyIGkgPSAwLCBkYXRhID0ge307XG4gICAgICAgIGRhdGEucHRyID0gb3B0aW9ucy5pbnB1dE9mZnNldCB8fCAwO1xuICAgICAgICBkYXRhLnBpeGVscyA9IHt9O1xuXG4gICAgICAgIC8vIEZpbGUgaGVhZGVyXG4gICAgICAgIGlmICghTGVyYzJIZWxwZXJzLnJlYWRIZWFkZXJJbmZvKGlucHV0LCBkYXRhKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoZWFkZXJJbmZvID0gZGF0YS5oZWFkZXJJbmZvO1xuICAgICAgICB2YXIgZmlsZVZlcnNpb24gPSBoZWFkZXJJbmZvLmZpbGVWZXJzaW9uO1xuICAgICAgICB2YXIgT3V0UGl4ZWxUeXBlQXJyYXkgPSBMZXJjMkhlbHBlcnMuZ2V0RGF0YVR5cGVBcnJheShoZWFkZXJJbmZvLmltYWdlVHlwZSk7XG5cbiAgICAgICAgLy8gdmVyc2lvbiBjaGVja1xuICAgICAgICBpZiAoZmlsZVZlcnNpb24gPiA1KSB7XG4gICAgICAgICAgdGhyb3cgXCJ1bnN1cHBvcnRlZCBsZXJjIHZlcnNpb24gMi5cIiArIGZpbGVWZXJzaW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWFzayBIZWFkZXJcbiAgICAgICAgTGVyYzJIZWxwZXJzLnJlYWRNYXNrKGlucHV0LCBkYXRhKTtcbiAgICAgICAgaWYgKGhlYWRlckluZm8ubnVtVmFsaWRQaXhlbCAhPT0gaGVhZGVySW5mby53aWR0aCAqIGhlYWRlckluZm8uaGVpZ2h0ICYmICFkYXRhLnBpeGVscy5yZXN1bHRNYXNrKSB7XG4gICAgICAgICAgZGF0YS5waXhlbHMucmVzdWx0TWFzayA9IG9wdGlvbnMubWFza0RhdGE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbnVtUGl4ZWxzID0gaGVhZGVySW5mby53aWR0aCAqIGhlYWRlckluZm8uaGVpZ2h0O1xuICAgICAgICBkYXRhLnBpeGVscy5yZXN1bHRQaXhlbHMgPSBuZXcgT3V0UGl4ZWxUeXBlQXJyYXkobnVtUGl4ZWxzICogaGVhZGVySW5mby5udW1EaW1zKTtcblxuICAgICAgICBkYXRhLmNvdW50ZXIgPSB7XG4gICAgICAgICAgb25lc3dlZXA6IDAsXG4gICAgICAgICAgdW5jb21wcmVzc2VkOiAwLFxuICAgICAgICAgIGx1dDogMCxcbiAgICAgICAgICBiaXRzdHVmZmVyOiAwLFxuICAgICAgICAgIGNvbnN0YW50OiAwLFxuICAgICAgICAgIGNvbnN0YW50b2Zmc2V0OiAwXG4gICAgICAgIH07XG4gICAgICAgIHZhciB1c2VCU1FGb3JPdXRwdXREaW0gPSAhb3B0aW9ucy5yZXR1cm5QaXhlbEludGVybGVhdmVkRGltcztcbiAgICAgICAgaWYgKGhlYWRlckluZm8ubnVtVmFsaWRQaXhlbCAhPT0gMCkge1xuICAgICAgICAgIC8vbm90IHRlc3RlZFxuICAgICAgICAgIGlmIChoZWFkZXJJbmZvLnpNYXggPT09IGhlYWRlckluZm8uek1pbikgLy9jb25zdGFudCBzdXJmYWNlXG4gICAgICAgICAge1xuICAgICAgICAgICAgTGVyYzJIZWxwZXJzLmNvbnN0cnVjdENvbnN0YW50U3VyZmFjZShkYXRhLCB1c2VCU1FGb3JPdXRwdXREaW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChmaWxlVmVyc2lvbiA+PSA0ICYmIExlcmMySGVscGVycy5jaGVja01pbk1heFJhbmdlcyhpbnB1dCwgZGF0YSkpIHtcbiAgICAgICAgICAgIExlcmMySGVscGVycy5jb25zdHJ1Y3RDb25zdGFudFN1cmZhY2UoZGF0YSwgdXNlQlNRRm9yT3V0cHV0RGltKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhpbnB1dCwgZGF0YS5wdHIsIDIpO1xuICAgICAgICAgICAgdmFyIGJSZWFkRGF0YU9uZVN3ZWVwID0gdmlldy5nZXRVaW50OCgwKTtcbiAgICAgICAgICAgIGRhdGEucHRyKys7XG4gICAgICAgICAgICBpZiAoYlJlYWREYXRhT25lU3dlZXApIHtcbiAgICAgICAgICAgICAgLy9jb25zb2xlLmRlYnVnKFwiT25lU3dlZXBcIik7XG4gICAgICAgICAgICAgIExlcmMySGVscGVycy5yZWFkRGF0YU9uZVN3ZWVwKGlucHV0LCBkYXRhLCBPdXRQaXhlbFR5cGVBcnJheSwgdXNlQlNRRm9yT3V0cHV0RGltKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvL2xlcmMyLjE6IC8vYml0c3R1ZmZpbmcgKyBsdXRcbiAgICAgICAgICAgICAgLy9sZXJjMi4yOiAvL2JpdHN0dWZmaW5nICsgbHV0ICsgaHVmZm1hblxuICAgICAgICAgICAgICAvL2xlcmMyLjM6IG5ldyBiaXRzdHVmZmVyXG4gICAgICAgICAgICAgIGlmIChmaWxlVmVyc2lvbiA+IDEgJiYgaGVhZGVySW5mby5pbWFnZVR5cGUgPD0gMSAmJiBNYXRoLmFicyhoZWFkZXJJbmZvLm1heFpFcnJvciAtIDAuNSkgPCAwLjAwMDAxKSB7XG4gICAgICAgICAgICAgICAgLy90aGlzIGlzIDIueCBwbHVzIDggYml0ICh1bnNpZ25lZCBhbmQgc2lnbmVkKSBkYXRhLCBwb3NzaWJsaXR5IG9mIEh1ZmZtYW5cbiAgICAgICAgICAgICAgICB2YXIgZmxhZ0h1ZmZtYW4gPSB2aWV3LmdldFVpbnQ4KDEpO1xuICAgICAgICAgICAgICAgIGRhdGEucHRyKys7XG4gICAgICAgICAgICAgICAgZGF0YS5lbmNvZGVNb2RlID0gZmxhZ0h1ZmZtYW47XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdIdWZmbWFuID4gMiB8fCAoZmlsZVZlcnNpb24gPCA0ICYmIGZsYWdIdWZmbWFuID4gMSkpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IFwiSW52YWxpZCBIdWZmbWFuIGZsYWcgXCIgKyBmbGFnSHVmZm1hbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdIdWZmbWFuKSB7Ly8xIC0gZGVsdGEgSHVmZm1hbiwgMiAtIEh1ZmZtYW5cbiAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJIdWZmbWFuXCIpO1xuICAgICAgICAgICAgICAgICAgTGVyYzJIZWxwZXJzLnJlYWRIdWZmbWFuKGlucHV0LCBkYXRhLCBPdXRQaXhlbFR5cGVBcnJheSwgdXNlQlNRRm9yT3V0cHV0RGltKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiVGlsZXNcIik7XG4gICAgICAgICAgICAgICAgICBMZXJjMkhlbHBlcnMucmVhZFRpbGVzKGlucHV0LCBkYXRhLCBPdXRQaXhlbFR5cGVBcnJheSwgdXNlQlNRRm9yT3V0cHV0RGltKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7IC8vbGVyYzIueCBub24tOCBiaXQgZGF0YVxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJUaWxlc1wiKTtcbiAgICAgICAgICAgICAgICBMZXJjMkhlbHBlcnMucmVhZFRpbGVzKGlucHV0LCBkYXRhLCBPdXRQaXhlbFR5cGVBcnJheSwgdXNlQlNRRm9yT3V0cHV0RGltKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEuZW9mT2Zmc2V0ID0gZGF0YS5wdHI7XG4gICAgICAgIHZhciBkaWZmO1xuICAgICAgICBpZiAob3B0aW9ucy5pbnB1dE9mZnNldCkge1xuICAgICAgICAgIGRpZmYgPSBkYXRhLmhlYWRlckluZm8uYmxvYlNpemUgKyBvcHRpb25zLmlucHV0T2Zmc2V0IC0gZGF0YS5wdHI7XG4gICAgICAgICAgaWYgKE1hdGguYWJzKGRpZmYpID49IDEpIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5kZWJ1ZyhcImluY29ycmVjdCBlb2Y6IGRhdGFwdHIgXCIgKyBkYXRhLnB0ciArIFwiIG9mZnNldCBcIiArIG9wdGlvbnMuaW5wdXRPZmZzZXQgKyBcIiBibG9ic2l6ZSBcIiArIGRhdGEuaGVhZGVySW5mby5ibG9iU2l6ZSArIFwiIGRpZmY6IFwiICsgZGlmZik7XG4gICAgICAgICAgICBkYXRhLmVvZk9mZnNldCA9IG9wdGlvbnMuaW5wdXRPZmZzZXQgKyBkYXRhLmhlYWRlckluZm8uYmxvYlNpemU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRpZmYgPSBkYXRhLmhlYWRlckluZm8uYmxvYlNpemUgLSBkYXRhLnB0cjtcbiAgICAgICAgICBpZiAoTWF0aC5hYnMoZGlmZikgPj0gMSkge1xuICAgICAgICAgICAgLy9jb25zb2xlLmRlYnVnKFwiaW5jb3JyZWN0IGZpcnN0IGJhbmQgZW9mOiBkYXRhcHRyIFwiICsgZGF0YS5wdHIgKyBcIiBibG9ic2l6ZSBcIiArIGRhdGEuaGVhZGVySW5mby5ibG9iU2l6ZSArIFwiIGRpZmY6IFwiICsgZGlmZik7XG4gICAgICAgICAgICBkYXRhLmVvZk9mZnNldCA9IGRhdGEuaGVhZGVySW5mby5ibG9iU2l6ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgIHdpZHRoOiBoZWFkZXJJbmZvLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVhZGVySW5mby5oZWlnaHQsXG4gICAgICAgICAgcGl4ZWxEYXRhOiBkYXRhLnBpeGVscy5yZXN1bHRQaXhlbHMsXG4gICAgICAgICAgbWluVmFsdWU6IGhlYWRlckluZm8uek1pbixcbiAgICAgICAgICBtYXhWYWx1ZTogaGVhZGVySW5mby56TWF4LFxuICAgICAgICAgIHZhbGlkUGl4ZWxDb3VudDogaGVhZGVySW5mby5udW1WYWxpZFBpeGVsLFxuICAgICAgICAgIGRpbUNvdW50OiBoZWFkZXJJbmZvLm51bURpbXMsXG4gICAgICAgICAgZGltU3RhdHM6IHtcbiAgICAgICAgICAgIG1pblZhbHVlczogaGVhZGVySW5mby5taW5WYWx1ZXMsXG4gICAgICAgICAgICBtYXhWYWx1ZXM6IGhlYWRlckluZm8ubWF4VmFsdWVzXG4gICAgICAgICAgfSxcbiAgICAgICAgICBtYXNrRGF0YTogZGF0YS5waXhlbHMucmVzdWx0TWFza1xuICAgICAgICAgIC8vbm9EYXRhVmFsdWU6IG5vRGF0YVZhbHVlXG4gICAgICAgIH07XG5cbiAgICAgICAgLy93ZSBzaG91bGQgcmVtb3ZlIHRoaXMgaWYgdGhlcmUncyBubyBleGlzdGluZyBjbGllbnRcbiAgICAgICAgLy9vcHRpb25hbCBub0RhdGFWYWx1ZSBwcm9jZXNzaW5nLCBpdCdzIHVzZXIncyByZXNwb25zaWJsaXR5XG4gICAgICAgIGlmIChkYXRhLnBpeGVscy5yZXN1bHRNYXNrICYmIExlcmMySGVscGVycy5pc1ZhbGlkUGl4ZWxWYWx1ZShoZWFkZXJJbmZvLmltYWdlVHlwZSwgbm9EYXRhVmFsdWUpKSB7XG4gICAgICAgICAgdmFyIG1hc2sgPSBkYXRhLnBpeGVscy5yZXN1bHRNYXNrO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1QaXhlbHM7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFtYXNrW2ldKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5waXhlbERhdGFbaV0gPSBub0RhdGFWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0Lm5vRGF0YVZhbHVlID0gbm9EYXRhVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YS5ub0RhdGFWYWx1ZSA9IG5vRGF0YVZhbHVlO1xuICAgICAgICBpZiAob3B0aW9ucy5yZXR1cm5GaWxlSW5mbykge1xuICAgICAgICAgIHJlc3VsdC5maWxlSW5mbyA9IExlcmMySGVscGVycy5mb3JtYXRGaWxlSW5mbyhkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcblxuICAgICAgZ2V0QmFuZENvdW50OiBmdW5jdGlvbigvKmJ5dGUgYXJyYXkqLyBpbnB1dCkge1xuICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciB0ZW1wID0ge307XG4gICAgICAgIHRlbXAucHRyID0gMDtcbiAgICAgICAgdGVtcC5waXhlbHMgPSB7fTtcbiAgICAgICAgd2hpbGUgKGkgPCBpbnB1dC5ieXRlTGVuZ3RoIC0gNTgpIHtcbiAgICAgICAgICBMZXJjMkhlbHBlcnMucmVhZEhlYWRlckluZm8oaW5wdXQsIHRlbXApO1xuICAgICAgICAgIGkgKz0gdGVtcC5oZWFkZXJJbmZvLmJsb2JTaXplO1xuICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgdGVtcC5wdHIgPSBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIExlcmMyRGVjb2RlO1xuICB9KSgpO1xuXG4gIHZhciBpc1BsYXRmb3JtTGl0dGxlRW5kaWFuID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBhID0gbmV3IEFycmF5QnVmZmVyKDQpO1xuICAgIHZhciBiID0gbmV3IFVpbnQ4QXJyYXkoYSk7XG4gICAgdmFyIGMgPSBuZXcgVWludDMyQXJyYXkoYSk7XG4gICAgY1swXSA9IDE7XG4gICAgcmV0dXJuIGJbMF0gPT09IDE7XG4gIH0pKCk7XG5cbiAgdmFyIExlcmMgPSB7XG4gICAgLyoqKioqKioqKioqKndyYXBwZXIqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgIC8qKlxuICAgICAqIEEgd3JhcHBlciBmb3IgZGVjb2RpbmcgYm90aCBMRVJDMSBhbmQgTEVSQzIgYnl0ZSBzdHJlYW1zIGNhcGFibGUgb2YgaGFuZGxpbmcgbXVsdGliYW5kIHBpeGVsIGJsb2NrcyBmb3IgdmFyaW91cyBwaXhlbCB0eXBlcy5cbiAgICAgKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6TGVyY1xuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGlucHV0IFRoZSBMRVJDIGlucHV0IGJ5dGUgc3RyZWFtXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBUaGUgZGVjb2Rpbmcgb3B0aW9ucyBiZWxvdyBhcmUgb3B0aW9uYWwuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmlucHV0T2Zmc2V0XSBUaGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgaW4gdGhlIGlucHV0IGJ5dGUgc3RyZWFtLiBBIHZhbGlkIExlcmMgZmlsZSBpcyBleHBlY3RlZCBhdCB0aGF0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5waXhlbFR5cGVdIChMRVJDMSBvbmx5KSBEZWZhdWx0IHZhbHVlIGlzIEYzMi4gVmFsaWQgcGl4ZWwgdHlwZXMgZm9yIGlucHV0IGFyZSBVOC9TOC9TMTYvVTE2L1MzMi9VMzIvRjMyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5ub0RhdGFWYWx1ZV0gKExFUkMxIG9ubHkpLiBJdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgdGhlIHJldHVybmVkIG1hc2sgaW5zdGVhZCBvZiBzZXR0aW5nIHRoaXMgdmFsdWUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZXR1cm5QaXhlbEludGVybGVhdmVkRGltc10gKG5EaW0gTEVSQzIgb25seSkgSWYgdHJ1ZSwgcmV0dXJuZWQgZGltZW5zaW9ucyBhcmUgcGl4ZWwtaW50ZXJsZWF2ZWQsIGEuay5hIFtwMV9kaW0wLCBwMV9kaW0xLCBwMV9kaW1uLCBwMl9kaW0wLi4uXSwgZGVmYXVsdCBpcyBbcDFfZGltMCwgcDJfZGltMCwgLi4uLCBwMV9kaW0xLCBwMl9kaW0xLi4uXVxuICAgICAqIEByZXR1cm5zIHt7d2lkdGgsIGhlaWdodCwgcGl4ZWxzLCBwaXhlbFR5cGUsIG1hc2ssIHN0YXRpc3RpY3N9fVxuICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHdpZHRoIFdpZHRoIG9mIGRlY29kZWQgaW1hZ2UuXG4gICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0IEhlaWdodCBvZiBkZWNvZGVkIGltYWdlLlxuICAgICAgICogQHByb3BlcnR5IHthcnJheX0gcGl4ZWxzIFtiYW5kMSwgYmFuZDIsIOKApl0gRWFjaCBiYW5kIGlzIGEgdHlwZWQgYXJyYXkgb2Ygd2lkdGgqaGVpZ2h0LlxuICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHBpeGVsVHlwZSBUaGUgdHlwZSBvZiBwaXhlbHMgcmVwcmVzZW50ZWQgaW4gdGhlIG91dHB1dC5cbiAgICAgICAqIEBwcm9wZXJ0eSB7bWFza30gbWFzayBUeXBlZCBhcnJheSB3aXRoIGEgc2l6ZSBvZiB3aWR0aCpoZWlnaHQsIG9yIG51bGwgaWYgYWxsIHBpeGVscyBhcmUgdmFsaWQuXG4gICAgICAgKiBAcHJvcGVydHkge2FycmF5fSBzdGF0aXN0aWNzIFtzdGF0aXN0aWNzX2JhbmQxLCBzdGF0aXN0aWNzX2JhbmQyLCDigKZdIEVhY2ggZWxlbWVudCBpcyBhIHN0YXRpc3RpY3Mgb2JqZWN0IHJlcHJlc2VudGluZyBtaW4gYW5kIG1heCB2YWx1ZXNcbiAgICAqKi9cbiAgICBkZWNvZGU6IGZ1bmN0aW9uKGVuY29kZWREYXRhLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIWlzUGxhdGZvcm1MaXR0bGVFbmRpYW4pIHtcbiAgICAgICAgdGhyb3cgXCJCaWcgZW5kaWFuIHN5c3RlbSBpcyBub3Qgc3VwcG9ydGVkLlwiO1xuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB2YXIgaW5wdXRPZmZzZXQgPSBvcHRpb25zLmlucHV0T2Zmc2V0IHx8IDA7XG4gICAgICB2YXIgZmlsZUlkVmlldyA9IG5ldyBVaW50OEFycmF5KGVuY29kZWREYXRhLCBpbnB1dE9mZnNldCwgMTApO1xuICAgICAgdmFyIGZpbGVJZGVudGlmaWVyU3RyaW5nID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBmaWxlSWRWaWV3KTtcbiAgICAgIHZhciBsZXJjLCBtYWpvclZlcnNpb247XG4gICAgICBpZiAoZmlsZUlkZW50aWZpZXJTdHJpbmcudHJpbSgpID09PSBcIkNudFpJbWFnZVwiKSB7XG4gICAgICAgIGxlcmMgPSBMZXJjRGVjb2RlO1xuICAgICAgICBtYWpvclZlcnNpb24gPSAxO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZmlsZUlkZW50aWZpZXJTdHJpbmcuc3Vic3RyaW5nKDAsIDUpID09PSBcIkxlcmMyXCIpIHtcbiAgICAgICAgbGVyYyA9IExlcmMyRGVjb2RlO1xuICAgICAgICBtYWpvclZlcnNpb24gPSAyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IFwiVW5leHBlY3RlZCBmaWxlIGlkZW50aWZpZXIgc3RyaW5nOiBcIiArIGZpbGVJZGVudGlmaWVyU3RyaW5nO1xuICAgICAgfVxuXG4gICAgICB2YXIgaVBsYW5lID0gMCwgZW9mID0gZW5jb2RlZERhdGEuYnl0ZUxlbmd0aCAtIDEwLCBlbmNvZGVkTWFza0RhdGEsIGJhbmRNYXNrcyA9IFtdLCBiYW5kTWFzaywgbWFza0RhdGE7XG4gICAgICB2YXIgZGVjb2RlZFBpeGVsQmxvY2sgPSB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIHBpeGVsczogW10sXG4gICAgICAgIHBpeGVsVHlwZTogb3B0aW9ucy5waXhlbFR5cGUsXG4gICAgICAgIG1hc2s6IG51bGwsXG4gICAgICAgIHN0YXRpc3RpY3M6IFtdXG4gICAgICB9O1xuICAgICAgdmFyIHVuaXF1ZUJhbmRNYXNrQ291bnQgPSAwO1xuXG4gICAgICB3aGlsZSAoaW5wdXRPZmZzZXQgPCBlb2YpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGxlcmMuZGVjb2RlKGVuY29kZWREYXRhLCB7XG4gICAgICAgICAgaW5wdXRPZmZzZXQ6IGlucHV0T2Zmc2V0LC8vZm9yIGJvdGggbGVyYzEgYW5kIGxlcmMyXG4gICAgICAgICAgZW5jb2RlZE1hc2tEYXRhOiBlbmNvZGVkTWFza0RhdGEsLy9sZXJjMSBvbmx5XG4gICAgICAgICAgbWFza0RhdGE6IG1hc2tEYXRhLC8vbGVyYzIgb25seVxuICAgICAgICAgIHJldHVybk1hc2s6IGlQbGFuZSA9PT0gMCA/IHRydWUgOiBmYWxzZSwvL2xlcmMxIG9ubHlcbiAgICAgICAgICByZXR1cm5FbmNvZGVkTWFzazogaVBsYW5lID09PSAwID8gdHJ1ZSA6IGZhbHNlLC8vbGVyYzEgb25seVxuICAgICAgICAgIHJldHVybkZpbGVJbmZvOiB0cnVlLC8vZm9yIGJvdGggbGVyYzEgYW5kIGxlcmMyXG4gICAgICAgICAgcmV0dXJuUGl4ZWxJbnRlcmxlYXZlZERpbXM6IG9wdGlvbnMucmV0dXJuUGl4ZWxJbnRlcmxlYXZlZERpbXMsLy9mb3IgbmRpbSBsZXJjMiBvbmx5XG4gICAgICAgICAgcGl4ZWxUeXBlOiBvcHRpb25zLnBpeGVsVHlwZSB8fCBudWxsLC8vbGVyYzEgb25seVxuICAgICAgICAgIG5vRGF0YVZhbHVlOiBvcHRpb25zLm5vRGF0YVZhbHVlIHx8IG51bGwvL2xlcmMxIG9ubHlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaW5wdXRPZmZzZXQgPSByZXN1bHQuZmlsZUluZm8uZW9mT2Zmc2V0O1xuICAgICAgICBtYXNrRGF0YSA9IHJlc3VsdC5tYXNrRGF0YTsvL2xlcmMyXG4gICAgICAgIGlmIChpUGxhbmUgPT09IDApIHtcbiAgICAgICAgICBlbmNvZGVkTWFza0RhdGEgPSByZXN1bHQuZW5jb2RlZE1hc2tEYXRhOy8vbGVyYzFcbiAgICAgICAgICBkZWNvZGVkUGl4ZWxCbG9jay53aWR0aCA9IHJlc3VsdC53aWR0aDtcbiAgICAgICAgICBkZWNvZGVkUGl4ZWxCbG9jay5oZWlnaHQgPSByZXN1bHQuaGVpZ2h0O1xuICAgICAgICAgIGRlY29kZWRQaXhlbEJsb2NrLmRpbUNvdW50ID0gcmVzdWx0LmRpbUNvdW50IHx8IDE7XG4gICAgICAgICAgLy9kZWNvZGVkUGl4ZWxCbG9jay5kaW1TdGF0cyA9IGRlY29kZWRQaXhlbEJsb2NrLmRpbVN0YXRzO1xuICAgICAgICAgIGRlY29kZWRQaXhlbEJsb2NrLnBpeGVsVHlwZSA9IHJlc3VsdC5waXhlbFR5cGUgfHwgcmVzdWx0LmZpbGVJbmZvLnBpeGVsVHlwZTtcbiAgICAgICAgICBkZWNvZGVkUGl4ZWxCbG9jay5tYXNrID0gbWFza0RhdGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ham9yVmVyc2lvbiA+IDEpIHtcbiAgICAgICAgICBpZiAobWFza0RhdGEpIHtcbiAgICAgICAgICAgIGJhbmRNYXNrcy5wdXNoKG1hc2tEYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdC5maWxlSW5mby5tYXNrICYmIHJlc3VsdC5maWxlSW5mby5tYXNrLm51bUJ5dGVzID4gMCkge1xuICAgICAgICAgICAgdW5pcXVlQmFuZE1hc2tDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlQbGFuZSsrO1xuICAgICAgICBkZWNvZGVkUGl4ZWxCbG9jay5waXhlbHMucHVzaChyZXN1bHQucGl4ZWxEYXRhKTtcbiAgICAgICAgZGVjb2RlZFBpeGVsQmxvY2suc3RhdGlzdGljcy5wdXNoKHtcbiAgICAgICAgICBtaW5WYWx1ZTogcmVzdWx0Lm1pblZhbHVlLFxuICAgICAgICAgIG1heFZhbHVlOiByZXN1bHQubWF4VmFsdWUsXG4gICAgICAgICAgbm9EYXRhVmFsdWU6IHJlc3VsdC5ub0RhdGFWYWx1ZSxcbiAgICAgICAgICBkaW1TdGF0czogcmVzdWx0LmRpbVN0YXRzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdmFyIGksIGosIG51bVBpeGVscztcbiAgICAgIGlmIChtYWpvclZlcnNpb24gPiAxICYmIHVuaXF1ZUJhbmRNYXNrQ291bnQgPiAxKSB7XG4gICAgICAgIG51bVBpeGVscyA9IGRlY29kZWRQaXhlbEJsb2NrLndpZHRoICogZGVjb2RlZFBpeGVsQmxvY2suaGVpZ2h0O1xuICAgICAgICBkZWNvZGVkUGl4ZWxCbG9jay5iYW5kTWFza3MgPSBiYW5kTWFza3M7XG4gICAgICAgIG1hc2tEYXRhID0gbmV3IFVpbnQ4QXJyYXkobnVtUGl4ZWxzKTtcbiAgICAgICAgbWFza0RhdGEuc2V0KGJhbmRNYXNrc1swXSk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBiYW5kTWFza3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBiYW5kTWFzayA9IGJhbmRNYXNrc1tpXTtcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbnVtUGl4ZWxzOyBqKyspIHtcbiAgICAgICAgICAgIG1hc2tEYXRhW2pdID0gbWFza0RhdGFbal0gJiBiYW5kTWFza1tqXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlZFBpeGVsQmxvY2subWFza0RhdGEgPSBtYXNrRGF0YTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlY29kZWRQaXhlbEJsb2NrO1xuICAgIH1cbiAgfTtcblxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHsvKiBqc2hpbnQgaWdub3JlOmxpbmUgKi9cbiAgICAvL2FtZCBsb2FkZXJzIHN1Y2ggYXMgZG9qbyBhbmQgcmVxdWlyZUpTXG4gICAgLy9odHRwOi8vd2lraS5jb21tb25qcy5vcmcvd2lraS9Nb2R1bGVzL0FzeW5jaHJvbm91c0RlZmluaXRpb25cbiAgICBkZWZpbmUoW10sIGZ1bmN0aW9uKCkgeyByZXR1cm4gTGVyYzsgfSk7LyoganNoaW50IGlnbm9yZTpsaW5lICovXG4gIH1cbiAgZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cykgey8qIGpzaGludCBpZ25vcmU6bGluZSAqL1xuICAgIC8vY29tbW9uSlMgbW9kdWxlIDEuMC8xLjEvMS4xLjEgc3lzdGVtcywgc3VjaCBhcyBub2RlSlNcbiAgICAvL2h0dHA6Ly93aWtpLmNvbW1vbmpzLm9yZy93aWtpL01vZHVsZXNcbiAgICBtb2R1bGUuZXhwb3J0cyA9IExlcmM7LyoganNoaW50IGlnbm9yZTpsaW5lICovXG4gIH1cbiAgZWxzZSB7XG4gICAgLy9hc3NpZ24gdG8gdGhpcywgbW9zdCBsaWtlbHkgd2luZG93XG4gICAgdGhpcy5MZXJjID0gTGVyYztcbiAgfVxuXG59KSgpO1xuIiwiaW1wb3J0IHsgaW5mbGF0ZSB9IGZyb20gJ3Bha28nO1xuaW1wb3J0IExlcmMgZnJvbSAnbGVyYyc7XG5pbXBvcnQgeyBaU1RERGVjb2RlciB9IGZyb20gJ3pzdGRkZWMnO1xuaW1wb3J0IEJhc2VEZWNvZGVyIGZyb20gJy4vYmFzZWRlY29kZXIuanMnO1xuaW1wb3J0IHsgTGVyY1BhcmFtZXRlcnMsIExlcmNBZGRDb21wcmVzc2lvbiB9IGZyb20gJy4uL2dsb2JhbHMuanMnO1xuXG5leHBvcnQgY29uc3QgenN0ZCA9IG5ldyBaU1RERGVjb2RlcigpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMZXJjRGVjb2RlciBleHRlbmRzIEJhc2VEZWNvZGVyIHtcbiAgY29uc3RydWN0b3IoZmlsZURpcmVjdG9yeSkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLnBsYW5hckNvbmZpZ3VyYXRpb24gPSB0eXBlb2YgZmlsZURpcmVjdG9yeS5QbGFuYXJDb25maWd1cmF0aW9uICE9PSAndW5kZWZpbmVkJyA/IGZpbGVEaXJlY3RvcnkuUGxhbmFyQ29uZmlndXJhdGlvbiA6IDE7XG4gICAgdGhpcy5zYW1wbGVzUGVyUGl4ZWwgPSB0eXBlb2YgZmlsZURpcmVjdG9yeS5TYW1wbGVzUGVyUGl4ZWwgIT09ICd1bmRlZmluZWQnID8gZmlsZURpcmVjdG9yeS5TYW1wbGVzUGVyUGl4ZWwgOiAxO1xuXG4gICAgdGhpcy5hZGRDb21wcmVzc2lvbiA9IGZpbGVEaXJlY3RvcnkuTGVyY1BhcmFtZXRlcnNbTGVyY1BhcmFtZXRlcnMuQWRkQ29tcHJlc3Npb25dO1xuICB9XG5cbiAgZGVjb2RlQmxvY2soYnVmZmVyKSB7XG4gICAgc3dpdGNoICh0aGlzLmFkZENvbXByZXNzaW9uKSB7XG4gICAgICBjYXNlIExlcmNBZGRDb21wcmVzc2lvbi5Ob25lOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTGVyY0FkZENvbXByZXNzaW9uLkRlZmxhdGU6XG4gICAgICAgIGJ1ZmZlciA9IGluZmxhdGUobmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSkuYnVmZmVyOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduLCBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTGVyY0FkZENvbXByZXNzaW9uLlpzdGFuZGFyZDpcbiAgICAgICAgYnVmZmVyID0genN0ZC5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSkuYnVmZmVyOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduLCBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgTEVSQyBhZGRpdGlvbmFsIGNvbXByZXNzaW9uIG1ldGhvZCBpZGVudGlmaWVyOiAke3RoaXMuYWRkQ29tcHJlc3Npb259YCk7XG4gICAgfVxuXG4gICAgY29uc3QgbGVyY1Jlc3VsdCA9IExlcmMuZGVjb2RlKGJ1ZmZlciwgeyByZXR1cm5QaXhlbEludGVybGVhdmVkRGltczogdGhpcy5wbGFuYXJDb25maWd1cmF0aW9uID09PSAxIH0pO1xuICAgIGNvbnN0IGxlcmNEYXRhID0gbGVyY1Jlc3VsdC5waXhlbHNbMF07XG4gICAgcmV0dXJuIGxlcmNEYXRhLmJ1ZmZlcjtcbiAgfVxufVxuIiwibGV0IGluaXQ7XG5sZXQgaW5zdGFuY2U7XG5sZXQgaGVhcDtcbmNvbnN0IElNUE9SVF9PQkpFQ1QgPSB7XG4gIGVudjoge1xuICAgIGVtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGg6IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgaGVhcCA9IG5ldyBVaW50OEFycmF5KGluc3RhbmNlLmV4cG9ydHMubWVtb3J5LmJ1ZmZlcik7XG4gICAgfVxuICB9XG59O1xuLyoqXHJcbiAqIFpTVEQgKFpzdGFuZGFyZCkgZGVjb2Rlci5cclxuICovXG5jbGFzcyBaU1RERGVjb2RlciB7XG4gIGluaXQoKSB7XG4gICAgaWYgKGluaXQpIHJldHVybiBpbml0O1xuICAgIGlmICh0eXBlb2YgZmV0Y2ggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBXZWIuXG4gICAgICBpbml0ID0gZmV0Y2goJ2RhdGE6YXBwbGljYXRpb24vd2FzbTtiYXNlNjQsJyArIHdhc20pLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuYXJyYXlCdWZmZXIoKSkudGhlbihhcnJheUJ1ZmZlciA9PiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShhcnJheUJ1ZmZlciwgSU1QT1JUX09CSkVDVCkpLnRoZW4odGhpcy5faW5pdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vZGUuanMuXG4gICAgICBpbml0ID0gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoQnVmZmVyLmZyb20od2FzbSwgJ2Jhc2U2NCcpLCBJTVBPUlRfT0JKRUNUKS50aGVuKHRoaXMuX2luaXQpO1xuICAgIH1cbiAgICByZXR1cm4gaW5pdDtcbiAgfVxuICBfaW5pdChyZXN1bHQpIHtcbiAgICBpbnN0YW5jZSA9IHJlc3VsdC5pbnN0YW5jZTtcbiAgICBJTVBPUlRfT0JKRUNULmVudi5lbXNjcmlwdGVuX25vdGlmeV9tZW1vcnlfZ3Jvd3RoKDApOyAvLyBpbml0aWFsaXplIGhlYXAuXG4gIH1cblxuICBkZWNvZGUoYXJyYXksIHVuY29tcHJlc3NlZFNpemUgPSAwKSB7XG4gICAgaWYgKCFpbnN0YW5jZSkgdGhyb3cgbmV3IEVycm9yKGBaU1RERGVjb2RlcjogQXdhaXQgLmluaXQoKSBiZWZvcmUgZGVjb2RpbmcuYCk7XG4gICAgLy8gV3JpdGUgY29tcHJlc3NlZCBkYXRhIGludG8gV0FTTSBtZW1vcnkuXG4gICAgY29uc3QgY29tcHJlc3NlZFNpemUgPSBhcnJheS5ieXRlTGVuZ3RoO1xuICAgIGNvbnN0IGNvbXByZXNzZWRQdHIgPSBpbnN0YW5jZS5leHBvcnRzLm1hbGxvYyhjb21wcmVzc2VkU2l6ZSk7XG4gICAgaGVhcC5zZXQoYXJyYXksIGNvbXByZXNzZWRQdHIpO1xuICAgIC8vIERlY29tcHJlc3MgaW50byBXQVNNIG1lbW9yeS5cbiAgICB1bmNvbXByZXNzZWRTaXplID0gdW5jb21wcmVzc2VkU2l6ZSB8fCBOdW1iZXIoaW5zdGFuY2UuZXhwb3J0cy5aU1REX2ZpbmREZWNvbXByZXNzZWRTaXplKGNvbXByZXNzZWRQdHIsIGNvbXByZXNzZWRTaXplKSk7XG4gICAgY29uc3QgdW5jb21wcmVzc2VkUHRyID0gaW5zdGFuY2UuZXhwb3J0cy5tYWxsb2ModW5jb21wcmVzc2VkU2l6ZSk7XG4gICAgY29uc3QgYWN0dWFsU2l6ZSA9IGluc3RhbmNlLmV4cG9ydHMuWlNURF9kZWNvbXByZXNzKHVuY29tcHJlc3NlZFB0ciwgdW5jb21wcmVzc2VkU2l6ZSwgY29tcHJlc3NlZFB0ciwgY29tcHJlc3NlZFNpemUpO1xuICAgIC8vIFJlYWQgZGVjb21wcmVzc2VkIGRhdGEgYW5kIGZyZWUgV0FTTSBtZW1vcnkuXG4gICAgY29uc3QgZGVjID0gaGVhcC5zbGljZSh1bmNvbXByZXNzZWRQdHIsIHVuY29tcHJlc3NlZFB0ciArIGFjdHVhbFNpemUpO1xuICAgIGluc3RhbmNlLmV4cG9ydHMuZnJlZShjb21wcmVzc2VkUHRyKTtcbiAgICBpbnN0YW5jZS5leHBvcnRzLmZyZWUodW5jb21wcmVzc2VkUHRyKTtcbiAgICByZXR1cm4gZGVjO1xuICB9XG59XG4vKipcclxuICogQlNEIExpY2Vuc2VcclxuICpcclxuICogRm9yIFpzdGFuZGFyZCBzb2Z0d2FyZVxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtcHJlc2VudCwgWWFubiBDb2xsZXQsIEZhY2Vib29rLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXHJcbiAqIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuICpcclxuICogICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXHJcbiAqICAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxyXG4gKlxyXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXHJcbiAqICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cclxuICogICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXHJcbiAqXHJcbiAqICAqIE5laXRoZXIgdGhlIG5hbWUgRmFjZWJvb2sgbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvXHJcbiAqICAgIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljXHJcbiAqICAgIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cclxuICpcclxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXHJcbiAqIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXHJcbiAqIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkVcclxuICogRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcclxuICogQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXHJcbiAqIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcclxuICogTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXHJcbiAqIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXHJcbiAqIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXHJcbiAqIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxyXG4gKi9cbi8vIHdhc206YmVnaW5cbmNvbnN0IHdhc20gPSAnQUdGemJRRUFBQUFCcFFFVllBRi9BWDlnQW45L0FHQURmMzkvQVg5Z0JYOS9mMzkvQVg5Z0FYOEFZQUovZndGL1lBUi9mMzkvQVg5Z0EzOS9md0JnQm45L2YzOS9md0YvWUFkL2YzOS9mMzkvQVg5Z0FuOS9BWDVnQW41K0FYNWdBQUJnQlg5L2YzOS9BR0FHZjM5L2YzOS9BR0FJZjM5L2YzOS9mMzhBWUFsL2YzOS9mMzkvZjM4QVlBQUJmMkFJZjM5L2YzOS9mMzhCZjJBTmYzOS9mMzkvZjM5L2YzOS9md0YvWUFGL0FYNENKd0VEWlc1MkgyVnRjMk55YVhCMFpXNWZibTkwYVdaNVgyMWxiVzl5ZVY5bmNtOTNkR2dBQkFOcGFBRUZBQUFGQWdFRkN3QUNBUUFCQWdJRkJRY0FBd0FCRGdzQkFRY0FFaE1IQUFVQkRBUUVBQUFOQndRQ0FnWUNCQWdEQXdNREJnRUFDUWtIQmdJQ0FBWUdBZ1FVQndZR0F3SUdBQU1DQVFnQkJ3VUdDZ29FRVFBRUJBRUlBd2dEQlFnREVBOElBQWNBQkFVQmNBRUNBZ1VFQVFDQUFnWUpBWDhCUWFDZ3dBSUxCMkFIQm0xbGJXOXllUUlBQm0xaGJHeHZZd0FvQkdaeVpXVUFKZ3hhVTFSRVgybHpSWEp5YjNJQWFCbGFVMVJFWDJacGJtUkVaV052YlhCeVpYTnpaV1JUYVhwbEFGUVBXbE5VUkY5a1pXTnZiWEJ5WlhOekFFb0dYM04wWVhKMEFDUUpCd0VBUVFFTEFTUUt1c3NCYUE4QUlBQWdBQ2dDQkNBQmFqWUNCQXNaQUNBQUtBSUFJQUFvQWdSQkgzRjBRUUFnQVd0QkgzRjJDd2dBSUFCQmlIOUxDMzRCQkg5QkF5RUJJQUFvQWdRaUEwRWdUUVJBSUFBb0FnZ2lBU0FBS0FJUVR3UkFJQUFRRFE4TElBQW9BZ3dpQWlBQlJnUkFRUUZCQWlBRFFTQkpHdzhMSUFBZ0FTQUJJQUpySUFOQkEzWWlCQ0FCSUFScklBSkpJZ0ViSWdKcklnUTJBZ2dnQUNBRElBSkJBM1JyTmdJRUlBQWdCQ2dBQURZQ0FBc2dBUXNVQVFGL0lBQWdBUkFDSVFJZ0FDQUJFQUVnQWd2M0FRRUNmeUFDUlFSQUlBQkNBRGNDQUNBQVFRQTJBaEFnQUVJQU53SUlRYmgvRHdzZ0FDQUJOZ0lNSUFBZ0FVRUVhallDRUNBQ1FRUlBCRUFnQUNBQklBSnFJZ0ZCZkdvaUF6WUNDQ0FBSUFNb0FBQTJBZ0FnQVVGL2FpMEFBQ0lCQkVBZ0FFRUlJQUVRRkdzMkFnUWdBZzhMSUFCQkFEWUNCRUYvRHdzZ0FDQUJOZ0lJSUFBZ0FTMEFBQ0lETmdJQUlBSkJmbW9pQkVFQlRRUkFJQVJCQVd0RkJFQWdBQ0FCTFFBQ1FSQjBJQU55SWdNMkFnQUxJQUFnQVMwQUFVRUlkQ0FEYWpZQ0FBc2dBU0FDYWtGL2FpMEFBQ0lCUlFSQUlBQkJBRFlDQkVGc0R3c2dBRUVvSUFFUUZDQUNRUU4wYW1zMkFnUWdBZ3NXQUNBQUlBRXBBQUEzQUFBZ0FDQUJLUUFJTndBSUN5OEJBWDhnQVVFQ2RFR2dIV29vQWdBZ0FDZ0NBRUVnSUFFZ0FDZ0NCR3ByUVI5eGRuRWhBaUFBSUFFUUFTQUNDeUVBSUFGQ3o5YlR2dExIcTlsQ2ZpQUFmRUlmaVVLSGxhK3ZtTGJlbTU1L2Znc2RBUUYvSUFBb0FnZ2dBQ2dDREVZRWZ5QUFLQUlFUVNCR0JVRUFDd3VDQkFFRGZ5QUNRWURBQUU4RVFDQUFJQUVnQWhCbklBQVBDeUFBSUFKcUlRTUNRQ0FBSUFGelFRTnhSUVJBQWtBZ0FrRUJTQVJBSUFBaEFnd0JDeUFBUVFOeFJRUkFJQUFoQWd3QkN5QUFJUUlEUUNBQ0lBRXRBQUE2QUFBZ0FVRUJhaUVCSUFKQkFXb2lBaUFEVHcwQklBSkJBM0VOQUFzTEFrQWdBMEY4Y1NJRVFjQUFTUTBBSUFJZ0JFRkFhaUlGU3cwQUEwQWdBaUFCS0FJQU5nSUFJQUlnQVNnQ0JEWUNCQ0FDSUFFb0FnZzJBZ2dnQWlBQktBSU1OZ0lNSUFJZ0FTZ0NFRFlDRUNBQ0lBRW9BaFEyQWhRZ0FpQUJLQUlZTmdJWUlBSWdBU2dDSERZQ0hDQUNJQUVvQWlBMkFpQWdBaUFCS0FJa05nSWtJQUlnQVNnQ0tEWUNLQ0FDSUFFb0FpdzJBaXdnQWlBQktBSXdOZ0l3SUFJZ0FTZ0NORFlDTkNBQ0lBRW9BamcyQWpnZ0FpQUJLQUk4TmdJOElBRkJRR3NoQVNBQ1FVQnJJZ0lnQlUwTkFBc0xJQUlnQkU4TkFRTkFJQUlnQVNnQ0FEWUNBQ0FCUVFScUlRRWdBa0VFYWlJQ0lBUkpEUUFMREFFTElBTkJCRWtFUUNBQUlRSU1BUXNnQTBGOGFpSUVJQUJKQkVBZ0FDRUNEQUVMSUFBaEFnTkFJQUlnQVMwQUFEb0FBQ0FDSUFFdEFBRTZBQUVnQWlBQkxRQUNPZ0FDSUFJZ0FTMEFBem9BQXlBQlFRUnFJUUVnQWtFRWFpSUNJQVJORFFBTEN5QUNJQU5KQkVBRFFDQUNJQUV0QUFBNkFBQWdBVUVCYWlFQklBSkJBV29pQWlBRFJ3MEFDd3NnQUFzTUFDQUFJQUVwQUFBM0FBQUxRUUVDZnlBQUtBSUlJZ0VnQUNnQ0VFa0VRRUVERHdzZ0FDQUFLQUlFSWdKQkIzRTJBZ1FnQUNBQklBSkJBM1pySWdFMkFnZ2dBQ0FCS0FBQU5nSUFRUUFMREFBZ0FDQUJLQUlBTmdBQUMvY0NBUUovQWtBZ0FDQUJSZzBBQWtBZ0FTQUNhaUFBU3dSQUlBQWdBbW9pQkNBQlN3MEJDeUFBSUFFZ0FoQUxEd3NnQUNBQmMwRURjU0VEQWtBQ1FDQUFJQUZKQkVBZ0F3UkFJQUFoQXd3REN5QUFRUU54UlFSQUlBQWhBd3dDQ3lBQUlRTURRQ0FDUlEwRUlBTWdBUzBBQURvQUFDQUJRUUZxSVFFZ0FrRi9haUVDSUFOQkFXb2lBMEVEY1EwQUN3d0JDd0pBSUFNTkFDQUVRUU54QkVBRFFDQUNSUTBGSUFBZ0FrRi9haUlDYWlJRElBRWdBbW90QUFBNkFBQWdBMEVEY1EwQUN3c2dBa0VEVFEwQUEwQWdBQ0FDUVh4cUlnSnFJQUVnQW1vb0FnQTJBZ0FnQWtFRFN3MEFDd3NnQWtVTkFnTkFJQUFnQWtGL2FpSUNhaUFCSUFKcUxRQUFPZ0FBSUFJTkFBc01BZ3NnQWtFRFRRMEFJQUloQkFOQUlBTWdBU2dDQURZQ0FDQUJRUVJxSVFFZ0EwRUVhaUVESUFSQmZHb2lCRUVEU3cwQUN5QUNRUU54SVFJTElBSkZEUUFEUUNBRElBRXRBQUE2QUFBZ0EwRUJhaUVESUFGQkFXb2hBU0FDUVg5cUlnSU5BQXNMSUFBTDh3SUNBbjhCZmdKQUlBSkZEUUFnQUNBQ2FpSURRWDlxSUFFNkFBQWdBQ0FCT2dBQUlBSkJBMGtOQUNBRFFYNXFJQUU2QUFBZ0FDQUJPZ0FCSUFOQmZXb2dBVG9BQUNBQUlBRTZBQUlnQWtFSFNRMEFJQU5CZkdvZ0FUb0FBQ0FBSUFFNkFBTWdBa0VKU1EwQUlBQkJBQ0FBYTBFRGNTSUVhaUlESUFGQi93RnhRWUdDaEFoc0lnRTJBZ0FnQXlBQ0lBUnJRWHh4SWdScUlnSkJmR29nQVRZQ0FDQUVRUWxKRFFBZ0F5QUJOZ0lJSUFNZ0FUWUNCQ0FDUVhocUlBRTJBZ0FnQWtGMGFpQUJOZ0lBSUFSQkdVa05BQ0FESUFFMkFoZ2dBeUFCTmdJVUlBTWdBVFlDRUNBRElBRTJBZ3dnQWtGd2FpQUJOZ0lBSUFKQmJHb2dBVFlDQUNBQ1FXaHFJQUUyQWdBZ0FrRmthaUFCTmdJQUlBUWdBMEVFY1VFWWNpSUVheUlDUVNCSkRRQWdBYTBpQlVJZ2hpQUZoQ0VGSUFNZ0JHb2hBUU5BSUFFZ0JUY0RHQ0FCSUFVM0F4QWdBU0FGTndNSUlBRWdCVGNEQUNBQlFTQnFJUUVnQWtGZ2FpSUNRUjlMRFFBTEN5QUFDeThCQW44Z0FDZ0NCQ0FBS0FJQVFRSjBhaUlDTFFBQ0lRTWdBQ0FDTHdFQUlBRWdBaTBBQXhBSWFqWUNBQ0FEQ3k4QkFuOGdBQ2dDQkNBQUtBSUFRUUowYWlJQ0xRQUNJUU1nQUNBQ0x3RUFJQUVnQWkwQUF4QUZhallDQUNBREN4OEFJQUFnQVNBQ0tBSUVFQWcyQWdBZ0FSQUVHaUFBSUFKQkNHbzJBZ1FMQ0FBZ0FHZEJIM01MdWdVQkRYOGpBRUVRYXlJS0pBQUNmeUFFUVFOTkJFQWdDa0VBTmdJTUlBcEJER29nQXlBRUVBc2FJQUFnQVNBQ0lBcEJER3BCQkJBVklnQkJiQ0FBRUFNYklBQWdBQ0FFU3hzTUFRc2dBRUVBSUFFb0FnQkJBWFJCQW1vUUVDRU5RVlFnQXlnQUFDSUdRUTl4SWdCQkNrc05BQm9nQWlBQVFRVnFOZ0lBSUFNZ0JHb2lBa0Y4YWlFTUlBSkJlV29oRGlBQ1FYdHFJUkFnQUVFR2FpRUxRUVFoQlNBR1FRUjJJUVJCSUNBQWRDSUFRUUZ5SVFrZ0FTZ0NBQ0VQUVFBaEFpQURJUVlDUUFOQUlBbEJBa2dnQWlBUFMzSkZCRUFnQWlFSEFrQWdDQVJBQTBBZ0JFSC8vd054UWYvL0EwWUVRQ0FIUVJocUlRY2dCaUFRU1FSL0lBWkJBbW9pQmlnQUFDQUZkZ1VnQlVFUWFpRUZJQVJCRUhZTElRUU1BUXNMQTBBZ0JFRURjU0lJUVFOR0JFQWdCVUVDYWlFRklBUkJBblloQkNBSFFRTnFJUWNNQVFzTElBY2dDR29pQnlBUFN3MEVJQVZCQW1vaEJRTkFJQUlnQjBrRVFDQU5JQUpCQVhScVFRQTdBUUFnQWtFQmFpRUNEQUVMQ3lBR0lBNUxRUUFnQmlBRlFRTjFhaUlISUF4TEcwVUVRQ0FIS0FBQUlBVkJCM0VpQlhZaEJBd0NDeUFFUVFKMklRUUxJQVloQndzQ2Z5QUxRWDlxSUFRZ0FFRi9hbkVpQmlBQVFRRjBRWDlxSWdnZ0NXc2lFVWtOQUJvZ0JDQUljU0lFUVFBZ0VTQUVJQUJJRzJzaEJpQUxDeUVJSUEwZ0FrRUJkR29nQmtGL2FpSUVPd0VBSUFsQkFTQUdheUFFSUFaQkFVZ2JheUVKQTBBZ0NTQUFTQVJBSUFCQkFYVWhBQ0FMUVg5cUlRc01BUXNMQW44Z0J5QU9TMEVBSUFjZ0JTQUlhaUlGUVFOMWFpSUdJQXhMRzBVRVFDQUZRUWR4REFFTElBVWdEQ0lHSUFkclFRTjBhd3NoQlNBQ1FRRnFJUUlnQkVVaENDQUdLQUFBSUFWQkgzRjJJUVFNQVFzTFFXd2dDVUVCUnlBRlFTQktjZzBCR2lBQklBSkJmMm8yQWdBZ0JpQUZRUWRxUVFOMWFpQURhd3dCQzBGUUN5RUFJQXBCRUdva0FDQUFDd2tBUVFGQkJTQUFHd3NNQUNBQUlBRW9BQUEyQUFBTHFnTUJDbjhqQUVId0FHc2lDaVFBSUFKQkFXb2hEaUFBUVFocUlRdEJnSUFFSUFWQmYycDBRUkIxSVF4QkFDRUNRUUVoQmtFQklBVjBJZ2xCZjJvaUR5RUlBMEFnQWlBT1JrVUVRQUpBSUFFZ0FrRUJkQ0lOYWk4QkFDSUhRZi8vQTBZRVFDQUxJQWhCQTNScUlBSTJBZ1FnQ0VGL2FpRUlRUUVoQnd3QkN5QUdRUUFnRENBSFFSQjBRUkIxU2hzaEJnc2dDaUFOYWlBSE93RUFJQUpCQVdvaEFnd0JDd3NnQUNBRk5nSUVJQUFnQmpZQ0FDQUpRUU4ySUFsQkFYWnFRUU5xSVF4QkFDRUFRUUFoQmtFQUlRSURRQ0FHSUE1R0JFQURRQUpBSUFBZ0NVWU5BQ0FLSUFzZ0FFRURkR29pQVNnQ0JDSUdRUUYwYWlJQ0lBSXZBUUFpQWtFQmFqc0JBQ0FCSUFVZ0FoQVVheUlJT2dBRElBRWdBaUFJUWY4QmNYUWdDV3M3QVFBZ0FTQUVJQVpCQW5RaUFtb29BZ0E2QUFJZ0FTQUNJQU5xS0FJQU5nSUVJQUJCQVdvaEFBd0JDd3NGSUFFZ0JrRUJkR291QVFBaERVRUFJUWNEUUNBSElBMU9SUVJBSUFzZ0FrRURkR29nQmpZQ0JBTkFJQUlnREdvZ0QzRWlBaUFJU3cwQUN5QUhRUUZxSVFjTUFRc0xJQVpCQVdvaEJnd0JDd3NnQ2tId0FHb2tBQXNqQUVJQUlBRVFDU0FBaFVLSGxhK3ZtTGJlbTU1L2ZrTGozTXFWL003eTlZVi9mQXNRQUNBQVFuNDNBd2dnQUNBQk5nSUFDeVFCQVg4Z0FBUkFJQUVvQWdRaUFnUkFJQUVvQWdnZ0FDQUNFUUVBRHdzZ0FCQW1Dd3NmQUNBQUlBRWdBaThCQUJBSU5nSUFJQUVRQkJvZ0FDQUNRUVJxTmdJRUMwb0JBWDlCb0NBb0FnQWlBU0FBYWlJQVFYOU1CRUJCaUNCQk1EWUNBRUYvRHdzQ1FDQUFQd0JCRUhSTkRRQWdBQkJtRFFCQmlDQkJNRFlDQUVGL0R3dEJvQ0FnQURZQ0FDQUJDOWNCQVFoL1FicC9JUW9DUUNBQ0tBSUVJZ2dnQWlnQ0FDSUphaUlPSUFFZ0FHdExEUUJCYkNFS0lBa2dCQ0FES0FJQUlndHJTdzBBSUFBZ0NXb2lCQ0FDS0FJSUlneHJJUTBnQUNBQlFXQnFJZzhnQ3lBSlFRQVFLU0FESUFrZ0MybzJBZ0FDUUFKQUlBd2dCQ0FGYTAwRVFDQU5JUVVNQVFzZ0RDQUVJQVpyU3cwQ0lBY2dEU0FGYXlJQWFpSUJJQWhxSUFkTkJFQWdCQ0FCSUFnUUR4b01BZ3NnQkNBQlFRQWdBR3NRRHlFQklBSWdBQ0FJYWlJSU5nSUVJQUVnQUdzaEJBc2dCQ0FQSUFVZ0NFRUJFQ2tMSUE0aENnc2dDZ3ViQWdFQmZ5TUFRWUFCYXlJTkpBQWdEU0FETmdKOEFrQWdBa0VEU3dSQVFYOGhDUXdCQ3dKQUFrQUNRQUpBSUFKQkFXc09Bd0FEQWdFTElBWkZCRUJCdUg4aENRd0VDMEZzSVFrZ0JTMEFBQ0lDSUFOTERRTWdBQ0FISUFKQkFuUWlBbW9vQWdBZ0FpQUlhaWdDQUJBN0lBRWdBRFlDQUVFQklRa01Bd3NnQVNBSk5nSUFRUUFoQ1F3Q0N5QUtSUVJBUVd3aENRd0NDMEVBSVFrZ0MwVWdERUVaU0hJTkFVRUlJQVIwUVFocUlRQkJBQ0VDQTBBZ0FpQUFUdzBDSUFKQlFHc2hBZ3dBQUFzQUMwRnNJUWtnRFNBTlFmd0FhaUFOUWZnQWFpQUZJQVlRRlNJQ0VBTU5BQ0FOS0FKNElnTWdCRXNOQUNBQUlBMGdEU2dDZkNBSElBZ2dBeEFZSUFFZ0FEWUNBQ0FDSVFrTElBMUJnQUZxSkFBZ0NRc0xBQ0FBSUFFZ0FoQUxHZ3NRQUNBQUx3QUFJQUF0QUFKQkVIUnlDeThBQW45QnVIOGdBVUVJU1EwQUdrRnlJQUFvQUFRaUFFRjNTdzBBR2tHNGZ5QUFRUWhxSWdBZ0FDQUJTeHNMQ3drQUlBQWdBVHNBQUFzREFBRUxpZ1lCQlg4Z0FDQUFLQUlBSWdWQmZuRTJBZ0JCQUNBQUlBVkJBWFpxUVlRZ0tBSUFJZ1FnQUVZYklRRUNRQUpBSUFBb0FnUWlBa1VOQUNBQ0tBSUFJZ05CQVhFTkFDQUNRUWhxSWdVZ0EwRUJka0Y0YWlJRFFRZ2dBMEVJU3h0blFSOXpRUUowUVlBZmFpSURLQUlBUmdSQUlBTWdBaWdDRERZQ0FBc2dBaWdDQ0NJREJFQWdBeUFDS0FJTU5nSUVDeUFDS0FJTUlnTUVRQ0FESUFJb0FnZzJBZ0FMSUFJZ0FpZ0NBQ0FBS0FJQVFYNXhhallDQUVHRUlDRUFBa0FDUUNBQlJRMEFJQUVnQWpZQ0JDQUJLQUlBSWdOQkFYRU5BU0FEUVFGMlFYaHFJZ05CQ0NBRFFRaExHMmRCSDNOQkFuUkJnQjlxSWdNb0FnQWdBVUVJYWtZRVFDQURJQUVvQWd3MkFnQUxJQUVvQWdnaUF3UkFJQU1nQVNnQ0REWUNCQXNnQVNnQ0RDSURCRUFnQXlBQktBSUlOZ0lBUVlRZ0tBSUFJUVFMSUFJZ0FpZ0NBQ0FCS0FJQVFYNXhhallDQUNBQklBUkdEUUFnQVNBQktBSUFRUUYyYWtFRWFpRUFDeUFBSUFJMkFnQUxJQUlvQWdCQkFYWkJlR29pQUVFSUlBQkJDRXNiWjBFZmMwRUNkRUdBSDJvaUFTZ0NBQ0VBSUFFZ0JUWUNBQ0FDSUFBMkFnd2dBa0VBTmdJSUlBQkZEUUVnQUNBRk5nSUFEd3NDUUNBQlJRMEFJQUVvQWdBaUFrRUJjUTBBSUFKQkFYWkJlR29pQWtFSUlBSkJDRXNiWjBFZmMwRUNkRUdBSDJvaUFpZ0NBQ0FCUVFocVJnUkFJQUlnQVNnQ0REWUNBQXNnQVNnQ0NDSUNCRUFnQWlBQktBSU1OZ0lFQ3lBQktBSU1JZ0lFUUNBQ0lBRW9BZ2cyQWdCQmhDQW9BZ0FoQkFzZ0FDQUFLQUlBSUFFb0FnQkJmbkZxSWdJMkFnQUNRQ0FCSUFSSEJFQWdBU0FCS0FJQVFRRjJhaUFBTmdJRUlBQW9BZ0FoQWd3QkMwR0VJQ0FBTmdJQUN5QUNRUUYyUVhocUlnRkJDQ0FCUVFoTEcyZEJIM05CQW5SQmdCOXFJZ0lvQWdBaEFTQUNJQUJCQ0dvaUFqWUNBQ0FBSUFFMkFnd2dBRUVBTmdJSUlBRkZEUUVnQVNBQ05nSUFEd3NnQlVFQmRrRjRhaUlCUVFnZ0FVRUlTeHRuUVI5elFRSjBRWUFmYWlJQ0tBSUFJUUVnQWlBQVFRaHFJZ0kyQWdBZ0FDQUJOZ0lNSUFCQkFEWUNDQ0FCUlEwQUlBRWdBallDQUFzTERnQWdBQVJBSUFCQmVHb1FKUXNMZ0FJQkEzOENRQ0FBUVE5cVFYaHhRWVFnS0FJQUtBSUFRUUYyYXlJQ0VCMUJmMFlOQUFKQVFZUWdLQUlBSWdBb0FnQWlBVUVCY1EwQUlBRkJBWFpCZUdvaUFVRUlJQUZCQ0VzYlowRWZjMEVDZEVHQUgyb2lBU2dDQUNBQVFRaHFSZ1JBSUFFZ0FDZ0NERFlDQUFzZ0FDZ0NDQ0lCQkVBZ0FTQUFLQUlNTmdJRUN5QUFLQUlNSWdGRkRRQWdBU0FBS0FJSU5nSUFDMEVCSVFFZ0FDQUFLQUlBSUFKQkFYUnFJZ0kyQWdBZ0FrRUJjUTBBSUFKQkFYWkJlR29pQWtFSUlBSkJDRXNiWjBFZmMwRUNkRUdBSDJvaUF5Z0NBQ0VDSUFNZ0FFRUlhaUlETmdJQUlBQWdBallDRENBQVFRQTJBZ2dnQWtVTkFDQUNJQU0yQWdBTElBRUx0d0lCQTM4Q1FBSkFJQUJCQVNBQUd5SUNFRGdpQUEwQUFrQUNRRUdFSUNnQ0FDSUFSUTBBSUFBb0FnQWlBMEVCY1EwQUlBQWdBMEVCY2pZQ0FDQURRUUYyUVhocUlnRkJDQ0FCUVFoTEcyZEJIM05CQW5SQmdCOXFJZ0VvQWdBZ0FFRUlha1lFUUNBQklBQW9BZ3cyQWdBTElBQW9BZ2dpQVFSQUlBRWdBQ2dDRERZQ0JBc2dBQ2dDRENJQkJFQWdBU0FBS0FJSU5nSUFDeUFDRUNjaEFrRUFJUUZCaENBb0FnQWhBQ0FDRFFFZ0FDQUFLQUlBUVg1eE5nSUFRUUFQQ3lBQ1FROXFRWGh4SWdNUUhTSUNRWDlHRFFJZ0FrRUhha0Y0Y1NJQUlBSkhCRUFnQUNBQ2F4QWRRWDlHRFFNTEFrQkJoQ0FvQWdBaUFVVUVRRUdBSUNBQU5nSUFEQUVMSUFBZ0FUWUNCQXRCaENBZ0FEWUNBQ0FBSUFOQkFYUkJBWEkyQWdBTUFRc2dBRVVOQVFzZ0FFRUlhaUVCQ3lBQkM3a0RBUUovSUFBZ0Eyb2hCUUpBSUFOQkIwd0VRQU5BSUFBZ0JVOE5BaUFBSUFJdEFBQTZBQUFnQUVFQmFpRUFJQUpCQVdvaEFnd0FBQXNBQ3lBRVFRRkdCRUFDUUNBQUlBSnJJZ1pCQjAwRVFDQUFJQUl0QUFBNkFBQWdBQ0FDTFFBQk9nQUJJQUFnQWkwQUFqb0FBaUFBSUFJdEFBTTZBQU1nQUVFRWFpQUNJQVpCQW5RaUJrSEFIbW9vQWdCcUlnSVFGeUFDSUFaQjRCNXFLQUlBYXlFQ0RBRUxJQUFnQWhBTUN5QUNRUWhxSVFJZ0FFRUlhaUVBQ3dKQUFrQUNRQUpBSUFVZ0FVMEVRQ0FBSUFOcUlRRWdCRUVCUnlBQUlBSnJRUTlLY2cwQkEwQWdBQ0FDRUF3Z0FrRUlhaUVDSUFCQkNHb2lBQ0FCU1EwQUN3d0ZDeUFBSUFGTEJFQWdBQ0VCREFRTElBUkJBVWNnQUNBQ2EwRVBTbklOQVNBQUlRTWdBaUVFQTBBZ0F5QUVFQXdnQkVFSWFpRUVJQU5CQ0dvaUF5QUJTUTBBQ3d3Q0N3TkFJQUFnQWhBSElBSkJFR29oQWlBQVFSQnFJZ0FnQVVrTkFBc01Bd3NnQUNFRElBSWhCQU5BSUFNZ0JCQUhJQVJCRUdvaEJDQURRUkJxSWdNZ0FVa05BQXNMSUFJZ0FTQUFhMm9oQWdzRFFDQUJJQVZQRFFFZ0FTQUNMUUFBT2dBQUlBRkJBV29oQVNBQ1FRRnFJUUlNQUFBTEFBc0xRUUVDZnlBQUlBQW9BcmpnQVNJRE5nTEU0QUVnQUNnQ3ZPQUJJUVFnQUNBQk5nSzg0QUVnQUNBQklBSnFOZ0s0NEFFZ0FDQUJJQVFnQTJ0cU5nTEE0QUVMcGdFQkFYOGdBQ0FBS0FMczRRRVFGallDeU9BQklBQkNBRGNEK09BQklBQkNBRGNEdU9BQklBQkJ3T0FCYWtJQU53TUFJQUJCcU5BQWFpSUJRWXlBZ09BQU5nSUFJQUJCQURZQ21PSUJJQUJDQURjRGlPRUJJQUJDQXpjRGdPRUJJQUJCck5BQmFrSGdFaWtDQURjQ0FDQUFRYlRRQVdwQjZCSW9BZ0EyQWdBZ0FDQUJOZ0lNSUFBZ0FFR1lJR28yQWdnZ0FDQUFRYUF3YWpZQ0JDQUFJQUJCRUdvMkFnQUxZUUVCZjBHNGZ5RURBa0FnQVVFRFNRMEFJQUlnQUJBaElnRkJBM1lpQURZQ0NDQUNJQUZCQVhFMkFnUWdBaUFCUVFGMlFRTnhJZ00yQWdBQ1FDQURRWDlxSWdGQkFrc05BQUpBSUFGQkFXc09BZ0VBQWd0QmJBOExJQUFoQXdzZ0F3c01BQ0FBSUFFZ0FrRUFFQzRMaUFRQ0EzOENmaUFERUJZaEJDQUFRUUJCS0JBUUlRQWdCQ0FDU3dSQUlBUVBDeUFCUlFSQVFYOFBDd0pBQWtBZ0EwRUJSZzBBSUFFb0FBQWlCa0dvNnI1cFJnMEFRWFloQXlBR1FYQnhRZERVdE1JQlJ3MEJRUWdoQXlBQ1FRaEpEUUVnQUVFQVFTZ1FFQ0VBSUFFb0FBUWhBU0FBUVFFMkFoUWdBQ0FCclRjREFFRUFEd3NnQVNBQ0lBTVFMeUlESUFKTERRQWdBQ0FETmdJWVFYSWhBeUFCSUFScUlnVkJmMm90QUFBaUFrRUljUTBBSUFKQklIRWlCa1VFUUVGd0lRTWdCUzBBQUNJRlFhY0JTdzBCSUFWQkIzR3RRZ0VnQlVFRGRrRUthcTJHSWdkQ0E0aCtJQWQ4SVFnZ0JFRUJhaUVFQ3lBQ1FRWjJJUU1nQWtFQ2RpRUZBa0FnQWtFRGNVRi9haUlDUVFKTEJFQkJBQ0VDREFFTEFrQUNRQUpBSUFKQkFXc09BZ0VDQUFzZ0FTQUVhaTBBQUNFQ0lBUkJBV29oQkF3Q0N5QUJJQVJxTHdBQUlRSWdCRUVDYWlFRURBRUxJQUVnQkdvb0FBQWhBaUFFUVFScUlRUUxJQVZCQVhFaEJRSitBa0FDUUFKQUlBTkJmMm9pQTBFQ1RRUkFJQU5CQVdzT0FnSURBUXRDZnlBR1JRMERHaUFCSUFScU1RQUFEQU1MSUFFZ0JHb3ZBQUN0UW9BQ2ZBd0NDeUFCSUFScUtBQUFyUXdCQ3lBQklBUnFLUUFBQ3lFSElBQWdCVFlDSUNBQUlBSTJBaHdnQUNBSE53TUFRUUFoQXlBQVFRQTJBaFFnQUNBSElBZ2dCaHNpQnpjRENDQUFJQWRDZ0lBSUlBZENnSUFJVkJzK0FoQUxJQU1MV3dFQmYwRzRmeUVESUFJUUZpSUNJQUZOQkg4Z0FDQUNha0YvYWkwQUFDSUFRUU54UVFKMFFhQWVhaWdDQUNBQ2FpQUFRUVoySWdGQkFuUkJzQjVxS0FJQWFpQUFRU0J4SWdCRmFpQUJSU0FBUVFWMmNXb0ZRYmgvQ3dzZEFDQUFLQUtRNGdFUVdpQUFRUUEyQXFEaUFTQUFRZ0EzQTVEaUFRdTFBd0VGZnlNQVFaQUNheUlLSkFCQnVIOGhCZ0pBSUFWRkRRQWdCQ3dBQUNJSVFmOEJjU0VIQWtBZ0NFRi9UQVJBSUFkQmduOXFRUUYySWdnZ0JVOE5Ba0ZzSVFZZ0IwR0JmMm9pQlVHQUFrOE5BaUFFUVFGcUlRZEJBQ0VHQTBBZ0JpQUZUd1JBSUFVaEJpQUlJUWNNQXdVZ0FDQUdhaUFISUFaQkFYWnFJZ1F0QUFCQkJIWTZBQUFnQUNBR1FRRnlhaUFFTFFBQVFROXhPZ0FBSUFaQkFtb2hCZ3dCQ3dBQUN3QUxJQWNnQlU4TkFTQUFJQVJCQVdvZ0J5QUtFRk1pQmhBRERRRUxJQVloQkVFQUlRWWdBVUVBUVRRUUVDRUpRUUFoQlFOQUlBUWdCa2NFUUNBQUlBWnFJZ2d0QUFBaUFVRUxTd1JBUVd3aEJnd0RCU0FKSUFGQkFuUnFJZ0VnQVNnQ0FFRUJhallDQUNBR1FRRnFJUVpCQVNBSUxRQUFkRUVCZFNBRmFpRUZEQUlMQUFzTFFXd2hCaUFGUlEwQUlBVVFGRUVCYWlJQlFReExEUUFnQXlBQk5nSUFRUUZCQVNBQmRDQUZheUlERUJRaUFYUWdBMGNOQUNBQUlBUnFJQUZCQVdvaUFEb0FBQ0FKSUFCQkFuUnFJZ0FnQUNnQ0FFRUJhallDQUNBSktBSUVJZ0JCQWtrZ0FFRUJjWElOQUNBQ0lBUkJBV28yQWdBZ0IwRUJhaUVHQ3lBS1FaQUNhaVFBSUFZTHhoRUJESDhqQUVId0FHc2lCU1FBUVd3aEN3SkFJQU5CQ2trTkFDQUNMd0FBSVFvZ0FpOEFBaUVKSUFJdkFBUWhCeUFGUVFocUlBUVFEZ0pBSUFNZ0J5QUpJQXBxYWtFR2FpSU1TUTBBSUFVdEFBb2hDQ0FGUWRnQWFpQUNRUVpxSWdJZ0NoQUdJZ3NRQXcwQklBVkJRR3NnQWlBS2FpSUNJQWtRQmlJTEVBTU5BU0FGUVNocUlBSWdDV29pQWlBSEVBWWlDeEFERFFFZ0JVRVFhaUFDSUFkcUlBTWdER3NRQmlJTEVBTU5BU0FBSUFGcUlnOUJmV29oRUNBRVFRUnFJUVpCQVNFTElBQWdBVUVEYWtFQ2RpSURhaUlNSUFOcUlnSWdBMm9pRGlFRElBSWhCQ0FNSVFjRFFDQUxJQU1nRUVseEJFQWdBQ0FHSUFWQjJBQnFJQWdRQWtFQ2RHb2lDUzhCQURzQUFDQUZRZGdBYWlBSkxRQUNFQUVnQ1MwQUF5RUxJQWNnQmlBRlFVQnJJQWdRQWtFQ2RHb2lDUzhCQURzQUFDQUZRVUJySUFrdEFBSVFBU0FKTFFBRElRb2dCQ0FHSUFWQktHb2dDQkFDUVFKMGFpSUpMd0VBT3dBQUlBVkJLR29nQ1MwQUFoQUJJQWt0QUFNaENTQURJQVlnQlVFUWFpQUlFQUpCQW5ScUlnMHZBUUE3QUFBZ0JVRVFhaUFOTFFBQ0VBRWdEUzBBQXlFTklBQWdDMm9pQ3lBR0lBVkIyQUJxSUFnUUFrRUNkR29pQUM4QkFEc0FBQ0FGUWRnQWFpQUFMUUFDRUFFZ0FDMEFBeUVBSUFjZ0Ntb2lDaUFHSUFWQlFHc2dDQkFDUVFKMGFpSUhMd0VBT3dBQUlBVkJRR3NnQnkwQUFoQUJJQWN0QUFNaEJ5QUVJQWxxSWdrZ0JpQUZRU2hxSUFnUUFrRUNkR29pQkM4QkFEc0FBQ0FGUVNocUlBUXRBQUlRQVNBRUxRQURJUVFnQXlBTmFpSURJQVlnQlVFUWFpQUlFQUpCQW5ScUlnMHZBUUE3QUFBZ0JVRVFhaUFOTFFBQ0VBRWdBQ0FMYWlFQUlBY2dDbW9oQnlBRUlBbHFJUVFnQXlBTkxRQURhaUVESUFWQjJBQnFFQTBnQlVGQWF4QU5jaUFGUVNocUVBMXlJQVZCRUdvUURYSkZJUXNNQVFzTElBUWdEa3NnQnlBQ1MzSU5BRUZzSVFzZ0FDQU1TdzBCSUF4QmZXb2hDUU5BUVFBZ0FDQUpTU0FGUWRnQWFoQUVHd1JBSUFBZ0JpQUZRZGdBYWlBSUVBSkJBblJxSWdvdkFRQTdBQUFnQlVIWUFHb2dDaTBBQWhBQklBQWdDaTBBQTJvaUFDQUdJQVZCMkFCcUlBZ1FBa0VDZEdvaUNpOEJBRHNBQUNBRlFkZ0FhaUFLTFFBQ0VBRWdBQ0FLTFFBRGFpRUFEQUVGSUF4QmZtb2hDZ05BSUFWQjJBQnFFQVFnQUNBS1MzSkZCRUFnQUNBR0lBVkIyQUJxSUFnUUFrRUNkR29pQ1M4QkFEc0FBQ0FGUWRnQWFpQUpMUUFDRUFFZ0FDQUpMUUFEYWlFQURBRUxDd05BSUFBZ0NrMEVRQ0FBSUFZZ0JVSFlBR29nQ0JBQ1FRSjBhaUlKTHdFQU93QUFJQVZCMkFCcUlBa3RBQUlRQVNBQUlBa3RBQU5xSVFBTUFRc0xBa0FnQUNBTVR3MEFJQUFnQmlBRlFkZ0FhaUFJRUFJaUFFRUNkR29pREMwQUFEb0FBQ0FNTFFBRFFRRkdCRUFnQlVIWUFHb2dEQzBBQWhBQkRBRUxJQVVvQWx4Qkgwc05BQ0FGUWRnQWFpQUdJQUJCQW5ScUxRQUNFQUVnQlNnQ1hFRWhTUTBBSUFWQklEWUNYQXNnQWtGOWFpRU1BMEJCQUNBSElBeEpJQVZCUUdzUUJCc0VRQ0FISUFZZ0JVRkFheUFJRUFKQkFuUnFJZ0F2QVFBN0FBQWdCVUZBYXlBQUxRQUNFQUVnQnlBQUxRQURhaUlBSUFZZ0JVRkFheUFJRUFKQkFuUnFJZ2N2QVFBN0FBQWdCVUZBYXlBSExRQUNFQUVnQUNBSExRQURhaUVIREFFRklBSkJmbW9oREFOQUlBVkJRR3NRQkNBSElBeExja1VFUUNBSElBWWdCVUZBYXlBSUVBSkJBblJxSWdBdkFRQTdBQUFnQlVGQWF5QUFMUUFDRUFFZ0J5QUFMUUFEYWlFSERBRUxDd05BSUFjZ0RFMEVRQ0FISUFZZ0JVRkFheUFJRUFKQkFuUnFJZ0F2QVFBN0FBQWdCVUZBYXlBQUxRQUNFQUVnQnlBQUxRQURhaUVIREFFTEN3SkFJQWNnQWs4TkFDQUhJQVlnQlVGQWF5QUlFQUlpQUVFQ2RHb2lBaTBBQURvQUFDQUNMUUFEUVFGR0JFQWdCVUZBYXlBQ0xRQUNFQUVNQVFzZ0JTZ0NSRUVmU3cwQUlBVkJRR3NnQmlBQVFRSjBhaTBBQWhBQklBVW9Ba1JCSVVrTkFDQUZRU0EyQWtRTElBNUJmV29oQWdOQVFRQWdCQ0FDU1NBRlFTaHFFQVFiQkVBZ0JDQUdJQVZCS0dvZ0NCQUNRUUowYWlJQUx3RUFPd0FBSUFWQktHb2dBQzBBQWhBQklBUWdBQzBBQTJvaUFDQUdJQVZCS0dvZ0NCQUNRUUowYWlJRUx3RUFPd0FBSUFWQktHb2dCQzBBQWhBQklBQWdCQzBBQTJvaEJBd0JCU0FPUVg1cUlRSURRQ0FGUVNocUVBUWdCQ0FDUzNKRkJFQWdCQ0FHSUFWQktHb2dDQkFDUVFKMGFpSUFMd0VBT3dBQUlBVkJLR29nQUMwQUFoQUJJQVFnQUMwQUEyb2hCQXdCQ3dzRFFDQUVJQUpOQkVBZ0JDQUdJQVZCS0dvZ0NCQUNRUUowYWlJQUx3RUFPd0FBSUFWQktHb2dBQzBBQWhBQklBUWdBQzBBQTJvaEJBd0JDd3NDUUNBRUlBNVBEUUFnQkNBR0lBVkJLR29nQ0JBQ0lnQkJBblJxSWdJdEFBQTZBQUFnQWkwQUEwRUJSZ1JBSUFWQktHb2dBaTBBQWhBQkRBRUxJQVVvQWl4Qkgwc05BQ0FGUVNocUlBWWdBRUVDZEdvdEFBSVFBU0FGS0FJc1FTRkpEUUFnQlVFZ05nSXNDd05BUVFBZ0F5QVFTU0FGUVJCcUVBUWJCRUFnQXlBR0lBVkJFR29nQ0JBQ1FRSjBhaUlBTHdFQU93QUFJQVZCRUdvZ0FDMEFBaEFCSUFNZ0FDMEFBMm9pQUNBR0lBVkJFR29nQ0JBQ1FRSjBhaUlDTHdFQU93QUFJQVZCRUdvZ0FpMEFBaEFCSUFBZ0FpMEFBMm9oQXd3QkJTQVBRWDVxSVFJRFFDQUZRUkJxRUFRZ0F5QUNTM0pGQkVBZ0F5QUdJQVZCRUdvZ0NCQUNRUUowYWlJQUx3RUFPd0FBSUFWQkVHb2dBQzBBQWhBQklBTWdBQzBBQTJvaEF3d0JDd3NEUUNBRElBSk5CRUFnQXlBR0lBVkJFR29nQ0JBQ1FRSjBhaUlBTHdFQU93QUFJQVZCRUdvZ0FDMEFBaEFCSUFNZ0FDMEFBMm9oQXd3QkN3c0NRQ0FESUE5UERRQWdBeUFHSUFWQkVHb2dDQkFDSWdCQkFuUnFJZ0l0QUFBNkFBQWdBaTBBQTBFQlJnUkFJQVZCRUdvZ0FpMEFBaEFCREFFTElBVW9BaFJCSDBzTkFDQUZRUkJxSUFZZ0FFRUNkR290QUFJUUFTQUZLQUlVUVNGSkRRQWdCVUVnTmdJVUN5QUJRV3dnQlVIWUFHb1FDaUFGUVVCckVBcHhJQVZCS0dvUUNuRWdCVUVRYWhBS2NSc2hDd3dKQ3dBQUN3QUxBQUFMQUFzQUFBc0FDd0FBQ3dBTFFXd2hDd3NnQlVId0FHb2tBQ0FMQzdVRUFRNS9Jd0JCRUdzaUJpUUFJQVpCQkdvZ0FCQU9RVlFoQlFKQUlBUkIzQXRKRFFBZ0JpMEFCQ0VISUFOQjhBUnFRUUJCN0FBUUVDRUlJQWRCREVzTkFDQURRZHdKYWlJSklBZ2dCa0VJYWlBR1FReHFJQUVnQWhBeEloQVFBMFVFUUNBR0tBSU1JZ1FnQjBzTkFTQURRZHdGYWlFUElBTkJwQVZxSVJFZ0FFRUVhaUVTSUFOQnFBVnFJUUVnQkNFRkEwQWdCU0lDUVg5cUlRVWdDQ0FDUVFKMGFpZ0NBRVVOQUFzZ0FrRUJhaUVPUVFFaEJRTkFJQVVnRGs5RkJFQWdDQ0FGUVFKMElndHFLQUlBSVF3Z0FTQUxhaUFLTmdJQUlBVkJBV29oQlNBS0lBeHFJUW9NQVFzTElBRWdDallDQUVFQUlRVWdCaWdDQ0NFTEEwQWdCU0FMUmtVRVFDQUJJQVVnQ1dvdEFBQWlERUVDZEdvaURTQU5LQUlBSWcxQkFXbzJBZ0FnRHlBTlFRRjBhaUlOSUF3NkFBRWdEU0FGT2dBQUlBVkJBV29oQlF3QkN3dEJBQ0VCSUFOQkFEWUNxQVVnQkVGL2N5QUhhaUVKUVFFaEJRTkFJQVVnRGs5RkJFQWdDQ0FGUVFKMElndHFLQUlBSVF3Z0F5QUxhaUFCTmdJQUlBd2dCU0FKYW5RZ0FXb2hBU0FGUVFGcUlRVU1BUXNMSUFjZ0JFRUJhaUlCSUFKcklnUnJRUUZxSVFnRFFFRUJJUVVnQkNBSVQwVUVRQU5BSUFVZ0RrOUZCRUFnQlVFQ2RDSUpJQU1nQkVFMGJHcHFJQU1nQ1dvb0FnQWdCSFkyQWdBZ0JVRUJhaUVGREFFTEN5QUVRUUZxSVFRTUFRc0xJQklnQnlBUElBb2dFU0FESUFJZ0FSQmtJQVpCQVRvQUJTQUdJQWM2QUFZZ0FDQUdLQUlFTmdJQUN5QVFJUVVMSUFaQkVHb2tBQ0FGQzhFTkFRdC9Jd0JCOEFCcklnVWtBRUZzSVFrQ1FDQURRUXBKRFFBZ0FpOEFBQ0VLSUFJdkFBSWhEQ0FDTHdBRUlRWWdCVUVJYWlBRUVBNENRQ0FESUFZZ0NpQU1hbXBCQm1vaURVa05BQ0FGTFFBS0lRY2dCVUhZQUdvZ0FrRUdhaUlDSUFvUUJpSUpFQU1OQVNBRlFVQnJJQUlnQ21vaUFpQU1FQVlpQ1JBRERRRWdCVUVvYWlBQ0lBeHFJZ0lnQmhBR0lna1FBdzBCSUFWQkVHb2dBaUFHYWlBRElBMXJFQVlpQ1JBRERRRWdBQ0FCYWlJT1FYMXFJUThnQkVFRWFpRUdRUUVoQ1NBQUlBRkJBMnBCQW5ZaUFtb2lDaUFDYWlJTUlBSnFJZzBoQXlBTUlRUWdDaUVDQTBBZ0NTQURJQTlKY1FSQUlBWWdCVUhZQUdvZ0J4QUNRUUYwYWlJSUxRQUFJUXNnQlVIWUFHb2dDQzBBQVJBQklBQWdDem9BQUNBR0lBVkJRR3NnQnhBQ1FRRjBhaUlJTFFBQUlRc2dCVUZBYXlBSUxRQUJFQUVnQWlBTE9nQUFJQVlnQlVFb2FpQUhFQUpCQVhScUlnZ3RBQUFoQ3lBRlFTaHFJQWd0QUFFUUFTQUVJQXM2QUFBZ0JpQUZRUkJxSUFjUUFrRUJkR29pQ0MwQUFDRUxJQVZCRUdvZ0NDMEFBUkFCSUFNZ0N6b0FBQ0FHSUFWQjJBQnFJQWNRQWtFQmRHb2lDQzBBQUNFTElBVkIyQUJxSUFndEFBRVFBU0FBSUFzNkFBRWdCaUFGUVVCcklBY1FBa0VCZEdvaUNDMEFBQ0VMSUFWQlFHc2dDQzBBQVJBQklBSWdDem9BQVNBR0lBVkJLR29nQnhBQ1FRRjBhaUlJTFFBQUlRc2dCVUVvYWlBSUxRQUJFQUVnQkNBTE9nQUJJQVlnQlVFUWFpQUhFQUpCQVhScUlnZ3RBQUFoQ3lBRlFSQnFJQWd0QUFFUUFTQURJQXM2QUFFZ0EwRUNhaUVESUFSQkFtb2hCQ0FDUVFKcUlRSWdBRUVDYWlFQUlBa2dCVUhZQUdvUURVVnhJQVZCUUdzUURVVnhJQVZCS0dvUURVVnhJQVZCRUdvUURVVnhJUWtNQVFzTElBUWdEVXNnQWlBTVMzSU5BRUZzSVFrZ0FDQUtTdzBCSUFwQmZXb2hDUU5BSUFWQjJBQnFFQVFnQUNBSlQzSkZCRUFnQmlBRlFkZ0FhaUFIRUFKQkFYUnFJZ2d0QUFBaEN5QUZRZGdBYWlBSUxRQUJFQUVnQUNBTE9nQUFJQVlnQlVIWUFHb2dCeEFDUVFGMGFpSUlMUUFBSVFzZ0JVSFlBR29nQ0MwQUFSQUJJQUFnQ3pvQUFTQUFRUUpxSVFBTUFRc0xBMEFnQlVIWUFHb1FCQ0FBSUFwUGNrVUVRQ0FHSUFWQjJBQnFJQWNRQWtFQmRHb2lDUzBBQUNFSUlBVkIyQUJxSUFrdEFBRVFBU0FBSUFnNkFBQWdBRUVCYWlFQURBRUxDd05BSUFBZ0Nra0VRQ0FHSUFWQjJBQnFJQWNRQWtFQmRHb2lDUzBBQUNFSUlBVkIyQUJxSUFrdEFBRVFBU0FBSUFnNkFBQWdBRUVCYWlFQURBRUxDeUFNUVgxcUlRQURRQ0FGUVVCckVBUWdBaUFBVDNKRkJFQWdCaUFGUVVCcklBY1FBa0VCZEdvaUNpMEFBQ0VKSUFWQlFHc2dDaTBBQVJBQklBSWdDVG9BQUNBR0lBVkJRR3NnQnhBQ1FRRjBhaUlLTFFBQUlRa2dCVUZBYXlBS0xRQUJFQUVnQWlBSk9nQUJJQUpCQW1vaEFnd0JDd3NEUUNBRlFVQnJFQVFnQWlBTVQzSkZCRUFnQmlBRlFVQnJJQWNRQWtFQmRHb2lBQzBBQUNFS0lBVkJRR3NnQUMwQUFSQUJJQUlnQ2pvQUFDQUNRUUZxSVFJTUFRc0xBMEFnQWlBTVNRUkFJQVlnQlVGQWF5QUhFQUpCQVhScUlnQXRBQUFoQ2lBRlFVQnJJQUF0QUFFUUFTQUNJQW82QUFBZ0FrRUJhaUVDREFFTEN5QU5RWDFxSVFBRFFDQUZRU2hxRUFRZ0JDQUFUM0pGQkVBZ0JpQUZRU2hxSUFjUUFrRUJkR29pQWkwQUFDRUtJQVZCS0dvZ0FpMEFBUkFCSUFRZ0Nqb0FBQ0FHSUFWQktHb2dCeEFDUVFGMGFpSUNMUUFBSVFvZ0JVRW9haUFDTFFBQkVBRWdCQ0FLT2dBQklBUkJBbW9oQkF3QkN3c0RRQ0FGUVNocUVBUWdCQ0FOVDNKRkJFQWdCaUFGUVNocUlBY1FBa0VCZEdvaUFDMEFBQ0VDSUFWQktHb2dBQzBBQVJBQklBUWdBam9BQUNBRVFRRnFJUVFNQVFzTEEwQWdCQ0FOU1FSQUlBWWdCVUVvYWlBSEVBSkJBWFJxSWdBdEFBQWhBaUFGUVNocUlBQXRBQUVRQVNBRUlBSTZBQUFnQkVFQmFpRUVEQUVMQ3dOQUlBVkJFR29RQkNBRElBOVBja1VFUUNBR0lBVkJFR29nQnhBQ1FRRjBhaUlBTFFBQUlRSWdCVUVRYWlBQUxRQUJFQUVnQXlBQ09nQUFJQVlnQlVFUWFpQUhFQUpCQVhScUlnQXRBQUFoQWlBRlFSQnFJQUF0QUFFUUFTQURJQUk2QUFFZ0EwRUNhaUVEREFFTEN3TkFJQVZCRUdvUUJDQURJQTVQY2tVRVFDQUdJQVZCRUdvZ0J4QUNRUUYwYWlJQUxRQUFJUUlnQlVFUWFpQUFMUUFCRUFFZ0F5QUNPZ0FBSUFOQkFXb2hBd3dCQ3dzRFFDQURJQTVKQkVBZ0JpQUZRUkJxSUFjUUFrRUJkR29pQUMwQUFDRUNJQVZCRUdvZ0FDMEFBUkFCSUFNZ0Fqb0FBQ0FEUVFGcUlRTU1BUXNMSUFGQmJDQUZRZGdBYWhBS0lBVkJRR3NRQ25FZ0JVRW9haEFLY1NBRlFSQnFFQXB4R3lFSkRBRUxRV3doQ1FzZ0JVSHdBR29rQUNBSkM4b0NBUVIvSXdCQklHc2lCU1FBSUFVZ0JCQU9JQVV0QUFJaEJ5QUZRUWhxSUFJZ0F4QUdJZ0lRQTBVRVFDQUVRUVJxSVFJZ0FDQUJhaUlEUVgxcUlRUURRQ0FGUVFocUVBUWdBQ0FFVDNKRkJFQWdBaUFGUVFocUlBY1FBa0VCZEdvaUJpMEFBQ0VJSUFWQkNHb2dCaTBBQVJBQklBQWdDRG9BQUNBQ0lBVkJDR29nQnhBQ1FRRjBhaUlHTFFBQUlRZ2dCVUVJYWlBR0xRQUJFQUVnQUNBSU9nQUJJQUJCQW1vaEFBd0JDd3NEUUNBRlFRaHFFQVFnQUNBRFQzSkZCRUFnQWlBRlFRaHFJQWNRQWtFQmRHb2lCQzBBQUNFR0lBVkJDR29nQkMwQUFSQUJJQUFnQmpvQUFDQUFRUUZxSVFBTUFRc0xBMEFnQUNBRFQwVUVRQ0FDSUFWQkNHb2dCeEFDUVFGMGFpSUVMUUFBSVFZZ0JVRUlhaUFFTFFBQkVBRWdBQ0FHT2dBQUlBQkJBV29oQUF3QkN3c2dBVUZzSUFWQkNHb1FDaHNoQWdzZ0JVRWdhaVFBSUFJTHRnTUJDWDhqQUVFUWF5SUdKQUFnQmtFQU5nSU1JQVpCQURZQ0NFRlVJUVFDUUFKQUlBTkJRR3NpRENBRElBWkJDR29nQmtFTWFpQUJJQUlRTVNJQ0VBTU5BQ0FHUVFScUlBQVFEaUFHS0FJTUlnY2dCaTBBQkVFQmFrc05BU0FBUVFScUlRb2dCa0VBT2dBRklBWWdCem9BQmlBQUlBWW9BZ1EyQWdBZ0IwRUJhaUVKUVFFaEJBTkFJQVFnQ1VrRVFDQURJQVJCQW5ScUlnRW9BZ0FoQUNBQklBVTJBZ0FnQUNBRVFYOXFkQ0FGYWlFRklBUkJBV29oQkF3QkN3c2dCMEVCYWlFSFFRQWhCU0FHS0FJSUlRa0RRQ0FGSUFsR0RRRWdBeUFGSUF4cUxRQUFJZ1JCQW5ScUlnQkJBU0FFZEVFQmRTSUxJQUFvQWdBaUFXb2lBRFlDQUNBSElBUnJJUWhCQUNFRUFrQWdDMEVEVFFSQUEwQWdCQ0FMUmcwQ0lBb2dBU0FFYWtFQmRHb2lBQ0FJT2dBQklBQWdCVG9BQUNBRVFRRnFJUVFNQUFBTEFBc0RRQ0FCSUFCUERRRWdDaUFCUVFGMGFpSUVJQWc2QUFFZ0JDQUZPZ0FBSUFRZ0NEb0FBeUFFSUFVNkFBSWdCQ0FJT2dBRklBUWdCVG9BQkNBRUlBZzZBQWNnQkNBRk9nQUdJQUZCQkdvaEFRd0FBQXNBQ3lBRlFRRnFJUVVNQUFBTEFBc2dBaUVFQ3lBR1FSQnFKQUFnQkF1dEFRRUNmd0pBUVlRZ0tBSUFJQUJISUFBb0FnQkJBWFlpQXlBQmEwRjRhaUlDUVhoeFFRaEhjZ1IvSUFJRklBTVFKMFVOQVNBQ1FRaHFDMEVRU1EwQUlBQWdBQ2dDQUNJQ1FRRnhJQUFnQVdwQkQycEJlSEVpQVNBQWEwRUJkSEkyQWdBZ0FTQUFOZ0lFSUFFZ0FTZ0NBRUVCY1NBQUlBSkJBWFpxSUFGcklnSkJBWFJ5TmdJQVFZUWdJQUVnQWtILy8vLy9CM0ZxUVFScVFZUWdLQUlBSUFCR0d5QUJOZ0lBSUFFUUpRc0x5Z0lCQlg4Q1FBSkFBa0FnQUVFSUlBQkJDRXNiWjBFZmN5QUFhVUVCUjJvaUFVRUVTU0FBSUFGMmNnMEFJQUZCQW5SQi9CNXFLQUlBSWdKRkRRQURRQ0FDUVhocUlnTW9BZ0JCQVhaQmVHb2lCU0FBVHdSQUlBSWdCVUVJSUFWQkNFc2JaMEVmYzBFQ2RFR0FIMm9pQVNnQ0FFWUVRQ0FCSUFJb0FnUTJBZ0FMREFNTElBUkJIa3NOQVNBRVFRRnFJUVFnQWlnQ0JDSUNEUUFMQzBFQUlRTWdBVUVnVHcwQkEwQWdBVUVDZEVHQUgyb29BZ0FpQWtVRVFDQUJRUjVMSVFJZ0FVRUJhaUVCSUFKRkRRRU1Bd3NMSUFJZ0FrRjRhaUlES0FJQVFRRjJRWGhxSWdGQkNDQUJRUWhMRzJkQkgzTkJBblJCZ0I5cUlnRW9BZ0JHQkVBZ0FTQUNLQUlFTmdJQUN3c2dBaWdDQUNJQkJFQWdBU0FDS0FJRU5nSUVDeUFDS0FJRUlnRUVRQ0FCSUFJb0FnQTJBZ0FMSUFNZ0F5Z0NBRUVCY2pZQ0FDQURJQUFRTndzZ0F3dmhDd0lOZndWK0l3QkI4QUJySWdja0FDQUhJQUFvQXZEaEFTSUlOZ0pjSUFFZ0Ftb2hEU0FJSUFBb0FvRGlBV29oRHdKQUFrQWdCVVVFUUNBQklRUU1BUXNnQUNnQ3hPQUJJUkFnQUNnQ3dPQUJJUkVnQUNnQ3ZPQUJJUTRnQUVFQk5nS000UUZCQUNFSUEwQWdDRUVEUndSQUlBY2dDRUVDZENJQ2FpQUFJQUpxUWF6UUFXb29BZ0EyQWtRZ0NFRUJhaUVJREFFTEMwRnNJUXdnQjBFWWFpQURJQVFRQmhBRERRRWdCMEVzYWlBSFFSaHFJQUFvQWdBUUV5QUhRVFJxSUFkQkdHb2dBQ2dDQ0JBVElBZEJQR29nQjBFWWFpQUFLQUlFRUJNZ0RVRmdhaUVTSUFFaEJFRUFJUXdEUUNBSEtBSXdJQWNvQWl4QkEzUnFLUUlBSWhSQ0VJaW5RZjhCY1NFSUlBY29Ba0FnQnlnQ1BFRURkR29wQWdBaUZVSVFpS2RCL3dGeElRc2dCeWdDT0NBSEtBSTBRUU4wYWlrQ0FDSVdRaUNJcHlFSklCVkNJSWdoRnlBVVFpQ0lweUVDQWtBZ0ZrSVFpS2RCL3dGeElnTkJBazhFUUFKQUlBWkZJQU5CR1VseVJRUkFJQWtnQjBFWWFpQURRU0FnQnlnQ0hHc2lDaUFLSUFOTEd5SUtFQVVnQXlBS2F5SURkR29oQ1NBSFFSaHFFQVFhSUFORkRRRWdCMEVZYWlBREVBVWdDV29oQ1F3QkN5QUhRUmhxSUFNUUJTQUphaUVKSUFkQkdHb1FCQm9MSUFjcEFrUWhHQ0FISUFrMkFrUWdCeUFZTndOSURBRUxBa0FnQTBVRVFDQUNCRUFnQnlnQ1JDRUpEQU1MSUFjb0FrZ2hDUXdCQ3dKQUFrQWdCMEVZYWtFQkVBVWdDU0FDUldwcUlnTkJBMFlFUUNBSEtBSkVRWDlxSWdNZ0EwVnFJUWtNQVFzZ0EwRUNkQ0FIYWlnQ1JDSUpJQWxGYWlFSklBTkJBVVlOQVFzZ0J5QUhLQUpJTmdKTUN3c2dCeUFIS0FKRU5nSklJQWNnQ1RZQ1JBc2dGNmNoQXlBTEJFQWdCMEVZYWlBTEVBVWdBMm9oQXdzZ0NDQUxha0VVVHdSQUlBZEJHR29RQkJvTElBZ0VRQ0FIUVJocUlBZ1FCU0FDYWlFQ0N5QUhRUmhxRUFRYUlBY2dCMEVZYWlBVVFoaUlwMEgvQVhFUUNDQVVwMEgvL3dOeGFqWUNMQ0FISUFkQkdHb2dGVUlZaUtkQi93RnhFQWdnRmFkQi8vOERjV28yQWp3Z0IwRVlhaEFFR2lBSElBZEJHR29nRmtJWWlLZEIvd0Z4RUFnZ0ZxZEIvLzhEY1dvMkFqUWdCeUFDTmdKZ0lBY29BbHdoQ2lBSElBazJBbWdnQnlBRE5nSmtBa0FDUUFKQUlBUWdBaUFEYWlJTGFpQVNTdzBBSUFJZ0Ntb2lFeUFQU3cwQUlBMGdCR3NnQzBFZ2FrOE5BUXNnQnlBSEtRTm9Od01RSUFjZ0J5a0RZRGNEQ0NBRUlBMGdCMEVJYWlBSFFkd0FhaUFQSUE0Z0VTQVFFQjRoQ3d3QkN5QUNJQVJxSVFnZ0JDQUtFQWNnQWtFUlR3UkFJQVJCRUdvaEFnTkFJQUlnQ2tFUWFpSUtFQWNnQWtFUWFpSUNJQWhKRFFBTEN5QUlJQWxySVFJZ0J5QVROZ0pjSUFrZ0NDQU9hMHNFUUNBSklBZ2dFV3RMQkVCQmJDRUxEQUlMSUJBZ0FpQU9heUlDYWlJS0lBTnFJQkJOQkVBZ0NDQUtJQU1RRHhvTUFnc2dDQ0FLUVFBZ0Ftc1FEeUVJSUFjZ0FpQURhaUlETmdKa0lBZ2dBbXNoQ0NBT0lRSUxJQWxCRUU4RVFDQURJQWhxSVFNRFFDQUlJQUlRQnlBQ1FSQnFJUUlnQ0VFUWFpSUlJQU5KRFFBTERBRUxBa0FnQ1VFSFRRUkFJQWdnQWkwQUFEb0FBQ0FJSUFJdEFBRTZBQUVnQ0NBQ0xRQUNPZ0FDSUFnZ0FpMEFBem9BQXlBSVFRUnFJQUlnQ1VFQ2RDSURRY0FlYWlnQ0FHb2lBaEFYSUFJZ0EwSGdIbW9vQWdCcklRSWdCeWdDWkNFRERBRUxJQWdnQWhBTUN5QURRUWxKRFFBZ0F5QUlhaUVESUFoQkNHb2lDQ0FDUVFocUlnSnJRUTlNQkVBRFFDQUlJQUlRRENBQ1FRaHFJUUlnQ0VFSWFpSUlJQU5KRFFBTUFnQUxBQXNEUUNBSUlBSVFCeUFDUVJCcUlRSWdDRUVRYWlJSUlBTkpEUUFMQ3lBSFFSaHFFQVFhSUFzZ0RDQUxFQU1pQWhzaERDQUVJQVFnQzJvZ0Foc2hCQ0FGUVg5cUlnVU5BQXNnREJBRERRRkJiQ0VNSUFkQkdHb1FCRUVDU1EwQlFRQWhDQU5BSUFoQkEwY0VRQ0FBSUFoQkFuUWlBbXBCck5BQmFpQUNJQWRxS0FKRU5nSUFJQWhCQVdvaENBd0JDd3NnQnlnQ1hDRUlDMEc2ZnlFTUlBOGdDR3NpQUNBTklBUnJTdzBBSUFRRWZ5QUVJQWdnQUJBTElBQnFCVUVBQ3lBQmF5RU1DeUFIUWZBQWFpUUFJQXdMa1JjQ0ZuOEZmaU1BUWRBQmF5SUhKQUFnQnlBQUtBTHc0UUVpQ0RZQ3ZBRWdBU0FDYWlFU0lBZ2dBQ2dDZ09JQmFpRVRBa0FDUUNBRlJRUkFJQUVoQXd3QkN5QUFLQUxFNEFFaEVTQUFLQUxBNEFFaEZTQUFLQUs4NEFFaER5QUFRUUUyQW96aEFVRUFJUWdEUUNBSVFRTkhCRUFnQnlBSVFRSjBJZ0pxSUFBZ0FtcEJyTkFCYWlnQ0FEWUNWQ0FJUVFGcUlRZ01BUXNMSUFjZ0VUWUNaQ0FISUE4MkFtQWdCeUFCSUE5ck5nSm9RV3doRUNBSFFTaHFJQU1nQkJBR0VBTU5BU0FGUVFRZ0JVRUVTQnNoRnlBSFFUeHFJQWRCS0dvZ0FDZ0NBQkFUSUFkQnhBQnFJQWRCS0dvZ0FDZ0NDQkFUSUFkQnpBQnFJQWRCS0dvZ0FDZ0NCQkFUUVFBaEJDQUhRZUFBYWlFTUlBZEI1QUJxSVFvRFFDQUhRU2hxRUFSQkFrc2dCQ0FYVG5KRkJFQWdCeWdDUUNBSEtBSThRUU4wYWlrQ0FDSWRRaENJcDBIL0FYRWhDeUFIS0FKUUlBY29Ba3hCQTNScUtRSUFJaDVDRUlpblFmOEJjU0VKSUFjb0FrZ2dCeWdDUkVFRGRHb3BBZ0FpSDBJZ2lLY2hDQ0FlUWlDSUlTQWdIVUlnaUtjaEFnSkFJQjlDRUlpblFmOEJjU0lEUVFKUEJFQUNRQ0FHUlNBRFFSbEpja1VFUUNBSUlBZEJLR29nQTBFZ0lBY29BaXhySWcwZ0RTQURTeHNpRFJBRklBTWdEV3NpQTNScUlRZ2dCMEVvYWhBRUdpQURSUTBCSUFkQktHb2dBeEFGSUFocUlRZ01BUXNnQjBFb2FpQURFQVVnQ0dvaENDQUhRU2hxRUFRYUN5QUhLUUpVSVNFZ0J5QUlOZ0pVSUFjZ0lUY0RXQXdCQ3dKQUlBTkZCRUFnQWdSQUlBY29BbFFoQ0F3REN5QUhLQUpZSVFnTUFRc0NRQUpBSUFkQktHcEJBUkFGSUFnZ0FrVnFhaUlEUVFOR0JFQWdCeWdDVkVGL2FpSURJQU5GYWlFSURBRUxJQU5CQW5RZ0Iyb29BbFFpQ0NBSVJXb2hDQ0FEUVFGR0RRRUxJQWNnQnlnQ1dEWUNYQXNMSUFjZ0J5Z0NWRFlDV0NBSElBZzJBbFFMSUNDbklRTWdDUVJBSUFkQktHb2dDUkFGSUFOcUlRTUxJQWtnQzJwQkZFOEVRQ0FIUVNocUVBUWFDeUFMQkVBZ0IwRW9haUFMRUFVZ0Ftb2hBZ3NnQjBFb2FoQUVHaUFISUFjb0FtZ2dBbW9pQ1NBRGFqWUNhQ0FLSUF3Z0NDQUpTeHNvQWdBaERTQUhJQWRCS0dvZ0hVSVlpS2RCL3dGeEVBZ2dIYWRCLy84RGNXbzJBandnQnlBSFFTaHFJQjVDR0lpblFmOEJjUkFJSUI2blFmLy9BM0ZxTmdKTUlBZEJLR29RQkJvZ0IwRW9haUFmUWhpSXAwSC9BWEVRQ0NFT0lBZEI4QUJxSUFSQkJIUnFJZ3NnQ1NBTmFpQUlhellDRENBTElBZzJBZ2dnQ3lBRE5nSUVJQXNnQWpZQ0FDQUhJQTRnSDZkQi8vOERjV28yQWtRZ0JFRUJhaUVFREFFTEN5QUVJQmRJRFFFZ0VrRmdhaUVZSUFkQjRBQnFJUm9nQjBIa0FHb2hHeUFCSVFNRFFDQUhRU2hxRUFSQkFrc2dCQ0FGVG5KRkJFQWdCeWdDUUNBSEtBSThRUU4wYWlrQ0FDSWRRaENJcDBIL0FYRWhDeUFIS0FKUUlBY29Ba3hCQTNScUtRSUFJaDVDRUlpblFmOEJjU0VJSUFjb0FrZ2dCeWdDUkVFRGRHb3BBZ0FpSDBJZ2lLY2hDU0FlUWlDSUlTQWdIVUlnaUtjaERBSkFJQjlDRUlpblFmOEJjU0lDUVFKUEJFQUNRQ0FHUlNBQ1FSbEpja1VFUUNBSklBZEJLR29nQWtFZ0lBY29BaXhySWdvZ0NpQUNTeHNpQ2hBRklBSWdDbXNpQW5ScUlRa2dCMEVvYWhBRUdpQUNSUTBCSUFkQktHb2dBaEFGSUFscUlRa01BUXNnQjBFb2FpQUNFQVVnQ1dvaENTQUhRU2hxRUFRYUN5QUhLUUpVSVNFZ0J5QUpOZ0pVSUFjZ0lUY0RXQXdCQ3dKQUlBSkZCRUFnREFSQUlBY29BbFFoQ1F3REN5QUhLQUpZSVFrTUFRc0NRQUpBSUFkQktHcEJBUkFGSUFrZ0RFVnFhaUlDUVFOR0JFQWdCeWdDVkVGL2FpSUNJQUpGYWlFSkRBRUxJQUpCQW5RZ0Iyb29BbFFpQ1NBSlJXb2hDU0FDUVFGR0RRRUxJQWNnQnlnQ1dEWUNYQXNMSUFjZ0J5Z0NWRFlDV0NBSElBazJBbFFMSUNDbklSUWdDQVJBSUFkQktHb2dDQkFGSUJScUlSUUxJQWdnQzJwQkZFOEVRQ0FIUVNocUVBUWFDeUFMQkVBZ0IwRW9haUFMRUFVZ0RHb2hEQXNnQjBFb2FoQUVHaUFISUFjb0FtZ2dER29pR1NBVWFqWUNhQ0FiSUJvZ0NTQVpTeHNvQWdBaEhDQUhJQWRCS0dvZ0hVSVlpS2RCL3dGeEVBZ2dIYWRCLy84RGNXbzJBandnQnlBSFFTaHFJQjVDR0lpblFmOEJjUkFJSUI2blFmLy9BM0ZxTmdKTUlBZEJLR29RQkJvZ0J5QUhRU2hxSUI5Q0dJaW5RZjhCY1JBSUlCK25RZi8vQTNGcU5nSkVJQWNnQjBId0FHb2dCRUVEY1VFRWRHb2lEU2tEQ0NJZE53UElBU0FISUEwcEF3QWlIamNEd0FFQ1FBSkFBa0FnQnlnQ3ZBRWlEaUFlcHlJQ2FpSVdJQk5MRFFBZ0F5QUhLQUxFQVNJS0lBSnFJZ3RxSUJoTERRQWdFaUFEYXlBTFFTQnFUdzBCQ3lBSElBY3BBOGdCTndNUUlBY2dCeWtEd0FFM0F3Z2dBeUFTSUFkQkNHb2dCMEc4QVdvZ0V5QVBJQlVnRVJBZUlRc01BUXNnQWlBRGFpRUlJQU1nRGhBSElBSkJFVThFUUNBRFFSQnFJUUlEUUNBQ0lBNUJFR29pRGhBSElBSkJFR29pQWlBSVNRMEFDd3NnQ0NBZHB5SU9heUVDSUFjZ0ZqWUN2QUVnRGlBSUlBOXJTd1JBSUE0Z0NDQVZhMHNFUUVGc0lRc01BZ3NnRVNBQ0lBOXJJZ0pxSWhZZ0Ntb2dFVTBFUUNBSUlCWWdDaEFQR2d3Q0N5QUlJQlpCQUNBQ2F4QVBJUWdnQnlBQ0lBcHFJZ28yQXNRQklBZ2dBbXNoQ0NBUElRSUxJQTVCRUU4RVFDQUlJQXBxSVFvRFFDQUlJQUlRQnlBQ1FSQnFJUUlnQ0VFUWFpSUlJQXBKRFFBTERBRUxBa0FnRGtFSFRRUkFJQWdnQWkwQUFEb0FBQ0FJSUFJdEFBRTZBQUVnQ0NBQ0xRQUNPZ0FDSUFnZ0FpMEFBem9BQXlBSVFRUnFJQUlnRGtFQ2RDSUtRY0FlYWlnQ0FHb2lBaEFYSUFJZ0NrSGdIbW9vQWdCcklRSWdCeWdDeEFFaENnd0JDeUFJSUFJUURBc2dDa0VKU1EwQUlBZ2dDbW9oQ2lBSVFRaHFJZ2dnQWtFSWFpSUNhMEVQVEFSQUEwQWdDQ0FDRUF3Z0FrRUlhaUVDSUFoQkNHb2lDQ0FLU1EwQURBSUFDd0FMQTBBZ0NDQUNFQWNnQWtFUWFpRUNJQWhCRUdvaUNDQUtTUTBBQ3dzZ0N4QURCRUFnQ3lFUURBUUZJQTBnRERZQ0FDQU5JQmtnSEdvZ0NXczJBZ3dnRFNBSk5nSUlJQTBnRkRZQ0JDQUVRUUZxSVFRZ0F5QUxhaUVEREFJTEFBc0xJQVFnQlVnTkFTQUVJQmRySVF0QkFDRUVBMEFnQ3lBRlNBUkFJQWNnQjBId0FHb2dDMEVEY1VFRWRHb2lBaWtEQ0NJZE53UElBU0FISUFJcEF3QWlIamNEd0FFQ1FBSkFBa0FnQnlnQ3ZBRWlEQ0FlcHlJQ2FpSUtJQk5MRFFBZ0F5QUhLQUxFQVNJSklBSnFJaEJxSUJoTERRQWdFaUFEYXlBUVFTQnFUdzBCQ3lBSElBY3BBOGdCTndNZ0lBY2dCeWtEd0FFM0F4Z2dBeUFTSUFkQkdHb2dCMEc4QVdvZ0V5QVBJQlVnRVJBZUlSQU1BUXNnQWlBRGFpRUlJQU1nREJBSElBSkJFVThFUUNBRFFSQnFJUUlEUUNBQ0lBeEJFR29pREJBSElBSkJFR29pQWlBSVNRMEFDd3NnQ0NBZHB5SUdheUVDSUFjZ0NqWUN2QUVnQmlBSUlBOXJTd1JBSUFZZ0NDQVZhMHNFUUVGc0lSQU1BZ3NnRVNBQ0lBOXJJZ0pxSWd3Z0NXb2dFVTBFUUNBSUlBd2dDUkFQR2d3Q0N5QUlJQXhCQUNBQ2F4QVBJUWdnQnlBQ0lBbHFJZ2syQXNRQklBZ2dBbXNoQ0NBUElRSUxJQVpCRUU4RVFDQUlJQWxxSVFZRFFDQUlJQUlRQnlBQ1FSQnFJUUlnQ0VFUWFpSUlJQVpKRFFBTERBRUxBa0FnQmtFSFRRUkFJQWdnQWkwQUFEb0FBQ0FJSUFJdEFBRTZBQUVnQ0NBQ0xRQUNPZ0FDSUFnZ0FpMEFBem9BQXlBSVFRUnFJQUlnQmtFQ2RDSUdRY0FlYWlnQ0FHb2lBaEFYSUFJZ0JrSGdIbW9vQWdCcklRSWdCeWdDeEFFaENRd0JDeUFJSUFJUURBc2dDVUVKU1EwQUlBZ2dDV29oQmlBSVFRaHFJZ2dnQWtFSWFpSUNhMEVQVEFSQUEwQWdDQ0FDRUF3Z0FrRUlhaUVDSUFoQkNHb2lDQ0FHU1EwQURBSUFDd0FMQTBBZ0NDQUNFQWNnQWtFUWFpRUNJQWhCRUdvaUNDQUdTUTBBQ3dzZ0VCQUREUU1nQzBFQmFpRUxJQU1nRUdvaEF3d0JDd3NEUUNBRVFRTkhCRUFnQUNBRVFRSjBJZ0pxUWF6UUFXb2dBaUFIYWlnQ1ZEWUNBQ0FFUVFGcUlRUU1BUXNMSUFjb0Fyd0JJUWdMUWJwL0lSQWdFeUFJYXlJQUlCSWdBMnRMRFFBZ0F3Ui9JQU1nQ0NBQUVBc2dBR29GUVFBTElBRnJJUkFMSUFkQjBBRnFKQUFnRUFzbEFDQUFRZ0EzQWdBZ0FFRUFPd0VJSUFCQkFEb0FDeUFBSUFFMkFnd2dBQ0FDT2dBS0M3UUZBUU4vSXdCQk1Hc2lCQ1FBSUFCQi93RnFJZ1ZCZldvaEJnSkFJQU12QVFJRVFDQUVRUmhxSUFFZ0FoQUdJZ0lRQXcwQklBUkJFR29nQkVFWWFpQURFQndnQkVFSWFpQUVRUmhxSUFNUUhDQUFJUU1EUUFKQUlBUkJHR29RQkNBRElBWlBja1VFUUNBRElBUkJFR29nQkVFWWFoQVNPZ0FBSUFNZ0JFRUlhaUFFUVJocUVCSTZBQUVnQkVFWWFoQUVSUTBCSUFOQkFtb2hBd3NnQlVGK2FpRUZBbjhEUUVHNmZ5RUNJQU1pQVNBRlN3MEZJQUVnQkVFUWFpQUVRUmhxRUJJNkFBQWdBVUVCYWlFRElBUkJHR29RQkVFRFJnUkFRUUloQWlBRVFRaHFEQUlMSUFNZ0JVc05CU0FCSUFSQkNHb2dCRUVZYWhBU09nQUJJQUZCQW1vaEEwRURJUUlnQkVFWWFoQUVRUU5IRFFBTElBUkJFR29MSVFVZ0F5QUZJQVJCR0dvUUVqb0FBQ0FCSUFKcUlBQnJJUUlNQXdzZ0F5QUVRUkJxSUFSQkdHb1FFam9BQWlBRElBUkJDR29nQkVFWWFoQVNPZ0FESUFOQkJHb2hBd3dBQUFzQUN5QUVRUmhxSUFFZ0FoQUdJZ0lRQXcwQUlBUkJFR29nQkVFWWFpQURFQndnQkVFSWFpQUVRUmhxSUFNUUhDQUFJUU1EUUFKQUlBUkJHR29RQkNBRElBWlBja1VFUUNBRElBUkJFR29nQkVFWWFoQVJPZ0FBSUFNZ0JFRUlhaUFFUVJocUVCRTZBQUVnQkVFWWFoQUVSUTBCSUFOQkFtb2hBd3NnQlVGK2FpRUZBbjhEUUVHNmZ5RUNJQU1pQVNBRlN3MEVJQUVnQkVFUWFpQUVRUmhxRUJFNkFBQWdBVUVCYWlFRElBUkJHR29RQkVFRFJnUkFRUUloQWlBRVFRaHFEQUlMSUFNZ0JVc05CQ0FCSUFSQkNHb2dCRUVZYWhBUk9nQUJJQUZCQW1vaEEwRURJUUlnQkVFWWFoQUVRUU5IRFFBTElBUkJFR29MSVFVZ0F5QUZJQVJCR0dvUUVUb0FBQ0FCSUFKcUlBQnJJUUlNQWdzZ0F5QUVRUkJxSUFSQkdHb1FFVG9BQWlBRElBUkJDR29nQkVFWWFoQVJPZ0FESUFOQkJHb2hBd3dBQUFzQUN5QUVRVEJxSkFBZ0FndHBBUUYvQW44Q1FBSkFJQUpCQjAwTkFDQUJLQUFBUWJmSXd1RitSdzBBSUFBZ0FTZ0FCRFlDbU9JQlFXSWdBRUVRYWlBQklBSVFQaUlERUFNTkFob2dBRUtCZ0lDQUVEY0RpT0VCSUFBZ0FTQURhaUFDSUFOckVDb01BUXNnQUNBQklBSVFLZ3RCQUFzTHJRTUJCbjhqQUVHQUFXc2lBeVFBUVdJaENBSkFJQUpCQ1VrTkFDQUFRWmpRQUdvZ0FVRUlhaUlFSUFKQmVHb2dBRUdZMEFBUU15SUZFQU1pQmcwQUlBTkJIellDZkNBRElBTkIvQUJxSUFOQitBQnFJQVFnQkNBRmFpQUdHeUlFSUFFZ0Ftb2lBaUFFYXhBVklnVVFBdzBBSUFNb0Fud2lCa0VmU3cwQUlBTW9BbmdpQjBFSlR3MEFJQUJCaUNCcUlBTWdCa0dBQzBHQURDQUhFQmdnQTBFME5nSjhJQU1nQTBIOEFHb2dBMEg0QUdvZ0JDQUZhaUlFSUFJZ0JHc1FGU0lGRUFNTkFDQURLQUo4SWdaQk5Fc05BQ0FES0FKNElnZEJDazhOQUNBQVFaQXdhaUFESUFaQmdBMUI0QTRnQnhBWUlBTkJJellDZkNBRElBTkIvQUJxSUFOQitBQnFJQVFnQldvaUJDQUNJQVJyRUJVaUJSQUREUUFnQXlnQ2ZDSUdRU05MRFFBZ0F5Z0NlQ0lIUVFwUERRQWdBQ0FESUFaQndCQkIwQkVnQnhBWUlBUWdCV29pQkVFTWFpSUZJQUpMRFFBZ0FpQUZheUVGUVFBaEFnTkFJQUpCQTBjRVFDQUVLQUFBSWdaQmYyb2dCVThOQWlBQUlBSkJBblJxUVp6UUFXb2dCallDQUNBQ1FRRnFJUUlnQkVFRWFpRUVEQUVMQ3lBRUlBRnJJUWdMSUFOQmdBRnFKQUFnQ0F0R0FRTi9JQUJCQ0dvaEF5QUFLQUlFSVFKQkFDRUFBMEFnQUNBQ2RrVUVRQ0FCSUFNZ0FFRURkR290QUFKQkZrdHFJUUVnQUVFQmFpRUFEQUVMQ3lBQlFRZ2dBbXQwQzRZREFRVi9RYmgvSVFjQ1FDQURSUTBBSUFJdEFBQWlCRVVFUUNBQlFRQTJBZ0JCQVVHNGZ5QURRUUZHR3c4TEFuOGdBa0VCYWlJRklBUkJHSFJCR0hVaUJrRi9TZzBBR2lBR1FYOUdCRUFnQTBFRFNBMENJQVV2QUFCQmdQNEJhaUVFSUFKQkEyb01BUXNnQTBFQ1NBMEJJQUl0QUFFZ0JFRUlkSEpCZ0lCK2FpRUVJQUpCQW1vTElRVWdBU0FFTmdJQUlBVkJBV29pQVNBQ0lBTnFJZ05MRFFCQmJDRUhJQUJCRUdvZ0FDQUZMUUFBSWdWQkJuWkJJMEVKSUFFZ0F5QUJhMEhBRUVIUUVVSHdFaUFBS0FLTTRRRWdBQ2dDbk9JQklBUVFIeUlHRUFNaUNBMEFJQUJCbUNCcUlBQkJDR29nQlVFRWRrRURjVUVmUVFnZ0FTQUJJQVpxSUFnYklnRWdBeUFCYTBHQUMwR0FERUdBRnlBQUtBS000UUVnQUNnQ25PSUJJQVFRSHlJR0VBTWlDQTBBSUFCQm9EQnFJQUJCQkdvZ0JVRUNka0VEY1VFMFFRa2dBU0FCSUFacUlBZ2JJZ0VnQXlBQmEwR0FEVUhnRGtHUUdTQUFLQUtNNFFFZ0FDZ0NuT0lCSUFRUUh5SUFFQU1OQUNBQUlBRnFJQUpySVFjTElBY0xyUU1CQ244akFFR0FCR3NpQ0NRQUFuOUJVaUFDUWY4QlN3MEFHa0ZVSUFOQkRFc05BQm9nQWtFQmFpRUxJQUJCQkdvaENVR0FnQVFnQTBGL2FuUkJFSFVoQ2tFQUlRSkJBU0VFUVFFZ0EzUWlCMEYvYWlJTUlRVURRQ0FDSUF0R1JRUkFBa0FnQVNBQ1FRRjBJZzFxTHdFQUlnWkIvLzhEUmdSQUlBa2dCVUVDZEdvZ0Fqb0FBaUFGUVg5cUlRVkJBU0VHREFFTElBUkJBQ0FLSUFaQkVIUkJFSFZLR3lFRUN5QUlJQTFxSUFZN0FRQWdBa0VCYWlFQ0RBRUxDeUFBSUFRN0FRSWdBQ0FET3dFQUlBZEJBM1lnQjBFQmRtcEJBMm9oQmtFQUlRUkJBQ0VDQTBBZ0JDQUxSa1VFUUNBQklBUkJBWFJxTGdFQUlRcEJBQ0VBQTBBZ0FDQUtUa1VFUUNBSklBSkJBblJxSUFRNkFBSURRQ0FDSUFacUlBeHhJZ0lnQlVzTkFBc2dBRUVCYWlFQURBRUxDeUFFUVFGcUlRUU1BUXNMUVg4Z0FnMEFHa0VBSVFJRGZ5QUNJQWRHQkg5QkFBVWdDQ0FKSUFKQkFuUnFJZ0F0QUFKQkFYUnFJZ0VnQVM4QkFDSUJRUUZxT3dFQUlBQWdBeUFCRUJScklnVTZBQU1nQUNBQklBVkIvd0Z4ZENBSGF6c0JBQ0FDUVFGcUlRSU1BUXNMQ3lFRklBaEJnQVJxSkFBZ0JRdmpCZ0VJZjBGc0lRY0NRQ0FDUVFOSkRRQUNRQUpBQWtBQ1FDQUJMUUFBSWdOQkEzRWlDVUVCYXc0REF3RUFBZ3NnQUNnQ2lPRUJEUUJCWWc4TElBSkJCVWtOQWtFRElRWWdBU2dBQUNFRkFuOENRQUpBSUFOQkFuWkJBM0VpQ0VGK2FpSUVRUUZOQkVBZ0JFRUJhdzBCREFJTElBVkJEblpCL3dkeElRUWdCVUVFZGtIL0IzRWhBeUFJUlF3Q0N5QUZRUkoySVFSQkJDRUdJQVZCQkhaQi8vOEFjU0VEUVFBTUFRc2dCVUVFZGtILy93OXhJZ05CZ0lBSVN3MERJQUV0QUFSQkNuUWdCVUVXZG5JaEJFRUZJUVpCQUFzaEJTQUVJQVpxSWdvZ0Frc05BZ0pBSUFOQmdRWkpEUUFnQUNnQ25PSUJSUTBBUVFBaEFnTkFJQUpCZzRBQlN3MEJJQUpCUUdzaEFnd0FBQXNBQ3dKL0lBbEJBMFlFUUNBQklBWnFJUUVnQUVIdzRnRnFJUUlnQUNnQ0RDRUdJQVVFUUNBQ0lBTWdBU0FFSUFZUVh3d0NDeUFDSUFNZ0FTQUVJQVlRWFF3QkN5QUFRYmpRQVdvaEFpQUJJQVpxSVFFZ0FFSHc0Z0ZxSVFZZ0FFR28wQUJxSVFnZ0JRUkFJQWdnQmlBRElBRWdCQ0FDRUY0TUFRc2dDQ0FHSUFNZ0FTQUVJQUlRWEFzUUF3MENJQUFnQXpZQ2dPSUJJQUJCQVRZQ2lPRUJJQUFnQUVIdzRnRnFOZ0x3NFFFZ0NVRUNSZ1JBSUFBZ0FFR28wQUJxTmdJTUN5QUFJQU5xSWdCQmlPTUJha0lBTndBQUlBQkJnT01CYWtJQU53QUFJQUJCK09JQmFrSUFOd0FBSUFCQjhPSUJha0lBTndBQUlBb1BDd0ovQWtBQ1FBSkFJQU5CQW5aQkEzRkJmMm9pQkVFQ1N3MEFJQVJCQVdzT0FnQUNBUXRCQVNFRUlBTkJBM1lNQWd0QkFpRUVJQUV2QUFCQkJIWU1BUXRCQXlFRUlBRVFJVUVFZGdzaUF5QUVhaUlGUVNCcUlBSkxCRUFnQlNBQ1N3MENJQUJCOE9JQmFpQUJJQVJxSUFNUUN5RUJJQUFnQXpZQ2dPSUJJQUFnQVRZQzhPRUJJQUVnQTJvaUFFSUFOd0FZSUFCQ0FEY0FFQ0FBUWdBM0FBZ2dBRUlBTndBQUlBVVBDeUFBSUFNMkFvRGlBU0FBSUFFZ0JHbzJBdkRoQVNBRkR3c0Nmd0pBQWtBQ1FDQURRUUoyUVFOeFFYOXFJZ1JCQWtzTkFDQUVRUUZyRGdJQUFnRUxRUUVoQnlBRFFRTjJEQUlMUVFJaEJ5QUJMd0FBUVFSMkRBRUxJQUpCQkVrZ0FSQWhJZ0pCajRDQUFVdHlEUUZCQXlFSElBSkJCSFlMSVFJZ0FFSHc0Z0ZxSUFFZ0Iyb3RBQUFnQWtFZ2FoQVFJUUVnQUNBQ05nS0E0Z0VnQUNBQk5nTHc0UUVnQjBFQmFpRUhDeUFIQzBzQUlBQkMrZXJRME9mSm9lVGhBRGNESUNBQVFnQTNBeGdnQUVMUDF0Tyswc2VyMlVJM0F4QWdBRUxXNjRMdTZ2Mko5ZUFBTndNSUlBQkNBRGNEQUNBQVFTaHFRUUJCS0JBUUdndmlBZ0lDZndWK0lBQkJLR29pQVNBQUtBSklhaUVDQW40Z0FDa0RBQ0lEUWlCYUJFQWdBQ2tERUNJRVFnZUpJQUFwQXdnaUJVSUJpWHdnQUNrREdDSUdRZ3lKZkNBQUtRTWdJZ2RDRW9sOElBVVFHU0FFRUJrZ0JoQVpJQWNRR1F3QkN5QUFLUU1ZUXNYUDJiTHg1YnJxSjN3TElBTjhJUU1EUUNBQlFRaHFJZ0FnQWswRVFFSUFJQUVwQUFBUUNTQURoVUliaVVLSGxhK3ZtTGJlbTU1L2ZrTGozTXFWL003eTlZVi9mQ0VESUFBaEFRd0JDd3NDUUNBQlFRUnFJZ0FnQWtzRVFDQUJJUUFNQVFzZ0FTZ0FBSzFDaDVXdnI1aTIzcHVlZjM0Z0E0VkNGNGxDejliVHZ0TEhxOWxDZmtMNTg5M3htZmFacXhaOElRTUxBMEFnQUNBQ1NRUkFJQUF4QUFCQ3hjL1pzdkhsdXVvbmZpQURoVUlMaVVLSGxhK3ZtTGJlbTU1L2ZpRURJQUJCQVdvaEFBd0JDd3NnQTBJaGlDQURoVUxQMXRPKzBzZXIyVUorSWdOQ0hZZ2dBNFZDK2ZQZDhabjJtYXNXZmlJRFFpQ0lJQU9GQys4Q0FnSi9CSDRnQUNBQUtRTUFJQUt0ZkRjREFBSkFBa0FnQUNnQ1NDSURJQUpxSWdSQkgwMEVRQ0FCUlEwQklBQWdBMnBCS0dvZ0FTQUNFQ0FnQUNnQ1NDQUNhaUVFREFFTElBRWdBbW9oQWdKL0lBTUVRQ0FBUVNocUlnUWdBMm9nQVVFZ0lBTnJFQ0FnQUNBQUtRTUlJQVFwQUFBUUNUY0RDQ0FBSUFBcEF4QWdBQ2tBTUJBSk53TVFJQUFnQUNrREdDQUFLUUE0RUFrM0F4Z2dBQ0FBS1FNZ0lBQkJRR3NwQUFBUUNUY0RJQ0FBS0FKSUlRTWdBRUVBTmdKSUlBRWdBMnRCSUdvaEFRc2dBVUVnYWlBQ1RRc0VRQ0FDUVdCcUlRTWdBQ2tESUNFRklBQXBBeGdoQmlBQUtRTVFJUWNnQUNrRENDRUlBMEFnQ0NBQktRQUFFQWtoQ0NBSElBRXBBQWdRQ1NFSElBWWdBU2tBRUJBSklRWWdCU0FCS1FBWUVBa2hCU0FCUVNCcUlnRWdBMDBOQUFzZ0FDQUZOd01nSUFBZ0JqY0RHQ0FBSUFjM0F4QWdBQ0FJTndNSUN5QUJJQUpQRFFFZ0FFRW9haUFCSUFJZ0FXc2lCQkFnQ3lBQUlBUTJBa2dMQ3k4QkFYOGdBRVVFUUVHMmYwRUFJQU1iRHd0QnVuOGhCQ0FESUFGTkJIOGdBQ0FDSUFNUUVCb2dBd1ZCdW44TEN5OEJBWDhnQUVVRVFFRzJmMEVBSUFNYkR3dEJ1bjhoQkNBRElBRk5CSDhnQUNBQ0lBTVFDeG9nQXdWQnVuOExDNmdDQVFaL0l3QkJFR3NpQnlRQUlBQkIyT0FCYWlrREFFS0FnSUFRVmlFSVFiaC9JUVVDUUNBRVFmLy9CMHNOQUNBQUlBTWdCQkJDSWdVUUF5SUdEUUFnQUNnQ25PSUJJUWtnQUNBSFFReHFJQU1nQXlBRmFpQUdHeUlLSUFSQkFDQUZJQVliYXlJR0VFQWlBeEFEQkVBZ0F5RUZEQUVMSUFjb0Fnd2hCQ0FCUlFSQVFicC9JUVVnQkVFQVNnMEJDeUFHSUFOcklRVWdBeUFLYWlFREFrQWdDUVJBSUFCQkFEWUNuT0lCREFFTEFrQUNRQUpBSUFSQkJVZ05BQ0FBUWRqZ0FXb3BBd0JDZ0lDQUNGZ05BQXdCQ3lBQVFRQTJBcHppQVF3QkN5QUFLQUlJRUQ4aEJpQUFRUUEyQXB6aUFTQUdRUlJQRFFFTElBQWdBU0FDSUFNZ0JTQUVJQWdRT1NFRkRBRUxJQUFnQVNBQ0lBTWdCU0FFSUFnUU9pRUZDeUFIUVJCcUpBQWdCUXRuQUNBQVFkRGdBV29nQVNBQ0lBQW9BdXpoQVJBdUlnRVFBd1JBSUFFUEMwRzRmeUVDQWtBZ0FRMEFJQUJCN09BQmFpZ0NBQ0lCQkVCQllDRUNJQUFvQXBqaUFTQUJSdzBCQzBFQUlRSWdBRUh3NEFGcUtBSUFSUTBBSUFCQmtPRUJhaEJEQ3lBQ0N5Y0JBWDhRVnlJRVJRUkFRVUFQQ3lBRUlBQWdBU0FDSUFNZ0JCQkxFRThoQUNBRUVGWWdBQXMvQVFGL0FrQUNRQUpBSUFBb0FxRGlBVUVCYWlJQlFRSkxEUUFnQVVFQmF3NENBQUVDQ3lBQUVEQkJBQThMSUFCQkFEWUNvT0lCQ3lBQUtBS1U0Z0VMdkFNQ0IzOEJmaU1BUVJCcklna2tBRUc0ZnlFR0FrQWdCQ2dDQUNJSVFRVkJDU0FBS0FMczRRRWlCUnRKRFFBZ0F5Z0NBQ0lIUVFGQkJTQUZHeUFGRUM4aUJSQURCRUFnQlNFR0RBRUxJQWdnQlVFRGFra05BQ0FBSUFjZ0JSQkpJZ1lRQXcwQUlBRWdBbW9oQ2lBQVFaRGhBV29oQ3lBSUlBVnJJUUlnQlNBSGFpRUhJQUVoQlFOQUlBY2dBaUFKRUN3aUJoQUREUUVnQWtGOWFpSUNJQVpKQkVCQnVIOGhCZ3dDQ3lBSktBSUFJZ2hCQWtzRVFFRnNJUVlNQWdzZ0IwRURhaUVIQW44Q1FBSkFBa0FnQ0VFQmF3NENBZ0FCQ3lBQUlBVWdDaUFGYXlBSElBWVFTQXdDQ3lBRklBb2dCV3NnQnlBR0VFY01BUXNnQlNBS0lBVnJJQWN0QUFBZ0NTZ0NDQkJHQ3lJSUVBTUVRQ0FJSVFZTUFnc2dBQ2dDOE9BQkJFQWdDeUFGSUFnUVJRc2dBaUFHYXlFQ0lBWWdCMm9oQnlBRklBaHFJUVVnQ1NnQ0JFVU5BQXNnQUNrRDBPQUJJZ3hDZjFJRVFFRnNJUVlnRENBRklBRnJyRklOQVFzZ0FDZ0M4T0FCQkVCQmFpRUdJQUpCQkVrTkFTQUxFRVFoRENBSEtBQUFJQXluUncwQklBZEJCR29oQnlBQ1FYeHFJUUlMSUFNZ0J6WUNBQ0FFSUFJMkFnQWdCU0FCYXlFR0N5QUpRUkJxSkFBZ0Jnc3VBQ0FBRUNzQ2YwRUFRUUFRQXcwQUdpQUJSU0FDUlhKRkJFQkJZaUFBSUFFZ0FoQTlFQU1OQVJvTFFRQUxDemNBSUFFRVFDQUFJQUFvQXNUZ0FTQUJLQUlFSUFFb0FnaHFSellDbk9JQkN5QUFFQ3RCQUJBRElBRkZja1VFUUNBQUlBRVFXd3NMMFFJQkIzOGpBRUVRYXlJR0pBQWdCaUFFTmdJSUlBWWdBellDRENBRkJFQWdCU2dDQkNFS0lBVW9BZ2doQ1FzZ0FTRUlBa0FDUUFOQUlBQW9BdXpoQVJBV0lRc0NRQU5BSUFRZ0Mwa05BU0FES0FBQVFYQnhRZERVdE1JQlJnUkFJQU1nQkJBaUlnY1FBdzBFSUFRZ0Iyc2hCQ0FESUFkcUlRTU1BUXNMSUFZZ0F6WUNEQ0FHSUFRMkFnZ0NRQ0FGQkVBZ0FDQUZFRTVCQUNFSFFRQVFBMFVOQVF3RkN5QUFJQW9nQ1JCTklnY1FBdzBFQ3lBQUlBZ1FVQ0FNUVFGSFFRQWdBQ0FJSUFJZ0JrRU1haUFHUVFocUVFd2lCeUlEYTBFQUlBTVFBeHRCQ2tkeVJRUkFRYmgvSVFjTUJBc2dCeEFERFFNZ0FpQUhheUVDSUFjZ0NHb2hDRUVCSVF3Z0JpZ0NEQ0VESUFZb0FnZ2hCQXdCQ3dzZ0JpQUROZ0lNSUFZZ0JEWUNDRUc0ZnlFSElBUU5BU0FJSUFGcklRY01BUXNnQmlBRE5nSU1JQVlnQkRZQ0NBc2dCa0VRYWlRQUlBY0xSZ0VDZnlBQklBQW9BcmpnQVNJQ1J3UkFJQUFnQWpZQ3hPQUJJQUFnQVRZQ3VPQUJJQUFvQXJ6Z0FTRURJQUFnQVRZQ3ZPQUJJQUFnQVNBRElBSnJhallDd09BQkN3dXRBZ0lFZndGK0l3QkJRR29pQkNRQUFrQUNRQ0FDUVFoSkRRQWdBU2dBQUVGd2NVSFExTFRDQVVjTkFDQUJJQUlRSWlFQklBQkNBRGNEQ0NBQVFRQTJBZ1FnQUNBQk5nSUFEQUVMSUFSQkdHb2dBU0FDRUMwaUF4QURCRUFnQUNBREVCb01BUXNnQXdSQUlBQkJ1SDhRR2d3QkN5QUNJQVFvQWpBaUEyc2hBaUFCSUFOcUlRTURRQUpBSUFBZ0F5QUNJQVJCQ0dvUUxDSUZFQU1FZnlBRkJTQUNJQVZCQTJvaUJVOE5BVUc0ZndzUUdnd0NDeUFHUVFGcUlRWWdBaUFGYXlFQ0lBTWdCV29oQXlBRUtBSU1SUTBBQ3lBRUtBSTRCRUFnQWtFRFRRUkFJQUJCdUg4UUdnd0NDeUFEUVFScUlRTUxJQVFvQWlnaEFpQUVLUU1ZSVFjZ0FFRUFOZ0lFSUFBZ0F5QUJhellDQUNBQUlBSWdCbXl0SUFjZ0IwSi9VUnMzQXdnTElBUkJRR3NrQUFzbEFRRi9Jd0JCRUdzaUFpUUFJQUlnQUNBQkVGRWdBaWdDQUNFQUlBSkJFR29rQUNBQUMzMEJCSDhqQUVHUUJHc2lCQ1FBSUFSQi93RTJBZ2dDUUNBRVFSQnFJQVJCQ0dvZ0JFRU1haUFCSUFJUUZTSUdFQU1FUUNBR0lRVU1BUXRCVkNFRklBUW9BZ3dpQjBFR1N3MEFJQU1nQkVFUWFpQUVLQUlJSUFjUVFTSUZFQU1OQUNBQUlBRWdCbW9nQWlBR2F5QURFRHdoQlFzZ0JFR1FCR29rQUNBRkM0Y0JBZ0ovQW41QkFCQVdJUU1DUUFOQUlBRWdBMDhFUUFKQUlBQW9BQUJCY0hGQjBOUzB3Z0ZHQkVBZ0FDQUJFQ0lpQWhBRFJRMEJRbjRQQ3lBQUlBRVFWU0lFUW4xV0RRTWdCQ0FGZkNJRklBUlVJUUpDZmlFRUlBSU5BeUFBSUFFUVVpSUNFQU1OQXdzZ0FTQUNheUVCSUFBZ0Ftb2hBQXdCQ3d0Q2ZpQUZJQUViSVFRTElBUUxQd0lCZndGK0l3QkJNR3NpQWlRQUFuNUNmaUFDUVFocUlBQWdBUkF0RFFBYVFnQWdBaWdDSEVFQlJnMEFHaUFDS1FNSUN5RURJQUpCTUdva0FDQURDNDBCQVFKL0l3QkJNR3NpQVNRQUFrQWdBRVVOQUNBQUtBS0k0Z0VOQUNBQklBQkIvT0VCYWlnQ0FEWUNLQ0FCSUFBcEF2VGhBVGNESUNBQUVEQWdBQ2dDcU9JQklRSWdBU0FCS0FJb05nSVlJQUVnQVNrRElEY0RFQ0FDSUFGQkVHb1FHeUFBUVFBMkFxamlBU0FCSUFFb0FpZzJBZ2dnQVNBQktRTWdOd01BSUFBZ0FSQWJDeUFCUVRCcUpBQUxLZ0VDZnlNQVFSQnJJZ0FrQUNBQVFRQTJBZ2dnQUVJQU53TUFJQUFRV0NFQklBQkJFR29rQUNBQkM0Y0JBUU4vSXdCQkVHc2lBaVFBQWtBZ0FDZ0NBRVVnQUNnQ0JFVnpEUUFnQWlBQUtBSUlOZ0lJSUFJZ0FDa0NBRGNEQUFKL0lBSW9BZ0FpQVFSQUlBSW9BZ2hCcU9NSklBRVJCUUFNQVF0QnFPTUpFQ2dMSWdGRkRRQWdBU0FBS1FJQU53TDA0UUVnQVVIODRRRnFJQUFvQWdnMkFnQWdBUkJaSUFFaEF3c2dBa0VRYWlRQUlBTUx5d0VCQW44akFFRWdheUlCSkFBZ0FFR0JnSURBQURZQ3RPSUJJQUJCQURZQ2lPSUJJQUJCQURZQzdPRUJJQUJDQURjRGtPSUJJQUJCQURZQ3BPTUpJQUJCQURZQzNPSUJJQUJDQURjQ3pPSUJJQUJCQURZQ3ZPSUJJQUJCQURZQ3hPQUJJQUJDQURjQ25PSUJJQUJCcE9JQmFrSUFOd0lBSUFCQnJPSUJha0VBTmdJQUlBRkNBRGNDRUNBQlFnQTNBaGdnQVNBQktRTVlOd01JSUFFZ0FTa0RFRGNEQUNBQktBSUlRUWgyUVFGeElRSWdBRUVBTmdMZzRnRWdBQ0FDTmdLTTRnRWdBVUVnYWlRQUMzWUJBMzhqQUVFd2F5SUJKQUFnQUFSQUlBRWdBRUhFMEFGcUlnSW9BZ0EyQWlnZ0FTQUFLUUs4MEFFM0F5QWdBQ2dDQUNFRElBRWdBaWdDQURZQ0dDQUJJQUFwQXJ6UUFUY0RFQ0FESUFGQkVHb1FHeUFCSUFFb0FpZzJBZ2dnQVNBQktRTWdOd01BSUFBZ0FSQWJDeUFCUVRCcUpBQUx6QUVCQVg4Z0FDQUJLQUswMEFFMkFwamlBU0FBSUFFb0FnUWlBallDd09BQklBQWdBallDdk9BQklBQWdBaUFCS0FJSWFpSUNOZ0s0NEFFZ0FDQUNOZ0xFNEFFZ0FTZ0N1TkFCQkVBZ0FFS0JnSUNBRURjRGlPRUJJQUFnQVVHazBBQnFOZ0lNSUFBZ0FVR1VJR28yQWdnZ0FDQUJRWnd3YWpZQ0JDQUFJQUZCREdvMkFnQWdBRUdzMEFGcUlBRkJxTkFCYWlnQ0FEWUNBQ0FBUWJEUUFXb2dBVUdzMEFGcUtBSUFOZ0lBSUFCQnROQUJhaUFCUWJEUUFXb29BZ0EyQWdBUEN5QUFRZ0EzQTRqaEFRczdBQ0FDUlFSQVFicC9Ed3NnQkVVRVFFRnNEd3NnQWlBRUVHQUVRQ0FBSUFFZ0FpQURJQVFnQlJCaER3c2dBQ0FCSUFJZ0F5QUVJQVVRWlF0R0FRRi9Jd0JCRUdzaUJTUUFJQVZCQ0dvZ0JCQU9BbjhnQlMwQUNRUkFJQUFnQVNBQ0lBTWdCQkF5REFFTElBQWdBU0FDSUFNZ0JCQTBDeUVBSUFWQkVHb2tBQ0FBQ3pRQUlBQWdBeUFFSUFVUU5pSUZFQU1FUUNBRkR3c2dCU0FFU1FSL0lBRWdBaUFESUFWcUlBUWdCV3NnQUJBMUJVRzRmd3NMUmdFQmZ5TUFRUkJySWdVa0FDQUZRUWhxSUFRUURnSi9JQVV0QUFrRVFDQUFJQUVnQWlBRElBUVFZZ3dCQ3lBQUlBRWdBaUFESUFRUU5Rc2hBQ0FGUVJCcUpBQWdBQXRaQVFGL1FROGhBaUFCSUFCSkJFQWdBVUVFZENBQWJpRUNDeUFBUVFoMklnRWdBa0VZYkNJQVFZd0lhaWdDQUd3Z0FFR0lDR29vQWdCcUlnSkJBM1lnQW1vZ0FFR0FDR29vQWdBZ0FFR0VDR29vQWdBZ0FXeHFTUXMzQUNBQUlBTWdCQ0FGUVlBUUVETWlCUkFEQkVBZ0JROExJQVVnQkVrRWZ5QUJJQUlnQXlBRmFpQUVJQVZySUFBUU1nVkJ1SDhMQzc4REFRTi9Jd0JCSUdzaUJTUUFJQVZCQ0dvZ0FpQURFQVlpQWhBRFJRUkFJQUFnQVdvaUIwRjlhaUVHSUFVZ0JCQU9JQVJCQkdvaEFpQUZMUUFDSVFNRFFFRUFJQUFnQmtrZ0JVRUlhaEFFR3dSQUlBQWdBaUFGUVFocUlBTVFBa0VDZEdvaUJDOEJBRHNBQUNBRlFRaHFJQVF0QUFJUUFTQUFJQVF0QUFOcUlnUWdBaUFGUVFocUlBTVFBa0VDZEdvaUFDOEJBRHNBQUNBRlFRaHFJQUF0QUFJUUFTQUVJQUF0QUFOcUlRQU1BUVVnQjBGK2FpRUVBMEFnQlVFSWFoQUVJQUFnQkV0eVJRUkFJQUFnQWlBRlFRaHFJQU1RQWtFQ2RHb2lCaThCQURzQUFDQUZRUWhxSUFZdEFBSVFBU0FBSUFZdEFBTnFJUUFNQVFzTEEwQWdBQ0FFUzBVRVFDQUFJQUlnQlVFSWFpQURFQUpCQW5ScUlnWXZBUUE3QUFBZ0JVRUlhaUFHTFFBQ0VBRWdBQ0FHTFFBRGFpRUFEQUVMQ3dKQUlBQWdCMDhOQUNBQUlBSWdCVUVJYWlBREVBSWlBMEVDZEdvaUFDMEFBRG9BQUNBQUxRQURRUUZHQkVBZ0JVRUlhaUFBTFFBQ0VBRU1BUXNnQlNnQ0RFRWZTdzBBSUFWQkNHb2dBaUFEUVFKMGFpMEFBaEFCSUFVb0FneEJJVWtOQUNBRlFTQTJBZ3dMSUFGQmJDQUZRUWhxRUFvYklRSUxDd3NnQlVFZ2FpUUFJQUlMa2dJQkJIOGpBRUZBYWlJSkpBQWdDU0FEUVRRUUN5RURBa0FnQkVFQ1NBMEFJQU1nQkVFQ2RHb29BZ0FoQ1NBRFFUeHFJQWdRSXlBRFFRRTZBRDhnQXlBQ09nQStRUUFoQkNBREtBSThJUW9EUUNBRUlBbEdEUUVnQUNBRVFRSjBhaUFLTmdFQUlBUkJBV29oQkF3QUFBc0FDMEVBSVFrRFFDQUdJQWxHUlFSQUlBTWdCU0FKUVFGMGFpSUtMUUFCSWd0QkFuUnFJZ3dvQWdBaEJDQURRVHhxSUFvdEFBQkJDSFFnQ0dwQi8vOERjUkFqSUFOQkFqb0FQeUFESUFjZ0Myc2lDaUFDYWpvQVBpQUVRUUVnQVNBS2EzUnFJUW9nQXlnQ1BDRUxBMEFnQUNBRVFRSjBhaUFMTmdFQUlBUkJBV29pQkNBS1NRMEFDeUFNSUFvMkFnQWdDVUVCYWlFSkRBRUxDeUFEUVVCckpBQUxvd0lCQ1g4akFFSFFBR3NpQ1NRQUlBbEJFR29nQlVFMEVBc2FJQWNnQm1zaER5QUhJQUZySVJBRFFBSkFJQU1nQ2tjRVFFRUJJQUVnQnlBQ0lBcEJBWFJxSWdZdEFBRWlER3NpQ0dzaUMzUWhEU0FHTFFBQUlRNGdDVUVRYWlBTVFRSjBhaUlNS0FJQUlRWWdDeUFQVHdSQUlBQWdCa0VDZEdvZ0N5QUlJQVVnQ0VFMGJHb2dDQ0FRYWlJSVFRRWdDRUVCU2hzaUNDQUNJQVFnQ0VFQ2RHb29BZ0FpQ0VFQmRHb2dBeUFJYXlBSElBNFFZeUFHSUExcUlRZ01BZ3NnQ1VFTWFpQU9FQ01nQ1VFQk9nQVBJQWtnQ0RvQURpQUdJQTFxSVFnZ0NTZ0NEQ0VMQTBBZ0JpQUlUdzBDSUFBZ0JrRUNkR29nQ3pZQkFDQUdRUUZxSVFZTUFBQUxBQXNnQ1VIUUFHb2tBQThMSUF3Z0NEWUNBQ0FLUVFGcUlRb01BQUFMQUFzMEFDQUFJQU1nQkNBRkVEWWlCUkFEQkVBZ0JROExJQVVnQkVrRWZ5QUJJQUlnQXlBRmFpQUVJQVZySUFBUU5BVkJ1SDhMQ3lNQUlBQS9BRUVRZEd0Qi8vOERha0VRZGtBQVFYOUdCRUJCQUE4TFFRQVFBRUVCQ3pzQkFYOGdBZ1JBQTBBZ0FDQUJJQUpCZ0NBZ0FrR0FJRWtiSWdNUUN5RUFJQUZCZ0NCcUlRRWdBRUdBSUdvaEFDQUNJQU5ySWdJTkFBc0xDd1lBSUFBUUF3c0xxQlVKQUVHSUNBc05BUUFBQUFFQUFBQUNBQUFBQWdCQm9BZ0xzd1lCQUFBQUFRQUFBQUlBQUFBQ0FBQUFKZ0FBQUlJQUFBQWhCUUFBU2dBQUFHY0lBQUFtQUFBQXdBRUFBSUFBQUFCSkJRQUFTZ0FBQUw0SUFBQXBBQUFBTEFJQUFJQUFBQUJKQlFBQVNnQUFBTDRJQUFBdkFBQUF5Z0lBQUlBQUFBQ0tCUUFBU2dBQUFJUUpBQUExQUFBQWN3TUFBSUFBQUFDZEJRQUFTZ0FBQUtBSkFBQTlBQUFBZ1FNQUFJQUFBQURyQlFBQVN3QUFBRDRLQUFCRUFBQUFuZ01BQUlBQUFBQk5CZ0FBU3dBQUFLb0tBQUJMQUFBQXN3TUFBSUFBQUFEQkJnQUFUUUFBQUI4TkFBQk5BQUFBVXdRQUFJQUFBQUFqQ0FBQVVRQUFBS1lQQUFCVUFBQUFtUVFBQUlBQUFBQkxDUUFBVndBQUFMRVNBQUJZQUFBQTJnUUFBSUFBQUFCdkNRQUFYUUFBQUNNVUFBQlVBQUFBUlFVQUFJQUFBQUJVQ2dBQWFnQUFBSXdVQUFCcUFBQUFyd1VBQUlBQUFBQjJDUUFBZkFBQUFFNFFBQUI4QUFBQTBnSUFBSUFBQUFCakJ3QUFrUUFBQUpBSEFBQ1NBQUFBQUFBQUFBRUFBQUFCQUFBQUJRQUFBQTBBQUFBZEFBQUFQUUFBQUgwQUFBRDlBQUFBL1FFQUFQMERBQUQ5QndBQS9ROEFBUDBmQUFEOVB3QUEvWDhBQVAzL0FBRDkvd0VBL2Y4REFQMy9Cd0Q5L3c4QS9mOGZBUDMvUHdEOS8zOEEvZi8vQVAzLy93SDkvLzhEL2YvL0IvMy8vdy85Ly84Zi9mLy9QLzMvLzM4QUFBQUFBUUFBQUFJQUFBQURBQUFBQkFBQUFBVUFBQUFHQUFBQUJ3QUFBQWdBQUFBSkFBQUFDZ0FBQUFzQUFBQU1BQUFBRFFBQUFBNEFBQUFQQUFBQUVBQUFBQkVBQUFBU0FBQUFFd0FBQUJRQUFBQVZBQUFBRmdBQUFCY0FBQUFZQUFBQUdRQUFBQm9BQUFBYkFBQUFIQUFBQUIwQUFBQWVBQUFBSHdBQUFBTUFBQUFFQUFBQUJRQUFBQVlBQUFBSEFBQUFDQUFBQUFrQUFBQUtBQUFBQ3dBQUFBd0FBQUFOQUFBQURnQUFBQThBQUFBUUFBQUFFUUFBQUJJQUFBQVRBQUFBRkFBQUFCVUFBQUFXQUFBQUZ3QUFBQmdBQUFBWkFBQUFHZ0FBQUJzQUFBQWNBQUFBSFFBQUFCNEFBQUFmQUFBQUlBQUFBQ0VBQUFBaUFBQUFJd0FBQUNVQUFBQW5BQUFBS1FBQUFDc0FBQUF2QUFBQU13QUFBRHNBQUFCREFBQUFVd0FBQUdNQUFBQ0RBQUFBQXdFQUFBTUNBQUFEQkFBQUF3Z0FBQU1RQUFBRElBQUFBMEFBQUFPQUFBQURBQUVBUWVBUEMxRUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFnQUFBQUlBQUFBREFBQUFBd0FBQUFRQUFBQUVBQUFBQlFBQUFBY0FBQUFJQUFBQUNRQUFBQW9BQUFBTEFBQUFEQUFBQUEwQUFBQU9BQUFBRHdBQUFCQUFRY1FRQzRzQkFRQUFBQUlBQUFBREFBQUFCQUFBQUFVQUFBQUdBQUFBQndBQUFBZ0FBQUFKQUFBQUNnQUFBQXNBQUFBTUFBQUFEUUFBQUE0QUFBQVBBQUFBRUFBQUFCSUFBQUFVQUFBQUZnQUFBQmdBQUFBY0FBQUFJQUFBQUNnQUFBQXdBQUFBUUFBQUFJQUFBQUFBQVFBQUFBSUFBQUFFQUFBQUNBQUFBQkFBQUFBZ0FBQUFRQUFBQUlBQUFBQUFBUUJCa0JJTDVnUUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFnQUFBQUlBQUFBREFBQUFBd0FBQUFRQUFBQUdBQUFBQndBQUFBZ0FBQUFKQUFBQUNnQUFBQXNBQUFBTUFBQUFEUUFBQUE0QUFBQVBBQUFBRUFBQUFBRUFBQUFFQUFBQUNBQUFBQUFBQUFBQkFBRUJCZ0FBQUFBQUFBUUFBQUFBRUFBQUJBQUFBQUFnQUFBRkFRQUFBQUFBQUFVREFBQUFBQUFBQlFRQUFBQUFBQUFGQmdBQUFBQUFBQVVIQUFBQUFBQUFCUWtBQUFBQUFBQUZDZ0FBQUFBQUFBVU1BQUFBQUFBQUJnNEFBQUFBQUFFRkVBQUFBQUFBQVFVVUFBQUFBQUFCQlJZQUFBQUFBQUlGSEFBQUFBQUFBd1VnQUFBQUFBQUVCVEFBQUFBZ0FBWUZRQUFBQUFBQUJ3V0FBQUFBQUFBSUJnQUJBQUFBQUFvR0FBUUFBQUFBREFZQUVBQUFJQUFBQkFBQUFBQUFBQUFFQVFBQUFBQUFBQVVDQUFBQUlBQUFCUVFBQUFBQUFBQUZCUUFBQUNBQUFBVUhBQUFBQUFBQUJRZ0FBQUFnQUFBRkNnQUFBQUFBQUFVTEFBQUFBQUFBQmcwQUFBQWdBQUVGRUFBQUFBQUFBUVVTQUFBQUlBQUJCUllBQUFBQUFBSUZHQUFBQUNBQUF3VWdBQUFBQUFBREJTZ0FBQUFBQUFZRVFBQUFBQkFBQmdSQUFBQUFJQUFIQllBQUFBQUFBQWtHQUFJQUFBQUFDd1lBQ0FBQU1BQUFCQUFBQUFBUUFBQUVBUUFBQUNBQUFBVUNBQUFBSUFBQUJRTUFBQUFnQUFBRkJRQUFBQ0FBQUFVR0FBQUFJQUFBQlFnQUFBQWdBQUFGQ1FBQUFDQUFBQVVMQUFBQUlBQUFCUXdBQUFBQUFBQUdEd0FBQUNBQUFRVVNBQUFBSUFBQkJSUUFBQUFnQUFJRkdBQUFBQ0FBQWdVY0FBQUFJQUFEQlNnQUFBQWdBQVFGTUFBQUFBQUFFQVlBQUFFQUFBQVBCZ0NBQUFBQUFBNEdBRUFBQUFBQURRWUFJQUJCZ0JjTGh3SUJBQUVCQlFBQUFBQUFBQVVBQUFBQUFBQUdCRDBBQUFBQUFBa0YvUUVBQUFBQUR3WDlmd0FBQUFBVkJmMy9Id0FBQUFNRkJRQUFBQUFBQndSOUFBQUFBQUFNQmYwUEFBQUFBQklGL2Y4REFBQUFGd1g5LzM4QUFBQUZCUjBBQUFBQUFBZ0UvUUFBQUFBQURnWDlQd0FBQUFBVUJmMy9Ed0FBQUFJRkFRQUFBQkFBQndSOUFBQUFBQUFMQmYwSEFBQUFBQkVGL2Y4QkFBQUFGZ1g5L3o4QUFBQUVCUTBBQUFBUUFBZ0UvUUFBQUFBQURRWDlId0FBQUFBVEJmMy9Cd0FBQUFFRkFRQUFBQkFBQmdROUFBQUFBQUFLQmYwREFBQUFBQkFGL2Y4QUFBQUFIQVg5Ly84UEFBQWJCZjMvL3djQUFCb0YvZi8vQXdBQUdRWDkvLzhCQUFBWUJmMy8vd0JCa0JrTGhnUUJBQUVCQmdBQUFBQUFBQVlEQUFBQUFBQUFCQVFBQUFBZ0FBQUZCUUFBQUFBQUFBVUdBQUFBQUFBQUJRZ0FBQUFBQUFBRkNRQUFBQUFBQUFVTEFBQUFBQUFBQmcwQUFBQUFBQUFHRUFBQUFBQUFBQVlUQUFBQUFBQUFCaFlBQUFBQUFBQUdHUUFBQUFBQUFBWWNBQUFBQUFBQUJoOEFBQUFBQUFBR0lnQUFBQUFBQVFZbEFBQUFBQUFCQmlrQUFBQUFBQUlHTHdBQUFBQUFBd1k3QUFBQUFBQUVCbE1BQUFBQUFBY0dnd0FBQUFBQUNRWURBZ0FBRUFBQUJBUUFBQUFBQUFBRUJRQUFBQ0FBQUFVR0FBQUFBQUFBQlFjQUFBQWdBQUFGQ1FBQUFBQUFBQVVLQUFBQUFBQUFCZ3dBQUFBQUFBQUdEd0FBQUFBQUFBWVNBQUFBQUFBQUJoVUFBQUFBQUFBR0dBQUFBQUFBQUFZYkFBQUFBQUFBQmg0QUFBQUFBQUFHSVFBQUFBQUFBUVlqQUFBQUFBQUJCaWNBQUFBQUFBSUdLd0FBQUFBQUF3WXpBQUFBQUFBRUJrTUFBQUFBQUFVR1l3QUFBQUFBQ0FZREFRQUFJQUFBQkFRQUFBQXdBQUFFQkFBQUFCQUFBQVFGQUFBQUlBQUFCUWNBQUFBZ0FBQUZDQUFBQUNBQUFBVUtBQUFBSUFBQUJRc0FBQUFBQUFBR0RnQUFBQUFBQUFZUkFBQUFBQUFBQmhRQUFBQUFBQUFHRndBQUFBQUFBQVlhQUFBQUFBQUFCaDBBQUFBQUFBQUdJQUFBQUFBQUVBWURBQUVBQUFBUEJnT0FBQUFBQUE0R0EwQUFBQUFBRFFZRElBQUFBQUFNQmdNUUFBQUFBQXNHQXdnQUFBQUFDZ1lEQkFCQnBCMEwyUUVCQUFBQUF3QUFBQWNBQUFBUEFBQUFId0FBQUQ4QUFBQi9BQUFBL3dBQUFQOEJBQUQvQXdBQS93Y0FBUDhQQUFEL0h3QUEvejhBQVA5L0FBRC8vd0FBLy84QkFQLy9Bd0QvL3djQS8vOFBBUC8vSHdELy96OEEvLzkvQVAvLy93RC8vLzhCLy8vL0EvLy8vd2YvLy84UC8vLy9ILy8vL3ovLy8vOS9BQUFBQUFFQUFBQUNBQUFBQkFBQUFBQUFBQUFDQUFBQUJBQUFBQWdBQUFBQUFBQUFBUUFBQUFJQUFBQUJBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQWdBQUFBSUFBQUFDQUFBQUFjQUFBQUlBQUFBQ1FBQUFBb0FBQUFMQUVHZ0lBc0R3QkJRJztcbi8vIHdhc206ZW5kXG5cbmV4cG9ydCB7IFpTVEREZWNvZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD16c3RkZGVjLm1vZGVybi5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==
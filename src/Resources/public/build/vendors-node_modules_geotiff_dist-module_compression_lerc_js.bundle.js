(self["webpackChunkmapsbundle"] = self["webpackChunkmapsbundle"] || []).push([["vendors-node_modules_geotiff_dist-module_compression_lerc_js"],{

/***/ "./node_modules/lerc/LercDecode.js":
/*!*****************************************!*\
  !*** ./node_modules/lerc/LercDecode.js ***!
  \*****************************************/
/***/ ((module, exports) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;ï»¿/* jshint forin: false, bitwise: false */
/*
Copyright 2015-2021 Esri

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

A copy of the license and additional notices are located with the
source distribution at:

http://github.com/Esri/lerc/

Contributors:  Johannes Schmid, (LERC v1)
               Chayanika Khatua, (LERC v1)
               Wenxue Ju (LERC v1, v2.x)
*/

/* Copyright 2015-2021 Esri. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 @preserve */

/**
 * a module for decoding LERC blobs
 * @module Lerc
 */
(function() {
  //this decoder supports all lerc versions, each version has its own class (LercDecode and Lerc2Decode). 
  //the exported module handles format variation autoamtically.

  //the original LercDecode for Version 1
  var LercDecode = (function() {

    // Note: currently, this module only has an implementation for decoding LERC data, not encoding. The name of
    // the class was chosen to be future proof.

    var CntZImage = {};

    CntZImage.defaultNoDataValue = -3.4027999387901484e+38; // smallest Float32 value

    /**
     * Decode a LERC byte stream and return an object containing the pixel data and some required and optional
     * information about it, such as the image's width and height.
     *
     * @param {ArrayBuffer} input The LERC input byte stream
     * @param {object} [options] Decoding options, containing any of the following properties:
     * @config {number} [inputOffset = 0]
     *        Skip the first inputOffset bytes of the input byte stream. A valid LERC file is expected at that position.
     * @config {Uint8Array} [encodedMask = null]
     *        If specified, the decoder will not read mask information from the input and use the specified encoded
     *        mask data instead. Mask header/data must not be present in the LERC byte stream in this case.
     * @config {number} [noDataValue = LercCode.defaultNoDataValue]
     *        Pixel value to use for masked pixels.
     * @config {ArrayBufferView|Array} [pixelType = Float32Array]
     *        The desired type of the pixelData array in the return value. Note that it is the caller's responsibility to
     *        provide an appropriate noDataValue if the default pixelType is overridden.
     * @config {boolean} [returnMask = false]
     *        If true, the return value will contain a maskData property of type Uint8Array which has one element per
     *        pixel, the value of which is 1 or 0 depending on whether that pixel's data is present or masked. If the
     *        input LERC data does not contain a mask, maskData will not be returned.
     * @config {boolean} [returnEncodedMask = false]
     *        If true, the return value will contain a encodedMaskData property, which can be passed into encode() as
     *        encodedMask.
     * @config {boolean} [returnFileInfo = false]
     *        If true, the return value will have a fileInfo property that contains metadata obtained from the
     *        LERC headers and the decoding process.
     * @config {boolean} [computeUsedBitDepths = false]
     *        If true, the fileInfo property in the return value will contain the set of all block bit depths
     *        encountered during decoding. Will only have an effect if returnFileInfo option is true.
     * @returns {{width, height, pixelData, minValue, maxValue, noDataValue, maskData, encodedMaskData, fileInfo}}
     */
    CntZImage.decode = function(input, options) {
      options = options || {};

      var skipMask = options.encodedMaskData || (options.encodedMaskData === null);
      var parsedData = parse(input, options.inputOffset || 0, skipMask);

      var noDataValue = (options.noDataValue !== null) ? options.noDataValue : CntZImage.defaultNoDataValue;

      var uncompressedData = uncompressPixelValues(parsedData, options.pixelType || Float32Array,
        options.encodedMaskData, noDataValue, options.returnMask);

      var result = {
        width: parsedData.width,
        height: parsedData.height,
        pixelData: uncompressedData.resultPixels,
        minValue: uncompressedData.minValue,
        maxValue: parsedData.pixels.maxValue,
        noDataValue: noDataValue
      };

      if (uncompressedData.resultMask) {
        result.maskData = uncompressedData.resultMask;
      }

      if (options.returnEncodedMask && parsedData.mask) {
        result.encodedMaskData = parsedData.mask.bitset ? parsedData.mask.bitset : null;
      }

      if (options.returnFileInfo) {
        result.fileInfo = formatFileInfo(parsedData);
        if (options.computeUsedBitDepths) {
          result.fileInfo.bitDepths = computeUsedBitDepths(parsedData);
        }
      }

      return result;
    };

    var uncompressPixelValues = function(data, TypedArrayClass, maskBitset, noDataValue, storeDecodedMask) {
      var blockIdx = 0;
      var numX = data.pixels.numBlocksX;
      var numY = data.pixels.numBlocksY;
      var blockWidth = Math.floor(data.width / numX);
      var blockHeight = Math.floor(data.height / numY);
      var scale = 2 * data.maxZError;
      var minValue = Number.MAX_VALUE, currentValue;
      maskBitset = maskBitset || ((data.mask) ? data.mask.bitset : null);

      var resultPixels, resultMask;
      resultPixels = new TypedArrayClass(data.width * data.height);
      if (storeDecodedMask && maskBitset) {
        resultMask = new Uint8Array(data.width * data.height);
      }
      var blockDataBuffer = new Float32Array(blockWidth * blockHeight);

      var xx, yy;
      for (var y = 0; y <= numY; y++) {
        var thisBlockHeight = (y !== numY) ? blockHeight : (data.height % numY);
        if (thisBlockHeight === 0) {
          continue;
        }
        for (var x = 0; x <= numX; x++) {
          var thisBlockWidth = (x !== numX) ? blockWidth : (data.width % numX);
          if (thisBlockWidth === 0) {
            continue;
          }

          var outPtr = y * data.width * blockHeight + x * blockWidth;
          var outStride = data.width - thisBlockWidth;

          var block = data.pixels.blocks[blockIdx];

          var blockData, blockPtr, constValue;
          if (block.encoding < 2) {
            // block is either uncompressed or bit-stuffed (encodings 0 and 1)
            if (block.encoding === 0) {
              // block is uncompressed
              blockData = block.rawData;
            } else {
              // block is bit-stuffed
              unstuff(block.stuffedData, block.bitsPerPixel, block.numValidPixels, block.offset, scale, blockDataBuffer, data.pixels.maxValue);
              blockData = blockDataBuffer;
            }
            blockPtr = 0;
          }
          else if (block.encoding === 2) {
            // block is all 0
            constValue = 0;
          }
          else {
            // block has constant value (encoding === 3)
            constValue = block.offset;
          }

          var maskByte;
          if (maskBitset) {
            for (yy = 0; yy < thisBlockHeight; yy++) {
              if (outPtr & 7) {
                //
                maskByte = maskBitset[outPtr >> 3];
                maskByte <<= outPtr & 7;
              }
              for (xx = 0; xx < thisBlockWidth; xx++) {
                if (!(outPtr & 7)) {
                  // read next byte from mask
                  maskByte = maskBitset[outPtr >> 3];
                }
                if (maskByte & 128) {
                  // pixel data present
                  if (resultMask) {
                    resultMask[outPtr] = 1;
                  }
                  currentValue = (block.encoding < 2) ? blockData[blockPtr++] : constValue;
                  minValue = minValue > currentValue ? currentValue : minValue;
                  resultPixels[outPtr++] = currentValue;
                } else {
                  // pixel data not present
                  if (resultMask) {
                    resultMask[outPtr] = 0;
                  }
                  resultPixels[outPtr++] = noDataValue;
                }
                maskByte <<= 1;
              }
              outPtr += outStride;
            }
          } else {
            // mask not present, simply copy block over
            if (block.encoding < 2) {
              // duplicating this code block for performance reasons
              // blockData case:
              for (yy = 0; yy < thisBlockHeight; yy++) {
                for (xx = 0; xx < thisBlockWidth; xx++) {
                  currentValue = blockData[blockPtr++];
                  minValue = minValue > currentValue ? currentValue : minValue;
                  resultPixels[outPtr++] = currentValue;
                }
                outPtr += outStride;
              }
            }
            else {
              // constValue case:
              minValue = minValue > constValue ? constValue : minValue;
              for (yy = 0; yy < thisBlockHeight; yy++) {
                for (xx = 0; xx < thisBlockWidth; xx++) {
                  resultPixels[outPtr++] = constValue;
                }
                outPtr += outStride;
              }
            }
          }
          if ((block.encoding === 1) && (blockPtr !== block.numValidPixels)) {
            throw "Block and Mask do not match";
          }
          blockIdx++;
        }
      }

      return {
        resultPixels: resultPixels,
        resultMask: resultMask,
        minValue: minValue
      };
    };

    var formatFileInfo = function(data) {
      return {
        "fileIdentifierString": data.fileIdentifierString,
        "fileVersion": data.fileVersion,
        "imageType": data.imageType,
        "height": data.height,
        "width": data.width,
        "maxZError": data.maxZError,
        "eofOffset": data.eofOffset,
        "mask": data.mask ? {
          "numBlocksX": data.mask.numBlocksX,
          "numBlocksY": data.mask.numBlocksY,
          "numBytes": data.mask.numBytes,
          "maxValue": data.mask.maxValue
        } : null,
        "pixels": {
          "numBlocksX": data.pixels.numBlocksX,
          "numBlocksY": data.pixels.numBlocksY,
          "numBytes": data.pixels.numBytes,
          "maxValue": data.pixels.maxValue,
          "noDataValue": data.noDataValue
        }
      };
    };

    var computeUsedBitDepths = function(data) {
      var numBlocks = data.pixels.numBlocksX * data.pixels.numBlocksY;
      var bitDepths = {};
      for (var i = 0; i < numBlocks; i++) {
        var block = data.pixels.blocks[i];
        if (block.encoding === 0) {
          bitDepths.float32 = true;
        } else if (block.encoding === 1) {
          bitDepths[block.bitsPerPixel] = true;
        } else {
          bitDepths[0] = true;
        }
      }

      return Object.keys(bitDepths);
    };

    var parse = function(input, fp, skipMask) {
      var data = {};

      // File header
      var fileIdView = new Uint8Array(input, fp, 10);
      data.fileIdentifierString = String.fromCharCode.apply(null, fileIdView);
      if (data.fileIdentifierString.trim() !== "CntZImage") {
        throw "Unexpected file identifier string: " + data.fileIdentifierString;
      }
      fp += 10;
      var view = new DataView(input, fp, 24);
      data.fileVersion = view.getInt32(0, true);
      data.imageType = view.getInt32(4, true);
      data.height = view.getUint32(8, true);
      data.width = view.getUint32(12, true);
      data.maxZError = view.getFloat64(16, true);
      fp += 24;

      // Mask Header
      if (!skipMask) {
        view = new DataView(input, fp, 16);
        data.mask = {};
        data.mask.numBlocksY = view.getUint32(0, true);
        data.mask.numBlocksX = view.getUint32(4, true);
        data.mask.numBytes = view.getUint32(8, true);
        data.mask.maxValue = view.getFloat32(12, true);
        fp += 16;

        // Mask Data
        if (data.mask.numBytes > 0) {
          var bitset = new Uint8Array(Math.ceil(data.width * data.height / 8));
          view = new DataView(input, fp, data.mask.numBytes);
          var cnt = view.getInt16(0, true);
          var ip = 2, op = 0;
          do {
            if (cnt > 0) {
              while (cnt--) { bitset[op++] = view.getUint8(ip++); }
            } else {
              var val = view.getUint8(ip++);
              cnt = -cnt;
              while (cnt--) { bitset[op++] = val; }
            }
            cnt = view.getInt16(ip, true);
            ip += 2;
          } while (ip < data.mask.numBytes);
          if ((cnt !== -32768) || (op < bitset.length)) {
            throw "Unexpected end of mask RLE encoding";
          }
          data.mask.bitset = bitset;
          fp += data.mask.numBytes;
        }
        else if ((data.mask.numBytes | data.mask.numBlocksY | data.mask.maxValue) === 0) {  // Special case, all nodata
          data.mask.bitset = new Uint8Array(Math.ceil(data.width * data.height / 8));
        }
      }

      // Pixel Header
      view = new DataView(input, fp, 16);
      data.pixels = {};
      data.pixels.numBlocksY = view.getUint32(0, true);
      data.pixels.numBlocksX = view.getUint32(4, true);
      data.pixels.numBytes = view.getUint32(8, true);
      data.pixels.maxValue = view.getFloat32(12, true);
      fp += 16;

      var numBlocksX = data.pixels.numBlocksX;
      var numBlocksY = data.pixels.numBlocksY;
      // the number of blocks specified in the header does not take into account the blocks at the end of
      // each row/column with a special width/height that make the image complete in case the width is not
      // evenly divisible by the number of blocks.
      var actualNumBlocksX = numBlocksX + ((data.width % numBlocksX) > 0 ? 1 : 0);
      var actualNumBlocksY = numBlocksY + ((data.height % numBlocksY) > 0 ? 1 : 0);
      data.pixels.blocks = new Array(actualNumBlocksX * actualNumBlocksY);
      var blockI = 0;
      for (var blockY = 0; blockY < actualNumBlocksY; blockY++) {
        for (var blockX = 0; blockX < actualNumBlocksX; blockX++) {

          // Block
          var size = 0;
          var bytesLeft = input.byteLength - fp;
          view = new DataView(input, fp, Math.min(10, bytesLeft));
          var block = {};
          data.pixels.blocks[blockI++] = block;
          var headerByte = view.getUint8(0); size++;
          block.encoding = headerByte & 63;
          if (block.encoding > 3) {
            throw "Invalid block encoding (" + block.encoding + ")";
          }
          if (block.encoding === 2) {
            fp++;
            continue;
          }
          if ((headerByte !== 0) && (headerByte !== 2)) {
            headerByte >>= 6;
            block.offsetType = headerByte;
            if (headerByte === 2) {
              block.offset = view.getInt8(1); size++;
            } else if (headerByte === 1) {
              block.offset = view.getInt16(1, true); size += 2;
            } else if (headerByte === 0) {
              block.offset = view.getFloat32(1, true); size += 4;
            } else {
              throw "Invalid block offset type";
            }

            if (block.encoding === 1) {
              headerByte = view.getUint8(size); size++;
              block.bitsPerPixel = headerByte & 63;
              headerByte >>= 6;
              block.numValidPixelsType = headerByte;
              if (headerByte === 2) {
                block.numValidPixels = view.getUint8(size); size++;
              } else if (headerByte === 1) {
                block.numValidPixels = view.getUint16(size, true); size += 2;
              } else if (headerByte === 0) {
                block.numValidPixels = view.getUint32(size, true); size += 4;
              } else {
                throw "Invalid valid pixel count type";
              }
            }
          }
          fp += size;

          if (block.encoding === 3) {
            continue;
          }

          var arrayBuf, store8;
          if (block.encoding === 0) {
            var numPixels = (data.pixels.numBytes - 1) / 4;
            if (numPixels !== Math.floor(numPixels)) {
              throw "uncompressed block has invalid length";
            }
            arrayBuf = new ArrayBuffer(numPixels * 4);
            store8 = new Uint8Array(arrayBuf);
            store8.set(new Uint8Array(input, fp, numPixels * 4));
            var rawData = new Float32Array(arrayBuf);
            block.rawData = rawData;
            fp += numPixels * 4;
          } else if (block.encoding === 1) {
            var dataBytes = Math.ceil(block.numValidPixels * block.bitsPerPixel / 8);
            var dataWords = Math.ceil(dataBytes / 4);
            arrayBuf = new ArrayBuffer(dataWords * 4);
            store8 = new Uint8Array(arrayBuf);
            store8.set(new Uint8Array(input, fp, dataBytes));
            block.stuffedData = new Uint32Array(arrayBuf);
            fp += dataBytes;
          }
        }
      }
      data.eofOffset = fp;
      return data;
    };

    var unstuff = function(src, bitsPerPixel, numPixels, offset, scale, dest, maxValue) {
      var bitMask = (1 << bitsPerPixel) - 1;
      var i = 0, o;
      var bitsLeft = 0;
      var n, buffer;
      var nmax = Math.ceil((maxValue - offset) / scale);
      // get rid of trailing bytes that are already part of next block
      var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);
      src[src.length - 1] <<= 8 * numInvalidTailBytes;

      for (o = 0; o < numPixels; o++) {
        if (bitsLeft === 0) {
          buffer = src[i++];
          bitsLeft = 32;
        }
        if (bitsLeft >= bitsPerPixel) {
          n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;
          bitsLeft -= bitsPerPixel;
        } else {
          var missingBits = (bitsPerPixel - bitsLeft);
          n = ((buffer & bitMask) << missingBits) & bitMask;
          buffer = src[i++];
          bitsLeft = 32 - missingBits;
          n += (buffer >>> bitsLeft);
        }
        //pixel values may exceed max due to quantization
        dest[o] = n < nmax ? offset + n * scale : maxValue;
      }
      return dest;
    };

    return CntZImage;
  })();

  //version 2. Supports 2.1, 2.2, 2.3
  var Lerc2Decode = (function() {
    "use strict";
    // Note: currently, this module only has an implementation for decoding LERC data, not encoding. The name of
    // the class was chosen to be future proof, following LercDecode.

    /*****************************************
    * private static class bitsutffer used by Lerc2Decode
    *******************************************/
    var BitStuffer = {
      //methods ending with 2 are for the new byte order used by Lerc2.3 and above.
      //originalUnstuff is used to unpack Huffman code table. code is duplicated to unstuffx for performance reasons.
      unstuff: function(src, dest, bitsPerPixel, numPixels, lutArr, offset, scale, maxValue) {
        var bitMask = (1 << bitsPerPixel) - 1;
        var i = 0, o;
        var bitsLeft = 0;
        var n, buffer, missingBits, nmax;

        // get rid of trailing bytes that are already part of next block
        var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);
        src[src.length - 1] <<= 8 * numInvalidTailBytes;
        if (lutArr) {
          for (o = 0; o < numPixels; o++) {
            if (bitsLeft === 0) {
              buffer = src[i++];
              bitsLeft = 32;
            }
            if (bitsLeft >= bitsPerPixel) {
              n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;
              bitsLeft -= bitsPerPixel;
            }
            else {
              missingBits = (bitsPerPixel - bitsLeft);
              n = ((buffer & bitMask) << missingBits) & bitMask;
              buffer = src[i++];
              bitsLeft = 32 - missingBits;
              n += (buffer >>> bitsLeft);
            }
            dest[o] = lutArr[n];//offset + lutArr[n] * scale;
          }
        }
        else {
          nmax = Math.ceil((maxValue - offset) / scale);
          for (o = 0; o < numPixels; o++) {
            if (bitsLeft === 0) {
              buffer = src[i++];
              bitsLeft = 32;
            }
            if (bitsLeft >= bitsPerPixel) {
              n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;
              bitsLeft -= bitsPerPixel;
            }
            else {
              missingBits = (bitsPerPixel - bitsLeft);
              n = ((buffer & bitMask) << missingBits) & bitMask;
              buffer = src[i++];
              bitsLeft = 32 - missingBits;
              n += (buffer >>> bitsLeft);
            }
            //pixel values may exceed max due to quantization
            dest[o] = n < nmax ? offset + n * scale : maxValue;
          }
        }
      },

      unstuffLUT: function(src, bitsPerPixel, numPixels, offset, scale, maxValue) {
        var bitMask = (1 << bitsPerPixel) - 1;
        var i = 0, o = 0, missingBits = 0, bitsLeft = 0, n = 0;
        var buffer;
        var dest = [];

        // get rid of trailing bytes that are already part of next block
        var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);
        src[src.length - 1] <<= 8 * numInvalidTailBytes;

        var nmax = Math.ceil((maxValue - offset) / scale);
        for (o = 0; o < numPixels; o++) {
          if (bitsLeft === 0) {
            buffer = src[i++];
            bitsLeft = 32;
          }
          if (bitsLeft >= bitsPerPixel) {
            n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;
            bitsLeft -= bitsPerPixel;
          } else {
            missingBits = (bitsPerPixel - bitsLeft);
            n = ((buffer & bitMask) << missingBits) & bitMask;
            buffer = src[i++];
            bitsLeft = 32 - missingBits;
            n += (buffer >>> bitsLeft);
          }
          //dest.push(n);
          dest[o] = n < nmax ? offset + n * scale : maxValue;
        }
        dest.unshift(offset);//1st one
        return dest;
      },

      unstuff2: function(src, dest, bitsPerPixel, numPixels, lutArr, offset, scale, maxValue) {
        var bitMask = (1 << bitsPerPixel) - 1;
        var i = 0, o;
        var bitsLeft = 0, bitPos = 0;
        var n, buffer, missingBits;
        if (lutArr) {
          for (o = 0; o < numPixels; o++) {
            if (bitsLeft === 0) {
              buffer = src[i++];
              bitsLeft = 32;
              bitPos = 0;
            }
            if (bitsLeft >= bitsPerPixel) {
              n = ((buffer >>> bitPos) & bitMask);
              bitsLeft -= bitsPerPixel;
              bitPos += bitsPerPixel;
            } else {
              missingBits = (bitsPerPixel - bitsLeft);
              n = (buffer >>> bitPos) & bitMask;
              buffer = src[i++];
              bitsLeft = 32 - missingBits;
              n |= (buffer & ((1 << missingBits) - 1)) << (bitsPerPixel - missingBits);
              bitPos = missingBits;
            }
            dest[o] = lutArr[n];
          }
        }
        else {
          var nmax = Math.ceil((maxValue - offset) / scale);
          for (o = 0; o < numPixels; o++) {
            if (bitsLeft === 0) {
              buffer = src[i++];
              bitsLeft = 32;
              bitPos = 0;
            }
            if (bitsLeft >= bitsPerPixel) {
              //no unsigned left shift
              n = ((buffer >>> bitPos) & bitMask);
              bitsLeft -= bitsPerPixel;
              bitPos += bitsPerPixel;
            } else {
              missingBits = (bitsPerPixel - bitsLeft);
              n = (buffer >>> bitPos) & bitMask;//((buffer & bitMask) << missingBits) & bitMask;
              buffer = src[i++];
              bitsLeft = 32 - missingBits;
              n |= (buffer & ((1 << missingBits) - 1)) << (bitsPerPixel - missingBits);
              bitPos = missingBits;
            }
            //pixel values may exceed max due to quantization
            dest[o] = n < nmax ? offset + n * scale : maxValue;
          }
        }
        return dest;
      },

      unstuffLUT2: function(src, bitsPerPixel, numPixels, offset, scale, maxValue) {
        var bitMask = (1 << bitsPerPixel) - 1;
        var i = 0, o = 0, missingBits = 0, bitsLeft = 0, n = 0, bitPos = 0;
        var buffer;
        var dest = [];
        var nmax = Math.ceil((maxValue - offset) / scale);
        for (o = 0; o < numPixels; o++) {
          if (bitsLeft === 0) {
            buffer = src[i++];
            bitsLeft = 32;
            bitPos = 0;
          }
          if (bitsLeft >= bitsPerPixel) {
            //no unsigned left shift
            n = ((buffer >>> bitPos) & bitMask);
            bitsLeft -= bitsPerPixel;
            bitPos += bitsPerPixel;
          } else {
            missingBits = (bitsPerPixel - bitsLeft);
            n = (buffer >>> bitPos) & bitMask;//((buffer & bitMask) << missingBits) & bitMask;
            buffer = src[i++];
            bitsLeft = 32 - missingBits;
            n |= (buffer & ((1 << missingBits) - 1)) << (bitsPerPixel - missingBits);
            bitPos = missingBits;
          }
          //dest.push(n);
          dest[o] = n < nmax ? offset + n * scale : maxValue;
        }
        dest.unshift(offset);
        return dest;
      },

      originalUnstuff: function(src, dest, bitsPerPixel, numPixels) {
        var bitMask = (1 << bitsPerPixel) - 1;
        var i = 0, o;
        var bitsLeft = 0;
        var n, buffer, missingBits;

        // get rid of trailing bytes that are already part of next block
        var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);
        src[src.length - 1] <<= 8 * numInvalidTailBytes;

        for (o = 0; o < numPixels; o++) {
          if (bitsLeft === 0) {
            buffer = src[i++];
            bitsLeft = 32;
          }
          if (bitsLeft >= bitsPerPixel) {
            n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;
            bitsLeft -= bitsPerPixel;
          }
          else {
            missingBits = (bitsPerPixel - bitsLeft);
            n = ((buffer & bitMask) << missingBits) & bitMask;
            buffer = src[i++];
            bitsLeft = 32 - missingBits;
            n += (buffer >>> bitsLeft);
          }
          dest[o] = n;
        }
        return dest;
      },

      originalUnstuff2: function(src, dest, bitsPerPixel, numPixels) {
        var bitMask = (1 << bitsPerPixel) - 1;
        var i = 0, o;
        var bitsLeft = 0, bitPos = 0;
        var n, buffer, missingBits;
        //micro-optimizations
        for (o = 0; o < numPixels; o++) {
          if (bitsLeft === 0) {
            buffer = src[i++];
            bitsLeft = 32;
            bitPos = 0;
          }
          if (bitsLeft >= bitsPerPixel) {
            //no unsigned left shift
            n = ((buffer >>> bitPos) & bitMask);
            bitsLeft -= bitsPerPixel;
            bitPos += bitsPerPixel;
          } else {
            missingBits = (bitsPerPixel - bitsLeft);
            n = (buffer >>> bitPos) & bitMask;//((buffer & bitMask) << missingBits) & bitMask;
            buffer = src[i++];
            bitsLeft = 32 - missingBits;
            n |= (buffer & ((1 << missingBits) - 1)) << (bitsPerPixel - missingBits);
            bitPos = missingBits;
          }
          dest[o] = n;
        }
        return dest;
      }
    };

    /*****************************************
    *private static class used by Lerc2Decode
    ******************************************/
    var Lerc2Helpers = {
      HUFFMAN_LUT_BITS_MAX: 12, //use 2^12 lut, treat it like constant
      computeChecksumFletcher32: function(input) {

        var sum1 = 0xffff, sum2 = 0xffff;
        var len = input.length;
        var words = Math.floor(len / 2);
        var i = 0;
        while (words) {
          var tlen = (words >= 359) ? 359 : words;
          words -= tlen;
          do {
            sum1 += (input[i++] << 8);
            sum2 += sum1 += input[i++];
          } while (--tlen);

          sum1 = (sum1 & 0xffff) + (sum1 >>> 16);
          sum2 = (sum2 & 0xffff) + (sum2 >>> 16);
        }

        // add the straggler byte if it exists
        if (len & 1) {
          sum2 += sum1 += (input[i] << 8);
        }
        // second reduction step to reduce sums to 16 bits
        sum1 = (sum1 & 0xffff) + (sum1 >>> 16);
        sum2 = (sum2 & 0xffff) + (sum2 >>> 16);

        return (sum2 << 16 | sum1) >>> 0;
      },

      readHeaderInfo: function(input, data) {
        var ptr = data.ptr;
        var fileIdView = new Uint8Array(input, ptr, 6);
        var headerInfo = {};
        headerInfo.fileIdentifierString = String.fromCharCode.apply(null, fileIdView);
        if (headerInfo.fileIdentifierString.lastIndexOf("Lerc2", 0) !== 0) {
          throw "Unexpected file identifier string (expect Lerc2 ): " + headerInfo.fileIdentifierString;
        }
        ptr += 6;
        var view = new DataView(input, ptr, 8);
        var fileVersion = view.getInt32(0, true);
        headerInfo.fileVersion = fileVersion;
        ptr += 4;
        if (fileVersion >= 3) {
          headerInfo.checksum = view.getUint32(4, true); //nrows
          ptr += 4;
        }

        //keys start from here
        view = new DataView(input, ptr, 12);
        headerInfo.height = view.getUint32(0, true); //nrows
        headerInfo.width = view.getUint32(4, true); //ncols
        ptr += 8;
        if (fileVersion >= 4) {
          headerInfo.numDims = view.getUint32(8, true);
          ptr += 4;
        }
        else {
          headerInfo.numDims = 1;
        }

        view = new DataView(input, ptr, 40);
        headerInfo.numValidPixel = view.getUint32(0, true);
        headerInfo.microBlockSize = view.getInt32(4, true);
        headerInfo.blobSize = view.getInt32(8, true);
        headerInfo.imageType = view.getInt32(12, true);

        headerInfo.maxZError = view.getFloat64(16, true);
        headerInfo.zMin = view.getFloat64(24, true);
        headerInfo.zMax = view.getFloat64(32, true);
        ptr += 40;
        data.headerInfo = headerInfo;
        data.ptr = ptr;

        var checksum, keyLength;
        if (fileVersion >= 3) {
          keyLength = fileVersion >= 4 ? 52 : 48;
          checksum = this.computeChecksumFletcher32(new Uint8Array(input, ptr - keyLength, headerInfo.blobSize - 14));
          if (checksum !== headerInfo.checksum) {
            throw "Checksum failed.";
          }
        }
        return true;
      },

      checkMinMaxRanges: function(input, data) {
        var headerInfo = data.headerInfo;
        var OutPixelTypeArray = this.getDataTypeArray(headerInfo.imageType);
        var rangeBytes = headerInfo.numDims * this.getDataTypeSize(headerInfo.imageType);
        var minValues = this.readSubArray(input, data.ptr, OutPixelTypeArray, rangeBytes);
        var maxValues = this.readSubArray(input, data.ptr + rangeBytes, OutPixelTypeArray, rangeBytes);
        data.ptr += (2 * rangeBytes);
        var i, equal = true;
        for (i = 0; i < headerInfo.numDims; i++) {
          if (minValues[i] !== maxValues[i]) {
            equal = false;
            break;
          }
        }
        headerInfo.minValues = minValues;
        headerInfo.maxValues = maxValues;
        return equal;
      },

      readSubArray: function(input, ptr, OutPixelTypeArray, numBytes) {
        var rawData;
        if (OutPixelTypeArray === Uint8Array) {
          rawData = new Uint8Array(input, ptr, numBytes);
        }
        else {
          var arrayBuf = new ArrayBuffer(numBytes);
          var store8 = new Uint8Array(arrayBuf);
          store8.set(new Uint8Array(input, ptr, numBytes));
          rawData = new OutPixelTypeArray(arrayBuf);
        }
        return rawData;
      },

      readMask: function(input, data) {
        var ptr = data.ptr;
        var headerInfo = data.headerInfo;
        var numPixels = headerInfo.width * headerInfo.height;
        var numValidPixel = headerInfo.numValidPixel;

        var view = new DataView(input, ptr, 4);
        var mask = {};
        mask.numBytes = view.getUint32(0, true);
        ptr += 4;

        // Mask Data
        if ((0 === numValidPixel || numPixels === numValidPixel) && 0 !== mask.numBytes) {
          throw ("invalid mask");
        }
        var bitset, resultMask;
        if (numValidPixel === 0) {
          bitset = new Uint8Array(Math.ceil(numPixels / 8));
          mask.bitset = bitset;
          resultMask = new Uint8Array(numPixels);
          data.pixels.resultMask = resultMask;
          ptr += mask.numBytes;
        }// ????? else if (data.mask.numBytes > 0 && data.mask.numBytes< data.numValidPixel) {
        else if (mask.numBytes > 0) {
          bitset = new Uint8Array(Math.ceil(numPixels / 8));
          view = new DataView(input, ptr, mask.numBytes);
          var cnt = view.getInt16(0, true);
          var ip = 2, op = 0, val = 0;
          do {
            if (cnt > 0) {
              while (cnt--) { bitset[op++] = view.getUint8(ip++); }
            } else {
              val = view.getUint8(ip++);
              cnt = -cnt;
              while (cnt--) { bitset[op++] = val; }
            }
            cnt = view.getInt16(ip, true);
            ip += 2;
          } while (ip < mask.numBytes);
          if ((cnt !== -32768) || (op < bitset.length)) {
            throw "Unexpected end of mask RLE encoding";
          }

          resultMask = new Uint8Array(numPixels);
          var mb = 0, k = 0;

          for (k = 0; k < numPixels; k++) {
            if (k & 7) {
              mb = bitset[k >> 3];
              mb <<= k & 7;
            }
            else {
              mb = bitset[k >> 3];
            }
            if (mb & 128) {
              resultMask[k] = 1;
            }
          }
          data.pixels.resultMask = resultMask;

          mask.bitset = bitset;
          ptr += mask.numBytes;
        }
        data.ptr = ptr;
        data.mask = mask;
        return true;
      },

      readDataOneSweep: function(input, data, OutPixelTypeArray, useBSQForOutputDim) {
        var ptr = data.ptr;
        var headerInfo = data.headerInfo;
        var numDims = headerInfo.numDims;
        var numPixels = headerInfo.width * headerInfo.height;
        var imageType = headerInfo.imageType;
        var numBytes = headerInfo.numValidPixel * Lerc2Helpers.getDataTypeSize(imageType) * numDims;
        //data.pixels.numBytes = numBytes;
        var rawData;
        var mask = data.pixels.resultMask;
        if (OutPixelTypeArray === Uint8Array) {
          rawData = new Uint8Array(input, ptr, numBytes);
        }
        else {
          var arrayBuf = new ArrayBuffer(numBytes);
          var store8 = new Uint8Array(arrayBuf);
          store8.set(new Uint8Array(input, ptr, numBytes));
          rawData = new OutPixelTypeArray(arrayBuf);
        }
        if (rawData.length === numPixels * numDims) {
          if (useBSQForOutputDim) {
            data.pixels.resultPixels = Lerc2Helpers.swapDimensionOrder(rawData, numPixels, numDims, OutPixelTypeArray, true);
          }
          else {
            data.pixels.resultPixels = rawData;
          }
        }
        else  //mask
        {
          data.pixels.resultPixels = new OutPixelTypeArray(numPixels * numDims);
          var z = 0, k = 0, i = 0, nStart = 0;
          if (numDims > 1) {
            if (useBSQForOutputDim) {
              for (k = 0; k < numPixels; k++) {
                if (mask[k]) {
                  nStart = k;
                  for (i = 0; i < numDims; i++, nStart+=numPixels) {
                    data.pixels.resultPixels[nStart] = rawData[z++];
                  }
                }
              }
            }
            else {
              for (k = 0; k < numPixels; k++) {
                if (mask[k]) {
                  nStart = k * numDims;
                  for (i = 0; i < numDims; i++) {
                    data.pixels.resultPixels[nStart + i] = rawData[z++];
                  }
                }
              }
            }
          }
          else {
            for (k = 0; k < numPixels; k++) {
              if (mask[k]) {
                data.pixels.resultPixels[k] = rawData[z++];
              }
            }
          }
        }
        ptr += numBytes;
        data.ptr = ptr;       //return data;
        return true;
      },

      readHuffmanTree: function(input, data) {
        var BITS_MAX = this.HUFFMAN_LUT_BITS_MAX; //8 is slow for the large test image
        //var size_max = 1 << BITS_MAX;
        /* ************************
        * reading code table
        *************************/
        var view = new DataView(input, data.ptr, 16);
        data.ptr += 16;
        var version = view.getInt32(0, true);
        if (version < 2) {
          throw "unsupported Huffman version";
        }
        var size = view.getInt32(4, true);
        var i0 = view.getInt32(8, true);
        var i1 = view.getInt32(12, true);
        if (i0 >= i1) {
          return false;
        }
        var blockDataBuffer = new Uint32Array(i1 - i0);
        Lerc2Helpers.decodeBits(input, data, blockDataBuffer);
        var codeTable = []; //size
        var i, j, k, len;

        for (i = i0; i < i1; i++) {
          j = i - (i < size ? 0 : size);//wrap around
          codeTable[j] = { first: blockDataBuffer[i - i0], second: null };
        }

        var dataBytes = input.byteLength - data.ptr;
        var dataWords = Math.ceil(dataBytes / 4);
        var arrayBuf = new ArrayBuffer(dataWords * 4);
        var store8 = new Uint8Array(arrayBuf);
        store8.set(new Uint8Array(input, data.ptr, dataBytes));
        var stuffedData = new Uint32Array(arrayBuf); //must start from x*4
        var bitPos = 0, word, srcPtr = 0;
        word = stuffedData[0];
        for (i = i0; i < i1; i++) {
          j = i - (i < size ? 0 : size);//wrap around
          len = codeTable[j].first;
          if (len > 0) {
            codeTable[j].second = (word << bitPos) >>> (32 - len);

            if (32 - bitPos >= len) {
              bitPos += len;
              if (bitPos === 32) {
                bitPos = 0;
                srcPtr++;
                word = stuffedData[srcPtr];
              }
            }
            else {
              bitPos += len - 32;
              srcPtr++;
              word = stuffedData[srcPtr];
              codeTable[j].second |= word >>> (32 - bitPos);
            }
          }
        }

        //finished reading code table

        /* ************************
        * building lut
        *************************/
        var numBitsLUT = 0, numBitsLUTQick = 0;
        var tree = new TreeNode();
        for (i = 0; i < codeTable.length; i++) {
          if (codeTable[i] !== undefined) {
            numBitsLUT = Math.max(numBitsLUT, codeTable[i].first);
          }
        }
        if (numBitsLUT >= BITS_MAX) {
          numBitsLUTQick = BITS_MAX;
        }
        else {
          numBitsLUTQick = numBitsLUT;
        }
        // for debugging purpose
        // if (numBitsLUT >= 30) {
        //   console.log("WARning, large NUM LUT BITS IS " + numBitsLUT);
        // }
        var decodeLut = [], entry, code, numEntries, jj, currentBit, node;
        for (i = i0; i < i1; i++) {
          j = i - (i < size ? 0 : size);//wrap around
          len = codeTable[j].first;
          if (len > 0) {
            entry = [len, j];
            if (len <= numBitsLUTQick) {
              code = codeTable[j].second << (numBitsLUTQick - len);
              numEntries = 1 << (numBitsLUTQick - len);
              for (k = 0; k < numEntries; k++) {
                decodeLut[code | k] = entry;
              }
            }
            else {
              //build tree
              code = codeTable[j].second;
              node = tree;
              for (jj = len - 1; jj >= 0; jj--) {
                currentBit = code >>> jj & 1; //no left shift as length could be 30,31
                if (currentBit) {
                  if (!node.right) {
                    node.right = new TreeNode();
                  }
                  node = node.right;
                }
                else {
                  if (!node.left) {
                    node.left = new TreeNode();
                  }
                  node = node.left;
                }
                if (jj === 0 && !node.val) {
                  node.val = entry[1];
                }
              }
            }
          }
        }
        return {
          decodeLut: decodeLut,
          numBitsLUTQick: numBitsLUTQick,
          numBitsLUT: numBitsLUT,
          tree: tree,
          stuffedData: stuffedData,
          srcPtr: srcPtr,
          bitPos: bitPos
        };
      },

      readHuffman: function(input, data, OutPixelTypeArray, useBSQForOutputDim) {
        var headerInfo = data.headerInfo;
        var numDims = headerInfo.numDims;
        var height = data.headerInfo.height;
        var width = data.headerInfo.width;
        var numPixels = width * height;
        //var size_max = 1 << BITS_MAX;
        /* ************************
        * reading huffman structure info
        *************************/
        var huffmanInfo = this.readHuffmanTree(input, data);
        var decodeLut = huffmanInfo.decodeLut;
        var tree = huffmanInfo.tree;
        //stuffedData includes huffman headers
        var stuffedData = huffmanInfo.stuffedData;
        var srcPtr = huffmanInfo.srcPtr;
        var bitPos = huffmanInfo.bitPos;
        var numBitsLUTQick = huffmanInfo.numBitsLUTQick;
        var numBitsLUT = huffmanInfo.numBitsLUT;
        var offset = data.headerInfo.imageType === 0 ? 128 : 0;
        /*************************
        *  decode
        ***************************/
        var node, val, delta, mask = data.pixels.resultMask, valTmp, valTmpQuick, currentBit;
        var i, j, k, ii;
        var prevVal = 0;
        if (bitPos > 0) {
          srcPtr++;
          bitPos = 0;
        }
        var word = stuffedData[srcPtr];
        var deltaEncode = data.encodeMode === 1;
        var resultPixelsAllDim = new OutPixelTypeArray(numPixels * numDims);
        var resultPixels = resultPixelsAllDim;
        var iDim;
        // TODO: reevaluate the need to keep inlined decoding code as IE support is phasing out
        if (numDims < 2 || deltaEncode) {
          for (iDim = 0; iDim < numDims; iDim++) {
            if (numDims > 1) {
              //get the mem block of current dimension
              resultPixels = new OutPixelTypeArray(resultPixelsAllDim.buffer, numPixels * iDim, numPixels);
              prevVal = 0;
            }
            if (data.headerInfo.numValidPixel === width * height) { //all valid
              for (k = 0, i = 0; i < height; i++) {
                for (j = 0; j < width; j++, k++) {
                  val = 0;
                  valTmp = (word << bitPos) >>> (32 - numBitsLUTQick);
                  valTmpQuick = valTmp;// >>> deltaBits;
                  if (32 - bitPos < numBitsLUTQick) {
                    valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUTQick));
                    valTmpQuick = valTmp;// >>> deltaBits;
                  }
                  if (decodeLut[valTmpQuick])    // if there, move the correct number of bits and done
                  {
                    val = decodeLut[valTmpQuick][1];
                    bitPos += decodeLut[valTmpQuick][0];
                  }
                  else {
                    valTmp = (word << bitPos) >>> (32 - numBitsLUT);
                    valTmpQuick = valTmp;// >>> deltaBits;
                    if (32 - bitPos < numBitsLUT) {
                      valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUT));
                      valTmpQuick = valTmp;// >>> deltaBits;
                    }
                    node = tree;
                    for (ii = 0; ii < numBitsLUT; ii++) {
                      currentBit = valTmp >>> (numBitsLUT - ii - 1) & 1;
                      node = currentBit ? node.right : node.left;
                      if (!(node.left || node.right)) {
                        val = node.val;
                        bitPos = bitPos + ii + 1;
                        break;
                      }
                    }
                  }
    
                  if (bitPos >= 32) {
                    bitPos -= 32;
                    srcPtr++;
                    word = stuffedData[srcPtr];
                  }
    
                  delta = val - offset;
                  if (deltaEncode) {
                    if (j > 0) {
                      delta += prevVal;    // use overflow
                    }
                    else if (i > 0) {
                      delta += resultPixels[k - width];
                    }
                    else {
                      delta += prevVal;
                    }
                    delta &= 0xFF; //overflow
                    resultPixels[k] = delta;//overflow
                    prevVal = delta;
                  }
                  else {
                    resultPixels[k] = delta;
                  }
                }
              }
            }
            else { //not all valid, use mask
              for (k = 0, i = 0; i < height; i++) {
                for (j = 0; j < width; j++, k++) {
                  if (mask[k]) {
                    val = 0;
                    valTmp = (word << bitPos) >>> (32 - numBitsLUTQick);
                    valTmpQuick = valTmp;// >>> deltaBits;
                    if (32 - bitPos < numBitsLUTQick) {
                      valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUTQick));
                      valTmpQuick = valTmp;// >>> deltaBits;
                    }
                    if (decodeLut[valTmpQuick])    // if there, move the correct number of bits and done
                    {
                      val = decodeLut[valTmpQuick][1];
                      bitPos += decodeLut[valTmpQuick][0];
                    }
                    else {
                      valTmp = (word << bitPos) >>> (32 - numBitsLUT);
                      valTmpQuick = valTmp;// >>> deltaBits;
                      if (32 - bitPos < numBitsLUT) {
                        valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUT));
                        valTmpQuick = valTmp;// >>> deltaBits;
                      }
                      node = tree;
                      for (ii = 0; ii < numBitsLUT; ii++) {
                        currentBit = valTmp >>> (numBitsLUT - ii - 1) & 1;
                        node = currentBit ? node.right : node.left;
                        if (!(node.left || node.right)) {
                          val = node.val;
                          bitPos = bitPos + ii + 1;
                          break;
                        }
                      }
                    }
    
                    if (bitPos >= 32) {
                      bitPos -= 32;
                      srcPtr++;
                      word = stuffedData[srcPtr];
                    }
    
                    delta = val - offset;
                    if (deltaEncode) {
                      if (j > 0 && mask[k - 1]) {
                        delta += prevVal;    // use overflow
                      }
                      else if (i > 0 && mask[k - width]) {
                        delta += resultPixels[k - width];
                      }
                      else {
                        delta += prevVal;
                      }
    
                      delta &= 0xFF; //overflow
                      resultPixels[k] = delta;//overflow
                      prevVal = delta;
                    }
                    else {
                      resultPixels[k] = delta;
                    }
                  }
                }
              }
            }
          }
        }
        else {
          for (k = 0, i = 0; i < height; i++) {
            for (j = 0; j < width; j++) {
              k = i * width + j;
              if (!mask || mask[k]) {
                for (iDim = 0; iDim < numDims; iDim++, k+=numPixels) {
                  val = 0;
                  valTmp = (word << bitPos) >>> (32 - numBitsLUTQick);
                  valTmpQuick = valTmp;
                  if (32 - bitPos < numBitsLUTQick) {
                    valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUTQick));
                    valTmpQuick = valTmp;
                  }
                  if (decodeLut[valTmpQuick])
                  {
                    val = decodeLut[valTmpQuick][1];
                    bitPos += decodeLut[valTmpQuick][0];
                  }
                  else {
                    valTmp = (word << bitPos) >>> (32 - numBitsLUT);
                    valTmpQuick = valTmp;
                    if (32 - bitPos < numBitsLUT) {
                      valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUT));
                      valTmpQuick = valTmp;
                    }
                    node = tree;
                    for (ii = 0; ii < numBitsLUT; ii++) {
                      currentBit = valTmp >>> (numBitsLUT - ii - 1) & 1;
                      node = currentBit ? node.right : node.left;
                      if (!(node.left || node.right)) {
                        val = node.val;
                        bitPos = bitPos + ii + 1;
                        break;
                      }
                    }
                  }

                  if (bitPos >= 32) {
                    bitPos -= 32;
                    srcPtr++;
                    word = stuffedData[srcPtr];
                  }

                  delta = val - offset;
                  resultPixels[k] = delta;
                }
              }
            }
          }
        }
        data.ptr = data.ptr + (srcPtr + 1) * 4 + (bitPos > 0 ? 4 : 0);
        data.pixels.resultPixels = resultPixelsAllDim;
        //swap for BIP layout
        if (numDims > 1 && !useBSQForOutputDim) {
          data.pixels.resultPixels = Lerc2Helpers.swapDimensionOrder(resultPixelsAllDim, numPixels, numDims, OutPixelTypeArray);
        }
      },

      decodeBits: function(input, data, blockDataBuffer, offset, iDim) {
        {
          //bitstuff encoding is 3
          var headerInfo = data.headerInfo;
          var fileVersion = headerInfo.fileVersion;
          //var block = {};
          var blockPtr = 0;
          var viewByteLength = ((input.byteLength - data.ptr) >= 5) ? 5 : (input.byteLength - data.ptr);
          var view = new DataView(input, data.ptr, viewByteLength);
          var headerByte = view.getUint8(0);
          blockPtr++;
          var bits67 = headerByte >> 6;
          var n = (bits67 === 0) ? 4 : 3 - bits67;
          var doLut = (headerByte & 32) > 0 ? true : false;//5th bit
          var numBits = headerByte & 31;
          var numElements = 0;
          if (n === 1) {
            numElements = view.getUint8(blockPtr); blockPtr++;
          } else if (n === 2) {
            numElements = view.getUint16(blockPtr, true); blockPtr += 2;
          } else if (n === 4) {
            numElements = view.getUint32(blockPtr, true); blockPtr += 4;
          } else {
            throw "Invalid valid pixel count type";
          }
          //fix: huffman codes are bit stuffed, but not bound by data's max value, so need to use originalUnstuff
          //offset = offset || 0;
          var scale = 2 * headerInfo.maxZError;
          var stuffedData, arrayBuf, store8, dataBytes, dataWords;
          var lutArr, lutData, lutBytes, lutBitsPerElement, bitsPerPixel;
          var zMax = headerInfo.numDims > 1 ? headerInfo.maxValues[iDim] : headerInfo.zMax;
          if (doLut) {
            data.counter.lut++;
            lutBytes = view.getUint8(blockPtr);
            lutBitsPerElement = numBits;
            blockPtr++;
            dataBytes = Math.ceil((lutBytes - 1) * numBits / 8);
            dataWords = Math.ceil(dataBytes / 4);
            arrayBuf = new ArrayBuffer(dataWords * 4);
            store8 = new Uint8Array(arrayBuf);

            data.ptr += blockPtr;
            store8.set(new Uint8Array(input, data.ptr, dataBytes));

            lutData = new Uint32Array(arrayBuf);
            data.ptr += dataBytes;

            bitsPerPixel = 0;
            while ((lutBytes - 1) >>> bitsPerPixel) {
              bitsPerPixel++;
            }
            dataBytes = Math.ceil(numElements * bitsPerPixel / 8);
            dataWords = Math.ceil(dataBytes / 4);
            arrayBuf = new ArrayBuffer(dataWords * 4);
            store8 = new Uint8Array(arrayBuf);
            store8.set(new Uint8Array(input, data.ptr, dataBytes));
            stuffedData = new Uint32Array(arrayBuf);
            data.ptr += dataBytes;
            if (fileVersion >= 3) {
              lutArr = BitStuffer.unstuffLUT2(lutData, numBits, lutBytes - 1, offset, scale, zMax);
            }
            else {
              lutArr = BitStuffer.unstuffLUT(lutData, numBits, lutBytes - 1, offset, scale, zMax);
            }
            //lutArr.unshift(0);
            if (fileVersion >= 3) {
              //BitStuffer.unstuff2(block, blockDataBuffer, headerInfo.zMax);
              BitStuffer.unstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements, lutArr);
            }
            else {
              BitStuffer.unstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements, lutArr);
            }
          }
          else {
            //console.debug("bitstuffer");
            data.counter.bitstuffer++;
            bitsPerPixel = numBits;
            data.ptr += blockPtr;
            if (bitsPerPixel > 0) {
              dataBytes = Math.ceil(numElements * bitsPerPixel / 8);
              dataWords = Math.ceil(dataBytes / 4);
              arrayBuf = new ArrayBuffer(dataWords * 4);
              store8 = new Uint8Array(arrayBuf);
              store8.set(new Uint8Array(input, data.ptr, dataBytes));
              stuffedData = new Uint32Array(arrayBuf);
              data.ptr += dataBytes;
              if (fileVersion >= 3) {
                if (offset == null) {
                  BitStuffer.originalUnstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements);
                }
                else {
                  BitStuffer.unstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements, false, offset, scale, zMax);
                }
              }
              else {
                if (offset == null) {
                  BitStuffer.originalUnstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements);
                }
                else {
                  BitStuffer.unstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements, false, offset, scale, zMax);
                }
              }
            }
          }
        }

      },

      readTiles: function(input, data, OutPixelTypeArray, useBSQForOutputDim) {
        var headerInfo = data.headerInfo;
        var width = headerInfo.width;
        var height = headerInfo.height;
        var numPixels = width * height;
        var microBlockSize = headerInfo.microBlockSize;
        var imageType = headerInfo.imageType;
        var dataTypeSize = Lerc2Helpers.getDataTypeSize(imageType);
        var numBlocksX = Math.ceil(width / microBlockSize);
        var numBlocksY = Math.ceil(height / microBlockSize);
        data.pixels.numBlocksY = numBlocksY;
        data.pixels.numBlocksX = numBlocksX;
        data.pixels.ptr = 0;
        var row = 0, col = 0, blockY = 0, blockX = 0, thisBlockHeight = 0, thisBlockWidth = 0, bytesLeft = 0, headerByte = 0, bits67 = 0, testCode = 0, outPtr = 0, outStride = 0, numBytes = 0, bytesleft = 0, z = 0, blockPtr = 0;
        var view, block, arrayBuf, store8, rawData;
        var blockEncoding;
        var blockDataBuffer = new OutPixelTypeArray(microBlockSize * microBlockSize);
        var lastBlockHeight = (height % microBlockSize) || microBlockSize;
        var lastBlockWidth = (width % microBlockSize) || microBlockSize;
        var offsetType, offset;
        var numDims = headerInfo.numDims, iDim;
        var mask = data.pixels.resultMask;
        var resultPixels = data.pixels.resultPixels;
        var fileVersion = headerInfo.fileVersion;
        var fileVersionCheckNum = fileVersion >= 5 ? 14 : 15;
        var isDiffEncoding;
        var zMax = headerInfo.zMax;
        //var resultPixelsAllDim = resultPixels;
        var resultPixelsPrevDim;
        for (blockY = 0; blockY < numBlocksY; blockY++) {
          thisBlockHeight = (blockY !== numBlocksY - 1) ? microBlockSize : lastBlockHeight;
          for (blockX = 0; blockX < numBlocksX; blockX++) {
            //console.debug("y" + blockY + " x" + blockX);
            thisBlockWidth = (blockX !== numBlocksX - 1) ? microBlockSize : lastBlockWidth;

            outPtr = blockY * width * microBlockSize + blockX * microBlockSize;
            outStride = width - thisBlockWidth;

            for (iDim = 0; iDim < numDims; iDim++) {
              if (numDims > 1) {
                resultPixelsPrevDim = resultPixels;
                outPtr = blockY * width * microBlockSize + blockX * microBlockSize;
                resultPixels = new OutPixelTypeArray(data.pixels.resultPixels.buffer, numPixels * iDim * dataTypeSize, numPixels);
                zMax = headerInfo.maxValues[iDim];
              } else {
                resultPixelsPrevDim = null;
              }
              bytesLeft = input.byteLength - data.ptr;
              view = new DataView(input, data.ptr, Math.min(10, bytesLeft));
              block = {};
              blockPtr = 0;
              headerByte = view.getUint8(0);
              blockPtr++;
              isDiffEncoding = headerInfo.fileVersion >= 5 ? headerByte & 4 : 0;
              bits67 = (headerByte >> 6) & 0xFF;
              testCode = (headerByte >> 2) & fileVersionCheckNum;    // use bits 2345 for integrity check
              if (testCode !== (((blockX * microBlockSize) >> 3) & fileVersionCheckNum)) {
                throw "integrity issue";
              }

              if (isDiffEncoding && iDim === 0) {
                throw "integrity issue";
              }

              blockEncoding = headerByte & 3;
              if (blockEncoding > 3) {
                data.ptr += blockPtr;
                throw "Invalid block encoding (" + blockEncoding + ")";
              }
              else if (blockEncoding === 2) { //constant 0
                if (isDiffEncoding) {
                  if (mask) {
                    for (row = 0; row < thisBlockHeight; row++) {
                      for (col = 0; col < thisBlockWidth; col++) {
                        if (mask[outPtr]) {
                          resultPixels[outPtr] = resultPixelsPrevDim[outPtr];
                        }
                        outPtr++;
                      }
                    }
                  }
                  else {
                    for (row = 0; row < thisBlockHeight; row++) {
                      for (col = 0; col < thisBlockWidth; col++) {
                        resultPixels[outPtr] = resultPixelsPrevDim[outPtr];
                        outPtr++;
                      }
                    }
                  }
                }
                data.counter.constant++;
                data.ptr += blockPtr;
                continue;
              }
              else if (blockEncoding === 0) {  //uncompressed
                if (isDiffEncoding) {
                  // doesn't make sense, should not happen
                  throw "integrity issue";
                }
                data.counter.uncompressed++;
                data.ptr += blockPtr;
                numBytes = thisBlockHeight * thisBlockWidth * dataTypeSize;
                bytesleft = input.byteLength - data.ptr;
                numBytes = numBytes < bytesleft ? numBytes : bytesleft;
                //bit alignment
                arrayBuf = new ArrayBuffer((numBytes % dataTypeSize) === 0 ? numBytes : (numBytes + dataTypeSize - numBytes % dataTypeSize));
                store8 = new Uint8Array(arrayBuf);
                store8.set(new Uint8Array(input, data.ptr, numBytes));
                rawData = new OutPixelTypeArray(arrayBuf);
                z = 0;
                if (mask) {
                  for (row = 0; row < thisBlockHeight; row++) {
                    for (col = 0; col < thisBlockWidth; col++) {
                      if (mask[outPtr]) {
                        resultPixels[outPtr] = rawData[z++];
                      }
                      outPtr++;
                    }
                    outPtr += outStride;
                  }
                }
                else {//all valid
                  for (row = 0; row < thisBlockHeight; row++) {
                    for (col = 0; col < thisBlockWidth; col++) {
                      resultPixels[outPtr++] = rawData[z++];
                    }
                    outPtr += outStride;
                  }
                }
                data.ptr += z * dataTypeSize;
              }
              else { //1 or 3
                offsetType = Lerc2Helpers.getDataTypeUsed((isDiffEncoding && imageType < 6) ? 4 : imageType, bits67);
                offset = Lerc2Helpers.getOnePixel(block, blockPtr, offsetType, view);
                blockPtr += Lerc2Helpers.getDataTypeSize(offsetType);
                if (blockEncoding === 3) //constant offset value
                {
                  data.ptr += blockPtr;
                  data.counter.constantoffset++;
                  //you can delete the following resultMask case in favor of performance because val is constant and users use nodata mask, otherwise nodatavalue post processing handles it too.
                  //while the above statement is true, we're not doing it as we want to keep invalid pixel value at 0 rather than arbitrary values
                  if (mask) {
                    for (row = 0; row < thisBlockHeight; row++) {
                      for (col = 0; col < thisBlockWidth; col++) {
                        if (mask[outPtr]) {
                          resultPixels[outPtr] = isDiffEncoding ? Math.min(zMax, resultPixelsPrevDim[outPtr] + offset) : offset;
                        }
                        outPtr++;
                      }
                      outPtr += outStride;
                    }
                  }
                  else {
                    for (row = 0; row < thisBlockHeight; row++) {
                      for (col = 0; col < thisBlockWidth; col++) {
                        resultPixels[outPtr] = isDiffEncoding ? Math.min(zMax, resultPixelsPrevDim[outPtr] + offset) : offset;
                        outPtr++;
                      }
                      outPtr += outStride;
                    }
                  }
                }
                else { //bitstuff encoding is 3
                  data.ptr += blockPtr;
                  //heavy lifting
                  Lerc2Helpers.decodeBits(input, data, blockDataBuffer, offset, iDim);
                  blockPtr = 0;
                  // duplicate code to favor performance, diff encoding is for multidimension only
                  if (isDiffEncoding) {
                    if (mask) {
                      for (row = 0; row < thisBlockHeight; row++) {
                        for (col = 0; col < thisBlockWidth; col++) {
                          if (mask[outPtr]) {
                            resultPixels[outPtr] = blockDataBuffer[blockPtr++] + resultPixelsPrevDim[outPtr];
                          }
                          outPtr++;
                        }
                        outPtr += outStride;
                      }
                    }
                    else {
                      for (row = 0; row < thisBlockHeight; row++) {
                        for (col = 0; col < thisBlockWidth; col++) {
                          resultPixels[outPtr] = blockDataBuffer[blockPtr++] + resultPixelsPrevDim[outPtr];
                          outPtr++;
                        }
                        outPtr += outStride;
                      }
                    }
                  }
                  else if (mask) {
                    for (row = 0; row < thisBlockHeight; row++) {
                      for (col = 0; col < thisBlockWidth; col++) {
                        if (mask[outPtr]) {
                          resultPixels[outPtr] = blockDataBuffer[blockPtr++];
                        }
                        outPtr++;
                      }
                      outPtr += outStride;
                    }
                  }
                  else {
                    for (row = 0; row < thisBlockHeight; row++) {
                      for (col = 0; col < thisBlockWidth; col++) {
                        resultPixels[outPtr++] = blockDataBuffer[blockPtr++];
                      }
                      outPtr += outStride;
                    }
                  }
                }
              }
            }
          }
        }
        //swap for BIP: it's always easier for clients to handle BSQ so we keep existing logic and introduce a swap here to minimze changes
        if (numDims > 1 && !useBSQForOutputDim) {
          data.pixels.resultPixels = Lerc2Helpers.swapDimensionOrder(data.pixels.resultPixels, numPixels, numDims, OutPixelTypeArray);
        }
      },

      /*****************
      *  private methods (helper methods)
      *****************/

      formatFileInfo: function(data) {
        return {
          "fileIdentifierString": data.headerInfo.fileIdentifierString,
          "fileVersion": data.headerInfo.fileVersion,
          "imageType": data.headerInfo.imageType,
          "height": data.headerInfo.height,
          "width": data.headerInfo.width,
          "numValidPixel": data.headerInfo.numValidPixel,
          "microBlockSize": data.headerInfo.microBlockSize,
          "blobSize": data.headerInfo.blobSize,
          "maxZError": data.headerInfo.maxZError,
          "pixelType": Lerc2Helpers.getPixelType(data.headerInfo.imageType),
          "eofOffset": data.eofOffset,
          "mask": data.mask ? {
            "numBytes": data.mask.numBytes
          } : null,
          "pixels": {
            "numBlocksX": data.pixels.numBlocksX,
            "numBlocksY": data.pixels.numBlocksY,
            //"numBytes": data.pixels.numBytes,
            "maxValue": data.headerInfo.zMax,
            "minValue": data.headerInfo.zMin,
            "noDataValue": data.noDataValue
          }
        };
      },

      constructConstantSurface: function(data, useBSQForOutputDim) {
        var val = data.headerInfo.zMax;
        var valMin = data.headerInfo.zMin;
        var maxValues = data.headerInfo.maxValues;
        var numDims = data.headerInfo.numDims;
        var numPixels = data.headerInfo.height * data.headerInfo.width;
        var i = 0, k = 0, nStart = 0;
        var mask = data.pixels.resultMask;
        var resultPixels = data.pixels.resultPixels;
        if (mask) {
          if (numDims > 1) {
            if (useBSQForOutputDim) {
              for (i = 0; i < numDims; i++) {
                nStart = i * numPixels;
                val = maxValues[i];
                for (k = 0; k < numPixels; k++) {
                  if (mask[k]) {
                    resultPixels[nStart + k] = val;
                  }
                }
              }  
            }
            else {
              for (k = 0; k < numPixels; k++) {
                if (mask[k]) {
                  nStart = k * numDims;
                  for (i = 0; i < numDims; i++) {
                    resultPixels[nStart + numDims] = maxValues[i];
                  }
                }
              }
            }
          }
          else {
            for (k = 0; k < numPixels; k++) {
              if (mask[k]) {
                resultPixels[k] = val;
              }
            }
          }
        }
        else {
          if (numDims > 1 && valMin !== val) {
            if (useBSQForOutputDim) {
              for (i = 0; i < numDims; i++) {
                nStart = i * numPixels;
                val = maxValues[i];
                for (k = 0; k < numPixels; k++) {
                  resultPixels[nStart + k] = val;
                }
              }
            }
            else {
              for (k = 0; k < numPixels; k++) {
                nStart = k * numDims;
                for (i = 0; i < numDims; i++) {
                  resultPixels[nStart + i] = maxValues[i];
                }
              }
            }
          }
          else {
            for (k = 0; k < numPixels * numDims; k++) {
              resultPixels[k] = val;
            }
          }
        }
        return;
      },

      getDataTypeArray: function(t) {
        var tp;
        switch (t) {
          case 0: //char
            tp = Int8Array;
            break;
          case 1: //byte
            tp = Uint8Array;
            break;
          case 2: //short
            tp = Int16Array;
            break;
          case 3: //ushort
            tp = Uint16Array;
            break;
          case 4:
            tp = Int32Array;
            break;
          case 5:
            tp = Uint32Array;
            break;
          case 6:
            tp = Float32Array;
            break;
          case 7:
            tp = Float64Array;
            break;
          default:
            tp = Float32Array;
        }
        return tp;
      },

      getPixelType: function(t) {
        var tp;
        switch (t) {
          case 0: //char
            tp = "S8";
            break;
          case 1: //byte
            tp = "U8";
            break;
          case 2: //short
            tp = "S16";
            break;
          case 3: //ushort
            tp = "U16";
            break;
          case 4:
            tp = "S32";
            break;
          case 5:
            tp = "U32";
            break;
          case 6:
            tp = "F32";
            break;
          case 7:
            tp = "F64";
            break;
          default:
            tp = "F32";
        }
        return tp;
      },

      isValidPixelValue: function(t, val) {
        if (val == null) {
          return false;
        }
        var isValid;
        switch (t) {
          case 0: //char
            isValid = val >= -128 && val <= 127;
            break;
          case 1: //byte  (unsigned char)
            isValid = val >= 0 && val <= 255;
            break;
          case 2: //short
            isValid = val >= -32768 && val <= 32767;
            break;
          case 3: //ushort
            isValid = val >= 0 && val <= 65536;
            break;
          case 4: //int 32
            isValid = val >= -2147483648 && val <= 2147483647;
            break;
          case 5: //uinit 32
            isValid = val >= 0 && val <= 4294967296;
            break;
          case 6:
            isValid = val >= -3.4027999387901484e+38 && val <= 3.4027999387901484e+38;
            break;
          case 7:
            isValid = val >= -1.7976931348623157e+308 && val <= 1.7976931348623157e+308;
            break;
          default:
            isValid = false;
        }
        return isValid;
      },

      getDataTypeSize: function(t) {
        var s = 0;
        switch (t) {
          case 0: //ubyte
          case 1: //byte
            s = 1;
            break;
          case 2: //short
          case 3: //ushort
            s = 2;
            break;
          case 4:
          case 5:
          case 6:
            s = 4;
            break;
          case 7:
            s = 8;
            break;
          default:
            s = t;
        }
        return s;
      },

      getDataTypeUsed: function(dt, tc) {
        var t = dt;
        switch (dt) {
          case 2: //short
          case 4: //long
            t = dt - tc;
            break;
          case 3: //ushort
          case 5: //ulong
            t = dt - 2 * tc;
            break;
          case 6: //float
            if (0 === tc) {
              t = dt;
            }
            else if (1 === tc) {
              t = 2;
            }
            else {
              t = 1;//byte
            }
            break;
          case 7: //double
            if (0 === tc) {
              t = dt;
            }
            else {
              t = dt - 2 * tc + 1;
            }
            break;
          default:
            t = dt;
            break;
        }
        return t;
      },

      getOnePixel: function(block, blockPtr, offsetType, view) {
        var temp = 0;
        switch (offsetType) {
          case 0: //char
            temp = view.getInt8(blockPtr);
            break;
          case 1: //byte
            temp = view.getUint8(blockPtr);
            break;
          case 2:
            temp = view.getInt16(blockPtr, true);
            break;
          case 3:
            temp = view.getUint16(blockPtr, true);
            break;
          case 4:
            temp = view.getInt32(blockPtr, true);
            break;
          case 5:
            temp = view.getUInt32(blockPtr, true);
            break;
          case 6:
            temp = view.getFloat32(blockPtr, true);
            break;
          case 7:
            temp = view.getFloat64(blockPtr, true);
            break;
          default:
            throw ("the decoder does not understand this pixel type");
        }
        return temp;
      },

      swapDimensionOrder: function(pixels, numPixels, numDims, OutPixelTypeArray, inputIsBIP) {
        var i = 0, j = 0, iDim = 0, temp = 0, swap = pixels;
        if (numDims > 1) {
          swap = new OutPixelTypeArray(numPixels * numDims);
          if (inputIsBIP) {
            for (i=0; i<numPixels; i++) {
              temp = i;
              for (iDim=0; iDim < numDims; iDim++, temp += numPixels) {
                swap[temp] = pixels[j++];
              }
            }  
          }
          else {
            for (i=0; i<numPixels; i++) {
              temp = i;
              for (iDim=0; iDim < numDims; iDim++, temp += numPixels) {
                swap[j++] = pixels[temp];
              }
            }
          }
        }
        return swap;
      }
    };

    /***************************************************
    *private class for a tree node. Huffman code is in Lerc2Helpers
    ****************************************************/
    var TreeNode = function(val, left, right) {
      this.val = val;
      this.left = left;
      this.right = right;
    };

    var Lerc2Decode = {
      /*
      * ********removed options compared to LERC1. We can bring some of them back if needed.
       * removed pixel type. LERC2 is typed and doesn't require user to give pixel type
       * changed encodedMaskData to maskData. LERC2 's js version make it faster to use maskData directly.
       * removed returnMask. mask is used by LERC2 internally and is cost free. In case of user input mask, it's returned as well and has neglible cost.
       * removed nodatavalue. Because LERC2 pixels are typed, nodatavalue will sacrify a useful value for many types (8bit, 16bit) etc,
       *       user has to be knowledgable enough about raster and their data to avoid usability issues. so nodata value is simply removed now.
       *       We can add it back later if their's a clear requirement.
       * removed encodedMask. This option was not implemented in LercDecode. It can be done after decoding (less efficient)
       * removed computeUsedBitDepths.
       *
       *
       * response changes compared to LERC1
       * 1. encodedMaskData is not available
       * 2. noDataValue is optional (returns only if user's noDataValue is with in the valid data type range)
       * 3. maskData is always available
      */
      /*****************
      *  public properties
      ******************/
      //HUFFMAN_LUT_BITS_MAX: 12, //use 2^12 lut, not configurable

      /*****************
      *  public methods
      *****************/

      /**
       * Decode a LERC2 byte stream and return an object containing the pixel data and optional metadata.
       *
       * @param {ArrayBuffer} input The LERC input byte stream
       * @param {object} [options] options Decoding options
       * @param {number} [options.inputOffset] The number of bytes to skip in the input byte stream. A valid LERC file is expected at that position
       * @param {boolean} [options.returnFileInfo] If true, the return value will have a fileInfo property that contains metadata obtained from the LERC headers and the decoding process
       * @param {boolean} [options.returnPixelInterleavedDims]  If true, returned dimensions are pixel-interleaved, a.k.a [p1_dim0, p1_dim1, p1_dimn, p2_dim0...], default is [p1_dim0, p2_dim0, ..., p1_dim1, p2_dim1...]
       */
      decode: function(/*byte array*/ input, /*object*/ options) {
        //currently there's a bug in the sparse array, so please do not set to false
        options = options || {};
        var noDataValue = options.noDataValue;

        //initialize
        var i = 0, data = {};
        data.ptr = options.inputOffset || 0;
        data.pixels = {};

        // File header
        if (!Lerc2Helpers.readHeaderInfo(input, data)) {
          return;
        }

        var headerInfo = data.headerInfo;
        var fileVersion = headerInfo.fileVersion;
        var OutPixelTypeArray = Lerc2Helpers.getDataTypeArray(headerInfo.imageType);

        // version check
        if (fileVersion > 5) {
          throw "unsupported lerc version 2." + fileVersion;
        }

        // Mask Header
        Lerc2Helpers.readMask(input, data);
        if (headerInfo.numValidPixel !== headerInfo.width * headerInfo.height && !data.pixels.resultMask) {
          data.pixels.resultMask = options.maskData;
        }

        var numPixels = headerInfo.width * headerInfo.height;
        data.pixels.resultPixels = new OutPixelTypeArray(numPixels * headerInfo.numDims);

        data.counter = {
          onesweep: 0,
          uncompressed: 0,
          lut: 0,
          bitstuffer: 0,
          constant: 0,
          constantoffset: 0
        };
        var useBSQForOutputDim = !options.returnPixelInterleavedDims;
        if (headerInfo.numValidPixel !== 0) {
          //not tested
          if (headerInfo.zMax === headerInfo.zMin) //constant surface
          {
            Lerc2Helpers.constructConstantSurface(data, useBSQForOutputDim);
          }
          else if (fileVersion >= 4 && Lerc2Helpers.checkMinMaxRanges(input, data)) {
            Lerc2Helpers.constructConstantSurface(data, useBSQForOutputDim);
          }
          else {
            var view = new DataView(input, data.ptr, 2);
            var bReadDataOneSweep = view.getUint8(0);
            data.ptr++;
            if (bReadDataOneSweep) {
              //console.debug("OneSweep");
              Lerc2Helpers.readDataOneSweep(input, data, OutPixelTypeArray, useBSQForOutputDim);
            }
            else {
              //lerc2.1: //bitstuffing + lut
              //lerc2.2: //bitstuffing + lut + huffman
              //lerc2.3: new bitstuffer
              if (fileVersion > 1 && headerInfo.imageType <= 1 && Math.abs(headerInfo.maxZError - 0.5) < 0.00001) {
                //this is 2.x plus 8 bit (unsigned and signed) data, possiblity of Huffman
                var flagHuffman = view.getUint8(1);
                data.ptr++;
                data.encodeMode = flagHuffman;
                if (flagHuffman > 2 || (fileVersion < 4 && flagHuffman > 1)) {
                  throw "Invalid Huffman flag " + flagHuffman;
                }
                if (flagHuffman) {//1 - delta Huffman, 2 - Huffman
                  //console.log("Huffman");
                  Lerc2Helpers.readHuffman(input, data, OutPixelTypeArray, useBSQForOutputDim);
                }
                else {
                  //console.log("Tiles");
                  Lerc2Helpers.readTiles(input, data, OutPixelTypeArray, useBSQForOutputDim);
                }
              }
              else { //lerc2.x non-8 bit data
                //console.log("Tiles");
                Lerc2Helpers.readTiles(input, data, OutPixelTypeArray, useBSQForOutputDim);
              }
            }
          }
        }

        data.eofOffset = data.ptr;
        var diff;
        if (options.inputOffset) {
          diff = data.headerInfo.blobSize + options.inputOffset - data.ptr;
          if (Math.abs(diff) >= 1) {
            //console.debug("incorrect eof: dataptr " + data.ptr + " offset " + options.inputOffset + " blobsize " + data.headerInfo.blobSize + " diff: " + diff);
            data.eofOffset = options.inputOffset + data.headerInfo.blobSize;
          }
        }
        else {
          diff = data.headerInfo.blobSize - data.ptr;
          if (Math.abs(diff) >= 1) {
            //console.debug("incorrect first band eof: dataptr " + data.ptr + " blobsize " + data.headerInfo.blobSize + " diff: " + diff);
            data.eofOffset = data.headerInfo.blobSize;
          }
        }

        var result = {
          width: headerInfo.width,
          height: headerInfo.height,
          pixelData: data.pixels.resultPixels,
          minValue: headerInfo.zMin,
          maxValue: headerInfo.zMax,
          validPixelCount: headerInfo.numValidPixel,
          dimCount: headerInfo.numDims,
          dimStats: {
            minValues: headerInfo.minValues,
            maxValues: headerInfo.maxValues
          },
          maskData: data.pixels.resultMask
          //noDataValue: noDataValue
        };

        //we should remove this if there's no existing client
        //optional noDataValue processing, it's user's responsiblity
        if (data.pixels.resultMask && Lerc2Helpers.isValidPixelValue(headerInfo.imageType, noDataValue)) {
          var mask = data.pixels.resultMask;
          for (i = 0; i < numPixels; i++) {
            if (!mask[i]) {
              result.pixelData[i] = noDataValue;
            }
          }
          result.noDataValue = noDataValue;
        }
        data.noDataValue = noDataValue;
        if (options.returnFileInfo) {
          result.fileInfo = Lerc2Helpers.formatFileInfo(data);
        }
        return result;
      },

      getBandCount: function(/*byte array*/ input) {
        var count = 0;
        var i = 0;
        var temp = {};
        temp.ptr = 0;
        temp.pixels = {};
        while (i < input.byteLength - 58) {
          Lerc2Helpers.readHeaderInfo(input, temp);
          i += temp.headerInfo.blobSize;
          count++;
          temp.ptr = i;
        }
        return count;
      }
    };

    return Lerc2Decode;
  })();

  var isPlatformLittleEndian = (function() {
    var a = new ArrayBuffer(4);
    var b = new Uint8Array(a);
    var c = new Uint32Array(a);
    c[0] = 1;
    return b[0] === 1;
  })();

  var Lerc = {
    /************wrapper**********************************************/
    /**
     * A wrapper for decoding both LERC1 and LERC2 byte streams capable of handling multiband pixel blocks for various pixel types.
     *
     * @alias module:Lerc
     * @param {ArrayBuffer} input The LERC input byte stream
     * @param {object} [options] The decoding options below are optional.
     * @param {number} [options.inputOffset] The number of bytes to skip in the input byte stream. A valid Lerc file is expected at that position.
     * @param {string} [options.pixelType] (LERC1 only) Default value is F32. Valid pixel types for input are U8/S8/S16/U16/S32/U32/F32.
     * @param {number} [options.noDataValue] (LERC1 only). It is recommended to use the returned mask instead of setting this value.
     * @param {boolean} [options.returnPixelInterleavedDims] (nDim LERC2 only) If true, returned dimensions are pixel-interleaved, a.k.a [p1_dim0, p1_dim1, p1_dimn, p2_dim0...], default is [p1_dim0, p2_dim0, ..., p1_dim1, p2_dim1...]
     * @returns {{width, height, pixels, pixelType, mask, statistics}}
       * @property {number} width Width of decoded image.
       * @property {number} height Height of decoded image.
       * @property {array} pixels [band1, band2, â¦] Each band is a typed array of width*height.
       * @property {string} pixelType The type of pixels represented in the output.
       * @property {mask} mask Typed array with a size of width*height, or null if all pixels are valid.
       * @property {array} statistics [statistics_band1, statistics_band2, â¦] Each element is a statistics object representing min and max values
    **/
    decode: function(encodedData, options) {
      if (!isPlatformLittleEndian) {
        throw "Big endian system is not supported.";
      }
      options = options || {};
      var inputOffset = options.inputOffset || 0;
      var fileIdView = new Uint8Array(encodedData, inputOffset, 10);
      var fileIdentifierString = String.fromCharCode.apply(null, fileIdView);
      var lerc, majorVersion;
      if (fileIdentifierString.trim() === "CntZImage") {
        lerc = LercDecode;
        majorVersion = 1;
      }
      else if (fileIdentifierString.substring(0, 5) === "Lerc2") {
        lerc = Lerc2Decode;
        majorVersion = 2;
      }
      else {
        throw "Unexpected file identifier string: " + fileIdentifierString;
      }

      var iPlane = 0, eof = encodedData.byteLength - 10, encodedMaskData, bandMasks = [], bandMask, maskData;
      var decodedPixelBlock = {
        width: 0,
        height: 0,
        pixels: [],
        pixelType: options.pixelType,
        mask: null,
        statistics: []
      };
      var uniqueBandMaskCount = 0;

      while (inputOffset < eof) {
        var result = lerc.decode(encodedData, {
          inputOffset: inputOffset,//for both lerc1 and lerc2
          encodedMaskData: encodedMaskData,//lerc1 only
          maskData: maskData,//lerc2 only
          returnMask: iPlane === 0 ? true : false,//lerc1 only
          returnEncodedMask: iPlane === 0 ? true : false,//lerc1 only
          returnFileInfo: true,//for both lerc1 and lerc2
          returnPixelInterleavedDims: options.returnPixelInterleavedDims,//for ndim lerc2 only
          pixelType: options.pixelType || null,//lerc1 only
          noDataValue: options.noDataValue || null//lerc1 only
        });

        inputOffset = result.fileInfo.eofOffset;
        maskData = result.maskData;//lerc2
        if (iPlane === 0) {
          encodedMaskData = result.encodedMaskData;//lerc1
          decodedPixelBlock.width = result.width;
          decodedPixelBlock.height = result.height;
          decodedPixelBlock.dimCount = result.dimCount || 1;
          //decodedPixelBlock.dimStats = decodedPixelBlock.dimStats;
          decodedPixelBlock.pixelType = result.pixelType || result.fileInfo.pixelType;
          decodedPixelBlock.mask = maskData;
        }
        if (majorVersion > 1) {
          if (maskData) {
            bandMasks.push(maskData);
          }
          if (result.fileInfo.mask && result.fileInfo.mask.numBytes > 0) {
            uniqueBandMaskCount++;
          }
        }

        iPlane++;
        decodedPixelBlock.pixels.push(result.pixelData);
        decodedPixelBlock.statistics.push({
          minValue: result.minValue,
          maxValue: result.maxValue,
          noDataValue: result.noDataValue,
          dimStats: result.dimStats
        });
      }
      var i, j, numPixels;
      if (majorVersion > 1 && uniqueBandMaskCount > 1) {
        numPixels = decodedPixelBlock.width * decodedPixelBlock.height;
        decodedPixelBlock.bandMasks = bandMasks;
        maskData = new Uint8Array(numPixels);
        maskData.set(bandMasks[0]);
        for (i = 1; i < bandMasks.length; i++) {
          bandMask = bandMasks[i];
          for (j = 0; j < numPixels; j++) {
            maskData[j] = maskData[j] & bandMask[j];
          }
        }
        decodedPixelBlock.maskData = maskData;
      }

      return decodedPixelBlock;
    }
  };

  if (true) {/* jshint ignore:line */
    //amd loaders such as dojo and requireJS
    //http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() { return Lerc; }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));/* jshint ignore:line */
  }
  else {}

})();


/***/ }),

/***/ "./node_modules/geotiff/dist-module/compression/lerc.js":
/*!**************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/compression/lerc.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LercDecoder)
/* harmony export */ });
/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pako */ "./node_modules/pako/dist/pako.esm.mjs");
/* harmony import */ var lerc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lerc */ "./node_modules/lerc/LercDecode.js");
/* harmony import */ var _basedecoder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basedecoder.js */ "./node_modules/geotiff/dist-module/compression/basedecoder.js");
/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../globals.js */ "./node_modules/geotiff/dist-module/globals.js");





class LercDecoder extends _basedecoder_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor(fileDirectory) {
    super();

    this.planarConfiguration = typeof fileDirectory.PlanarConfiguration !== 'undefined' ? fileDirectory.PlanarConfiguration : 1;
    this.samplesPerPixel = typeof fileDirectory.SamplesPerPixel !== 'undefined' ? fileDirectory.SamplesPerPixel : 1;

    this.addCompression = fileDirectory.LercParameters[_globals_js__WEBPACK_IMPORTED_MODULE_3__.LercParameters.AddCompression];
  }

  decodeBlock(buffer) {
    switch (this.addCompression) {
      case _globals_js__WEBPACK_IMPORTED_MODULE_3__.LercAddCompression.None:
        break;
      case _globals_js__WEBPACK_IMPORTED_MODULE_3__.LercAddCompression.Deflate:
        buffer = (0,pako__WEBPACK_IMPORTED_MODULE_0__.inflate)(new Uint8Array(buffer)).buffer; // eslint-disable-line no-param-reassign, prefer-destructuring
        break;
      default:
        throw new Error(`Unsupported LERC additional compression method identifier: ${this.addCompression}`);
    }

    const lercResult = lerc__WEBPACK_IMPORTED_MODULE_1__.decode(buffer, { returnPixelInterleavedDims: this.planarConfiguration === 1 });
    const lercData = lercResult.pixels[0];
    return lercData.buffer;
  }
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfZ2VvdGlmZl9kaXN0LW1vZHVsZV9jb21wcmVzc2lvbl9sZXJjX2pzLmJ1bmRsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZGQUE2Rjs7QUFFN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDREQUE0RDs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0EsZ0JBQWdCLHVCQUF1QjtBQUN2QztBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QixzQkFBc0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixxQkFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRCw2QkFBNkIscUJBQXFCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRCw2QkFBNkIscUJBQXFCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCLGlCQUFpQixRQUFRO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCLGlCQUFpQixTQUFTO0FBQzFCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGtCQUFrQjtBQUNsQixvQkFBb0IsUUFBUTtBQUM1QixvQkFBb0IsUUFBUTtBQUM1QixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsUUFBUTtBQUM1QixvQkFBb0IsTUFBTTtBQUMxQixvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU0sSUFBMEMsR0FBRztBQUNuRDtBQUNBO0FBQ0EsSUFBSSxpQ0FBTyxFQUFFLG1DQUFFLGFBQWEsY0FBYztBQUFBLGtHQUFDLENBQUM7QUFDNUM7QUFDQSxPQUFPLEVBUUo7O0FBRUgsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNueEU4QjtBQUNQO0FBQ21CO0FBQ3dCOztBQUVwRCwwQkFBMEIsdURBQVc7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVEQUF1RCxzRUFBNkI7QUFDcEY7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZ0VBQXVCO0FBQ2xDO0FBQ0EsV0FBVyxtRUFBMEI7QUFDckMsaUJBQWlCLDZDQUFPLGlDQUFpQztBQUN6RDtBQUNBO0FBQ0Esc0ZBQXNGLG9CQUFvQjtBQUMxRzs7QUFFQSx1QkFBdUIsd0NBQVcsV0FBVyw0REFBNEQ7QUFDekc7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXBzYnVuZGxlLy4vbm9kZV9tb2R1bGVzL2xlcmMvTGVyY0RlY29kZS5qcyIsIndlYnBhY2s6Ly9tYXBzYnVuZGxlLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvY29tcHJlc3Npb24vbGVyYy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyLvu78vKiBqc2hpbnQgZm9yaW46IGZhbHNlLCBiaXR3aXNlOiBmYWxzZSAqL1xuLypcbkNvcHlyaWdodCAyMDE1LTIwMjEgRXNyaVxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbmh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5BIGNvcHkgb2YgdGhlIGxpY2Vuc2UgYW5kIGFkZGl0aW9uYWwgbm90aWNlcyBhcmUgbG9jYXRlZCB3aXRoIHRoZVxuc291cmNlIGRpc3RyaWJ1dGlvbiBhdDpcblxuaHR0cDovL2dpdGh1Yi5jb20vRXNyaS9sZXJjL1xuXG5Db250cmlidXRvcnM6ICBKb2hhbm5lcyBTY2htaWQsIChMRVJDIHYxKVxuICAgICAgICAgICAgICAgQ2hheWFuaWthIEtoYXR1YSwgKExFUkMgdjEpXG4gICAgICAgICAgICAgICBXZW54dWUgSnUgKExFUkMgdjEsIHYyLngpXG4qL1xuXG4vKiBDb3B5cmlnaHQgMjAxNS0yMDIxIEVzcmkuIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMCBAcHJlc2VydmUgKi9cblxuLyoqXG4gKiBhIG1vZHVsZSBmb3IgZGVjb2RpbmcgTEVSQyBibG9ic1xuICogQG1vZHVsZSBMZXJjXG4gKi9cbihmdW5jdGlvbigpIHtcbiAgLy90aGlzIGRlY29kZXIgc3VwcG9ydHMgYWxsIGxlcmMgdmVyc2lvbnMsIGVhY2ggdmVyc2lvbiBoYXMgaXRzIG93biBjbGFzcyAoTGVyY0RlY29kZSBhbmQgTGVyYzJEZWNvZGUpLiBcbiAgLy90aGUgZXhwb3J0ZWQgbW9kdWxlIGhhbmRsZXMgZm9ybWF0IHZhcmlhdGlvbiBhdXRvYW10aWNhbGx5LlxuXG4gIC8vdGhlIG9yaWdpbmFsIExlcmNEZWNvZGUgZm9yIFZlcnNpb24gMVxuICB2YXIgTGVyY0RlY29kZSA9IChmdW5jdGlvbigpIHtcblxuICAgIC8vIE5vdGU6IGN1cnJlbnRseSwgdGhpcyBtb2R1bGUgb25seSBoYXMgYW4gaW1wbGVtZW50YXRpb24gZm9yIGRlY29kaW5nIExFUkMgZGF0YSwgbm90IGVuY29kaW5nLiBUaGUgbmFtZSBvZlxuICAgIC8vIHRoZSBjbGFzcyB3YXMgY2hvc2VuIHRvIGJlIGZ1dHVyZSBwcm9vZi5cblxuICAgIHZhciBDbnRaSW1hZ2UgPSB7fTtcblxuICAgIENudFpJbWFnZS5kZWZhdWx0Tm9EYXRhVmFsdWUgPSAtMy40MDI3OTk5Mzg3OTAxNDg0ZSszODsgLy8gc21hbGxlc3QgRmxvYXQzMiB2YWx1ZVxuXG4gICAgLyoqXG4gICAgICogRGVjb2RlIGEgTEVSQyBieXRlIHN0cmVhbSBhbmQgcmV0dXJuIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBwaXhlbCBkYXRhIGFuZCBzb21lIHJlcXVpcmVkIGFuZCBvcHRpb25hbFxuICAgICAqIGluZm9ybWF0aW9uIGFib3V0IGl0LCBzdWNoIGFzIHRoZSBpbWFnZSdzIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBpbnB1dCBUaGUgTEVSQyBpbnB1dCBieXRlIHN0cmVhbVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gRGVjb2Rpbmcgb3B0aW9ucywgY29udGFpbmluZyBhbnkgb2YgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAqIEBjb25maWcge251bWJlcn0gW2lucHV0T2Zmc2V0ID0gMF1cbiAgICAgKiAgICAgICAgU2tpcCB0aGUgZmlyc3QgaW5wdXRPZmZzZXQgYnl0ZXMgb2YgdGhlIGlucHV0IGJ5dGUgc3RyZWFtLiBBIHZhbGlkIExFUkMgZmlsZSBpcyBleHBlY3RlZCBhdCB0aGF0IHBvc2l0aW9uLlxuICAgICAqIEBjb25maWcge1VpbnQ4QXJyYXl9IFtlbmNvZGVkTWFzayA9IG51bGxdXG4gICAgICogICAgICAgIElmIHNwZWNpZmllZCwgdGhlIGRlY29kZXIgd2lsbCBub3QgcmVhZCBtYXNrIGluZm9ybWF0aW9uIGZyb20gdGhlIGlucHV0IGFuZCB1c2UgdGhlIHNwZWNpZmllZCBlbmNvZGVkXG4gICAgICogICAgICAgIG1hc2sgZGF0YSBpbnN0ZWFkLiBNYXNrIGhlYWRlci9kYXRhIG11c3Qgbm90IGJlIHByZXNlbnQgaW4gdGhlIExFUkMgYnl0ZSBzdHJlYW0gaW4gdGhpcyBjYXNlLlxuICAgICAqIEBjb25maWcge251bWJlcn0gW25vRGF0YVZhbHVlID0gTGVyY0NvZGUuZGVmYXVsdE5vRGF0YVZhbHVlXVxuICAgICAqICAgICAgICBQaXhlbCB2YWx1ZSB0byB1c2UgZm9yIG1hc2tlZCBwaXhlbHMuXG4gICAgICogQGNvbmZpZyB7QXJyYXlCdWZmZXJWaWV3fEFycmF5fSBbcGl4ZWxUeXBlID0gRmxvYXQzMkFycmF5XVxuICAgICAqICAgICAgICBUaGUgZGVzaXJlZCB0eXBlIG9mIHRoZSBwaXhlbERhdGEgYXJyYXkgaW4gdGhlIHJldHVybiB2YWx1ZS4gTm90ZSB0aGF0IGl0IGlzIHRoZSBjYWxsZXIncyByZXNwb25zaWJpbGl0eSB0b1xuICAgICAqICAgICAgICBwcm92aWRlIGFuIGFwcHJvcHJpYXRlIG5vRGF0YVZhbHVlIGlmIHRoZSBkZWZhdWx0IHBpeGVsVHlwZSBpcyBvdmVycmlkZGVuLlxuICAgICAqIEBjb25maWcge2Jvb2xlYW59IFtyZXR1cm5NYXNrID0gZmFsc2VdXG4gICAgICogICAgICAgIElmIHRydWUsIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBjb250YWluIGEgbWFza0RhdGEgcHJvcGVydHkgb2YgdHlwZSBVaW50OEFycmF5IHdoaWNoIGhhcyBvbmUgZWxlbWVudCBwZXJcbiAgICAgKiAgICAgICAgcGl4ZWwsIHRoZSB2YWx1ZSBvZiB3aGljaCBpcyAxIG9yIDAgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhhdCBwaXhlbCdzIGRhdGEgaXMgcHJlc2VudCBvciBtYXNrZWQuIElmIHRoZVxuICAgICAqICAgICAgICBpbnB1dCBMRVJDIGRhdGEgZG9lcyBub3QgY29udGFpbiBhIG1hc2ssIG1hc2tEYXRhIHdpbGwgbm90IGJlIHJldHVybmVkLlxuICAgICAqIEBjb25maWcge2Jvb2xlYW59IFtyZXR1cm5FbmNvZGVkTWFzayA9IGZhbHNlXVxuICAgICAqICAgICAgICBJZiB0cnVlLCB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgY29udGFpbiBhIGVuY29kZWRNYXNrRGF0YSBwcm9wZXJ0eSwgd2hpY2ggY2FuIGJlIHBhc3NlZCBpbnRvIGVuY29kZSgpIGFzXG4gICAgICogICAgICAgIGVuY29kZWRNYXNrLlxuICAgICAqIEBjb25maWcge2Jvb2xlYW59IFtyZXR1cm5GaWxlSW5mbyA9IGZhbHNlXVxuICAgICAqICAgICAgICBJZiB0cnVlLCB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgaGF2ZSBhIGZpbGVJbmZvIHByb3BlcnR5IHRoYXQgY29udGFpbnMgbWV0YWRhdGEgb2J0YWluZWQgZnJvbSB0aGVcbiAgICAgKiAgICAgICAgTEVSQyBoZWFkZXJzIGFuZCB0aGUgZGVjb2RpbmcgcHJvY2Vzcy5cbiAgICAgKiBAY29uZmlnIHtib29sZWFufSBbY29tcHV0ZVVzZWRCaXREZXB0aHMgPSBmYWxzZV1cbiAgICAgKiAgICAgICAgSWYgdHJ1ZSwgdGhlIGZpbGVJbmZvIHByb3BlcnR5IGluIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBjb250YWluIHRoZSBzZXQgb2YgYWxsIGJsb2NrIGJpdCBkZXB0aHNcbiAgICAgKiAgICAgICAgZW5jb3VudGVyZWQgZHVyaW5nIGRlY29kaW5nLiBXaWxsIG9ubHkgaGF2ZSBhbiBlZmZlY3QgaWYgcmV0dXJuRmlsZUluZm8gb3B0aW9uIGlzIHRydWUuXG4gICAgICogQHJldHVybnMge3t3aWR0aCwgaGVpZ2h0LCBwaXhlbERhdGEsIG1pblZhbHVlLCBtYXhWYWx1ZSwgbm9EYXRhVmFsdWUsIG1hc2tEYXRhLCBlbmNvZGVkTWFza0RhdGEsIGZpbGVJbmZvfX1cbiAgICAgKi9cbiAgICBDbnRaSW1hZ2UuZGVjb2RlID0gZnVuY3Rpb24oaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICB2YXIgc2tpcE1hc2sgPSBvcHRpb25zLmVuY29kZWRNYXNrRGF0YSB8fCAob3B0aW9ucy5lbmNvZGVkTWFza0RhdGEgPT09IG51bGwpO1xuICAgICAgdmFyIHBhcnNlZERhdGEgPSBwYXJzZShpbnB1dCwgb3B0aW9ucy5pbnB1dE9mZnNldCB8fCAwLCBza2lwTWFzayk7XG5cbiAgICAgIHZhciBub0RhdGFWYWx1ZSA9IChvcHRpb25zLm5vRGF0YVZhbHVlICE9PSBudWxsKSA/IG9wdGlvbnMubm9EYXRhVmFsdWUgOiBDbnRaSW1hZ2UuZGVmYXVsdE5vRGF0YVZhbHVlO1xuXG4gICAgICB2YXIgdW5jb21wcmVzc2VkRGF0YSA9IHVuY29tcHJlc3NQaXhlbFZhbHVlcyhwYXJzZWREYXRhLCBvcHRpb25zLnBpeGVsVHlwZSB8fCBGbG9hdDMyQXJyYXksXG4gICAgICAgIG9wdGlvbnMuZW5jb2RlZE1hc2tEYXRhLCBub0RhdGFWYWx1ZSwgb3B0aW9ucy5yZXR1cm5NYXNrKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgd2lkdGg6IHBhcnNlZERhdGEud2lkdGgsXG4gICAgICAgIGhlaWdodDogcGFyc2VkRGF0YS5oZWlnaHQsXG4gICAgICAgIHBpeGVsRGF0YTogdW5jb21wcmVzc2VkRGF0YS5yZXN1bHRQaXhlbHMsXG4gICAgICAgIG1pblZhbHVlOiB1bmNvbXByZXNzZWREYXRhLm1pblZhbHVlLFxuICAgICAgICBtYXhWYWx1ZTogcGFyc2VkRGF0YS5waXhlbHMubWF4VmFsdWUsXG4gICAgICAgIG5vRGF0YVZhbHVlOiBub0RhdGFWYWx1ZVxuICAgICAgfTtcblxuICAgICAgaWYgKHVuY29tcHJlc3NlZERhdGEucmVzdWx0TWFzaykge1xuICAgICAgICByZXN1bHQubWFza0RhdGEgPSB1bmNvbXByZXNzZWREYXRhLnJlc3VsdE1hc2s7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnJldHVybkVuY29kZWRNYXNrICYmIHBhcnNlZERhdGEubWFzaykge1xuICAgICAgICByZXN1bHQuZW5jb2RlZE1hc2tEYXRhID0gcGFyc2VkRGF0YS5tYXNrLmJpdHNldCA/IHBhcnNlZERhdGEubWFzay5iaXRzZXQgOiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5yZXR1cm5GaWxlSW5mbykge1xuICAgICAgICByZXN1bHQuZmlsZUluZm8gPSBmb3JtYXRGaWxlSW5mbyhwYXJzZWREYXRhKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuY29tcHV0ZVVzZWRCaXREZXB0aHMpIHtcbiAgICAgICAgICByZXN1bHQuZmlsZUluZm8uYml0RGVwdGhzID0gY29tcHV0ZVVzZWRCaXREZXB0aHMocGFyc2VkRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgdmFyIHVuY29tcHJlc3NQaXhlbFZhbHVlcyA9IGZ1bmN0aW9uKGRhdGEsIFR5cGVkQXJyYXlDbGFzcywgbWFza0JpdHNldCwgbm9EYXRhVmFsdWUsIHN0b3JlRGVjb2RlZE1hc2spIHtcbiAgICAgIHZhciBibG9ja0lkeCA9IDA7XG4gICAgICB2YXIgbnVtWCA9IGRhdGEucGl4ZWxzLm51bUJsb2Nrc1g7XG4gICAgICB2YXIgbnVtWSA9IGRhdGEucGl4ZWxzLm51bUJsb2Nrc1k7XG4gICAgICB2YXIgYmxvY2tXaWR0aCA9IE1hdGguZmxvb3IoZGF0YS53aWR0aCAvIG51bVgpO1xuICAgICAgdmFyIGJsb2NrSGVpZ2h0ID0gTWF0aC5mbG9vcihkYXRhLmhlaWdodCAvIG51bVkpO1xuICAgICAgdmFyIHNjYWxlID0gMiAqIGRhdGEubWF4WkVycm9yO1xuICAgICAgdmFyIG1pblZhbHVlID0gTnVtYmVyLk1BWF9WQUxVRSwgY3VycmVudFZhbHVlO1xuICAgICAgbWFza0JpdHNldCA9IG1hc2tCaXRzZXQgfHwgKChkYXRhLm1hc2spID8gZGF0YS5tYXNrLmJpdHNldCA6IG51bGwpO1xuXG4gICAgICB2YXIgcmVzdWx0UGl4ZWxzLCByZXN1bHRNYXNrO1xuICAgICAgcmVzdWx0UGl4ZWxzID0gbmV3IFR5cGVkQXJyYXlDbGFzcyhkYXRhLndpZHRoICogZGF0YS5oZWlnaHQpO1xuICAgICAgaWYgKHN0b3JlRGVjb2RlZE1hc2sgJiYgbWFza0JpdHNldCkge1xuICAgICAgICByZXN1bHRNYXNrID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS53aWR0aCAqIGRhdGEuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHZhciBibG9ja0RhdGFCdWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KGJsb2NrV2lkdGggKiBibG9ja0hlaWdodCk7XG5cbiAgICAgIHZhciB4eCwgeXk7XG4gICAgICBmb3IgKHZhciB5ID0gMDsgeSA8PSBudW1ZOyB5KyspIHtcbiAgICAgICAgdmFyIHRoaXNCbG9ja0hlaWdodCA9ICh5ICE9PSBudW1ZKSA/IGJsb2NrSGVpZ2h0IDogKGRhdGEuaGVpZ2h0ICUgbnVtWSk7XG4gICAgICAgIGlmICh0aGlzQmxvY2tIZWlnaHQgPT09IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8PSBudW1YOyB4KyspIHtcbiAgICAgICAgICB2YXIgdGhpc0Jsb2NrV2lkdGggPSAoeCAhPT0gbnVtWCkgPyBibG9ja1dpZHRoIDogKGRhdGEud2lkdGggJSBudW1YKTtcbiAgICAgICAgICBpZiAodGhpc0Jsb2NrV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBvdXRQdHIgPSB5ICogZGF0YS53aWR0aCAqIGJsb2NrSGVpZ2h0ICsgeCAqIGJsb2NrV2lkdGg7XG4gICAgICAgICAgdmFyIG91dFN0cmlkZSA9IGRhdGEud2lkdGggLSB0aGlzQmxvY2tXaWR0aDtcblxuICAgICAgICAgIHZhciBibG9jayA9IGRhdGEucGl4ZWxzLmJsb2Nrc1tibG9ja0lkeF07XG5cbiAgICAgICAgICB2YXIgYmxvY2tEYXRhLCBibG9ja1B0ciwgY29uc3RWYWx1ZTtcbiAgICAgICAgICBpZiAoYmxvY2suZW5jb2RpbmcgPCAyKSB7XG4gICAgICAgICAgICAvLyBibG9jayBpcyBlaXRoZXIgdW5jb21wcmVzc2VkIG9yIGJpdC1zdHVmZmVkIChlbmNvZGluZ3MgMCBhbmQgMSlcbiAgICAgICAgICAgIGlmIChibG9jay5lbmNvZGluZyA9PT0gMCkge1xuICAgICAgICAgICAgICAvLyBibG9jayBpcyB1bmNvbXByZXNzZWRcbiAgICAgICAgICAgICAgYmxvY2tEYXRhID0gYmxvY2sucmF3RGF0YTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGJsb2NrIGlzIGJpdC1zdHVmZmVkXG4gICAgICAgICAgICAgIHVuc3R1ZmYoYmxvY2suc3R1ZmZlZERhdGEsIGJsb2NrLmJpdHNQZXJQaXhlbCwgYmxvY2subnVtVmFsaWRQaXhlbHMsIGJsb2NrLm9mZnNldCwgc2NhbGUsIGJsb2NrRGF0YUJ1ZmZlciwgZGF0YS5waXhlbHMubWF4VmFsdWUpO1xuICAgICAgICAgICAgICBibG9ja0RhdGEgPSBibG9ja0RhdGFCdWZmZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBibG9ja1B0ciA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGJsb2NrLmVuY29kaW5nID09PSAyKSB7XG4gICAgICAgICAgICAvLyBibG9jayBpcyBhbGwgMFxuICAgICAgICAgICAgY29uc3RWYWx1ZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gYmxvY2sgaGFzIGNvbnN0YW50IHZhbHVlIChlbmNvZGluZyA9PT0gMylcbiAgICAgICAgICAgIGNvbnN0VmFsdWUgPSBibG9jay5vZmZzZXQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG1hc2tCeXRlO1xuICAgICAgICAgIGlmIChtYXNrQml0c2V0KSB7XG4gICAgICAgICAgICBmb3IgKHl5ID0gMDsgeXkgPCB0aGlzQmxvY2tIZWlnaHQ7IHl5KyspIHtcbiAgICAgICAgICAgICAgaWYgKG91dFB0ciAmIDcpIHtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIG1hc2tCeXRlID0gbWFza0JpdHNldFtvdXRQdHIgPj4gM107XG4gICAgICAgICAgICAgICAgbWFza0J5dGUgPDw9IG91dFB0ciAmIDc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yICh4eCA9IDA7IHh4IDwgdGhpc0Jsb2NrV2lkdGg7IHh4KyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIShvdXRQdHIgJiA3KSkge1xuICAgICAgICAgICAgICAgICAgLy8gcmVhZCBuZXh0IGJ5dGUgZnJvbSBtYXNrXG4gICAgICAgICAgICAgICAgICBtYXNrQnl0ZSA9IG1hc2tCaXRzZXRbb3V0UHRyID4+IDNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWFza0J5dGUgJiAxMjgpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHBpeGVsIGRhdGEgcHJlc2VudFxuICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdE1hc2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0TWFza1tvdXRQdHJdID0gMTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IChibG9jay5lbmNvZGluZyA8IDIpID8gYmxvY2tEYXRhW2Jsb2NrUHRyKytdIDogY29uc3RWYWx1ZTtcbiAgICAgICAgICAgICAgICAgIG1pblZhbHVlID0gbWluVmFsdWUgPiBjdXJyZW50VmFsdWUgPyBjdXJyZW50VmFsdWUgOiBtaW5WYWx1ZTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1tvdXRQdHIrK10gPSBjdXJyZW50VmFsdWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIHBpeGVsIGRhdGEgbm90IHByZXNlbnRcbiAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRNYXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdE1hc2tbb3V0UHRyXSA9IDA7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXN1bHRQaXhlbHNbb3V0UHRyKytdID0gbm9EYXRhVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hc2tCeXRlIDw8PSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG91dFB0ciArPSBvdXRTdHJpZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG1hc2sgbm90IHByZXNlbnQsIHNpbXBseSBjb3B5IGJsb2NrIG92ZXJcbiAgICAgICAgICAgIGlmIChibG9jay5lbmNvZGluZyA8IDIpIHtcbiAgICAgICAgICAgICAgLy8gZHVwbGljYXRpbmcgdGhpcyBjb2RlIGJsb2NrIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG4gICAgICAgICAgICAgIC8vIGJsb2NrRGF0YSBjYXNlOlxuICAgICAgICAgICAgICBmb3IgKHl5ID0gMDsgeXkgPCB0aGlzQmxvY2tIZWlnaHQ7IHl5KyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHh4ID0gMDsgeHggPCB0aGlzQmxvY2tXaWR0aDsgeHgrKykge1xuICAgICAgICAgICAgICAgICAgY3VycmVudFZhbHVlID0gYmxvY2tEYXRhW2Jsb2NrUHRyKytdO1xuICAgICAgICAgICAgICAgICAgbWluVmFsdWUgPSBtaW5WYWx1ZSA+IGN1cnJlbnRWYWx1ZSA/IGN1cnJlbnRWYWx1ZSA6IG1pblZhbHVlO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzW291dFB0cisrXSA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0UHRyICs9IG91dFN0cmlkZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGNvbnN0VmFsdWUgY2FzZTpcbiAgICAgICAgICAgICAgbWluVmFsdWUgPSBtaW5WYWx1ZSA+IGNvbnN0VmFsdWUgPyBjb25zdFZhbHVlIDogbWluVmFsdWU7XG4gICAgICAgICAgICAgIGZvciAoeXkgPSAwOyB5eSA8IHRoaXNCbG9ja0hlaWdodDsgeXkrKykge1xuICAgICAgICAgICAgICAgIGZvciAoeHggPSAwOyB4eCA8IHRoaXNCbG9ja1dpZHRoOyB4eCsrKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHRQaXhlbHNbb3V0UHRyKytdID0gY29uc3RWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0UHRyICs9IG91dFN0cmlkZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKGJsb2NrLmVuY29kaW5nID09PSAxKSAmJiAoYmxvY2tQdHIgIT09IGJsb2NrLm51bVZhbGlkUGl4ZWxzKSkge1xuICAgICAgICAgICAgdGhyb3cgXCJCbG9jayBhbmQgTWFzayBkbyBub3QgbWF0Y2hcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYmxvY2tJZHgrKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHRQaXhlbHM6IHJlc3VsdFBpeGVscyxcbiAgICAgICAgcmVzdWx0TWFzazogcmVzdWx0TWFzayxcbiAgICAgICAgbWluVmFsdWU6IG1pblZhbHVlXG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgZm9ybWF0RmlsZUluZm8gPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBcImZpbGVJZGVudGlmaWVyU3RyaW5nXCI6IGRhdGEuZmlsZUlkZW50aWZpZXJTdHJpbmcsXG4gICAgICAgIFwiZmlsZVZlcnNpb25cIjogZGF0YS5maWxlVmVyc2lvbixcbiAgICAgICAgXCJpbWFnZVR5cGVcIjogZGF0YS5pbWFnZVR5cGUsXG4gICAgICAgIFwiaGVpZ2h0XCI6IGRhdGEuaGVpZ2h0LFxuICAgICAgICBcIndpZHRoXCI6IGRhdGEud2lkdGgsXG4gICAgICAgIFwibWF4WkVycm9yXCI6IGRhdGEubWF4WkVycm9yLFxuICAgICAgICBcImVvZk9mZnNldFwiOiBkYXRhLmVvZk9mZnNldCxcbiAgICAgICAgXCJtYXNrXCI6IGRhdGEubWFzayA/IHtcbiAgICAgICAgICBcIm51bUJsb2Nrc1hcIjogZGF0YS5tYXNrLm51bUJsb2Nrc1gsXG4gICAgICAgICAgXCJudW1CbG9ja3NZXCI6IGRhdGEubWFzay5udW1CbG9ja3NZLFxuICAgICAgICAgIFwibnVtQnl0ZXNcIjogZGF0YS5tYXNrLm51bUJ5dGVzLFxuICAgICAgICAgIFwibWF4VmFsdWVcIjogZGF0YS5tYXNrLm1heFZhbHVlXG4gICAgICAgIH0gOiBudWxsLFxuICAgICAgICBcInBpeGVsc1wiOiB7XG4gICAgICAgICAgXCJudW1CbG9ja3NYXCI6IGRhdGEucGl4ZWxzLm51bUJsb2Nrc1gsXG4gICAgICAgICAgXCJudW1CbG9ja3NZXCI6IGRhdGEucGl4ZWxzLm51bUJsb2Nrc1ksXG4gICAgICAgICAgXCJudW1CeXRlc1wiOiBkYXRhLnBpeGVscy5udW1CeXRlcyxcbiAgICAgICAgICBcIm1heFZhbHVlXCI6IGRhdGEucGl4ZWxzLm1heFZhbHVlLFxuICAgICAgICAgIFwibm9EYXRhVmFsdWVcIjogZGF0YS5ub0RhdGFWYWx1ZVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY29tcHV0ZVVzZWRCaXREZXB0aHMgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgbnVtQmxvY2tzID0gZGF0YS5waXhlbHMubnVtQmxvY2tzWCAqIGRhdGEucGl4ZWxzLm51bUJsb2Nrc1k7XG4gICAgICB2YXIgYml0RGVwdGhzID0ge307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUJsb2NrczsgaSsrKSB7XG4gICAgICAgIHZhciBibG9jayA9IGRhdGEucGl4ZWxzLmJsb2Nrc1tpXTtcbiAgICAgICAgaWYgKGJsb2NrLmVuY29kaW5nID09PSAwKSB7XG4gICAgICAgICAgYml0RGVwdGhzLmZsb2F0MzIgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGJsb2NrLmVuY29kaW5nID09PSAxKSB7XG4gICAgICAgICAgYml0RGVwdGhzW2Jsb2NrLmJpdHNQZXJQaXhlbF0gPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJpdERlcHRoc1swXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGJpdERlcHRocyk7XG4gICAgfTtcblxuICAgIHZhciBwYXJzZSA9IGZ1bmN0aW9uKGlucHV0LCBmcCwgc2tpcE1hc2spIHtcbiAgICAgIHZhciBkYXRhID0ge307XG5cbiAgICAgIC8vIEZpbGUgaGVhZGVyXG4gICAgICB2YXIgZmlsZUlkVmlldyA9IG5ldyBVaW50OEFycmF5KGlucHV0LCBmcCwgMTApO1xuICAgICAgZGF0YS5maWxlSWRlbnRpZmllclN0cmluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgZmlsZUlkVmlldyk7XG4gICAgICBpZiAoZGF0YS5maWxlSWRlbnRpZmllclN0cmluZy50cmltKCkgIT09IFwiQ250WkltYWdlXCIpIHtcbiAgICAgICAgdGhyb3cgXCJVbmV4cGVjdGVkIGZpbGUgaWRlbnRpZmllciBzdHJpbmc6IFwiICsgZGF0YS5maWxlSWRlbnRpZmllclN0cmluZztcbiAgICAgIH1cbiAgICAgIGZwICs9IDEwO1xuICAgICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcoaW5wdXQsIGZwLCAyNCk7XG4gICAgICBkYXRhLmZpbGVWZXJzaW9uID0gdmlldy5nZXRJbnQzMigwLCB0cnVlKTtcbiAgICAgIGRhdGEuaW1hZ2VUeXBlID0gdmlldy5nZXRJbnQzMig0LCB0cnVlKTtcbiAgICAgIGRhdGEuaGVpZ2h0ID0gdmlldy5nZXRVaW50MzIoOCwgdHJ1ZSk7XG4gICAgICBkYXRhLndpZHRoID0gdmlldy5nZXRVaW50MzIoMTIsIHRydWUpO1xuICAgICAgZGF0YS5tYXhaRXJyb3IgPSB2aWV3LmdldEZsb2F0NjQoMTYsIHRydWUpO1xuICAgICAgZnAgKz0gMjQ7XG5cbiAgICAgIC8vIE1hc2sgSGVhZGVyXG4gICAgICBpZiAoIXNraXBNYXNrKSB7XG4gICAgICAgIHZpZXcgPSBuZXcgRGF0YVZpZXcoaW5wdXQsIGZwLCAxNik7XG4gICAgICAgIGRhdGEubWFzayA9IHt9O1xuICAgICAgICBkYXRhLm1hc2subnVtQmxvY2tzWSA9IHZpZXcuZ2V0VWludDMyKDAsIHRydWUpO1xuICAgICAgICBkYXRhLm1hc2subnVtQmxvY2tzWCA9IHZpZXcuZ2V0VWludDMyKDQsIHRydWUpO1xuICAgICAgICBkYXRhLm1hc2subnVtQnl0ZXMgPSB2aWV3LmdldFVpbnQzMig4LCB0cnVlKTtcbiAgICAgICAgZGF0YS5tYXNrLm1heFZhbHVlID0gdmlldy5nZXRGbG9hdDMyKDEyLCB0cnVlKTtcbiAgICAgICAgZnAgKz0gMTY7XG5cbiAgICAgICAgLy8gTWFzayBEYXRhXG4gICAgICAgIGlmIChkYXRhLm1hc2subnVtQnl0ZXMgPiAwKSB7XG4gICAgICAgICAgdmFyIGJpdHNldCA9IG5ldyBVaW50OEFycmF5KE1hdGguY2VpbChkYXRhLndpZHRoICogZGF0YS5oZWlnaHQgLyA4KSk7XG4gICAgICAgICAgdmlldyA9IG5ldyBEYXRhVmlldyhpbnB1dCwgZnAsIGRhdGEubWFzay5udW1CeXRlcyk7XG4gICAgICAgICAgdmFyIGNudCA9IHZpZXcuZ2V0SW50MTYoMCwgdHJ1ZSk7XG4gICAgICAgICAgdmFyIGlwID0gMiwgb3AgPSAwO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChjbnQgPiAwKSB7XG4gICAgICAgICAgICAgIHdoaWxlIChjbnQtLSkgeyBiaXRzZXRbb3ArK10gPSB2aWV3LmdldFVpbnQ4KGlwKyspOyB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgdmFsID0gdmlldy5nZXRVaW50OChpcCsrKTtcbiAgICAgICAgICAgICAgY250ID0gLWNudDtcbiAgICAgICAgICAgICAgd2hpbGUgKGNudC0tKSB7IGJpdHNldFtvcCsrXSA9IHZhbDsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY250ID0gdmlldy5nZXRJbnQxNihpcCwgdHJ1ZSk7XG4gICAgICAgICAgICBpcCArPSAyO1xuICAgICAgICAgIH0gd2hpbGUgKGlwIDwgZGF0YS5tYXNrLm51bUJ5dGVzKTtcbiAgICAgICAgICBpZiAoKGNudCAhPT0gLTMyNzY4KSB8fCAob3AgPCBiaXRzZXQubGVuZ3RoKSkge1xuICAgICAgICAgICAgdGhyb3cgXCJVbmV4cGVjdGVkIGVuZCBvZiBtYXNrIFJMRSBlbmNvZGluZ1wiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhLm1hc2suYml0c2V0ID0gYml0c2V0O1xuICAgICAgICAgIGZwICs9IGRhdGEubWFzay5udW1CeXRlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoZGF0YS5tYXNrLm51bUJ5dGVzIHwgZGF0YS5tYXNrLm51bUJsb2Nrc1kgfCBkYXRhLm1hc2subWF4VmFsdWUpID09PSAwKSB7ICAvLyBTcGVjaWFsIGNhc2UsIGFsbCBub2RhdGFcbiAgICAgICAgICBkYXRhLm1hc2suYml0c2V0ID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKGRhdGEud2lkdGggKiBkYXRhLmhlaWdodCAvIDgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBQaXhlbCBIZWFkZXJcbiAgICAgIHZpZXcgPSBuZXcgRGF0YVZpZXcoaW5wdXQsIGZwLCAxNik7XG4gICAgICBkYXRhLnBpeGVscyA9IHt9O1xuICAgICAgZGF0YS5waXhlbHMubnVtQmxvY2tzWSA9IHZpZXcuZ2V0VWludDMyKDAsIHRydWUpO1xuICAgICAgZGF0YS5waXhlbHMubnVtQmxvY2tzWCA9IHZpZXcuZ2V0VWludDMyKDQsIHRydWUpO1xuICAgICAgZGF0YS5waXhlbHMubnVtQnl0ZXMgPSB2aWV3LmdldFVpbnQzMig4LCB0cnVlKTtcbiAgICAgIGRhdGEucGl4ZWxzLm1heFZhbHVlID0gdmlldy5nZXRGbG9hdDMyKDEyLCB0cnVlKTtcbiAgICAgIGZwICs9IDE2O1xuXG4gICAgICB2YXIgbnVtQmxvY2tzWCA9IGRhdGEucGl4ZWxzLm51bUJsb2Nrc1g7XG4gICAgICB2YXIgbnVtQmxvY2tzWSA9IGRhdGEucGl4ZWxzLm51bUJsb2Nrc1k7XG4gICAgICAvLyB0aGUgbnVtYmVyIG9mIGJsb2NrcyBzcGVjaWZpZWQgaW4gdGhlIGhlYWRlciBkb2VzIG5vdCB0YWtlIGludG8gYWNjb3VudCB0aGUgYmxvY2tzIGF0IHRoZSBlbmQgb2ZcbiAgICAgIC8vIGVhY2ggcm93L2NvbHVtbiB3aXRoIGEgc3BlY2lhbCB3aWR0aC9oZWlnaHQgdGhhdCBtYWtlIHRoZSBpbWFnZSBjb21wbGV0ZSBpbiBjYXNlIHRoZSB3aWR0aCBpcyBub3RcbiAgICAgIC8vIGV2ZW5seSBkaXZpc2libGUgYnkgdGhlIG51bWJlciBvZiBibG9ja3MuXG4gICAgICB2YXIgYWN0dWFsTnVtQmxvY2tzWCA9IG51bUJsb2Nrc1ggKyAoKGRhdGEud2lkdGggJSBudW1CbG9ja3NYKSA+IDAgPyAxIDogMCk7XG4gICAgICB2YXIgYWN0dWFsTnVtQmxvY2tzWSA9IG51bUJsb2Nrc1kgKyAoKGRhdGEuaGVpZ2h0ICUgbnVtQmxvY2tzWSkgPiAwID8gMSA6IDApO1xuICAgICAgZGF0YS5waXhlbHMuYmxvY2tzID0gbmV3IEFycmF5KGFjdHVhbE51bUJsb2Nrc1ggKiBhY3R1YWxOdW1CbG9ja3NZKTtcbiAgICAgIHZhciBibG9ja0kgPSAwO1xuICAgICAgZm9yICh2YXIgYmxvY2tZID0gMDsgYmxvY2tZIDwgYWN0dWFsTnVtQmxvY2tzWTsgYmxvY2tZKyspIHtcbiAgICAgICAgZm9yICh2YXIgYmxvY2tYID0gMDsgYmxvY2tYIDwgYWN0dWFsTnVtQmxvY2tzWDsgYmxvY2tYKyspIHtcblxuICAgICAgICAgIC8vIEJsb2NrXG4gICAgICAgICAgdmFyIHNpemUgPSAwO1xuICAgICAgICAgIHZhciBieXRlc0xlZnQgPSBpbnB1dC5ieXRlTGVuZ3RoIC0gZnA7XG4gICAgICAgICAgdmlldyA9IG5ldyBEYXRhVmlldyhpbnB1dCwgZnAsIE1hdGgubWluKDEwLCBieXRlc0xlZnQpKTtcbiAgICAgICAgICB2YXIgYmxvY2sgPSB7fTtcbiAgICAgICAgICBkYXRhLnBpeGVscy5ibG9ja3NbYmxvY2tJKytdID0gYmxvY2s7XG4gICAgICAgICAgdmFyIGhlYWRlckJ5dGUgPSB2aWV3LmdldFVpbnQ4KDApOyBzaXplKys7XG4gICAgICAgICAgYmxvY2suZW5jb2RpbmcgPSBoZWFkZXJCeXRlICYgNjM7XG4gICAgICAgICAgaWYgKGJsb2NrLmVuY29kaW5nID4gMykge1xuICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIGJsb2NrIGVuY29kaW5nIChcIiArIGJsb2NrLmVuY29kaW5nICsgXCIpXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChibG9jay5lbmNvZGluZyA9PT0gMikge1xuICAgICAgICAgICAgZnArKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKGhlYWRlckJ5dGUgIT09IDApICYmIChoZWFkZXJCeXRlICE9PSAyKSkge1xuICAgICAgICAgICAgaGVhZGVyQnl0ZSA+Pj0gNjtcbiAgICAgICAgICAgIGJsb2NrLm9mZnNldFR5cGUgPSBoZWFkZXJCeXRlO1xuICAgICAgICAgICAgaWYgKGhlYWRlckJ5dGUgPT09IDIpIHtcbiAgICAgICAgICAgICAgYmxvY2sub2Zmc2V0ID0gdmlldy5nZXRJbnQ4KDEpOyBzaXplKys7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhlYWRlckJ5dGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgYmxvY2sub2Zmc2V0ID0gdmlldy5nZXRJbnQxNigxLCB0cnVlKTsgc2l6ZSArPSAyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChoZWFkZXJCeXRlID09PSAwKSB7XG4gICAgICAgICAgICAgIGJsb2NrLm9mZnNldCA9IHZpZXcuZ2V0RmxvYXQzMigxLCB0cnVlKTsgc2l6ZSArPSA0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIGJsb2NrIG9mZnNldCB0eXBlXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChibG9jay5lbmNvZGluZyA9PT0gMSkge1xuICAgICAgICAgICAgICBoZWFkZXJCeXRlID0gdmlldy5nZXRVaW50OChzaXplKTsgc2l6ZSsrO1xuICAgICAgICAgICAgICBibG9jay5iaXRzUGVyUGl4ZWwgPSBoZWFkZXJCeXRlICYgNjM7XG4gICAgICAgICAgICAgIGhlYWRlckJ5dGUgPj49IDY7XG4gICAgICAgICAgICAgIGJsb2NrLm51bVZhbGlkUGl4ZWxzVHlwZSA9IGhlYWRlckJ5dGU7XG4gICAgICAgICAgICAgIGlmIChoZWFkZXJCeXRlID09PSAyKSB7XG4gICAgICAgICAgICAgICAgYmxvY2subnVtVmFsaWRQaXhlbHMgPSB2aWV3LmdldFVpbnQ4KHNpemUpOyBzaXplKys7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGVhZGVyQnl0ZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGJsb2NrLm51bVZhbGlkUGl4ZWxzID0gdmlldy5nZXRVaW50MTYoc2l6ZSwgdHJ1ZSk7IHNpemUgKz0gMjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChoZWFkZXJCeXRlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYmxvY2subnVtVmFsaWRQaXhlbHMgPSB2aWV3LmdldFVpbnQzMihzaXplLCB0cnVlKTsgc2l6ZSArPSA0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IFwiSW52YWxpZCB2YWxpZCBwaXhlbCBjb3VudCB0eXBlXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZnAgKz0gc2l6ZTtcblxuICAgICAgICAgIGlmIChibG9jay5lbmNvZGluZyA9PT0gMykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGFycmF5QnVmLCBzdG9yZTg7XG4gICAgICAgICAgaWYgKGJsb2NrLmVuY29kaW5nID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgbnVtUGl4ZWxzID0gKGRhdGEucGl4ZWxzLm51bUJ5dGVzIC0gMSkgLyA0O1xuICAgICAgICAgICAgaWYgKG51bVBpeGVscyAhPT0gTWF0aC5mbG9vcihudW1QaXhlbHMpKSB7XG4gICAgICAgICAgICAgIHRocm93IFwidW5jb21wcmVzc2VkIGJsb2NrIGhhcyBpbnZhbGlkIGxlbmd0aFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJyYXlCdWYgPSBuZXcgQXJyYXlCdWZmZXIobnVtUGl4ZWxzICogNCk7XG4gICAgICAgICAgICBzdG9yZTggPSBuZXcgVWludDhBcnJheShhcnJheUJ1Zik7XG4gICAgICAgICAgICBzdG9yZTguc2V0KG5ldyBVaW50OEFycmF5KGlucHV0LCBmcCwgbnVtUGl4ZWxzICogNCkpO1xuICAgICAgICAgICAgdmFyIHJhd0RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGFycmF5QnVmKTtcbiAgICAgICAgICAgIGJsb2NrLnJhd0RhdGEgPSByYXdEYXRhO1xuICAgICAgICAgICAgZnAgKz0gbnVtUGl4ZWxzICogNDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGJsb2NrLmVuY29kaW5nID09PSAxKSB7XG4gICAgICAgICAgICB2YXIgZGF0YUJ5dGVzID0gTWF0aC5jZWlsKGJsb2NrLm51bVZhbGlkUGl4ZWxzICogYmxvY2suYml0c1BlclBpeGVsIC8gOCk7XG4gICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gTWF0aC5jZWlsKGRhdGFCeXRlcyAvIDQpO1xuICAgICAgICAgICAgYXJyYXlCdWYgPSBuZXcgQXJyYXlCdWZmZXIoZGF0YVdvcmRzICogNCk7XG4gICAgICAgICAgICBzdG9yZTggPSBuZXcgVWludDhBcnJheShhcnJheUJ1Zik7XG4gICAgICAgICAgICBzdG9yZTguc2V0KG5ldyBVaW50OEFycmF5KGlucHV0LCBmcCwgZGF0YUJ5dGVzKSk7XG4gICAgICAgICAgICBibG9jay5zdHVmZmVkRGF0YSA9IG5ldyBVaW50MzJBcnJheShhcnJheUJ1Zik7XG4gICAgICAgICAgICBmcCArPSBkYXRhQnl0ZXM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkYXRhLmVvZk9mZnNldCA9IGZwO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcblxuICAgIHZhciB1bnN0dWZmID0gZnVuY3Rpb24oc3JjLCBiaXRzUGVyUGl4ZWwsIG51bVBpeGVscywgb2Zmc2V0LCBzY2FsZSwgZGVzdCwgbWF4VmFsdWUpIHtcbiAgICAgIHZhciBiaXRNYXNrID0gKDEgPDwgYml0c1BlclBpeGVsKSAtIDE7XG4gICAgICB2YXIgaSA9IDAsIG87XG4gICAgICB2YXIgYml0c0xlZnQgPSAwO1xuICAgICAgdmFyIG4sIGJ1ZmZlcjtcbiAgICAgIHZhciBubWF4ID0gTWF0aC5jZWlsKChtYXhWYWx1ZSAtIG9mZnNldCkgLyBzY2FsZSk7XG4gICAgICAvLyBnZXQgcmlkIG9mIHRyYWlsaW5nIGJ5dGVzIHRoYXQgYXJlIGFscmVhZHkgcGFydCBvZiBuZXh0IGJsb2NrXG4gICAgICB2YXIgbnVtSW52YWxpZFRhaWxCeXRlcyA9IHNyYy5sZW5ndGggKiA0IC0gTWF0aC5jZWlsKGJpdHNQZXJQaXhlbCAqIG51bVBpeGVscyAvIDgpO1xuICAgICAgc3JjW3NyYy5sZW5ndGggLSAxXSA8PD0gOCAqIG51bUludmFsaWRUYWlsQnl0ZXM7XG5cbiAgICAgIGZvciAobyA9IDA7IG8gPCBudW1QaXhlbHM7IG8rKykge1xuICAgICAgICBpZiAoYml0c0xlZnQgPT09IDApIHtcbiAgICAgICAgICBidWZmZXIgPSBzcmNbaSsrXTtcbiAgICAgICAgICBiaXRzTGVmdCA9IDMyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiaXRzTGVmdCA+PSBiaXRzUGVyUGl4ZWwpIHtcbiAgICAgICAgICBuID0gKGJ1ZmZlciA+Pj4gKGJpdHNMZWZ0IC0gYml0c1BlclBpeGVsKSkgJiBiaXRNYXNrO1xuICAgICAgICAgIGJpdHNMZWZ0IC09IGJpdHNQZXJQaXhlbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbWlzc2luZ0JpdHMgPSAoYml0c1BlclBpeGVsIC0gYml0c0xlZnQpO1xuICAgICAgICAgIG4gPSAoKGJ1ZmZlciAmIGJpdE1hc2spIDw8IG1pc3NpbmdCaXRzKSAmIGJpdE1hc2s7XG4gICAgICAgICAgYnVmZmVyID0gc3JjW2krK107XG4gICAgICAgICAgYml0c0xlZnQgPSAzMiAtIG1pc3NpbmdCaXRzO1xuICAgICAgICAgIG4gKz0gKGJ1ZmZlciA+Pj4gYml0c0xlZnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vcGl4ZWwgdmFsdWVzIG1heSBleGNlZWQgbWF4IGR1ZSB0byBxdWFudGl6YXRpb25cbiAgICAgICAgZGVzdFtvXSA9IG4gPCBubWF4ID8gb2Zmc2V0ICsgbiAqIHNjYWxlIDogbWF4VmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVzdDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENudFpJbWFnZTtcbiAgfSkoKTtcblxuICAvL3ZlcnNpb24gMi4gU3VwcG9ydHMgMi4xLCAyLjIsIDIuM1xuICB2YXIgTGVyYzJEZWNvZGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgLy8gTm90ZTogY3VycmVudGx5LCB0aGlzIG1vZHVsZSBvbmx5IGhhcyBhbiBpbXBsZW1lbnRhdGlvbiBmb3IgZGVjb2RpbmcgTEVSQyBkYXRhLCBub3QgZW5jb2RpbmcuIFRoZSBuYW1lIG9mXG4gICAgLy8gdGhlIGNsYXNzIHdhcyBjaG9zZW4gdG8gYmUgZnV0dXJlIHByb29mLCBmb2xsb3dpbmcgTGVyY0RlY29kZS5cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICogcHJpdmF0ZSBzdGF0aWMgY2xhc3MgYml0c3V0ZmZlciB1c2VkIGJ5IExlcmMyRGVjb2RlXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICB2YXIgQml0U3R1ZmZlciA9IHtcbiAgICAgIC8vbWV0aG9kcyBlbmRpbmcgd2l0aCAyIGFyZSBmb3IgdGhlIG5ldyBieXRlIG9yZGVyIHVzZWQgYnkgTGVyYzIuMyBhbmQgYWJvdmUuXG4gICAgICAvL29yaWdpbmFsVW5zdHVmZiBpcyB1c2VkIHRvIHVucGFjayBIdWZmbWFuIGNvZGUgdGFibGUuIGNvZGUgaXMgZHVwbGljYXRlZCB0byB1bnN0dWZmeCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy5cbiAgICAgIHVuc3R1ZmY6IGZ1bmN0aW9uKHNyYywgZGVzdCwgYml0c1BlclBpeGVsLCBudW1QaXhlbHMsIGx1dEFyciwgb2Zmc2V0LCBzY2FsZSwgbWF4VmFsdWUpIHtcbiAgICAgICAgdmFyIGJpdE1hc2sgPSAoMSA8PCBiaXRzUGVyUGl4ZWwpIC0gMTtcbiAgICAgICAgdmFyIGkgPSAwLCBvO1xuICAgICAgICB2YXIgYml0c0xlZnQgPSAwO1xuICAgICAgICB2YXIgbiwgYnVmZmVyLCBtaXNzaW5nQml0cywgbm1heDtcblxuICAgICAgICAvLyBnZXQgcmlkIG9mIHRyYWlsaW5nIGJ5dGVzIHRoYXQgYXJlIGFscmVhZHkgcGFydCBvZiBuZXh0IGJsb2NrXG4gICAgICAgIHZhciBudW1JbnZhbGlkVGFpbEJ5dGVzID0gc3JjLmxlbmd0aCAqIDQgLSBNYXRoLmNlaWwoYml0c1BlclBpeGVsICogbnVtUGl4ZWxzIC8gOCk7XG4gICAgICAgIHNyY1tzcmMubGVuZ3RoIC0gMV0gPDw9IDggKiBudW1JbnZhbGlkVGFpbEJ5dGVzO1xuICAgICAgICBpZiAobHV0QXJyKSB7XG4gICAgICAgICAgZm9yIChvID0gMDsgbyA8IG51bVBpeGVsczsgbysrKSB7XG4gICAgICAgICAgICBpZiAoYml0c0xlZnQgPT09IDApIHtcbiAgICAgICAgICAgICAgYnVmZmVyID0gc3JjW2krK107XG4gICAgICAgICAgICAgIGJpdHNMZWZ0ID0gMzI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYml0c0xlZnQgPj0gYml0c1BlclBpeGVsKSB7XG4gICAgICAgICAgICAgIG4gPSAoYnVmZmVyID4+PiAoYml0c0xlZnQgLSBiaXRzUGVyUGl4ZWwpKSAmIGJpdE1hc2s7XG4gICAgICAgICAgICAgIGJpdHNMZWZ0IC09IGJpdHNQZXJQaXhlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBtaXNzaW5nQml0cyA9IChiaXRzUGVyUGl4ZWwgLSBiaXRzTGVmdCk7XG4gICAgICAgICAgICAgIG4gPSAoKGJ1ZmZlciAmIGJpdE1hc2spIDw8IG1pc3NpbmdCaXRzKSAmIGJpdE1hc2s7XG4gICAgICAgICAgICAgIGJ1ZmZlciA9IHNyY1tpKytdO1xuICAgICAgICAgICAgICBiaXRzTGVmdCA9IDMyIC0gbWlzc2luZ0JpdHM7XG4gICAgICAgICAgICAgIG4gKz0gKGJ1ZmZlciA+Pj4gYml0c0xlZnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVzdFtvXSA9IGx1dEFycltuXTsvL29mZnNldCArIGx1dEFycltuXSAqIHNjYWxlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBubWF4ID0gTWF0aC5jZWlsKChtYXhWYWx1ZSAtIG9mZnNldCkgLyBzY2FsZSk7XG4gICAgICAgICAgZm9yIChvID0gMDsgbyA8IG51bVBpeGVsczsgbysrKSB7XG4gICAgICAgICAgICBpZiAoYml0c0xlZnQgPT09IDApIHtcbiAgICAgICAgICAgICAgYnVmZmVyID0gc3JjW2krK107XG4gICAgICAgICAgICAgIGJpdHNMZWZ0ID0gMzI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYml0c0xlZnQgPj0gYml0c1BlclBpeGVsKSB7XG4gICAgICAgICAgICAgIG4gPSAoYnVmZmVyID4+PiAoYml0c0xlZnQgLSBiaXRzUGVyUGl4ZWwpKSAmIGJpdE1hc2s7XG4gICAgICAgICAgICAgIGJpdHNMZWZ0IC09IGJpdHNQZXJQaXhlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBtaXNzaW5nQml0cyA9IChiaXRzUGVyUGl4ZWwgLSBiaXRzTGVmdCk7XG4gICAgICAgICAgICAgIG4gPSAoKGJ1ZmZlciAmIGJpdE1hc2spIDw8IG1pc3NpbmdCaXRzKSAmIGJpdE1hc2s7XG4gICAgICAgICAgICAgIGJ1ZmZlciA9IHNyY1tpKytdO1xuICAgICAgICAgICAgICBiaXRzTGVmdCA9IDMyIC0gbWlzc2luZ0JpdHM7XG4gICAgICAgICAgICAgIG4gKz0gKGJ1ZmZlciA+Pj4gYml0c0xlZnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9waXhlbCB2YWx1ZXMgbWF5IGV4Y2VlZCBtYXggZHVlIHRvIHF1YW50aXphdGlvblxuICAgICAgICAgICAgZGVzdFtvXSA9IG4gPCBubWF4ID8gb2Zmc2V0ICsgbiAqIHNjYWxlIDogbWF4VmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB1bnN0dWZmTFVUOiBmdW5jdGlvbihzcmMsIGJpdHNQZXJQaXhlbCwgbnVtUGl4ZWxzLCBvZmZzZXQsIHNjYWxlLCBtYXhWYWx1ZSkge1xuICAgICAgICB2YXIgYml0TWFzayA9ICgxIDw8IGJpdHNQZXJQaXhlbCkgLSAxO1xuICAgICAgICB2YXIgaSA9IDAsIG8gPSAwLCBtaXNzaW5nQml0cyA9IDAsIGJpdHNMZWZ0ID0gMCwgbiA9IDA7XG4gICAgICAgIHZhciBidWZmZXI7XG4gICAgICAgIHZhciBkZXN0ID0gW107XG5cbiAgICAgICAgLy8gZ2V0IHJpZCBvZiB0cmFpbGluZyBieXRlcyB0aGF0IGFyZSBhbHJlYWR5IHBhcnQgb2YgbmV4dCBibG9ja1xuICAgICAgICB2YXIgbnVtSW52YWxpZFRhaWxCeXRlcyA9IHNyYy5sZW5ndGggKiA0IC0gTWF0aC5jZWlsKGJpdHNQZXJQaXhlbCAqIG51bVBpeGVscyAvIDgpO1xuICAgICAgICBzcmNbc3JjLmxlbmd0aCAtIDFdIDw8PSA4ICogbnVtSW52YWxpZFRhaWxCeXRlcztcblxuICAgICAgICB2YXIgbm1heCA9IE1hdGguY2VpbCgobWF4VmFsdWUgLSBvZmZzZXQpIC8gc2NhbGUpO1xuICAgICAgICBmb3IgKG8gPSAwOyBvIDwgbnVtUGl4ZWxzOyBvKyspIHtcbiAgICAgICAgICBpZiAoYml0c0xlZnQgPT09IDApIHtcbiAgICAgICAgICAgIGJ1ZmZlciA9IHNyY1tpKytdO1xuICAgICAgICAgICAgYml0c0xlZnQgPSAzMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJpdHNMZWZ0ID49IGJpdHNQZXJQaXhlbCkge1xuICAgICAgICAgICAgbiA9IChidWZmZXIgPj4+IChiaXRzTGVmdCAtIGJpdHNQZXJQaXhlbCkpICYgYml0TWFzaztcbiAgICAgICAgICAgIGJpdHNMZWZ0IC09IGJpdHNQZXJQaXhlbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWlzc2luZ0JpdHMgPSAoYml0c1BlclBpeGVsIC0gYml0c0xlZnQpO1xuICAgICAgICAgICAgbiA9ICgoYnVmZmVyICYgYml0TWFzaykgPDwgbWlzc2luZ0JpdHMpICYgYml0TWFzaztcbiAgICAgICAgICAgIGJ1ZmZlciA9IHNyY1tpKytdO1xuICAgICAgICAgICAgYml0c0xlZnQgPSAzMiAtIG1pc3NpbmdCaXRzO1xuICAgICAgICAgICAgbiArPSAoYnVmZmVyID4+PiBiaXRzTGVmdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vZGVzdC5wdXNoKG4pO1xuICAgICAgICAgIGRlc3Rbb10gPSBuIDwgbm1heCA/IG9mZnNldCArIG4gKiBzY2FsZSA6IG1heFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGRlc3QudW5zaGlmdChvZmZzZXQpOy8vMXN0IG9uZVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgIH0sXG5cbiAgICAgIHVuc3R1ZmYyOiBmdW5jdGlvbihzcmMsIGRlc3QsIGJpdHNQZXJQaXhlbCwgbnVtUGl4ZWxzLCBsdXRBcnIsIG9mZnNldCwgc2NhbGUsIG1heFZhbHVlKSB7XG4gICAgICAgIHZhciBiaXRNYXNrID0gKDEgPDwgYml0c1BlclBpeGVsKSAtIDE7XG4gICAgICAgIHZhciBpID0gMCwgbztcbiAgICAgICAgdmFyIGJpdHNMZWZ0ID0gMCwgYml0UG9zID0gMDtcbiAgICAgICAgdmFyIG4sIGJ1ZmZlciwgbWlzc2luZ0JpdHM7XG4gICAgICAgIGlmIChsdXRBcnIpIHtcbiAgICAgICAgICBmb3IgKG8gPSAwOyBvIDwgbnVtUGl4ZWxzOyBvKyspIHtcbiAgICAgICAgICAgIGlmIChiaXRzTGVmdCA9PT0gMCkge1xuICAgICAgICAgICAgICBidWZmZXIgPSBzcmNbaSsrXTtcbiAgICAgICAgICAgICAgYml0c0xlZnQgPSAzMjtcbiAgICAgICAgICAgICAgYml0UG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiaXRzTGVmdCA+PSBiaXRzUGVyUGl4ZWwpIHtcbiAgICAgICAgICAgICAgbiA9ICgoYnVmZmVyID4+PiBiaXRQb3MpICYgYml0TWFzayk7XG4gICAgICAgICAgICAgIGJpdHNMZWZ0IC09IGJpdHNQZXJQaXhlbDtcbiAgICAgICAgICAgICAgYml0UG9zICs9IGJpdHNQZXJQaXhlbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1pc3NpbmdCaXRzID0gKGJpdHNQZXJQaXhlbCAtIGJpdHNMZWZ0KTtcbiAgICAgICAgICAgICAgbiA9IChidWZmZXIgPj4+IGJpdFBvcykgJiBiaXRNYXNrO1xuICAgICAgICAgICAgICBidWZmZXIgPSBzcmNbaSsrXTtcbiAgICAgICAgICAgICAgYml0c0xlZnQgPSAzMiAtIG1pc3NpbmdCaXRzO1xuICAgICAgICAgICAgICBuIHw9IChidWZmZXIgJiAoKDEgPDwgbWlzc2luZ0JpdHMpIC0gMSkpIDw8IChiaXRzUGVyUGl4ZWwgLSBtaXNzaW5nQml0cyk7XG4gICAgICAgICAgICAgIGJpdFBvcyA9IG1pc3NpbmdCaXRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVzdFtvXSA9IGx1dEFycltuXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIG5tYXggPSBNYXRoLmNlaWwoKG1heFZhbHVlIC0gb2Zmc2V0KSAvIHNjYWxlKTtcbiAgICAgICAgICBmb3IgKG8gPSAwOyBvIDwgbnVtUGl4ZWxzOyBvKyspIHtcbiAgICAgICAgICAgIGlmIChiaXRzTGVmdCA9PT0gMCkge1xuICAgICAgICAgICAgICBidWZmZXIgPSBzcmNbaSsrXTtcbiAgICAgICAgICAgICAgYml0c0xlZnQgPSAzMjtcbiAgICAgICAgICAgICAgYml0UG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiaXRzTGVmdCA+PSBiaXRzUGVyUGl4ZWwpIHtcbiAgICAgICAgICAgICAgLy9ubyB1bnNpZ25lZCBsZWZ0IHNoaWZ0XG4gICAgICAgICAgICAgIG4gPSAoKGJ1ZmZlciA+Pj4gYml0UG9zKSAmIGJpdE1hc2spO1xuICAgICAgICAgICAgICBiaXRzTGVmdCAtPSBiaXRzUGVyUGl4ZWw7XG4gICAgICAgICAgICAgIGJpdFBvcyArPSBiaXRzUGVyUGl4ZWw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtaXNzaW5nQml0cyA9IChiaXRzUGVyUGl4ZWwgLSBiaXRzTGVmdCk7XG4gICAgICAgICAgICAgIG4gPSAoYnVmZmVyID4+PiBiaXRQb3MpICYgYml0TWFzazsvLygoYnVmZmVyICYgYml0TWFzaykgPDwgbWlzc2luZ0JpdHMpICYgYml0TWFzaztcbiAgICAgICAgICAgICAgYnVmZmVyID0gc3JjW2krK107XG4gICAgICAgICAgICAgIGJpdHNMZWZ0ID0gMzIgLSBtaXNzaW5nQml0cztcbiAgICAgICAgICAgICAgbiB8PSAoYnVmZmVyICYgKCgxIDw8IG1pc3NpbmdCaXRzKSAtIDEpKSA8PCAoYml0c1BlclBpeGVsIC0gbWlzc2luZ0JpdHMpO1xuICAgICAgICAgICAgICBiaXRQb3MgPSBtaXNzaW5nQml0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vcGl4ZWwgdmFsdWVzIG1heSBleGNlZWQgbWF4IGR1ZSB0byBxdWFudGl6YXRpb25cbiAgICAgICAgICAgIGRlc3Rbb10gPSBuIDwgbm1heCA/IG9mZnNldCArIG4gKiBzY2FsZSA6IG1heFZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgIH0sXG5cbiAgICAgIHVuc3R1ZmZMVVQyOiBmdW5jdGlvbihzcmMsIGJpdHNQZXJQaXhlbCwgbnVtUGl4ZWxzLCBvZmZzZXQsIHNjYWxlLCBtYXhWYWx1ZSkge1xuICAgICAgICB2YXIgYml0TWFzayA9ICgxIDw8IGJpdHNQZXJQaXhlbCkgLSAxO1xuICAgICAgICB2YXIgaSA9IDAsIG8gPSAwLCBtaXNzaW5nQml0cyA9IDAsIGJpdHNMZWZ0ID0gMCwgbiA9IDAsIGJpdFBvcyA9IDA7XG4gICAgICAgIHZhciBidWZmZXI7XG4gICAgICAgIHZhciBkZXN0ID0gW107XG4gICAgICAgIHZhciBubWF4ID0gTWF0aC5jZWlsKChtYXhWYWx1ZSAtIG9mZnNldCkgLyBzY2FsZSk7XG4gICAgICAgIGZvciAobyA9IDA7IG8gPCBudW1QaXhlbHM7IG8rKykge1xuICAgICAgICAgIGlmIChiaXRzTGVmdCA9PT0gMCkge1xuICAgICAgICAgICAgYnVmZmVyID0gc3JjW2krK107XG4gICAgICAgICAgICBiaXRzTGVmdCA9IDMyO1xuICAgICAgICAgICAgYml0UG9zID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJpdHNMZWZ0ID49IGJpdHNQZXJQaXhlbCkge1xuICAgICAgICAgICAgLy9ubyB1bnNpZ25lZCBsZWZ0IHNoaWZ0XG4gICAgICAgICAgICBuID0gKChidWZmZXIgPj4+IGJpdFBvcykgJiBiaXRNYXNrKTtcbiAgICAgICAgICAgIGJpdHNMZWZ0IC09IGJpdHNQZXJQaXhlbDtcbiAgICAgICAgICAgIGJpdFBvcyArPSBiaXRzUGVyUGl4ZWw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1pc3NpbmdCaXRzID0gKGJpdHNQZXJQaXhlbCAtIGJpdHNMZWZ0KTtcbiAgICAgICAgICAgIG4gPSAoYnVmZmVyID4+PiBiaXRQb3MpICYgYml0TWFzazsvLygoYnVmZmVyICYgYml0TWFzaykgPDwgbWlzc2luZ0JpdHMpICYgYml0TWFzaztcbiAgICAgICAgICAgIGJ1ZmZlciA9IHNyY1tpKytdO1xuICAgICAgICAgICAgYml0c0xlZnQgPSAzMiAtIG1pc3NpbmdCaXRzO1xuICAgICAgICAgICAgbiB8PSAoYnVmZmVyICYgKCgxIDw8IG1pc3NpbmdCaXRzKSAtIDEpKSA8PCAoYml0c1BlclBpeGVsIC0gbWlzc2luZ0JpdHMpO1xuICAgICAgICAgICAgYml0UG9zID0gbWlzc2luZ0JpdHM7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vZGVzdC5wdXNoKG4pO1xuICAgICAgICAgIGRlc3Rbb10gPSBuIDwgbm1heCA/IG9mZnNldCArIG4gKiBzY2FsZSA6IG1heFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGRlc3QudW5zaGlmdChvZmZzZXQpO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgIH0sXG5cbiAgICAgIG9yaWdpbmFsVW5zdHVmZjogZnVuY3Rpb24oc3JjLCBkZXN0LCBiaXRzUGVyUGl4ZWwsIG51bVBpeGVscykge1xuICAgICAgICB2YXIgYml0TWFzayA9ICgxIDw8IGJpdHNQZXJQaXhlbCkgLSAxO1xuICAgICAgICB2YXIgaSA9IDAsIG87XG4gICAgICAgIHZhciBiaXRzTGVmdCA9IDA7XG4gICAgICAgIHZhciBuLCBidWZmZXIsIG1pc3NpbmdCaXRzO1xuXG4gICAgICAgIC8vIGdldCByaWQgb2YgdHJhaWxpbmcgYnl0ZXMgdGhhdCBhcmUgYWxyZWFkeSBwYXJ0IG9mIG5leHQgYmxvY2tcbiAgICAgICAgdmFyIG51bUludmFsaWRUYWlsQnl0ZXMgPSBzcmMubGVuZ3RoICogNCAtIE1hdGguY2VpbChiaXRzUGVyUGl4ZWwgKiBudW1QaXhlbHMgLyA4KTtcbiAgICAgICAgc3JjW3NyYy5sZW5ndGggLSAxXSA8PD0gOCAqIG51bUludmFsaWRUYWlsQnl0ZXM7XG5cbiAgICAgICAgZm9yIChvID0gMDsgbyA8IG51bVBpeGVsczsgbysrKSB7XG4gICAgICAgICAgaWYgKGJpdHNMZWZ0ID09PSAwKSB7XG4gICAgICAgICAgICBidWZmZXIgPSBzcmNbaSsrXTtcbiAgICAgICAgICAgIGJpdHNMZWZ0ID0gMzI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChiaXRzTGVmdCA+PSBiaXRzUGVyUGl4ZWwpIHtcbiAgICAgICAgICAgIG4gPSAoYnVmZmVyID4+PiAoYml0c0xlZnQgLSBiaXRzUGVyUGl4ZWwpKSAmIGJpdE1hc2s7XG4gICAgICAgICAgICBiaXRzTGVmdCAtPSBiaXRzUGVyUGl4ZWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWlzc2luZ0JpdHMgPSAoYml0c1BlclBpeGVsIC0gYml0c0xlZnQpO1xuICAgICAgICAgICAgbiA9ICgoYnVmZmVyICYgYml0TWFzaykgPDwgbWlzc2luZ0JpdHMpICYgYml0TWFzaztcbiAgICAgICAgICAgIGJ1ZmZlciA9IHNyY1tpKytdO1xuICAgICAgICAgICAgYml0c0xlZnQgPSAzMiAtIG1pc3NpbmdCaXRzO1xuICAgICAgICAgICAgbiArPSAoYnVmZmVyID4+PiBiaXRzTGVmdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlc3Rbb10gPSBuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgfSxcblxuICAgICAgb3JpZ2luYWxVbnN0dWZmMjogZnVuY3Rpb24oc3JjLCBkZXN0LCBiaXRzUGVyUGl4ZWwsIG51bVBpeGVscykge1xuICAgICAgICB2YXIgYml0TWFzayA9ICgxIDw8IGJpdHNQZXJQaXhlbCkgLSAxO1xuICAgICAgICB2YXIgaSA9IDAsIG87XG4gICAgICAgIHZhciBiaXRzTGVmdCA9IDAsIGJpdFBvcyA9IDA7XG4gICAgICAgIHZhciBuLCBidWZmZXIsIG1pc3NpbmdCaXRzO1xuICAgICAgICAvL21pY3JvLW9wdGltaXphdGlvbnNcbiAgICAgICAgZm9yIChvID0gMDsgbyA8IG51bVBpeGVsczsgbysrKSB7XG4gICAgICAgICAgaWYgKGJpdHNMZWZ0ID09PSAwKSB7XG4gICAgICAgICAgICBidWZmZXIgPSBzcmNbaSsrXTtcbiAgICAgICAgICAgIGJpdHNMZWZ0ID0gMzI7XG4gICAgICAgICAgICBiaXRQb3MgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYml0c0xlZnQgPj0gYml0c1BlclBpeGVsKSB7XG4gICAgICAgICAgICAvL25vIHVuc2lnbmVkIGxlZnQgc2hpZnRcbiAgICAgICAgICAgIG4gPSAoKGJ1ZmZlciA+Pj4gYml0UG9zKSAmIGJpdE1hc2spO1xuICAgICAgICAgICAgYml0c0xlZnQgLT0gYml0c1BlclBpeGVsO1xuICAgICAgICAgICAgYml0UG9zICs9IGJpdHNQZXJQaXhlbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWlzc2luZ0JpdHMgPSAoYml0c1BlclBpeGVsIC0gYml0c0xlZnQpO1xuICAgICAgICAgICAgbiA9IChidWZmZXIgPj4+IGJpdFBvcykgJiBiaXRNYXNrOy8vKChidWZmZXIgJiBiaXRNYXNrKSA8PCBtaXNzaW5nQml0cykgJiBiaXRNYXNrO1xuICAgICAgICAgICAgYnVmZmVyID0gc3JjW2krK107XG4gICAgICAgICAgICBiaXRzTGVmdCA9IDMyIC0gbWlzc2luZ0JpdHM7XG4gICAgICAgICAgICBuIHw9IChidWZmZXIgJiAoKDEgPDwgbWlzc2luZ0JpdHMpIC0gMSkpIDw8IChiaXRzUGVyUGl4ZWwgLSBtaXNzaW5nQml0cyk7XG4gICAgICAgICAgICBiaXRQb3MgPSBtaXNzaW5nQml0cztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVzdFtvXSA9IG47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICpwcml2YXRlIHN0YXRpYyBjbGFzcyB1c2VkIGJ5IExlcmMyRGVjb2RlXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgIHZhciBMZXJjMkhlbHBlcnMgPSB7XG4gICAgICBIVUZGTUFOX0xVVF9CSVRTX01BWDogMTIsIC8vdXNlIDJeMTIgbHV0LCB0cmVhdCBpdCBsaWtlIGNvbnN0YW50XG4gICAgICBjb21wdXRlQ2hlY2tzdW1GbGV0Y2hlcjMyOiBmdW5jdGlvbihpbnB1dCkge1xuXG4gICAgICAgIHZhciBzdW0xID0gMHhmZmZmLCBzdW0yID0gMHhmZmZmO1xuICAgICAgICB2YXIgbGVuID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICB2YXIgd29yZHMgPSBNYXRoLmZsb29yKGxlbiAvIDIpO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlICh3b3Jkcykge1xuICAgICAgICAgIHZhciB0bGVuID0gKHdvcmRzID49IDM1OSkgPyAzNTkgOiB3b3JkcztcbiAgICAgICAgICB3b3JkcyAtPSB0bGVuO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIHN1bTEgKz0gKGlucHV0W2krK10gPDwgOCk7XG4gICAgICAgICAgICBzdW0yICs9IHN1bTEgKz0gaW5wdXRbaSsrXTtcbiAgICAgICAgICB9IHdoaWxlICgtLXRsZW4pO1xuXG4gICAgICAgICAgc3VtMSA9IChzdW0xICYgMHhmZmZmKSArIChzdW0xID4+PiAxNik7XG4gICAgICAgICAgc3VtMiA9IChzdW0yICYgMHhmZmZmKSArIChzdW0yID4+PiAxNik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgdGhlIHN0cmFnZ2xlciBieXRlIGlmIGl0IGV4aXN0c1xuICAgICAgICBpZiAobGVuICYgMSkge1xuICAgICAgICAgIHN1bTIgKz0gc3VtMSArPSAoaW5wdXRbaV0gPDwgOCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2Vjb25kIHJlZHVjdGlvbiBzdGVwIHRvIHJlZHVjZSBzdW1zIHRvIDE2IGJpdHNcbiAgICAgICAgc3VtMSA9IChzdW0xICYgMHhmZmZmKSArIChzdW0xID4+PiAxNik7XG4gICAgICAgIHN1bTIgPSAoc3VtMiAmIDB4ZmZmZikgKyAoc3VtMiA+Pj4gMTYpO1xuXG4gICAgICAgIHJldHVybiAoc3VtMiA8PCAxNiB8IHN1bTEpID4+PiAwO1xuICAgICAgfSxcblxuICAgICAgcmVhZEhlYWRlckluZm86IGZ1bmN0aW9uKGlucHV0LCBkYXRhKSB7XG4gICAgICAgIHZhciBwdHIgPSBkYXRhLnB0cjtcbiAgICAgICAgdmFyIGZpbGVJZFZpZXcgPSBuZXcgVWludDhBcnJheShpbnB1dCwgcHRyLCA2KTtcbiAgICAgICAgdmFyIGhlYWRlckluZm8gPSB7fTtcbiAgICAgICAgaGVhZGVySW5mby5maWxlSWRlbnRpZmllclN0cmluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgZmlsZUlkVmlldyk7XG4gICAgICAgIGlmIChoZWFkZXJJbmZvLmZpbGVJZGVudGlmaWVyU3RyaW5nLmxhc3RJbmRleE9mKFwiTGVyYzJcIiwgMCkgIT09IDApIHtcbiAgICAgICAgICB0aHJvdyBcIlVuZXhwZWN0ZWQgZmlsZSBpZGVudGlmaWVyIHN0cmluZyAoZXhwZWN0IExlcmMyICk6IFwiICsgaGVhZGVySW5mby5maWxlSWRlbnRpZmllclN0cmluZztcbiAgICAgICAgfVxuICAgICAgICBwdHIgKz0gNjtcbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcoaW5wdXQsIHB0ciwgOCk7XG4gICAgICAgIHZhciBmaWxlVmVyc2lvbiA9IHZpZXcuZ2V0SW50MzIoMCwgdHJ1ZSk7XG4gICAgICAgIGhlYWRlckluZm8uZmlsZVZlcnNpb24gPSBmaWxlVmVyc2lvbjtcbiAgICAgICAgcHRyICs9IDQ7XG4gICAgICAgIGlmIChmaWxlVmVyc2lvbiA+PSAzKSB7XG4gICAgICAgICAgaGVhZGVySW5mby5jaGVja3N1bSA9IHZpZXcuZ2V0VWludDMyKDQsIHRydWUpOyAvL25yb3dzXG4gICAgICAgICAgcHRyICs9IDQ7XG4gICAgICAgIH1cblxuICAgICAgICAvL2tleXMgc3RhcnQgZnJvbSBoZXJlXG4gICAgICAgIHZpZXcgPSBuZXcgRGF0YVZpZXcoaW5wdXQsIHB0ciwgMTIpO1xuICAgICAgICBoZWFkZXJJbmZvLmhlaWdodCA9IHZpZXcuZ2V0VWludDMyKDAsIHRydWUpOyAvL25yb3dzXG4gICAgICAgIGhlYWRlckluZm8ud2lkdGggPSB2aWV3LmdldFVpbnQzMig0LCB0cnVlKTsgLy9uY29sc1xuICAgICAgICBwdHIgKz0gODtcbiAgICAgICAgaWYgKGZpbGVWZXJzaW9uID49IDQpIHtcbiAgICAgICAgICBoZWFkZXJJbmZvLm51bURpbXMgPSB2aWV3LmdldFVpbnQzMig4LCB0cnVlKTtcbiAgICAgICAgICBwdHIgKz0gNDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBoZWFkZXJJbmZvLm51bURpbXMgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmlldyA9IG5ldyBEYXRhVmlldyhpbnB1dCwgcHRyLCA0MCk7XG4gICAgICAgIGhlYWRlckluZm8ubnVtVmFsaWRQaXhlbCA9IHZpZXcuZ2V0VWludDMyKDAsIHRydWUpO1xuICAgICAgICBoZWFkZXJJbmZvLm1pY3JvQmxvY2tTaXplID0gdmlldy5nZXRJbnQzMig0LCB0cnVlKTtcbiAgICAgICAgaGVhZGVySW5mby5ibG9iU2l6ZSA9IHZpZXcuZ2V0SW50MzIoOCwgdHJ1ZSk7XG4gICAgICAgIGhlYWRlckluZm8uaW1hZ2VUeXBlID0gdmlldy5nZXRJbnQzMigxMiwgdHJ1ZSk7XG5cbiAgICAgICAgaGVhZGVySW5mby5tYXhaRXJyb3IgPSB2aWV3LmdldEZsb2F0NjQoMTYsIHRydWUpO1xuICAgICAgICBoZWFkZXJJbmZvLnpNaW4gPSB2aWV3LmdldEZsb2F0NjQoMjQsIHRydWUpO1xuICAgICAgICBoZWFkZXJJbmZvLnpNYXggPSB2aWV3LmdldEZsb2F0NjQoMzIsIHRydWUpO1xuICAgICAgICBwdHIgKz0gNDA7XG4gICAgICAgIGRhdGEuaGVhZGVySW5mbyA9IGhlYWRlckluZm87XG4gICAgICAgIGRhdGEucHRyID0gcHRyO1xuXG4gICAgICAgIHZhciBjaGVja3N1bSwga2V5TGVuZ3RoO1xuICAgICAgICBpZiAoZmlsZVZlcnNpb24gPj0gMykge1xuICAgICAgICAgIGtleUxlbmd0aCA9IGZpbGVWZXJzaW9uID49IDQgPyA1MiA6IDQ4O1xuICAgICAgICAgIGNoZWNrc3VtID0gdGhpcy5jb21wdXRlQ2hlY2tzdW1GbGV0Y2hlcjMyKG5ldyBVaW50OEFycmF5KGlucHV0LCBwdHIgLSBrZXlMZW5ndGgsIGhlYWRlckluZm8uYmxvYlNpemUgLSAxNCkpO1xuICAgICAgICAgIGlmIChjaGVja3N1bSAhPT0gaGVhZGVySW5mby5jaGVja3N1bSkge1xuICAgICAgICAgICAgdGhyb3cgXCJDaGVja3N1bSBmYWlsZWQuXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcblxuICAgICAgY2hlY2tNaW5NYXhSYW5nZXM6IGZ1bmN0aW9uKGlucHV0LCBkYXRhKSB7XG4gICAgICAgIHZhciBoZWFkZXJJbmZvID0gZGF0YS5oZWFkZXJJbmZvO1xuICAgICAgICB2YXIgT3V0UGl4ZWxUeXBlQXJyYXkgPSB0aGlzLmdldERhdGFUeXBlQXJyYXkoaGVhZGVySW5mby5pbWFnZVR5cGUpO1xuICAgICAgICB2YXIgcmFuZ2VCeXRlcyA9IGhlYWRlckluZm8ubnVtRGltcyAqIHRoaXMuZ2V0RGF0YVR5cGVTaXplKGhlYWRlckluZm8uaW1hZ2VUeXBlKTtcbiAgICAgICAgdmFyIG1pblZhbHVlcyA9IHRoaXMucmVhZFN1YkFycmF5KGlucHV0LCBkYXRhLnB0ciwgT3V0UGl4ZWxUeXBlQXJyYXksIHJhbmdlQnl0ZXMpO1xuICAgICAgICB2YXIgbWF4VmFsdWVzID0gdGhpcy5yZWFkU3ViQXJyYXkoaW5wdXQsIGRhdGEucHRyICsgcmFuZ2VCeXRlcywgT3V0UGl4ZWxUeXBlQXJyYXksIHJhbmdlQnl0ZXMpO1xuICAgICAgICBkYXRhLnB0ciArPSAoMiAqIHJhbmdlQnl0ZXMpO1xuICAgICAgICB2YXIgaSwgZXF1YWwgPSB0cnVlO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaGVhZGVySW5mby5udW1EaW1zOyBpKyspIHtcbiAgICAgICAgICBpZiAobWluVmFsdWVzW2ldICE9PSBtYXhWYWx1ZXNbaV0pIHtcbiAgICAgICAgICAgIGVxdWFsID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaGVhZGVySW5mby5taW5WYWx1ZXMgPSBtaW5WYWx1ZXM7XG4gICAgICAgIGhlYWRlckluZm8ubWF4VmFsdWVzID0gbWF4VmFsdWVzO1xuICAgICAgICByZXR1cm4gZXF1YWw7XG4gICAgICB9LFxuXG4gICAgICByZWFkU3ViQXJyYXk6IGZ1bmN0aW9uKGlucHV0LCBwdHIsIE91dFBpeGVsVHlwZUFycmF5LCBudW1CeXRlcykge1xuICAgICAgICB2YXIgcmF3RGF0YTtcbiAgICAgICAgaWYgKE91dFBpeGVsVHlwZUFycmF5ID09PSBVaW50OEFycmF5KSB7XG4gICAgICAgICAgcmF3RGF0YSA9IG5ldyBVaW50OEFycmF5KGlucHV0LCBwdHIsIG51bUJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgYXJyYXlCdWYgPSBuZXcgQXJyYXlCdWZmZXIobnVtQnl0ZXMpO1xuICAgICAgICAgIHZhciBzdG9yZTggPSBuZXcgVWludDhBcnJheShhcnJheUJ1Zik7XG4gICAgICAgICAgc3RvcmU4LnNldChuZXcgVWludDhBcnJheShpbnB1dCwgcHRyLCBudW1CeXRlcykpO1xuICAgICAgICAgIHJhd0RhdGEgPSBuZXcgT3V0UGl4ZWxUeXBlQXJyYXkoYXJyYXlCdWYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYXdEYXRhO1xuICAgICAgfSxcblxuICAgICAgcmVhZE1hc2s6IGZ1bmN0aW9uKGlucHV0LCBkYXRhKSB7XG4gICAgICAgIHZhciBwdHIgPSBkYXRhLnB0cjtcbiAgICAgICAgdmFyIGhlYWRlckluZm8gPSBkYXRhLmhlYWRlckluZm87XG4gICAgICAgIHZhciBudW1QaXhlbHMgPSBoZWFkZXJJbmZvLndpZHRoICogaGVhZGVySW5mby5oZWlnaHQ7XG4gICAgICAgIHZhciBudW1WYWxpZFBpeGVsID0gaGVhZGVySW5mby5udW1WYWxpZFBpeGVsO1xuXG4gICAgICAgIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KGlucHV0LCBwdHIsIDQpO1xuICAgICAgICB2YXIgbWFzayA9IHt9O1xuICAgICAgICBtYXNrLm51bUJ5dGVzID0gdmlldy5nZXRVaW50MzIoMCwgdHJ1ZSk7XG4gICAgICAgIHB0ciArPSA0O1xuXG4gICAgICAgIC8vIE1hc2sgRGF0YVxuICAgICAgICBpZiAoKDAgPT09IG51bVZhbGlkUGl4ZWwgfHwgbnVtUGl4ZWxzID09PSBudW1WYWxpZFBpeGVsKSAmJiAwICE9PSBtYXNrLm51bUJ5dGVzKSB7XG4gICAgICAgICAgdGhyb3cgKFwiaW52YWxpZCBtYXNrXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiaXRzZXQsIHJlc3VsdE1hc2s7XG4gICAgICAgIGlmIChudW1WYWxpZFBpeGVsID09PSAwKSB7XG4gICAgICAgICAgYml0c2V0ID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKG51bVBpeGVscyAvIDgpKTtcbiAgICAgICAgICBtYXNrLmJpdHNldCA9IGJpdHNldDtcbiAgICAgICAgICByZXN1bHRNYXNrID0gbmV3IFVpbnQ4QXJyYXkobnVtUGl4ZWxzKTtcbiAgICAgICAgICBkYXRhLnBpeGVscy5yZXN1bHRNYXNrID0gcmVzdWx0TWFzaztcbiAgICAgICAgICBwdHIgKz0gbWFzay5udW1CeXRlcztcbiAgICAgICAgfS8vID8/Pz8/IGVsc2UgaWYgKGRhdGEubWFzay5udW1CeXRlcyA+IDAgJiYgZGF0YS5tYXNrLm51bUJ5dGVzPCBkYXRhLm51bVZhbGlkUGl4ZWwpIHtcbiAgICAgICAgZWxzZSBpZiAobWFzay5udW1CeXRlcyA+IDApIHtcbiAgICAgICAgICBiaXRzZXQgPSBuZXcgVWludDhBcnJheShNYXRoLmNlaWwobnVtUGl4ZWxzIC8gOCkpO1xuICAgICAgICAgIHZpZXcgPSBuZXcgRGF0YVZpZXcoaW5wdXQsIHB0ciwgbWFzay5udW1CeXRlcyk7XG4gICAgICAgICAgdmFyIGNudCA9IHZpZXcuZ2V0SW50MTYoMCwgdHJ1ZSk7XG4gICAgICAgICAgdmFyIGlwID0gMiwgb3AgPSAwLCB2YWwgPSAwO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChjbnQgPiAwKSB7XG4gICAgICAgICAgICAgIHdoaWxlIChjbnQtLSkgeyBiaXRzZXRbb3ArK10gPSB2aWV3LmdldFVpbnQ4KGlwKyspOyB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YWwgPSB2aWV3LmdldFVpbnQ4KGlwKyspO1xuICAgICAgICAgICAgICBjbnQgPSAtY250O1xuICAgICAgICAgICAgICB3aGlsZSAoY250LS0pIHsgYml0c2V0W29wKytdID0gdmFsOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbnQgPSB2aWV3LmdldEludDE2KGlwLCB0cnVlKTtcbiAgICAgICAgICAgIGlwICs9IDI7XG4gICAgICAgICAgfSB3aGlsZSAoaXAgPCBtYXNrLm51bUJ5dGVzKTtcbiAgICAgICAgICBpZiAoKGNudCAhPT0gLTMyNzY4KSB8fCAob3AgPCBiaXRzZXQubGVuZ3RoKSkge1xuICAgICAgICAgICAgdGhyb3cgXCJVbmV4cGVjdGVkIGVuZCBvZiBtYXNrIFJMRSBlbmNvZGluZ1wiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc3VsdE1hc2sgPSBuZXcgVWludDhBcnJheShudW1QaXhlbHMpO1xuICAgICAgICAgIHZhciBtYiA9IDAsIGsgPSAwO1xuXG4gICAgICAgICAgZm9yIChrID0gMDsgayA8IG51bVBpeGVsczsgaysrKSB7XG4gICAgICAgICAgICBpZiAoayAmIDcpIHtcbiAgICAgICAgICAgICAgbWIgPSBiaXRzZXRbayA+PiAzXTtcbiAgICAgICAgICAgICAgbWIgPDw9IGsgJiA3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIG1iID0gYml0c2V0W2sgPj4gM107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWIgJiAxMjgpIHtcbiAgICAgICAgICAgICAgcmVzdWx0TWFza1trXSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGEucGl4ZWxzLnJlc3VsdE1hc2sgPSByZXN1bHRNYXNrO1xuXG4gICAgICAgICAgbWFzay5iaXRzZXQgPSBiaXRzZXQ7XG4gICAgICAgICAgcHRyICs9IG1hc2subnVtQnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YS5wdHIgPSBwdHI7XG4gICAgICAgIGRhdGEubWFzayA9IG1hc2s7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcblxuICAgICAgcmVhZERhdGFPbmVTd2VlcDogZnVuY3Rpb24oaW5wdXQsIGRhdGEsIE91dFBpeGVsVHlwZUFycmF5LCB1c2VCU1FGb3JPdXRwdXREaW0pIHtcbiAgICAgICAgdmFyIHB0ciA9IGRhdGEucHRyO1xuICAgICAgICB2YXIgaGVhZGVySW5mbyA9IGRhdGEuaGVhZGVySW5mbztcbiAgICAgICAgdmFyIG51bURpbXMgPSBoZWFkZXJJbmZvLm51bURpbXM7XG4gICAgICAgIHZhciBudW1QaXhlbHMgPSBoZWFkZXJJbmZvLndpZHRoICogaGVhZGVySW5mby5oZWlnaHQ7XG4gICAgICAgIHZhciBpbWFnZVR5cGUgPSBoZWFkZXJJbmZvLmltYWdlVHlwZTtcbiAgICAgICAgdmFyIG51bUJ5dGVzID0gaGVhZGVySW5mby5udW1WYWxpZFBpeGVsICogTGVyYzJIZWxwZXJzLmdldERhdGFUeXBlU2l6ZShpbWFnZVR5cGUpICogbnVtRGltcztcbiAgICAgICAgLy9kYXRhLnBpeGVscy5udW1CeXRlcyA9IG51bUJ5dGVzO1xuICAgICAgICB2YXIgcmF3RGF0YTtcbiAgICAgICAgdmFyIG1hc2sgPSBkYXRhLnBpeGVscy5yZXN1bHRNYXNrO1xuICAgICAgICBpZiAoT3V0UGl4ZWxUeXBlQXJyYXkgPT09IFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICByYXdEYXRhID0gbmV3IFVpbnQ4QXJyYXkoaW5wdXQsIHB0ciwgbnVtQnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBhcnJheUJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcihudW1CeXRlcyk7XG4gICAgICAgICAgdmFyIHN0b3JlOCA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmKTtcbiAgICAgICAgICBzdG9yZTguc2V0KG5ldyBVaW50OEFycmF5KGlucHV0LCBwdHIsIG51bUJ5dGVzKSk7XG4gICAgICAgICAgcmF3RGF0YSA9IG5ldyBPdXRQaXhlbFR5cGVBcnJheShhcnJheUJ1Zik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJhd0RhdGEubGVuZ3RoID09PSBudW1QaXhlbHMgKiBudW1EaW1zKSB7XG4gICAgICAgICAgaWYgKHVzZUJTUUZvck91dHB1dERpbSkge1xuICAgICAgICAgICAgZGF0YS5waXhlbHMucmVzdWx0UGl4ZWxzID0gTGVyYzJIZWxwZXJzLnN3YXBEaW1lbnNpb25PcmRlcihyYXdEYXRhLCBudW1QaXhlbHMsIG51bURpbXMsIE91dFBpeGVsVHlwZUFycmF5LCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhLnBpeGVscy5yZXN1bHRQaXhlbHMgPSByYXdEYXRhO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlICAvL21hc2tcbiAgICAgICAge1xuICAgICAgICAgIGRhdGEucGl4ZWxzLnJlc3VsdFBpeGVscyA9IG5ldyBPdXRQaXhlbFR5cGVBcnJheShudW1QaXhlbHMgKiBudW1EaW1zKTtcbiAgICAgICAgICB2YXIgeiA9IDAsIGsgPSAwLCBpID0gMCwgblN0YXJ0ID0gMDtcbiAgICAgICAgICBpZiAobnVtRGltcyA+IDEpIHtcbiAgICAgICAgICAgIGlmICh1c2VCU1FGb3JPdXRwdXREaW0pIHtcbiAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IG51bVBpeGVsczsgaysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hc2tba10pIHtcbiAgICAgICAgICAgICAgICAgIG5TdGFydCA9IGs7XG4gICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtRGltczsgaSsrLCBuU3RhcnQrPW51bVBpeGVscykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnBpeGVscy5yZXN1bHRQaXhlbHNbblN0YXJ0XSA9IHJhd0RhdGFbeisrXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbnVtUGl4ZWxzOyBrKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobWFza1trXSkge1xuICAgICAgICAgICAgICAgICAgblN0YXJ0ID0gayAqIG51bURpbXM7XG4gICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtRGltczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEucGl4ZWxzLnJlc3VsdFBpeGVsc1tuU3RhcnQgKyBpXSA9IHJhd0RhdGFbeisrXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbnVtUGl4ZWxzOyBrKyspIHtcbiAgICAgICAgICAgICAgaWYgKG1hc2tba10pIHtcbiAgICAgICAgICAgICAgICBkYXRhLnBpeGVscy5yZXN1bHRQaXhlbHNba10gPSByYXdEYXRhW3orK107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHRyICs9IG51bUJ5dGVzO1xuICAgICAgICBkYXRhLnB0ciA9IHB0cjsgICAgICAgLy9yZXR1cm4gZGF0YTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9LFxuXG4gICAgICByZWFkSHVmZm1hblRyZWU6IGZ1bmN0aW9uKGlucHV0LCBkYXRhKSB7XG4gICAgICAgIHZhciBCSVRTX01BWCA9IHRoaXMuSFVGRk1BTl9MVVRfQklUU19NQVg7IC8vOCBpcyBzbG93IGZvciB0aGUgbGFyZ2UgdGVzdCBpbWFnZVxuICAgICAgICAvL3ZhciBzaXplX21heCA9IDEgPDwgQklUU19NQVg7XG4gICAgICAgIC8qICoqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAqIHJlYWRpbmcgY29kZSB0YWJsZVxuICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhpbnB1dCwgZGF0YS5wdHIsIDE2KTtcbiAgICAgICAgZGF0YS5wdHIgKz0gMTY7XG4gICAgICAgIHZhciB2ZXJzaW9uID0gdmlldy5nZXRJbnQzMigwLCB0cnVlKTtcbiAgICAgICAgaWYgKHZlcnNpb24gPCAyKSB7XG4gICAgICAgICAgdGhyb3cgXCJ1bnN1cHBvcnRlZCBIdWZmbWFuIHZlcnNpb25cIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2l6ZSA9IHZpZXcuZ2V0SW50MzIoNCwgdHJ1ZSk7XG4gICAgICAgIHZhciBpMCA9IHZpZXcuZ2V0SW50MzIoOCwgdHJ1ZSk7XG4gICAgICAgIHZhciBpMSA9IHZpZXcuZ2V0SW50MzIoMTIsIHRydWUpO1xuICAgICAgICBpZiAoaTAgPj0gaTEpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJsb2NrRGF0YUJ1ZmZlciA9IG5ldyBVaW50MzJBcnJheShpMSAtIGkwKTtcbiAgICAgICAgTGVyYzJIZWxwZXJzLmRlY29kZUJpdHMoaW5wdXQsIGRhdGEsIGJsb2NrRGF0YUJ1ZmZlcik7XG4gICAgICAgIHZhciBjb2RlVGFibGUgPSBbXTsgLy9zaXplXG4gICAgICAgIHZhciBpLCBqLCBrLCBsZW47XG5cbiAgICAgICAgZm9yIChpID0gaTA7IGkgPCBpMTsgaSsrKSB7XG4gICAgICAgICAgaiA9IGkgLSAoaSA8IHNpemUgPyAwIDogc2l6ZSk7Ly93cmFwIGFyb3VuZFxuICAgICAgICAgIGNvZGVUYWJsZVtqXSA9IHsgZmlyc3Q6IGJsb2NrRGF0YUJ1ZmZlcltpIC0gaTBdLCBzZWNvbmQ6IG51bGwgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXRhQnl0ZXMgPSBpbnB1dC5ieXRlTGVuZ3RoIC0gZGF0YS5wdHI7XG4gICAgICAgIHZhciBkYXRhV29yZHMgPSBNYXRoLmNlaWwoZGF0YUJ5dGVzIC8gNCk7XG4gICAgICAgIHZhciBhcnJheUJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcihkYXRhV29yZHMgKiA0KTtcbiAgICAgICAgdmFyIHN0b3JlOCA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmKTtcbiAgICAgICAgc3RvcmU4LnNldChuZXcgVWludDhBcnJheShpbnB1dCwgZGF0YS5wdHIsIGRhdGFCeXRlcykpO1xuICAgICAgICB2YXIgc3R1ZmZlZERhdGEgPSBuZXcgVWludDMyQXJyYXkoYXJyYXlCdWYpOyAvL211c3Qgc3RhcnQgZnJvbSB4KjRcbiAgICAgICAgdmFyIGJpdFBvcyA9IDAsIHdvcmQsIHNyY1B0ciA9IDA7XG4gICAgICAgIHdvcmQgPSBzdHVmZmVkRGF0YVswXTtcbiAgICAgICAgZm9yIChpID0gaTA7IGkgPCBpMTsgaSsrKSB7XG4gICAgICAgICAgaiA9IGkgLSAoaSA8IHNpemUgPyAwIDogc2l6ZSk7Ly93cmFwIGFyb3VuZFxuICAgICAgICAgIGxlbiA9IGNvZGVUYWJsZVtqXS5maXJzdDtcbiAgICAgICAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAgICAgY29kZVRhYmxlW2pdLnNlY29uZCA9ICh3b3JkIDw8IGJpdFBvcykgPj4+ICgzMiAtIGxlbik7XG5cbiAgICAgICAgICAgIGlmICgzMiAtIGJpdFBvcyA+PSBsZW4pIHtcbiAgICAgICAgICAgICAgYml0UG9zICs9IGxlbjtcbiAgICAgICAgICAgICAgaWYgKGJpdFBvcyA9PT0gMzIpIHtcbiAgICAgICAgICAgICAgICBiaXRQb3MgPSAwO1xuICAgICAgICAgICAgICAgIHNyY1B0cisrO1xuICAgICAgICAgICAgICAgIHdvcmQgPSBzdHVmZmVkRGF0YVtzcmNQdHJdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgYml0UG9zICs9IGxlbiAtIDMyO1xuICAgICAgICAgICAgICBzcmNQdHIrKztcbiAgICAgICAgICAgICAgd29yZCA9IHN0dWZmZWREYXRhW3NyY1B0cl07XG4gICAgICAgICAgICAgIGNvZGVUYWJsZVtqXS5zZWNvbmQgfD0gd29yZCA+Pj4gKDMyIC0gYml0UG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL2ZpbmlzaGVkIHJlYWRpbmcgY29kZSB0YWJsZVxuXG4gICAgICAgIC8qICoqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAqIGJ1aWxkaW5nIGx1dFxuICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICB2YXIgbnVtQml0c0xVVCA9IDAsIG51bUJpdHNMVVRRaWNrID0gMDtcbiAgICAgICAgdmFyIHRyZWUgPSBuZXcgVHJlZU5vZGUoKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvZGVUYWJsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChjb2RlVGFibGVbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbnVtQml0c0xVVCA9IE1hdGgubWF4KG51bUJpdHNMVVQsIGNvZGVUYWJsZVtpXS5maXJzdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChudW1CaXRzTFVUID49IEJJVFNfTUFYKSB7XG4gICAgICAgICAgbnVtQml0c0xVVFFpY2sgPSBCSVRTX01BWDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBudW1CaXRzTFVUUWljayA9IG51bUJpdHNMVVQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZm9yIGRlYnVnZ2luZyBwdXJwb3NlXG4gICAgICAgIC8vIGlmIChudW1CaXRzTFVUID49IDMwKSB7XG4gICAgICAgIC8vICAgY29uc29sZS5sb2coXCJXQVJuaW5nLCBsYXJnZSBOVU0gTFVUIEJJVFMgSVMgXCIgKyBudW1CaXRzTFVUKTtcbiAgICAgICAgLy8gfVxuICAgICAgICB2YXIgZGVjb2RlTHV0ID0gW10sIGVudHJ5LCBjb2RlLCBudW1FbnRyaWVzLCBqaiwgY3VycmVudEJpdCwgbm9kZTtcbiAgICAgICAgZm9yIChpID0gaTA7IGkgPCBpMTsgaSsrKSB7XG4gICAgICAgICAgaiA9IGkgLSAoaSA8IHNpemUgPyAwIDogc2l6ZSk7Ly93cmFwIGFyb3VuZFxuICAgICAgICAgIGxlbiA9IGNvZGVUYWJsZVtqXS5maXJzdDtcbiAgICAgICAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAgICAgZW50cnkgPSBbbGVuLCBqXTtcbiAgICAgICAgICAgIGlmIChsZW4gPD0gbnVtQml0c0xVVFFpY2spIHtcbiAgICAgICAgICAgICAgY29kZSA9IGNvZGVUYWJsZVtqXS5zZWNvbmQgPDwgKG51bUJpdHNMVVRRaWNrIC0gbGVuKTtcbiAgICAgICAgICAgICAgbnVtRW50cmllcyA9IDEgPDwgKG51bUJpdHNMVVRRaWNrIC0gbGVuKTtcbiAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IG51bUVudHJpZXM7IGsrKykge1xuICAgICAgICAgICAgICAgIGRlY29kZUx1dFtjb2RlIHwga10gPSBlbnRyeTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vYnVpbGQgdHJlZVxuICAgICAgICAgICAgICBjb2RlID0gY29kZVRhYmxlW2pdLnNlY29uZDtcbiAgICAgICAgICAgICAgbm9kZSA9IHRyZWU7XG4gICAgICAgICAgICAgIGZvciAoamogPSBsZW4gLSAxOyBqaiA+PSAwOyBqai0tKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJpdCA9IGNvZGUgPj4+IGpqICYgMTsgLy9ubyBsZWZ0IHNoaWZ0IGFzIGxlbmd0aCBjb3VsZCBiZSAzMCwzMVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Qml0KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIW5vZGUucmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5yaWdodCA9IG5ldyBUcmVlTm9kZSgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLmxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5sZWZ0ID0gbmV3IFRyZWVOb2RlKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoamogPT09IDAgJiYgIW5vZGUudmFsKSB7XG4gICAgICAgICAgICAgICAgICBub2RlLnZhbCA9IGVudHJ5WzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRlY29kZUx1dDogZGVjb2RlTHV0LFxuICAgICAgICAgIG51bUJpdHNMVVRRaWNrOiBudW1CaXRzTFVUUWljayxcbiAgICAgICAgICBudW1CaXRzTFVUOiBudW1CaXRzTFVULFxuICAgICAgICAgIHRyZWU6IHRyZWUsXG4gICAgICAgICAgc3R1ZmZlZERhdGE6IHN0dWZmZWREYXRhLFxuICAgICAgICAgIHNyY1B0cjogc3JjUHRyLFxuICAgICAgICAgIGJpdFBvczogYml0UG9zXG4gICAgICAgIH07XG4gICAgICB9LFxuXG4gICAgICByZWFkSHVmZm1hbjogZnVuY3Rpb24oaW5wdXQsIGRhdGEsIE91dFBpeGVsVHlwZUFycmF5LCB1c2VCU1FGb3JPdXRwdXREaW0pIHtcbiAgICAgICAgdmFyIGhlYWRlckluZm8gPSBkYXRhLmhlYWRlckluZm87XG4gICAgICAgIHZhciBudW1EaW1zID0gaGVhZGVySW5mby5udW1EaW1zO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gZGF0YS5oZWFkZXJJbmZvLmhlaWdodDtcbiAgICAgICAgdmFyIHdpZHRoID0gZGF0YS5oZWFkZXJJbmZvLndpZHRoO1xuICAgICAgICB2YXIgbnVtUGl4ZWxzID0gd2lkdGggKiBoZWlnaHQ7XG4gICAgICAgIC8vdmFyIHNpemVfbWF4ID0gMSA8PCBCSVRTX01BWDtcbiAgICAgICAgLyogKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICogcmVhZGluZyBodWZmbWFuIHN0cnVjdHVyZSBpbmZvXG4gICAgICAgICoqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIHZhciBodWZmbWFuSW5mbyA9IHRoaXMucmVhZEh1ZmZtYW5UcmVlKGlucHV0LCBkYXRhKTtcbiAgICAgICAgdmFyIGRlY29kZUx1dCA9IGh1ZmZtYW5JbmZvLmRlY29kZUx1dDtcbiAgICAgICAgdmFyIHRyZWUgPSBodWZmbWFuSW5mby50cmVlO1xuICAgICAgICAvL3N0dWZmZWREYXRhIGluY2x1ZGVzIGh1ZmZtYW4gaGVhZGVyc1xuICAgICAgICB2YXIgc3R1ZmZlZERhdGEgPSBodWZmbWFuSW5mby5zdHVmZmVkRGF0YTtcbiAgICAgICAgdmFyIHNyY1B0ciA9IGh1ZmZtYW5JbmZvLnNyY1B0cjtcbiAgICAgICAgdmFyIGJpdFBvcyA9IGh1ZmZtYW5JbmZvLmJpdFBvcztcbiAgICAgICAgdmFyIG51bUJpdHNMVVRRaWNrID0gaHVmZm1hbkluZm8ubnVtQml0c0xVVFFpY2s7XG4gICAgICAgIHZhciBudW1CaXRzTFVUID0gaHVmZm1hbkluZm8ubnVtQml0c0xVVDtcbiAgICAgICAgdmFyIG9mZnNldCA9IGRhdGEuaGVhZGVySW5mby5pbWFnZVR5cGUgPT09IDAgPyAxMjggOiAwO1xuICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAqICBkZWNvZGVcbiAgICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICB2YXIgbm9kZSwgdmFsLCBkZWx0YSwgbWFzayA9IGRhdGEucGl4ZWxzLnJlc3VsdE1hc2ssIHZhbFRtcCwgdmFsVG1wUXVpY2ssIGN1cnJlbnRCaXQ7XG4gICAgICAgIHZhciBpLCBqLCBrLCBpaTtcbiAgICAgICAgdmFyIHByZXZWYWwgPSAwO1xuICAgICAgICBpZiAoYml0UG9zID4gMCkge1xuICAgICAgICAgIHNyY1B0cisrO1xuICAgICAgICAgIGJpdFBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdvcmQgPSBzdHVmZmVkRGF0YVtzcmNQdHJdO1xuICAgICAgICB2YXIgZGVsdGFFbmNvZGUgPSBkYXRhLmVuY29kZU1vZGUgPT09IDE7XG4gICAgICAgIHZhciByZXN1bHRQaXhlbHNBbGxEaW0gPSBuZXcgT3V0UGl4ZWxUeXBlQXJyYXkobnVtUGl4ZWxzICogbnVtRGltcyk7XG4gICAgICAgIHZhciByZXN1bHRQaXhlbHMgPSByZXN1bHRQaXhlbHNBbGxEaW07XG4gICAgICAgIHZhciBpRGltO1xuICAgICAgICAvLyBUT0RPOiByZWV2YWx1YXRlIHRoZSBuZWVkIHRvIGtlZXAgaW5saW5lZCBkZWNvZGluZyBjb2RlIGFzIElFIHN1cHBvcnQgaXMgcGhhc2luZyBvdXRcbiAgICAgICAgaWYgKG51bURpbXMgPCAyIHx8IGRlbHRhRW5jb2RlKSB7XG4gICAgICAgICAgZm9yIChpRGltID0gMDsgaURpbSA8IG51bURpbXM7IGlEaW0rKykge1xuICAgICAgICAgICAgaWYgKG51bURpbXMgPiAxKSB7XG4gICAgICAgICAgICAgIC8vZ2V0IHRoZSBtZW0gYmxvY2sgb2YgY3VycmVudCBkaW1lbnNpb25cbiAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzID0gbmV3IE91dFBpeGVsVHlwZUFycmF5KHJlc3VsdFBpeGVsc0FsbERpbS5idWZmZXIsIG51bVBpeGVscyAqIGlEaW0sIG51bVBpeGVscyk7XG4gICAgICAgICAgICAgIHByZXZWYWwgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEuaGVhZGVySW5mby5udW1WYWxpZFBpeGVsID09PSB3aWR0aCAqIGhlaWdodCkgeyAvL2FsbCB2YWxpZFxuICAgICAgICAgICAgICBmb3IgKGsgPSAwLCBpID0gMDsgaSA8IGhlaWdodDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHdpZHRoOyBqKyssIGsrKykge1xuICAgICAgICAgICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgICAgICAgICAgIHZhbFRtcCA9ICh3b3JkIDw8IGJpdFBvcykgPj4+ICgzMiAtIG51bUJpdHNMVVRRaWNrKTtcbiAgICAgICAgICAgICAgICAgIHZhbFRtcFF1aWNrID0gdmFsVG1wOy8vID4+PiBkZWx0YUJpdHM7XG4gICAgICAgICAgICAgICAgICBpZiAoMzIgLSBiaXRQb3MgPCBudW1CaXRzTFVUUWljaykge1xuICAgICAgICAgICAgICAgICAgICB2YWxUbXAgfD0gKChzdHVmZmVkRGF0YVtzcmNQdHIgKyAxXSkgPj4+ICg2NCAtIGJpdFBvcyAtIG51bUJpdHNMVVRRaWNrKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbFRtcFF1aWNrID0gdmFsVG1wOy8vID4+PiBkZWx0YUJpdHM7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoZGVjb2RlTHV0W3ZhbFRtcFF1aWNrXSkgICAgLy8gaWYgdGhlcmUsIG1vdmUgdGhlIGNvcnJlY3QgbnVtYmVyIG9mIGJpdHMgYW5kIGRvbmVcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gZGVjb2RlTHV0W3ZhbFRtcFF1aWNrXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgYml0UG9zICs9IGRlY29kZUx1dFt2YWxUbXBRdWlja11bMF07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsVG1wID0gKHdvcmQgPDwgYml0UG9zKSA+Pj4gKDMyIC0gbnVtQml0c0xVVCk7XG4gICAgICAgICAgICAgICAgICAgIHZhbFRtcFF1aWNrID0gdmFsVG1wOy8vID4+PiBkZWx0YUJpdHM7XG4gICAgICAgICAgICAgICAgICAgIGlmICgzMiAtIGJpdFBvcyA8IG51bUJpdHNMVVQpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YWxUbXAgfD0gKChzdHVmZmVkRGF0YVtzcmNQdHIgKyAxXSkgPj4+ICg2NCAtIGJpdFBvcyAtIG51bUJpdHNMVVQpKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YWxUbXBRdWljayA9IHZhbFRtcDsvLyA+Pj4gZGVsdGFCaXRzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSB0cmVlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGlpID0gMDsgaWkgPCBudW1CaXRzTFVUOyBpaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVudEJpdCA9IHZhbFRtcCA+Pj4gKG51bUJpdHNMVVQgLSBpaSAtIDEpICYgMTtcbiAgICAgICAgICAgICAgICAgICAgICBub2RlID0gY3VycmVudEJpdCA/IG5vZGUucmlnaHQgOiBub2RlLmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCEobm9kZS5sZWZ0IHx8IG5vZGUucmlnaHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBub2RlLnZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpdFBvcyA9IGJpdFBvcyArIGlpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgaWYgKGJpdFBvcyA+PSAzMikge1xuICAgICAgICAgICAgICAgICAgICBiaXRQb3MgLT0gMzI7XG4gICAgICAgICAgICAgICAgICAgIHNyY1B0cisrO1xuICAgICAgICAgICAgICAgICAgICB3b3JkID0gc3R1ZmZlZERhdGFbc3JjUHRyXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgIGRlbHRhID0gdmFsIC0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgaWYgKGRlbHRhRW5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIGRlbHRhICs9IHByZXZWYWw7ICAgIC8vIHVzZSBvdmVyZmxvd1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGVsdGEgKz0gcmVzdWx0UGl4ZWxzW2sgLSB3aWR0aF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGVsdGEgKz0gcHJldlZhbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWx0YSAmPSAweEZGOyAvL292ZXJmbG93XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1trXSA9IGRlbHRhOy8vb3ZlcmZsb3dcbiAgICAgICAgICAgICAgICAgICAgcHJldlZhbCA9IGRlbHRhO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1trXSA9IGRlbHRhO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7IC8vbm90IGFsbCB2YWxpZCwgdXNlIG1hc2tcbiAgICAgICAgICAgICAgZm9yIChrID0gMCwgaSA9IDA7IGkgPCBoZWlnaHQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB3aWR0aDsgaisrLCBrKyspIHtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXNrW2tdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhbFRtcCA9ICh3b3JkIDw8IGJpdFBvcykgPj4+ICgzMiAtIG51bUJpdHNMVVRRaWNrKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsVG1wUXVpY2sgPSB2YWxUbXA7Ly8gPj4+IGRlbHRhQml0cztcbiAgICAgICAgICAgICAgICAgICAgaWYgKDMyIC0gYml0UG9zIDwgbnVtQml0c0xVVFFpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YWxUbXAgfD0gKChzdHVmZmVkRGF0YVtzcmNQdHIgKyAxXSkgPj4+ICg2NCAtIGJpdFBvcyAtIG51bUJpdHNMVVRRaWNrKSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsVG1wUXVpY2sgPSB2YWxUbXA7Ly8gPj4+IGRlbHRhQml0cztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVjb2RlTHV0W3ZhbFRtcFF1aWNrXSkgICAgLy8gaWYgdGhlcmUsIG1vdmUgdGhlIGNvcnJlY3QgbnVtYmVyIG9mIGJpdHMgYW5kIGRvbmVcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGRlY29kZUx1dFt2YWxUbXBRdWlja11bMV07XG4gICAgICAgICAgICAgICAgICAgICAgYml0UG9zICs9IGRlY29kZUx1dFt2YWxUbXBRdWlja11bMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsVG1wID0gKHdvcmQgPDwgYml0UG9zKSA+Pj4gKDMyIC0gbnVtQml0c0xVVCk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsVG1wUXVpY2sgPSB2YWxUbXA7Ly8gPj4+IGRlbHRhQml0cztcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoMzIgLSBiaXRQb3MgPCBudW1CaXRzTFVUKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxUbXAgfD0gKChzdHVmZmVkRGF0YVtzcmNQdHIgKyAxXSkgPj4+ICg2NCAtIGJpdFBvcyAtIG51bUJpdHNMVVQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbFRtcFF1aWNrID0gdmFsVG1wOy8vID4+PiBkZWx0YUJpdHM7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSB0cmVlO1xuICAgICAgICAgICAgICAgICAgICAgIGZvciAoaWkgPSAwOyBpaSA8IG51bUJpdHNMVVQ7IGlpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRCaXQgPSB2YWxUbXAgPj4+IChudW1CaXRzTFVUIC0gaWkgLSAxKSAmIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gY3VycmVudEJpdCA/IG5vZGUucmlnaHQgOiBub2RlLmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShub2RlLmxlZnQgfHwgbm9kZS5yaWdodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gbm9kZS52YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJpdFBvcyA9IGJpdFBvcyArIGlpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChiaXRQb3MgPj0gMzIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBiaXRQb3MgLT0gMzI7XG4gICAgICAgICAgICAgICAgICAgICAgc3JjUHRyKys7XG4gICAgICAgICAgICAgICAgICAgICAgd29yZCA9IHN0dWZmZWREYXRhW3NyY1B0cl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgZGVsdGEgPSB2YWwgLSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWx0YUVuY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChqID4gMCAmJiBtYXNrW2sgLSAxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGEgKz0gcHJldlZhbDsgICAgLy8gdXNlIG92ZXJmbG93XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGkgPiAwICYmIG1hc2tbayAtIHdpZHRoXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGEgKz0gcmVzdWx0UGl4ZWxzW2sgLSB3aWR0aF07XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGEgKz0gcHJldlZhbDtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgZGVsdGEgJj0gMHhGRjsgLy9vdmVyZmxvd1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1trXSA9IGRlbHRhOy8vb3ZlcmZsb3dcbiAgICAgICAgICAgICAgICAgICAgICBwcmV2VmFsID0gZGVsdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzW2tdID0gZGVsdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZm9yIChrID0gMCwgaSA9IDA7IGkgPCBoZWlnaHQ7IGkrKykge1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHdpZHRoOyBqKyspIHtcbiAgICAgICAgICAgICAgayA9IGkgKiB3aWR0aCArIGo7XG4gICAgICAgICAgICAgIGlmICghbWFzayB8fCBtYXNrW2tdKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpRGltID0gMDsgaURpbSA8IG51bURpbXM7IGlEaW0rKywgays9bnVtUGl4ZWxzKSB7XG4gICAgICAgICAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICAgICAgICAgICAgdmFsVG1wID0gKHdvcmQgPDwgYml0UG9zKSA+Pj4gKDMyIC0gbnVtQml0c0xVVFFpY2spO1xuICAgICAgICAgICAgICAgICAgdmFsVG1wUXVpY2sgPSB2YWxUbXA7XG4gICAgICAgICAgICAgICAgICBpZiAoMzIgLSBiaXRQb3MgPCBudW1CaXRzTFVUUWljaykge1xuICAgICAgICAgICAgICAgICAgICB2YWxUbXAgfD0gKChzdHVmZmVkRGF0YVtzcmNQdHIgKyAxXSkgPj4+ICg2NCAtIGJpdFBvcyAtIG51bUJpdHNMVVRRaWNrKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbFRtcFF1aWNrID0gdmFsVG1wO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGRlY29kZUx1dFt2YWxUbXBRdWlja10pXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IGRlY29kZUx1dFt2YWxUbXBRdWlja11bMV07XG4gICAgICAgICAgICAgICAgICAgIGJpdFBvcyArPSBkZWNvZGVMdXRbdmFsVG1wUXVpY2tdWzBdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbFRtcCA9ICh3b3JkIDw8IGJpdFBvcykgPj4+ICgzMiAtIG51bUJpdHNMVVQpO1xuICAgICAgICAgICAgICAgICAgICB2YWxUbXBRdWljayA9IHZhbFRtcDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKDMyIC0gYml0UG9zIDwgbnVtQml0c0xVVCkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhbFRtcCB8PSAoKHN0dWZmZWREYXRhW3NyY1B0ciArIDFdKSA+Pj4gKDY0IC0gYml0UG9zIC0gbnVtQml0c0xVVCkpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhbFRtcFF1aWNrID0gdmFsVG1wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSB0cmVlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGlpID0gMDsgaWkgPCBudW1CaXRzTFVUOyBpaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVudEJpdCA9IHZhbFRtcCA+Pj4gKG51bUJpdHNMVVQgLSBpaSAtIDEpICYgMTtcbiAgICAgICAgICAgICAgICAgICAgICBub2RlID0gY3VycmVudEJpdCA/IG5vZGUucmlnaHQgOiBub2RlLmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCEobm9kZS5sZWZ0IHx8IG5vZGUucmlnaHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBub2RlLnZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpdFBvcyA9IGJpdFBvcyArIGlpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAoYml0UG9zID49IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgIGJpdFBvcyAtPSAzMjtcbiAgICAgICAgICAgICAgICAgICAgc3JjUHRyKys7XG4gICAgICAgICAgICAgICAgICAgIHdvcmQgPSBzdHVmZmVkRGF0YVtzcmNQdHJdO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBkZWx0YSA9IHZhbCAtIG9mZnNldDtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1trXSA9IGRlbHRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkYXRhLnB0ciA9IGRhdGEucHRyICsgKHNyY1B0ciArIDEpICogNCArIChiaXRQb3MgPiAwID8gNCA6IDApO1xuICAgICAgICBkYXRhLnBpeGVscy5yZXN1bHRQaXhlbHMgPSByZXN1bHRQaXhlbHNBbGxEaW07XG4gICAgICAgIC8vc3dhcCBmb3IgQklQIGxheW91dFxuICAgICAgICBpZiAobnVtRGltcyA+IDEgJiYgIXVzZUJTUUZvck91dHB1dERpbSkge1xuICAgICAgICAgIGRhdGEucGl4ZWxzLnJlc3VsdFBpeGVscyA9IExlcmMySGVscGVycy5zd2FwRGltZW5zaW9uT3JkZXIocmVzdWx0UGl4ZWxzQWxsRGltLCBudW1QaXhlbHMsIG51bURpbXMsIE91dFBpeGVsVHlwZUFycmF5KTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZGVjb2RlQml0czogZnVuY3Rpb24oaW5wdXQsIGRhdGEsIGJsb2NrRGF0YUJ1ZmZlciwgb2Zmc2V0LCBpRGltKSB7XG4gICAgICAgIHtcbiAgICAgICAgICAvL2JpdHN0dWZmIGVuY29kaW5nIGlzIDNcbiAgICAgICAgICB2YXIgaGVhZGVySW5mbyA9IGRhdGEuaGVhZGVySW5mbztcbiAgICAgICAgICB2YXIgZmlsZVZlcnNpb24gPSBoZWFkZXJJbmZvLmZpbGVWZXJzaW9uO1xuICAgICAgICAgIC8vdmFyIGJsb2NrID0ge307XG4gICAgICAgICAgdmFyIGJsb2NrUHRyID0gMDtcbiAgICAgICAgICB2YXIgdmlld0J5dGVMZW5ndGggPSAoKGlucHV0LmJ5dGVMZW5ndGggLSBkYXRhLnB0cikgPj0gNSkgPyA1IDogKGlucHV0LmJ5dGVMZW5ndGggLSBkYXRhLnB0cik7XG4gICAgICAgICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcoaW5wdXQsIGRhdGEucHRyLCB2aWV3Qnl0ZUxlbmd0aCk7XG4gICAgICAgICAgdmFyIGhlYWRlckJ5dGUgPSB2aWV3LmdldFVpbnQ4KDApO1xuICAgICAgICAgIGJsb2NrUHRyKys7XG4gICAgICAgICAgdmFyIGJpdHM2NyA9IGhlYWRlckJ5dGUgPj4gNjtcbiAgICAgICAgICB2YXIgbiA9IChiaXRzNjcgPT09IDApID8gNCA6IDMgLSBiaXRzNjc7XG4gICAgICAgICAgdmFyIGRvTHV0ID0gKGhlYWRlckJ5dGUgJiAzMikgPiAwID8gdHJ1ZSA6IGZhbHNlOy8vNXRoIGJpdFxuICAgICAgICAgIHZhciBudW1CaXRzID0gaGVhZGVyQnl0ZSAmIDMxO1xuICAgICAgICAgIHZhciBudW1FbGVtZW50cyA9IDA7XG4gICAgICAgICAgaWYgKG4gPT09IDEpIHtcbiAgICAgICAgICAgIG51bUVsZW1lbnRzID0gdmlldy5nZXRVaW50OChibG9ja1B0cik7IGJsb2NrUHRyKys7XG4gICAgICAgICAgfSBlbHNlIGlmIChuID09PSAyKSB7XG4gICAgICAgICAgICBudW1FbGVtZW50cyA9IHZpZXcuZ2V0VWludDE2KGJsb2NrUHRyLCB0cnVlKTsgYmxvY2tQdHIgKz0gMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKG4gPT09IDQpIHtcbiAgICAgICAgICAgIG51bUVsZW1lbnRzID0gdmlldy5nZXRVaW50MzIoYmxvY2tQdHIsIHRydWUpOyBibG9ja1B0ciArPSA0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBcIkludmFsaWQgdmFsaWQgcGl4ZWwgY291bnQgdHlwZVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvL2ZpeDogaHVmZm1hbiBjb2RlcyBhcmUgYml0IHN0dWZmZWQsIGJ1dCBub3QgYm91bmQgYnkgZGF0YSdzIG1heCB2YWx1ZSwgc28gbmVlZCB0byB1c2Ugb3JpZ2luYWxVbnN0dWZmXG4gICAgICAgICAgLy9vZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgICAgICAgICB2YXIgc2NhbGUgPSAyICogaGVhZGVySW5mby5tYXhaRXJyb3I7XG4gICAgICAgICAgdmFyIHN0dWZmZWREYXRhLCBhcnJheUJ1Ziwgc3RvcmU4LCBkYXRhQnl0ZXMsIGRhdGFXb3JkcztcbiAgICAgICAgICB2YXIgbHV0QXJyLCBsdXREYXRhLCBsdXRCeXRlcywgbHV0Qml0c1BlckVsZW1lbnQsIGJpdHNQZXJQaXhlbDtcbiAgICAgICAgICB2YXIgek1heCA9IGhlYWRlckluZm8ubnVtRGltcyA+IDEgPyBoZWFkZXJJbmZvLm1heFZhbHVlc1tpRGltXSA6IGhlYWRlckluZm8uek1heDtcbiAgICAgICAgICBpZiAoZG9MdXQpIHtcbiAgICAgICAgICAgIGRhdGEuY291bnRlci5sdXQrKztcbiAgICAgICAgICAgIGx1dEJ5dGVzID0gdmlldy5nZXRVaW50OChibG9ja1B0cik7XG4gICAgICAgICAgICBsdXRCaXRzUGVyRWxlbWVudCA9IG51bUJpdHM7XG4gICAgICAgICAgICBibG9ja1B0cisrO1xuICAgICAgICAgICAgZGF0YUJ5dGVzID0gTWF0aC5jZWlsKChsdXRCeXRlcyAtIDEpICogbnVtQml0cyAvIDgpO1xuICAgICAgICAgICAgZGF0YVdvcmRzID0gTWF0aC5jZWlsKGRhdGFCeXRlcyAvIDQpO1xuICAgICAgICAgICAgYXJyYXlCdWYgPSBuZXcgQXJyYXlCdWZmZXIoZGF0YVdvcmRzICogNCk7XG4gICAgICAgICAgICBzdG9yZTggPSBuZXcgVWludDhBcnJheShhcnJheUJ1Zik7XG5cbiAgICAgICAgICAgIGRhdGEucHRyICs9IGJsb2NrUHRyO1xuICAgICAgICAgICAgc3RvcmU4LnNldChuZXcgVWludDhBcnJheShpbnB1dCwgZGF0YS5wdHIsIGRhdGFCeXRlcykpO1xuXG4gICAgICAgICAgICBsdXREYXRhID0gbmV3IFVpbnQzMkFycmF5KGFycmF5QnVmKTtcbiAgICAgICAgICAgIGRhdGEucHRyICs9IGRhdGFCeXRlcztcblxuICAgICAgICAgICAgYml0c1BlclBpeGVsID0gMDtcbiAgICAgICAgICAgIHdoaWxlICgobHV0Qnl0ZXMgLSAxKSA+Pj4gYml0c1BlclBpeGVsKSB7XG4gICAgICAgICAgICAgIGJpdHNQZXJQaXhlbCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YUJ5dGVzID0gTWF0aC5jZWlsKG51bUVsZW1lbnRzICogYml0c1BlclBpeGVsIC8gOCk7XG4gICAgICAgICAgICBkYXRhV29yZHMgPSBNYXRoLmNlaWwoZGF0YUJ5dGVzIC8gNCk7XG4gICAgICAgICAgICBhcnJheUJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcihkYXRhV29yZHMgKiA0KTtcbiAgICAgICAgICAgIHN0b3JlOCA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmKTtcbiAgICAgICAgICAgIHN0b3JlOC5zZXQobmV3IFVpbnQ4QXJyYXkoaW5wdXQsIGRhdGEucHRyLCBkYXRhQnl0ZXMpKTtcbiAgICAgICAgICAgIHN0dWZmZWREYXRhID0gbmV3IFVpbnQzMkFycmF5KGFycmF5QnVmKTtcbiAgICAgICAgICAgIGRhdGEucHRyICs9IGRhdGFCeXRlcztcbiAgICAgICAgICAgIGlmIChmaWxlVmVyc2lvbiA+PSAzKSB7XG4gICAgICAgICAgICAgIGx1dEFyciA9IEJpdFN0dWZmZXIudW5zdHVmZkxVVDIobHV0RGF0YSwgbnVtQml0cywgbHV0Qnl0ZXMgLSAxLCBvZmZzZXQsIHNjYWxlLCB6TWF4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBsdXRBcnIgPSBCaXRTdHVmZmVyLnVuc3R1ZmZMVVQobHV0RGF0YSwgbnVtQml0cywgbHV0Qnl0ZXMgLSAxLCBvZmZzZXQsIHNjYWxlLCB6TWF4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vbHV0QXJyLnVuc2hpZnQoMCk7XG4gICAgICAgICAgICBpZiAoZmlsZVZlcnNpb24gPj0gMykge1xuICAgICAgICAgICAgICAvL0JpdFN0dWZmZXIudW5zdHVmZjIoYmxvY2ssIGJsb2NrRGF0YUJ1ZmZlciwgaGVhZGVySW5mby56TWF4KTtcbiAgICAgICAgICAgICAgQml0U3R1ZmZlci51bnN0dWZmMihzdHVmZmVkRGF0YSwgYmxvY2tEYXRhQnVmZmVyLCBiaXRzUGVyUGl4ZWwsIG51bUVsZW1lbnRzLCBsdXRBcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIEJpdFN0dWZmZXIudW5zdHVmZihzdHVmZmVkRGF0YSwgYmxvY2tEYXRhQnVmZmVyLCBiaXRzUGVyUGl4ZWwsIG51bUVsZW1lbnRzLCBsdXRBcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5kZWJ1ZyhcImJpdHN0dWZmZXJcIik7XG4gICAgICAgICAgICBkYXRhLmNvdW50ZXIuYml0c3R1ZmZlcisrO1xuICAgICAgICAgICAgYml0c1BlclBpeGVsID0gbnVtQml0cztcbiAgICAgICAgICAgIGRhdGEucHRyICs9IGJsb2NrUHRyO1xuICAgICAgICAgICAgaWYgKGJpdHNQZXJQaXhlbCA+IDApIHtcbiAgICAgICAgICAgICAgZGF0YUJ5dGVzID0gTWF0aC5jZWlsKG51bUVsZW1lbnRzICogYml0c1BlclBpeGVsIC8gOCk7XG4gICAgICAgICAgICAgIGRhdGFXb3JkcyA9IE1hdGguY2VpbChkYXRhQnl0ZXMgLyA0KTtcbiAgICAgICAgICAgICAgYXJyYXlCdWYgPSBuZXcgQXJyYXlCdWZmZXIoZGF0YVdvcmRzICogNCk7XG4gICAgICAgICAgICAgIHN0b3JlOCA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmKTtcbiAgICAgICAgICAgICAgc3RvcmU4LnNldChuZXcgVWludDhBcnJheShpbnB1dCwgZGF0YS5wdHIsIGRhdGFCeXRlcykpO1xuICAgICAgICAgICAgICBzdHVmZmVkRGF0YSA9IG5ldyBVaW50MzJBcnJheShhcnJheUJ1Zik7XG4gICAgICAgICAgICAgIGRhdGEucHRyICs9IGRhdGFCeXRlcztcbiAgICAgICAgICAgICAgaWYgKGZpbGVWZXJzaW9uID49IDMpIHtcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIEJpdFN0dWZmZXIub3JpZ2luYWxVbnN0dWZmMihzdHVmZmVkRGF0YSwgYmxvY2tEYXRhQnVmZmVyLCBiaXRzUGVyUGl4ZWwsIG51bUVsZW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBCaXRTdHVmZmVyLnVuc3R1ZmYyKHN0dWZmZWREYXRhLCBibG9ja0RhdGFCdWZmZXIsIGJpdHNQZXJQaXhlbCwgbnVtRWxlbWVudHMsIGZhbHNlLCBvZmZzZXQsIHNjYWxlLCB6TWF4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBCaXRTdHVmZmVyLm9yaWdpbmFsVW5zdHVmZihzdHVmZmVkRGF0YSwgYmxvY2tEYXRhQnVmZmVyLCBiaXRzUGVyUGl4ZWwsIG51bUVsZW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBCaXRTdHVmZmVyLnVuc3R1ZmYoc3R1ZmZlZERhdGEsIGJsb2NrRGF0YUJ1ZmZlciwgYml0c1BlclBpeGVsLCBudW1FbGVtZW50cywgZmFsc2UsIG9mZnNldCwgc2NhbGUsIHpNYXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICB9LFxuXG4gICAgICByZWFkVGlsZXM6IGZ1bmN0aW9uKGlucHV0LCBkYXRhLCBPdXRQaXhlbFR5cGVBcnJheSwgdXNlQlNRRm9yT3V0cHV0RGltKSB7XG4gICAgICAgIHZhciBoZWFkZXJJbmZvID0gZGF0YS5oZWFkZXJJbmZvO1xuICAgICAgICB2YXIgd2lkdGggPSBoZWFkZXJJbmZvLndpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gaGVhZGVySW5mby5oZWlnaHQ7XG4gICAgICAgIHZhciBudW1QaXhlbHMgPSB3aWR0aCAqIGhlaWdodDtcbiAgICAgICAgdmFyIG1pY3JvQmxvY2tTaXplID0gaGVhZGVySW5mby5taWNyb0Jsb2NrU2l6ZTtcbiAgICAgICAgdmFyIGltYWdlVHlwZSA9IGhlYWRlckluZm8uaW1hZ2VUeXBlO1xuICAgICAgICB2YXIgZGF0YVR5cGVTaXplID0gTGVyYzJIZWxwZXJzLmdldERhdGFUeXBlU2l6ZShpbWFnZVR5cGUpO1xuICAgICAgICB2YXIgbnVtQmxvY2tzWCA9IE1hdGguY2VpbCh3aWR0aCAvIG1pY3JvQmxvY2tTaXplKTtcbiAgICAgICAgdmFyIG51bUJsb2Nrc1kgPSBNYXRoLmNlaWwoaGVpZ2h0IC8gbWljcm9CbG9ja1NpemUpO1xuICAgICAgICBkYXRhLnBpeGVscy5udW1CbG9ja3NZID0gbnVtQmxvY2tzWTtcbiAgICAgICAgZGF0YS5waXhlbHMubnVtQmxvY2tzWCA9IG51bUJsb2Nrc1g7XG4gICAgICAgIGRhdGEucGl4ZWxzLnB0ciA9IDA7XG4gICAgICAgIHZhciByb3cgPSAwLCBjb2wgPSAwLCBibG9ja1kgPSAwLCBibG9ja1ggPSAwLCB0aGlzQmxvY2tIZWlnaHQgPSAwLCB0aGlzQmxvY2tXaWR0aCA9IDAsIGJ5dGVzTGVmdCA9IDAsIGhlYWRlckJ5dGUgPSAwLCBiaXRzNjcgPSAwLCB0ZXN0Q29kZSA9IDAsIG91dFB0ciA9IDAsIG91dFN0cmlkZSA9IDAsIG51bUJ5dGVzID0gMCwgYnl0ZXNsZWZ0ID0gMCwgeiA9IDAsIGJsb2NrUHRyID0gMDtcbiAgICAgICAgdmFyIHZpZXcsIGJsb2NrLCBhcnJheUJ1Ziwgc3RvcmU4LCByYXdEYXRhO1xuICAgICAgICB2YXIgYmxvY2tFbmNvZGluZztcbiAgICAgICAgdmFyIGJsb2NrRGF0YUJ1ZmZlciA9IG5ldyBPdXRQaXhlbFR5cGVBcnJheShtaWNyb0Jsb2NrU2l6ZSAqIG1pY3JvQmxvY2tTaXplKTtcbiAgICAgICAgdmFyIGxhc3RCbG9ja0hlaWdodCA9IChoZWlnaHQgJSBtaWNyb0Jsb2NrU2l6ZSkgfHwgbWljcm9CbG9ja1NpemU7XG4gICAgICAgIHZhciBsYXN0QmxvY2tXaWR0aCA9ICh3aWR0aCAlIG1pY3JvQmxvY2tTaXplKSB8fCBtaWNyb0Jsb2NrU2l6ZTtcbiAgICAgICAgdmFyIG9mZnNldFR5cGUsIG9mZnNldDtcbiAgICAgICAgdmFyIG51bURpbXMgPSBoZWFkZXJJbmZvLm51bURpbXMsIGlEaW07XG4gICAgICAgIHZhciBtYXNrID0gZGF0YS5waXhlbHMucmVzdWx0TWFzaztcbiAgICAgICAgdmFyIHJlc3VsdFBpeGVscyA9IGRhdGEucGl4ZWxzLnJlc3VsdFBpeGVscztcbiAgICAgICAgdmFyIGZpbGVWZXJzaW9uID0gaGVhZGVySW5mby5maWxlVmVyc2lvbjtcbiAgICAgICAgdmFyIGZpbGVWZXJzaW9uQ2hlY2tOdW0gPSBmaWxlVmVyc2lvbiA+PSA1ID8gMTQgOiAxNTtcbiAgICAgICAgdmFyIGlzRGlmZkVuY29kaW5nO1xuICAgICAgICB2YXIgek1heCA9IGhlYWRlckluZm8uek1heDtcbiAgICAgICAgLy92YXIgcmVzdWx0UGl4ZWxzQWxsRGltID0gcmVzdWx0UGl4ZWxzO1xuICAgICAgICB2YXIgcmVzdWx0UGl4ZWxzUHJldkRpbTtcbiAgICAgICAgZm9yIChibG9ja1kgPSAwOyBibG9ja1kgPCBudW1CbG9ja3NZOyBibG9ja1krKykge1xuICAgICAgICAgIHRoaXNCbG9ja0hlaWdodCA9IChibG9ja1kgIT09IG51bUJsb2Nrc1kgLSAxKSA/IG1pY3JvQmxvY2tTaXplIDogbGFzdEJsb2NrSGVpZ2h0O1xuICAgICAgICAgIGZvciAoYmxvY2tYID0gMDsgYmxvY2tYIDwgbnVtQmxvY2tzWDsgYmxvY2tYKyspIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5kZWJ1ZyhcInlcIiArIGJsb2NrWSArIFwiIHhcIiArIGJsb2NrWCk7XG4gICAgICAgICAgICB0aGlzQmxvY2tXaWR0aCA9IChibG9ja1ggIT09IG51bUJsb2Nrc1ggLSAxKSA/IG1pY3JvQmxvY2tTaXplIDogbGFzdEJsb2NrV2lkdGg7XG5cbiAgICAgICAgICAgIG91dFB0ciA9IGJsb2NrWSAqIHdpZHRoICogbWljcm9CbG9ja1NpemUgKyBibG9ja1ggKiBtaWNyb0Jsb2NrU2l6ZTtcbiAgICAgICAgICAgIG91dFN0cmlkZSA9IHdpZHRoIC0gdGhpc0Jsb2NrV2lkdGg7XG5cbiAgICAgICAgICAgIGZvciAoaURpbSA9IDA7IGlEaW0gPCBudW1EaW1zOyBpRGltKyspIHtcbiAgICAgICAgICAgICAgaWYgKG51bURpbXMgPiAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzUHJldkRpbSA9IHJlc3VsdFBpeGVscztcbiAgICAgICAgICAgICAgICBvdXRQdHIgPSBibG9ja1kgKiB3aWR0aCAqIG1pY3JvQmxvY2tTaXplICsgYmxvY2tYICogbWljcm9CbG9ja1NpemU7XG4gICAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzID0gbmV3IE91dFBpeGVsVHlwZUFycmF5KGRhdGEucGl4ZWxzLnJlc3VsdFBpeGVscy5idWZmZXIsIG51bVBpeGVscyAqIGlEaW0gKiBkYXRhVHlwZVNpemUsIG51bVBpeGVscyk7XG4gICAgICAgICAgICAgICAgek1heCA9IGhlYWRlckluZm8ubWF4VmFsdWVzW2lEaW1dO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1ByZXZEaW0gPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJ5dGVzTGVmdCA9IGlucHV0LmJ5dGVMZW5ndGggLSBkYXRhLnB0cjtcbiAgICAgICAgICAgICAgdmlldyA9IG5ldyBEYXRhVmlldyhpbnB1dCwgZGF0YS5wdHIsIE1hdGgubWluKDEwLCBieXRlc0xlZnQpKTtcbiAgICAgICAgICAgICAgYmxvY2sgPSB7fTtcbiAgICAgICAgICAgICAgYmxvY2tQdHIgPSAwO1xuICAgICAgICAgICAgICBoZWFkZXJCeXRlID0gdmlldy5nZXRVaW50OCgwKTtcbiAgICAgICAgICAgICAgYmxvY2tQdHIrKztcbiAgICAgICAgICAgICAgaXNEaWZmRW5jb2RpbmcgPSBoZWFkZXJJbmZvLmZpbGVWZXJzaW9uID49IDUgPyBoZWFkZXJCeXRlICYgNCA6IDA7XG4gICAgICAgICAgICAgIGJpdHM2NyA9IChoZWFkZXJCeXRlID4+IDYpICYgMHhGRjtcbiAgICAgICAgICAgICAgdGVzdENvZGUgPSAoaGVhZGVyQnl0ZSA+PiAyKSAmIGZpbGVWZXJzaW9uQ2hlY2tOdW07ICAgIC8vIHVzZSBiaXRzIDIzNDUgZm9yIGludGVncml0eSBjaGVja1xuICAgICAgICAgICAgICBpZiAodGVzdENvZGUgIT09ICgoKGJsb2NrWCAqIG1pY3JvQmxvY2tTaXplKSA+PiAzKSAmIGZpbGVWZXJzaW9uQ2hlY2tOdW0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJpbnRlZ3JpdHkgaXNzdWVcIjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChpc0RpZmZFbmNvZGluZyAmJiBpRGltID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJpbnRlZ3JpdHkgaXNzdWVcIjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJsb2NrRW5jb2RpbmcgPSBoZWFkZXJCeXRlICYgMztcbiAgICAgICAgICAgICAgaWYgKGJsb2NrRW5jb2RpbmcgPiAzKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5wdHIgKz0gYmxvY2tQdHI7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIGJsb2NrIGVuY29kaW5nIChcIiArIGJsb2NrRW5jb2RpbmcgKyBcIilcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChibG9ja0VuY29kaW5nID09PSAyKSB7IC8vY29uc3RhbnQgMFxuICAgICAgICAgICAgICAgIGlmIChpc0RpZmZFbmNvZGluZykge1xuICAgICAgICAgICAgICAgICAgaWYgKG1hc2spIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPCB0aGlzQmxvY2tIZWlnaHQ7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCB0aGlzQmxvY2tXaWR0aDsgY29sKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXNrW291dFB0cl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzW291dFB0cl0gPSByZXN1bHRQaXhlbHNQcmV2RGltW291dFB0cl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRQdHIrKztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IHRoaXNCbG9ja0hlaWdodDsgcm93KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IHRoaXNCbG9ja1dpZHRoOyBjb2wrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzW291dFB0cl0gPSByZXN1bHRQaXhlbHNQcmV2RGltW291dFB0cl07XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRQdHIrKztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YS5jb3VudGVyLmNvbnN0YW50Kys7XG4gICAgICAgICAgICAgICAgZGF0YS5wdHIgKz0gYmxvY2tQdHI7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoYmxvY2tFbmNvZGluZyA9PT0gMCkgeyAgLy91bmNvbXByZXNzZWRcbiAgICAgICAgICAgICAgICBpZiAoaXNEaWZmRW5jb2RpbmcpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGRvZXNuJ3QgbWFrZSBzZW5zZSwgc2hvdWxkIG5vdCBoYXBwZW5cbiAgICAgICAgICAgICAgICAgIHRocm93IFwiaW50ZWdyaXR5IGlzc3VlXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRhdGEuY291bnRlci51bmNvbXByZXNzZWQrKztcbiAgICAgICAgICAgICAgICBkYXRhLnB0ciArPSBibG9ja1B0cjtcbiAgICAgICAgICAgICAgICBudW1CeXRlcyA9IHRoaXNCbG9ja0hlaWdodCAqIHRoaXNCbG9ja1dpZHRoICogZGF0YVR5cGVTaXplO1xuICAgICAgICAgICAgICAgIGJ5dGVzbGVmdCA9IGlucHV0LmJ5dGVMZW5ndGggLSBkYXRhLnB0cjtcbiAgICAgICAgICAgICAgICBudW1CeXRlcyA9IG51bUJ5dGVzIDwgYnl0ZXNsZWZ0ID8gbnVtQnl0ZXMgOiBieXRlc2xlZnQ7XG4gICAgICAgICAgICAgICAgLy9iaXQgYWxpZ25tZW50XG4gICAgICAgICAgICAgICAgYXJyYXlCdWYgPSBuZXcgQXJyYXlCdWZmZXIoKG51bUJ5dGVzICUgZGF0YVR5cGVTaXplKSA9PT0gMCA/IG51bUJ5dGVzIDogKG51bUJ5dGVzICsgZGF0YVR5cGVTaXplIC0gbnVtQnl0ZXMgJSBkYXRhVHlwZVNpemUpKTtcbiAgICAgICAgICAgICAgICBzdG9yZTggPSBuZXcgVWludDhBcnJheShhcnJheUJ1Zik7XG4gICAgICAgICAgICAgICAgc3RvcmU4LnNldChuZXcgVWludDhBcnJheShpbnB1dCwgZGF0YS5wdHIsIG51bUJ5dGVzKSk7XG4gICAgICAgICAgICAgICAgcmF3RGF0YSA9IG5ldyBPdXRQaXhlbFR5cGVBcnJheShhcnJheUJ1Zik7XG4gICAgICAgICAgICAgICAgeiA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKG1hc2spIHtcbiAgICAgICAgICAgICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgdGhpc0Jsb2NrSGVpZ2h0OyByb3crKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IHRoaXNCbG9ja1dpZHRoOyBjb2wrKykge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXNrW291dFB0cl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1tvdXRQdHJdID0gcmF3RGF0YVt6KytdO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBvdXRQdHIrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvdXRQdHIgKz0gb3V0U3RyaWRlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHsvL2FsbCB2YWxpZFxuICAgICAgICAgICAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPCB0aGlzQmxvY2tIZWlnaHQ7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29sID0gMDsgY29sIDwgdGhpc0Jsb2NrV2lkdGg7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzW291dFB0cisrXSA9IHJhd0RhdGFbeisrXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvdXRQdHIgKz0gb3V0U3RyaWRlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRhLnB0ciArPSB6ICogZGF0YVR5cGVTaXplO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgeyAvLzEgb3IgM1xuICAgICAgICAgICAgICAgIG9mZnNldFR5cGUgPSBMZXJjMkhlbHBlcnMuZ2V0RGF0YVR5cGVVc2VkKChpc0RpZmZFbmNvZGluZyAmJiBpbWFnZVR5cGUgPCA2KSA/IDQgOiBpbWFnZVR5cGUsIGJpdHM2Nyk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gTGVyYzJIZWxwZXJzLmdldE9uZVBpeGVsKGJsb2NrLCBibG9ja1B0ciwgb2Zmc2V0VHlwZSwgdmlldyk7XG4gICAgICAgICAgICAgICAgYmxvY2tQdHIgKz0gTGVyYzJIZWxwZXJzLmdldERhdGFUeXBlU2l6ZShvZmZzZXRUeXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tFbmNvZGluZyA9PT0gMykgLy9jb25zdGFudCBvZmZzZXQgdmFsdWVcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBkYXRhLnB0ciArPSBibG9ja1B0cjtcbiAgICAgICAgICAgICAgICAgIGRhdGEuY291bnRlci5jb25zdGFudG9mZnNldCsrO1xuICAgICAgICAgICAgICAgICAgLy95b3UgY2FuIGRlbGV0ZSB0aGUgZm9sbG93aW5nIHJlc3VsdE1hc2sgY2FzZSBpbiBmYXZvciBvZiBwZXJmb3JtYW5jZSBiZWNhdXNlIHZhbCBpcyBjb25zdGFudCBhbmQgdXNlcnMgdXNlIG5vZGF0YSBtYXNrLCBvdGhlcndpc2Ugbm9kYXRhdmFsdWUgcG9zdCBwcm9jZXNzaW5nIGhhbmRsZXMgaXQgdG9vLlxuICAgICAgICAgICAgICAgICAgLy93aGlsZSB0aGUgYWJvdmUgc3RhdGVtZW50IGlzIHRydWUsIHdlJ3JlIG5vdCBkb2luZyBpdCBhcyB3ZSB3YW50IHRvIGtlZXAgaW52YWxpZCBwaXhlbCB2YWx1ZSBhdCAwIHJhdGhlciB0aGFuIGFyYml0cmFyeSB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgIGlmIChtYXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgdGhpc0Jsb2NrSGVpZ2h0OyByb3crKykge1xuICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29sID0gMDsgY29sIDwgdGhpc0Jsb2NrV2lkdGg7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFza1tvdXRQdHJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1tvdXRQdHJdID0gaXNEaWZmRW5jb2RpbmcgPyBNYXRoLm1pbih6TWF4LCByZXN1bHRQaXhlbHNQcmV2RGltW291dFB0cl0gKyBvZmZzZXQpIDogb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0UHRyKys7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIG91dFB0ciArPSBvdXRTdHJpZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IHRoaXNCbG9ja0hlaWdodDsgcm93KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IHRoaXNCbG9ja1dpZHRoOyBjb2wrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzW291dFB0cl0gPSBpc0RpZmZFbmNvZGluZyA/IE1hdGgubWluKHpNYXgsIHJlc3VsdFBpeGVsc1ByZXZEaW1bb3V0UHRyXSArIG9mZnNldCkgOiBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRQdHIrKztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgb3V0UHRyICs9IG91dFN0cmlkZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHsgLy9iaXRzdHVmZiBlbmNvZGluZyBpcyAzXG4gICAgICAgICAgICAgICAgICBkYXRhLnB0ciArPSBibG9ja1B0cjtcbiAgICAgICAgICAgICAgICAgIC8vaGVhdnkgbGlmdGluZ1xuICAgICAgICAgICAgICAgICAgTGVyYzJIZWxwZXJzLmRlY29kZUJpdHMoaW5wdXQsIGRhdGEsIGJsb2NrRGF0YUJ1ZmZlciwgb2Zmc2V0LCBpRGltKTtcbiAgICAgICAgICAgICAgICAgIGJsb2NrUHRyID0gMDtcbiAgICAgICAgICAgICAgICAgIC8vIGR1cGxpY2F0ZSBjb2RlIHRvIGZhdm9yIHBlcmZvcm1hbmNlLCBkaWZmIGVuY29kaW5nIGlzIGZvciBtdWx0aWRpbWVuc2lvbiBvbmx5XG4gICAgICAgICAgICAgICAgICBpZiAoaXNEaWZmRW5jb2RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hc2spIHtcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IHRoaXNCbG9ja0hlaWdodDsgcm93KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29sID0gMDsgY29sIDwgdGhpc0Jsb2NrV2lkdGg7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXNrW291dFB0cl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRQaXhlbHNbb3V0UHRyXSA9IGJsb2NrRGF0YUJ1ZmZlcltibG9ja1B0cisrXSArIHJlc3VsdFBpeGVsc1ByZXZEaW1bb3V0UHRyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRQdHIrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG91dFB0ciArPSBvdXRTdHJpZGU7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgdGhpc0Jsb2NrSGVpZ2h0OyByb3crKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCB0aGlzQmxvY2tXaWR0aDsgY29sKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzW291dFB0cl0gPSBibG9ja0RhdGFCdWZmZXJbYmxvY2tQdHIrK10gKyByZXN1bHRQaXhlbHNQcmV2RGltW291dFB0cl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG91dFB0cisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0UHRyICs9IG91dFN0cmlkZTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hc2spIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPCB0aGlzQmxvY2tIZWlnaHQ7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCB0aGlzQmxvY2tXaWR0aDsgY29sKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXNrW291dFB0cl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzW291dFB0cl0gPSBibG9ja0RhdGFCdWZmZXJbYmxvY2tQdHIrK107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRQdHIrKztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgb3V0UHRyICs9IG91dFN0cmlkZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgdGhpc0Jsb2NrSGVpZ2h0OyByb3crKykge1xuICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29sID0gMDsgY29sIDwgdGhpc0Jsb2NrV2lkdGg7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRQaXhlbHNbb3V0UHRyKytdID0gYmxvY2tEYXRhQnVmZmVyW2Jsb2NrUHRyKytdO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBvdXRQdHIgKz0gb3V0U3RyaWRlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vc3dhcCBmb3IgQklQOiBpdCdzIGFsd2F5cyBlYXNpZXIgZm9yIGNsaWVudHMgdG8gaGFuZGxlIEJTUSBzbyB3ZSBrZWVwIGV4aXN0aW5nIGxvZ2ljIGFuZCBpbnRyb2R1Y2UgYSBzd2FwIGhlcmUgdG8gbWluaW16ZSBjaGFuZ2VzXG4gICAgICAgIGlmIChudW1EaW1zID4gMSAmJiAhdXNlQlNRRm9yT3V0cHV0RGltKSB7XG4gICAgICAgICAgZGF0YS5waXhlbHMucmVzdWx0UGl4ZWxzID0gTGVyYzJIZWxwZXJzLnN3YXBEaW1lbnNpb25PcmRlcihkYXRhLnBpeGVscy5yZXN1bHRQaXhlbHMsIG51bVBpeGVscywgbnVtRGltcywgT3V0UGl4ZWxUeXBlQXJyYXkpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKioqKioqKioqKioqKioqKipcbiAgICAgICogIHByaXZhdGUgbWV0aG9kcyAoaGVscGVyIG1ldGhvZHMpXG4gICAgICAqKioqKioqKioqKioqKioqKi9cblxuICAgICAgZm9ybWF0RmlsZUluZm86IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBcImZpbGVJZGVudGlmaWVyU3RyaW5nXCI6IGRhdGEuaGVhZGVySW5mby5maWxlSWRlbnRpZmllclN0cmluZyxcbiAgICAgICAgICBcImZpbGVWZXJzaW9uXCI6IGRhdGEuaGVhZGVySW5mby5maWxlVmVyc2lvbixcbiAgICAgICAgICBcImltYWdlVHlwZVwiOiBkYXRhLmhlYWRlckluZm8uaW1hZ2VUeXBlLFxuICAgICAgICAgIFwiaGVpZ2h0XCI6IGRhdGEuaGVhZGVySW5mby5oZWlnaHQsXG4gICAgICAgICAgXCJ3aWR0aFwiOiBkYXRhLmhlYWRlckluZm8ud2lkdGgsXG4gICAgICAgICAgXCJudW1WYWxpZFBpeGVsXCI6IGRhdGEuaGVhZGVySW5mby5udW1WYWxpZFBpeGVsLFxuICAgICAgICAgIFwibWljcm9CbG9ja1NpemVcIjogZGF0YS5oZWFkZXJJbmZvLm1pY3JvQmxvY2tTaXplLFxuICAgICAgICAgIFwiYmxvYlNpemVcIjogZGF0YS5oZWFkZXJJbmZvLmJsb2JTaXplLFxuICAgICAgICAgIFwibWF4WkVycm9yXCI6IGRhdGEuaGVhZGVySW5mby5tYXhaRXJyb3IsXG4gICAgICAgICAgXCJwaXhlbFR5cGVcIjogTGVyYzJIZWxwZXJzLmdldFBpeGVsVHlwZShkYXRhLmhlYWRlckluZm8uaW1hZ2VUeXBlKSxcbiAgICAgICAgICBcImVvZk9mZnNldFwiOiBkYXRhLmVvZk9mZnNldCxcbiAgICAgICAgICBcIm1hc2tcIjogZGF0YS5tYXNrID8ge1xuICAgICAgICAgICAgXCJudW1CeXRlc1wiOiBkYXRhLm1hc2subnVtQnl0ZXNcbiAgICAgICAgICB9IDogbnVsbCxcbiAgICAgICAgICBcInBpeGVsc1wiOiB7XG4gICAgICAgICAgICBcIm51bUJsb2Nrc1hcIjogZGF0YS5waXhlbHMubnVtQmxvY2tzWCxcbiAgICAgICAgICAgIFwibnVtQmxvY2tzWVwiOiBkYXRhLnBpeGVscy5udW1CbG9ja3NZLFxuICAgICAgICAgICAgLy9cIm51bUJ5dGVzXCI6IGRhdGEucGl4ZWxzLm51bUJ5dGVzLFxuICAgICAgICAgICAgXCJtYXhWYWx1ZVwiOiBkYXRhLmhlYWRlckluZm8uek1heCxcbiAgICAgICAgICAgIFwibWluVmFsdWVcIjogZGF0YS5oZWFkZXJJbmZvLnpNaW4sXG4gICAgICAgICAgICBcIm5vRGF0YVZhbHVlXCI6IGRhdGEubm9EYXRhVmFsdWVcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9LFxuXG4gICAgICBjb25zdHJ1Y3RDb25zdGFudFN1cmZhY2U6IGZ1bmN0aW9uKGRhdGEsIHVzZUJTUUZvck91dHB1dERpbSkge1xuICAgICAgICB2YXIgdmFsID0gZGF0YS5oZWFkZXJJbmZvLnpNYXg7XG4gICAgICAgIHZhciB2YWxNaW4gPSBkYXRhLmhlYWRlckluZm8uek1pbjtcbiAgICAgICAgdmFyIG1heFZhbHVlcyA9IGRhdGEuaGVhZGVySW5mby5tYXhWYWx1ZXM7XG4gICAgICAgIHZhciBudW1EaW1zID0gZGF0YS5oZWFkZXJJbmZvLm51bURpbXM7XG4gICAgICAgIHZhciBudW1QaXhlbHMgPSBkYXRhLmhlYWRlckluZm8uaGVpZ2h0ICogZGF0YS5oZWFkZXJJbmZvLndpZHRoO1xuICAgICAgICB2YXIgaSA9IDAsIGsgPSAwLCBuU3RhcnQgPSAwO1xuICAgICAgICB2YXIgbWFzayA9IGRhdGEucGl4ZWxzLnJlc3VsdE1hc2s7XG4gICAgICAgIHZhciByZXN1bHRQaXhlbHMgPSBkYXRhLnBpeGVscy5yZXN1bHRQaXhlbHM7XG4gICAgICAgIGlmIChtYXNrKSB7XG4gICAgICAgICAgaWYgKG51bURpbXMgPiAxKSB7XG4gICAgICAgICAgICBpZiAodXNlQlNRRm9yT3V0cHV0RGltKSB7XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1EaW1zOyBpKyspIHtcbiAgICAgICAgICAgICAgICBuU3RhcnQgPSBpICogbnVtUGl4ZWxzO1xuICAgICAgICAgICAgICAgIHZhbCA9IG1heFZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbnVtUGl4ZWxzOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXNrW2tdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1tuU3RhcnQgKyBrXSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBudW1QaXhlbHM7IGsrKykge1xuICAgICAgICAgICAgICAgIGlmIChtYXNrW2tdKSB7XG4gICAgICAgICAgICAgICAgICBuU3RhcnQgPSBrICogbnVtRGltcztcbiAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1EaW1zOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzW25TdGFydCArIG51bURpbXNdID0gbWF4VmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBudW1QaXhlbHM7IGsrKykge1xuICAgICAgICAgICAgICBpZiAobWFza1trXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1trXSA9IHZhbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAobnVtRGltcyA+IDEgJiYgdmFsTWluICE9PSB2YWwpIHtcbiAgICAgICAgICAgIGlmICh1c2VCU1FGb3JPdXRwdXREaW0pIHtcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bURpbXM7IGkrKykge1xuICAgICAgICAgICAgICAgIG5TdGFydCA9IGkgKiBudW1QaXhlbHM7XG4gICAgICAgICAgICAgICAgdmFsID0gbWF4VmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBudW1QaXhlbHM7IGsrKykge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzW25TdGFydCArIGtdID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBudW1QaXhlbHM7IGsrKykge1xuICAgICAgICAgICAgICAgIG5TdGFydCA9IGsgKiBudW1EaW1zO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1EaW1zOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1tuU3RhcnQgKyBpXSA9IG1heFZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbnVtUGl4ZWxzICogbnVtRGltczsgaysrKSB7XG4gICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1trXSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSxcblxuICAgICAgZ2V0RGF0YVR5cGVBcnJheTogZnVuY3Rpb24odCkge1xuICAgICAgICB2YXIgdHA7XG4gICAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICAgIGNhc2UgMDogLy9jaGFyXG4gICAgICAgICAgICB0cCA9IEludDhBcnJheTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTogLy9ieXRlXG4gICAgICAgICAgICB0cCA9IFVpbnQ4QXJyYXk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6IC8vc2hvcnRcbiAgICAgICAgICAgIHRwID0gSW50MTZBcnJheTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzogLy91c2hvcnRcbiAgICAgICAgICAgIHRwID0gVWludDE2QXJyYXk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICB0cCA9IEludDMyQXJyYXk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICB0cCA9IFVpbnQzMkFycmF5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgdHAgPSBGbG9hdDMyQXJyYXk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICB0cCA9IEZsb2F0NjRBcnJheTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0cCA9IEZsb2F0MzJBcnJheTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHA7XG4gICAgICB9LFxuXG4gICAgICBnZXRQaXhlbFR5cGU6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdmFyIHRwO1xuICAgICAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgICBjYXNlIDA6IC8vY2hhclxuICAgICAgICAgICAgdHAgPSBcIlM4XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE6IC8vYnl0ZVxuICAgICAgICAgICAgdHAgPSBcIlU4XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6IC8vc2hvcnRcbiAgICAgICAgICAgIHRwID0gXCJTMTZcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzogLy91c2hvcnRcbiAgICAgICAgICAgIHRwID0gXCJVMTZcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHRwID0gXCJTMzJcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHRwID0gXCJVMzJcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHRwID0gXCJGMzJcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHRwID0gXCJGNjRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0cCA9IFwiRjMyXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRwO1xuICAgICAgfSxcblxuICAgICAgaXNWYWxpZFBpeGVsVmFsdWU6IGZ1bmN0aW9uKHQsIHZhbCkge1xuICAgICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlzVmFsaWQ7XG4gICAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICAgIGNhc2UgMDogLy9jaGFyXG4gICAgICAgICAgICBpc1ZhbGlkID0gdmFsID49IC0xMjggJiYgdmFsIDw9IDEyNztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTogLy9ieXRlICAodW5zaWduZWQgY2hhcilcbiAgICAgICAgICAgIGlzVmFsaWQgPSB2YWwgPj0gMCAmJiB2YWwgPD0gMjU1O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOiAvL3Nob3J0XG4gICAgICAgICAgICBpc1ZhbGlkID0gdmFsID49IC0zMjc2OCAmJiB2YWwgPD0gMzI3Njc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6IC8vdXNob3J0XG4gICAgICAgICAgICBpc1ZhbGlkID0gdmFsID49IDAgJiYgdmFsIDw9IDY1NTM2O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA0OiAvL2ludCAzMlxuICAgICAgICAgICAgaXNWYWxpZCA9IHZhbCA+PSAtMjE0NzQ4MzY0OCAmJiB2YWwgPD0gMjE0NzQ4MzY0NztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNTogLy91aW5pdCAzMlxuICAgICAgICAgICAgaXNWYWxpZCA9IHZhbCA+PSAwICYmIHZhbCA8PSA0Mjk0OTY3Mjk2O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgaXNWYWxpZCA9IHZhbCA+PSAtMy40MDI3OTk5Mzg3OTAxNDg0ZSszOCAmJiB2YWwgPD0gMy40MDI3OTk5Mzg3OTAxNDg0ZSszODtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIGlzVmFsaWQgPSB2YWwgPj0gLTEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4ICYmIHZhbCA8PSAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwODtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzVmFsaWQ7XG4gICAgICB9LFxuXG4gICAgICBnZXREYXRhVHlwZVNpemU6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdmFyIHMgPSAwO1xuICAgICAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgICBjYXNlIDA6IC8vdWJ5dGVcbiAgICAgICAgICBjYXNlIDE6IC8vYnl0ZVxuICAgICAgICAgICAgcyA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6IC8vc2hvcnRcbiAgICAgICAgICBjYXNlIDM6IC8vdXNob3J0XG4gICAgICAgICAgICBzID0gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgcyA9IDQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBzID0gODtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBzID0gdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcztcbiAgICAgIH0sXG5cbiAgICAgIGdldERhdGFUeXBlVXNlZDogZnVuY3Rpb24oZHQsIHRjKSB7XG4gICAgICAgIHZhciB0ID0gZHQ7XG4gICAgICAgIHN3aXRjaCAoZHQpIHtcbiAgICAgICAgICBjYXNlIDI6IC8vc2hvcnRcbiAgICAgICAgICBjYXNlIDQ6IC8vbG9uZ1xuICAgICAgICAgICAgdCA9IGR0IC0gdGM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6IC8vdXNob3J0XG4gICAgICAgICAgY2FzZSA1OiAvL3Vsb25nXG4gICAgICAgICAgICB0ID0gZHQgLSAyICogdGM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDY6IC8vZmxvYXRcbiAgICAgICAgICAgIGlmICgwID09PSB0Yykge1xuICAgICAgICAgICAgICB0ID0gZHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgxID09PSB0Yykge1xuICAgICAgICAgICAgICB0ID0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0ID0gMTsvL2J5dGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNzogLy9kb3VibGVcbiAgICAgICAgICAgIGlmICgwID09PSB0Yykge1xuICAgICAgICAgICAgICB0ID0gZHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdCA9IGR0IC0gMiAqIHRjICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0ID0gZHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICAgIH0sXG5cbiAgICAgIGdldE9uZVBpeGVsOiBmdW5jdGlvbihibG9jaywgYmxvY2tQdHIsIG9mZnNldFR5cGUsIHZpZXcpIHtcbiAgICAgICAgdmFyIHRlbXAgPSAwO1xuICAgICAgICBzd2l0Y2ggKG9mZnNldFR5cGUpIHtcbiAgICAgICAgICBjYXNlIDA6IC8vY2hhclxuICAgICAgICAgICAgdGVtcCA9IHZpZXcuZ2V0SW50OChibG9ja1B0cik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE6IC8vYnl0ZVxuICAgICAgICAgICAgdGVtcCA9IHZpZXcuZ2V0VWludDgoYmxvY2tQdHIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdGVtcCA9IHZpZXcuZ2V0SW50MTYoYmxvY2tQdHIsIHRydWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgdGVtcCA9IHZpZXcuZ2V0VWludDE2KGJsb2NrUHRyLCB0cnVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHRlbXAgPSB2aWV3LmdldEludDMyKGJsb2NrUHRyLCB0cnVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHRlbXAgPSB2aWV3LmdldFVJbnQzMihibG9ja1B0ciwgdHJ1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICB0ZW1wID0gdmlldy5nZXRGbG9hdDMyKGJsb2NrUHRyLCB0cnVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHRlbXAgPSB2aWV3LmdldEZsb2F0NjQoYmxvY2tQdHIsIHRydWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IChcInRoZSBkZWNvZGVyIGRvZXMgbm90IHVuZGVyc3RhbmQgdGhpcyBwaXhlbCB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW1wO1xuICAgICAgfSxcblxuICAgICAgc3dhcERpbWVuc2lvbk9yZGVyOiBmdW5jdGlvbihwaXhlbHMsIG51bVBpeGVscywgbnVtRGltcywgT3V0UGl4ZWxUeXBlQXJyYXksIGlucHV0SXNCSVApIHtcbiAgICAgICAgdmFyIGkgPSAwLCBqID0gMCwgaURpbSA9IDAsIHRlbXAgPSAwLCBzd2FwID0gcGl4ZWxzO1xuICAgICAgICBpZiAobnVtRGltcyA+IDEpIHtcbiAgICAgICAgICBzd2FwID0gbmV3IE91dFBpeGVsVHlwZUFycmF5KG51bVBpeGVscyAqIG51bURpbXMpO1xuICAgICAgICAgIGlmIChpbnB1dElzQklQKSB7XG4gICAgICAgICAgICBmb3IgKGk9MDsgaTxudW1QaXhlbHM7IGkrKykge1xuICAgICAgICAgICAgICB0ZW1wID0gaTtcbiAgICAgICAgICAgICAgZm9yIChpRGltPTA7IGlEaW0gPCBudW1EaW1zOyBpRGltKyssIHRlbXAgKz0gbnVtUGl4ZWxzKSB7XG4gICAgICAgICAgICAgICAgc3dhcFt0ZW1wXSA9IHBpeGVsc1tqKytdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICBcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGk9MDsgaTxudW1QaXhlbHM7IGkrKykge1xuICAgICAgICAgICAgICB0ZW1wID0gaTtcbiAgICAgICAgICAgICAgZm9yIChpRGltPTA7IGlEaW0gPCBudW1EaW1zOyBpRGltKyssIHRlbXAgKz0gbnVtUGl4ZWxzKSB7XG4gICAgICAgICAgICAgICAgc3dhcFtqKytdID0gcGl4ZWxzW3RlbXBdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzd2FwO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgKnByaXZhdGUgY2xhc3MgZm9yIGEgdHJlZSBub2RlLiBIdWZmbWFuIGNvZGUgaXMgaW4gTGVyYzJIZWxwZXJzXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICB2YXIgVHJlZU5vZGUgPSBmdW5jdGlvbih2YWwsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICB0aGlzLnZhbCA9IHZhbDtcbiAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgfTtcblxuICAgIHZhciBMZXJjMkRlY29kZSA9IHtcbiAgICAgIC8qXG4gICAgICAqICoqKioqKioqcmVtb3ZlZCBvcHRpb25zIGNvbXBhcmVkIHRvIExFUkMxLiBXZSBjYW4gYnJpbmcgc29tZSBvZiB0aGVtIGJhY2sgaWYgbmVlZGVkLlxuICAgICAgICogcmVtb3ZlZCBwaXhlbCB0eXBlLiBMRVJDMiBpcyB0eXBlZCBhbmQgZG9lc24ndCByZXF1aXJlIHVzZXIgdG8gZ2l2ZSBwaXhlbCB0eXBlXG4gICAgICAgKiBjaGFuZ2VkIGVuY29kZWRNYXNrRGF0YSB0byBtYXNrRGF0YS4gTEVSQzIgJ3MganMgdmVyc2lvbiBtYWtlIGl0IGZhc3RlciB0byB1c2UgbWFza0RhdGEgZGlyZWN0bHkuXG4gICAgICAgKiByZW1vdmVkIHJldHVybk1hc2suIG1hc2sgaXMgdXNlZCBieSBMRVJDMiBpbnRlcm5hbGx5IGFuZCBpcyBjb3N0IGZyZWUuIEluIGNhc2Ugb2YgdXNlciBpbnB1dCBtYXNrLCBpdCdzIHJldHVybmVkIGFzIHdlbGwgYW5kIGhhcyBuZWdsaWJsZSBjb3N0LlxuICAgICAgICogcmVtb3ZlZCBub2RhdGF2YWx1ZS4gQmVjYXVzZSBMRVJDMiBwaXhlbHMgYXJlIHR5cGVkLCBub2RhdGF2YWx1ZSB3aWxsIHNhY3JpZnkgYSB1c2VmdWwgdmFsdWUgZm9yIG1hbnkgdHlwZXMgKDhiaXQsIDE2Yml0KSBldGMsXG4gICAgICAgKiAgICAgICB1c2VyIGhhcyB0byBiZSBrbm93bGVkZ2FibGUgZW5vdWdoIGFib3V0IHJhc3RlciBhbmQgdGhlaXIgZGF0YSB0byBhdm9pZCB1c2FiaWxpdHkgaXNzdWVzLiBzbyBub2RhdGEgdmFsdWUgaXMgc2ltcGx5IHJlbW92ZWQgbm93LlxuICAgICAgICogICAgICAgV2UgY2FuIGFkZCBpdCBiYWNrIGxhdGVyIGlmIHRoZWlyJ3MgYSBjbGVhciByZXF1aXJlbWVudC5cbiAgICAgICAqIHJlbW92ZWQgZW5jb2RlZE1hc2suIFRoaXMgb3B0aW9uIHdhcyBub3QgaW1wbGVtZW50ZWQgaW4gTGVyY0RlY29kZS4gSXQgY2FuIGJlIGRvbmUgYWZ0ZXIgZGVjb2RpbmcgKGxlc3MgZWZmaWNpZW50KVxuICAgICAgICogcmVtb3ZlZCBjb21wdXRlVXNlZEJpdERlcHRocy5cbiAgICAgICAqXG4gICAgICAgKlxuICAgICAgICogcmVzcG9uc2UgY2hhbmdlcyBjb21wYXJlZCB0byBMRVJDMVxuICAgICAgICogMS4gZW5jb2RlZE1hc2tEYXRhIGlzIG5vdCBhdmFpbGFibGVcbiAgICAgICAqIDIuIG5vRGF0YVZhbHVlIGlzIG9wdGlvbmFsIChyZXR1cm5zIG9ubHkgaWYgdXNlcidzIG5vRGF0YVZhbHVlIGlzIHdpdGggaW4gdGhlIHZhbGlkIGRhdGEgdHlwZSByYW5nZSlcbiAgICAgICAqIDMuIG1hc2tEYXRhIGlzIGFsd2F5cyBhdmFpbGFibGVcbiAgICAgICovXG4gICAgICAvKioqKioqKioqKioqKioqKipcbiAgICAgICogIHB1YmxpYyBwcm9wZXJ0aWVzXG4gICAgICAqKioqKioqKioqKioqKioqKiovXG4gICAgICAvL0hVRkZNQU5fTFVUX0JJVFNfTUFYOiAxMiwgLy91c2UgMl4xMiBsdXQsIG5vdCBjb25maWd1cmFibGVcblxuICAgICAgLyoqKioqKioqKioqKioqKioqXG4gICAgICAqICBwdWJsaWMgbWV0aG9kc1xuICAgICAgKioqKioqKioqKioqKioqKiovXG5cbiAgICAgIC8qKlxuICAgICAgICogRGVjb2RlIGEgTEVSQzIgYnl0ZSBzdHJlYW0gYW5kIHJldHVybiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgcGl4ZWwgZGF0YSBhbmQgb3B0aW9uYWwgbWV0YWRhdGEuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gaW5wdXQgVGhlIExFUkMgaW5wdXQgYnl0ZSBzdHJlYW1cbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gb3B0aW9ucyBEZWNvZGluZyBvcHRpb25zXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuaW5wdXRPZmZzZXRdIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBpbiB0aGUgaW5wdXQgYnl0ZSBzdHJlYW0uIEEgdmFsaWQgTEVSQyBmaWxlIGlzIGV4cGVjdGVkIGF0IHRoYXQgcG9zaXRpb25cbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmV0dXJuRmlsZUluZm9dIElmIHRydWUsIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBoYXZlIGEgZmlsZUluZm8gcHJvcGVydHkgdGhhdCBjb250YWlucyBtZXRhZGF0YSBvYnRhaW5lZCBmcm9tIHRoZSBMRVJDIGhlYWRlcnMgYW5kIHRoZSBkZWNvZGluZyBwcm9jZXNzXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJldHVyblBpeGVsSW50ZXJsZWF2ZWREaW1zXSAgSWYgdHJ1ZSwgcmV0dXJuZWQgZGltZW5zaW9ucyBhcmUgcGl4ZWwtaW50ZXJsZWF2ZWQsIGEuay5hIFtwMV9kaW0wLCBwMV9kaW0xLCBwMV9kaW1uLCBwMl9kaW0wLi4uXSwgZGVmYXVsdCBpcyBbcDFfZGltMCwgcDJfZGltMCwgLi4uLCBwMV9kaW0xLCBwMl9kaW0xLi4uXVxuICAgICAgICovXG4gICAgICBkZWNvZGU6IGZ1bmN0aW9uKC8qYnl0ZSBhcnJheSovIGlucHV0LCAvKm9iamVjdCovIG9wdGlvbnMpIHtcbiAgICAgICAgLy9jdXJyZW50bHkgdGhlcmUncyBhIGJ1ZyBpbiB0aGUgc3BhcnNlIGFycmF5LCBzbyBwbGVhc2UgZG8gbm90IHNldCB0byBmYWxzZVxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdmFyIG5vRGF0YVZhbHVlID0gb3B0aW9ucy5ub0RhdGFWYWx1ZTtcblxuICAgICAgICAvL2luaXRpYWxpemVcbiAgICAgICAgdmFyIGkgPSAwLCBkYXRhID0ge307XG4gICAgICAgIGRhdGEucHRyID0gb3B0aW9ucy5pbnB1dE9mZnNldCB8fCAwO1xuICAgICAgICBkYXRhLnBpeGVscyA9IHt9O1xuXG4gICAgICAgIC8vIEZpbGUgaGVhZGVyXG4gICAgICAgIGlmICghTGVyYzJIZWxwZXJzLnJlYWRIZWFkZXJJbmZvKGlucHV0LCBkYXRhKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoZWFkZXJJbmZvID0gZGF0YS5oZWFkZXJJbmZvO1xuICAgICAgICB2YXIgZmlsZVZlcnNpb24gPSBoZWFkZXJJbmZvLmZpbGVWZXJzaW9uO1xuICAgICAgICB2YXIgT3V0UGl4ZWxUeXBlQXJyYXkgPSBMZXJjMkhlbHBlcnMuZ2V0RGF0YVR5cGVBcnJheShoZWFkZXJJbmZvLmltYWdlVHlwZSk7XG5cbiAgICAgICAgLy8gdmVyc2lvbiBjaGVja1xuICAgICAgICBpZiAoZmlsZVZlcnNpb24gPiA1KSB7XG4gICAgICAgICAgdGhyb3cgXCJ1bnN1cHBvcnRlZCBsZXJjIHZlcnNpb24gMi5cIiArIGZpbGVWZXJzaW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWFzayBIZWFkZXJcbiAgICAgICAgTGVyYzJIZWxwZXJzLnJlYWRNYXNrKGlucHV0LCBkYXRhKTtcbiAgICAgICAgaWYgKGhlYWRlckluZm8ubnVtVmFsaWRQaXhlbCAhPT0gaGVhZGVySW5mby53aWR0aCAqIGhlYWRlckluZm8uaGVpZ2h0ICYmICFkYXRhLnBpeGVscy5yZXN1bHRNYXNrKSB7XG4gICAgICAgICAgZGF0YS5waXhlbHMucmVzdWx0TWFzayA9IG9wdGlvbnMubWFza0RhdGE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbnVtUGl4ZWxzID0gaGVhZGVySW5mby53aWR0aCAqIGhlYWRlckluZm8uaGVpZ2h0O1xuICAgICAgICBkYXRhLnBpeGVscy5yZXN1bHRQaXhlbHMgPSBuZXcgT3V0UGl4ZWxUeXBlQXJyYXkobnVtUGl4ZWxzICogaGVhZGVySW5mby5udW1EaW1zKTtcblxuICAgICAgICBkYXRhLmNvdW50ZXIgPSB7XG4gICAgICAgICAgb25lc3dlZXA6IDAsXG4gICAgICAgICAgdW5jb21wcmVzc2VkOiAwLFxuICAgICAgICAgIGx1dDogMCxcbiAgICAgICAgICBiaXRzdHVmZmVyOiAwLFxuICAgICAgICAgIGNvbnN0YW50OiAwLFxuICAgICAgICAgIGNvbnN0YW50b2Zmc2V0OiAwXG4gICAgICAgIH07XG4gICAgICAgIHZhciB1c2VCU1FGb3JPdXRwdXREaW0gPSAhb3B0aW9ucy5yZXR1cm5QaXhlbEludGVybGVhdmVkRGltcztcbiAgICAgICAgaWYgKGhlYWRlckluZm8ubnVtVmFsaWRQaXhlbCAhPT0gMCkge1xuICAgICAgICAgIC8vbm90IHRlc3RlZFxuICAgICAgICAgIGlmIChoZWFkZXJJbmZvLnpNYXggPT09IGhlYWRlckluZm8uek1pbikgLy9jb25zdGFudCBzdXJmYWNlXG4gICAgICAgICAge1xuICAgICAgICAgICAgTGVyYzJIZWxwZXJzLmNvbnN0cnVjdENvbnN0YW50U3VyZmFjZShkYXRhLCB1c2VCU1FGb3JPdXRwdXREaW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChmaWxlVmVyc2lvbiA+PSA0ICYmIExlcmMySGVscGVycy5jaGVja01pbk1heFJhbmdlcyhpbnB1dCwgZGF0YSkpIHtcbiAgICAgICAgICAgIExlcmMySGVscGVycy5jb25zdHJ1Y3RDb25zdGFudFN1cmZhY2UoZGF0YSwgdXNlQlNRRm9yT3V0cHV0RGltKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhpbnB1dCwgZGF0YS5wdHIsIDIpO1xuICAgICAgICAgICAgdmFyIGJSZWFkRGF0YU9uZVN3ZWVwID0gdmlldy5nZXRVaW50OCgwKTtcbiAgICAgICAgICAgIGRhdGEucHRyKys7XG4gICAgICAgICAgICBpZiAoYlJlYWREYXRhT25lU3dlZXApIHtcbiAgICAgICAgICAgICAgLy9jb25zb2xlLmRlYnVnKFwiT25lU3dlZXBcIik7XG4gICAgICAgICAgICAgIExlcmMySGVscGVycy5yZWFkRGF0YU9uZVN3ZWVwKGlucHV0LCBkYXRhLCBPdXRQaXhlbFR5cGVBcnJheSwgdXNlQlNRRm9yT3V0cHV0RGltKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvL2xlcmMyLjE6IC8vYml0c3R1ZmZpbmcgKyBsdXRcbiAgICAgICAgICAgICAgLy9sZXJjMi4yOiAvL2JpdHN0dWZmaW5nICsgbHV0ICsgaHVmZm1hblxuICAgICAgICAgICAgICAvL2xlcmMyLjM6IG5ldyBiaXRzdHVmZmVyXG4gICAgICAgICAgICAgIGlmIChmaWxlVmVyc2lvbiA+IDEgJiYgaGVhZGVySW5mby5pbWFnZVR5cGUgPD0gMSAmJiBNYXRoLmFicyhoZWFkZXJJbmZvLm1heFpFcnJvciAtIDAuNSkgPCAwLjAwMDAxKSB7XG4gICAgICAgICAgICAgICAgLy90aGlzIGlzIDIueCBwbHVzIDggYml0ICh1bnNpZ25lZCBhbmQgc2lnbmVkKSBkYXRhLCBwb3NzaWJsaXR5IG9mIEh1ZmZtYW5cbiAgICAgICAgICAgICAgICB2YXIgZmxhZ0h1ZmZtYW4gPSB2aWV3LmdldFVpbnQ4KDEpO1xuICAgICAgICAgICAgICAgIGRhdGEucHRyKys7XG4gICAgICAgICAgICAgICAgZGF0YS5lbmNvZGVNb2RlID0gZmxhZ0h1ZmZtYW47XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdIdWZmbWFuID4gMiB8fCAoZmlsZVZlcnNpb24gPCA0ICYmIGZsYWdIdWZmbWFuID4gMSkpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IFwiSW52YWxpZCBIdWZmbWFuIGZsYWcgXCIgKyBmbGFnSHVmZm1hbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdIdWZmbWFuKSB7Ly8xIC0gZGVsdGEgSHVmZm1hbiwgMiAtIEh1ZmZtYW5cbiAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJIdWZmbWFuXCIpO1xuICAgICAgICAgICAgICAgICAgTGVyYzJIZWxwZXJzLnJlYWRIdWZmbWFuKGlucHV0LCBkYXRhLCBPdXRQaXhlbFR5cGVBcnJheSwgdXNlQlNRRm9yT3V0cHV0RGltKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiVGlsZXNcIik7XG4gICAgICAgICAgICAgICAgICBMZXJjMkhlbHBlcnMucmVhZFRpbGVzKGlucHV0LCBkYXRhLCBPdXRQaXhlbFR5cGVBcnJheSwgdXNlQlNRRm9yT3V0cHV0RGltKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7IC8vbGVyYzIueCBub24tOCBiaXQgZGF0YVxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJUaWxlc1wiKTtcbiAgICAgICAgICAgICAgICBMZXJjMkhlbHBlcnMucmVhZFRpbGVzKGlucHV0LCBkYXRhLCBPdXRQaXhlbFR5cGVBcnJheSwgdXNlQlNRRm9yT3V0cHV0RGltKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEuZW9mT2Zmc2V0ID0gZGF0YS5wdHI7XG4gICAgICAgIHZhciBkaWZmO1xuICAgICAgICBpZiAob3B0aW9ucy5pbnB1dE9mZnNldCkge1xuICAgICAgICAgIGRpZmYgPSBkYXRhLmhlYWRlckluZm8uYmxvYlNpemUgKyBvcHRpb25zLmlucHV0T2Zmc2V0IC0gZGF0YS5wdHI7XG4gICAgICAgICAgaWYgKE1hdGguYWJzKGRpZmYpID49IDEpIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5kZWJ1ZyhcImluY29ycmVjdCBlb2Y6IGRhdGFwdHIgXCIgKyBkYXRhLnB0ciArIFwiIG9mZnNldCBcIiArIG9wdGlvbnMuaW5wdXRPZmZzZXQgKyBcIiBibG9ic2l6ZSBcIiArIGRhdGEuaGVhZGVySW5mby5ibG9iU2l6ZSArIFwiIGRpZmY6IFwiICsgZGlmZik7XG4gICAgICAgICAgICBkYXRhLmVvZk9mZnNldCA9IG9wdGlvbnMuaW5wdXRPZmZzZXQgKyBkYXRhLmhlYWRlckluZm8uYmxvYlNpemU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRpZmYgPSBkYXRhLmhlYWRlckluZm8uYmxvYlNpemUgLSBkYXRhLnB0cjtcbiAgICAgICAgICBpZiAoTWF0aC5hYnMoZGlmZikgPj0gMSkge1xuICAgICAgICAgICAgLy9jb25zb2xlLmRlYnVnKFwiaW5jb3JyZWN0IGZpcnN0IGJhbmQgZW9mOiBkYXRhcHRyIFwiICsgZGF0YS5wdHIgKyBcIiBibG9ic2l6ZSBcIiArIGRhdGEuaGVhZGVySW5mby5ibG9iU2l6ZSArIFwiIGRpZmY6IFwiICsgZGlmZik7XG4gICAgICAgICAgICBkYXRhLmVvZk9mZnNldCA9IGRhdGEuaGVhZGVySW5mby5ibG9iU2l6ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgIHdpZHRoOiBoZWFkZXJJbmZvLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVhZGVySW5mby5oZWlnaHQsXG4gICAgICAgICAgcGl4ZWxEYXRhOiBkYXRhLnBpeGVscy5yZXN1bHRQaXhlbHMsXG4gICAgICAgICAgbWluVmFsdWU6IGhlYWRlckluZm8uek1pbixcbiAgICAgICAgICBtYXhWYWx1ZTogaGVhZGVySW5mby56TWF4LFxuICAgICAgICAgIHZhbGlkUGl4ZWxDb3VudDogaGVhZGVySW5mby5udW1WYWxpZFBpeGVsLFxuICAgICAgICAgIGRpbUNvdW50OiBoZWFkZXJJbmZvLm51bURpbXMsXG4gICAgICAgICAgZGltU3RhdHM6IHtcbiAgICAgICAgICAgIG1pblZhbHVlczogaGVhZGVySW5mby5taW5WYWx1ZXMsXG4gICAgICAgICAgICBtYXhWYWx1ZXM6IGhlYWRlckluZm8ubWF4VmFsdWVzXG4gICAgICAgICAgfSxcbiAgICAgICAgICBtYXNrRGF0YTogZGF0YS5waXhlbHMucmVzdWx0TWFza1xuICAgICAgICAgIC8vbm9EYXRhVmFsdWU6IG5vRGF0YVZhbHVlXG4gICAgICAgIH07XG5cbiAgICAgICAgLy93ZSBzaG91bGQgcmVtb3ZlIHRoaXMgaWYgdGhlcmUncyBubyBleGlzdGluZyBjbGllbnRcbiAgICAgICAgLy9vcHRpb25hbCBub0RhdGFWYWx1ZSBwcm9jZXNzaW5nLCBpdCdzIHVzZXIncyByZXNwb25zaWJsaXR5XG4gICAgICAgIGlmIChkYXRhLnBpeGVscy5yZXN1bHRNYXNrICYmIExlcmMySGVscGVycy5pc1ZhbGlkUGl4ZWxWYWx1ZShoZWFkZXJJbmZvLmltYWdlVHlwZSwgbm9EYXRhVmFsdWUpKSB7XG4gICAgICAgICAgdmFyIG1hc2sgPSBkYXRhLnBpeGVscy5yZXN1bHRNYXNrO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1QaXhlbHM7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFtYXNrW2ldKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5waXhlbERhdGFbaV0gPSBub0RhdGFWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0Lm5vRGF0YVZhbHVlID0gbm9EYXRhVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YS5ub0RhdGFWYWx1ZSA9IG5vRGF0YVZhbHVlO1xuICAgICAgICBpZiAob3B0aW9ucy5yZXR1cm5GaWxlSW5mbykge1xuICAgICAgICAgIHJlc3VsdC5maWxlSW5mbyA9IExlcmMySGVscGVycy5mb3JtYXRGaWxlSW5mbyhkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcblxuICAgICAgZ2V0QmFuZENvdW50OiBmdW5jdGlvbigvKmJ5dGUgYXJyYXkqLyBpbnB1dCkge1xuICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciB0ZW1wID0ge307XG4gICAgICAgIHRlbXAucHRyID0gMDtcbiAgICAgICAgdGVtcC5waXhlbHMgPSB7fTtcbiAgICAgICAgd2hpbGUgKGkgPCBpbnB1dC5ieXRlTGVuZ3RoIC0gNTgpIHtcbiAgICAgICAgICBMZXJjMkhlbHBlcnMucmVhZEhlYWRlckluZm8oaW5wdXQsIHRlbXApO1xuICAgICAgICAgIGkgKz0gdGVtcC5oZWFkZXJJbmZvLmJsb2JTaXplO1xuICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgdGVtcC5wdHIgPSBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIExlcmMyRGVjb2RlO1xuICB9KSgpO1xuXG4gIHZhciBpc1BsYXRmb3JtTGl0dGxlRW5kaWFuID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBhID0gbmV3IEFycmF5QnVmZmVyKDQpO1xuICAgIHZhciBiID0gbmV3IFVpbnQ4QXJyYXkoYSk7XG4gICAgdmFyIGMgPSBuZXcgVWludDMyQXJyYXkoYSk7XG4gICAgY1swXSA9IDE7XG4gICAgcmV0dXJuIGJbMF0gPT09IDE7XG4gIH0pKCk7XG5cbiAgdmFyIExlcmMgPSB7XG4gICAgLyoqKioqKioqKioqKndyYXBwZXIqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgIC8qKlxuICAgICAqIEEgd3JhcHBlciBmb3IgZGVjb2RpbmcgYm90aCBMRVJDMSBhbmQgTEVSQzIgYnl0ZSBzdHJlYW1zIGNhcGFibGUgb2YgaGFuZGxpbmcgbXVsdGliYW5kIHBpeGVsIGJsb2NrcyBmb3IgdmFyaW91cyBwaXhlbCB0eXBlcy5cbiAgICAgKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6TGVyY1xuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGlucHV0IFRoZSBMRVJDIGlucHV0IGJ5dGUgc3RyZWFtXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBUaGUgZGVjb2Rpbmcgb3B0aW9ucyBiZWxvdyBhcmUgb3B0aW9uYWwuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmlucHV0T2Zmc2V0XSBUaGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgaW4gdGhlIGlucHV0IGJ5dGUgc3RyZWFtLiBBIHZhbGlkIExlcmMgZmlsZSBpcyBleHBlY3RlZCBhdCB0aGF0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5waXhlbFR5cGVdIChMRVJDMSBvbmx5KSBEZWZhdWx0IHZhbHVlIGlzIEYzMi4gVmFsaWQgcGl4ZWwgdHlwZXMgZm9yIGlucHV0IGFyZSBVOC9TOC9TMTYvVTE2L1MzMi9VMzIvRjMyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5ub0RhdGFWYWx1ZV0gKExFUkMxIG9ubHkpLiBJdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgdGhlIHJldHVybmVkIG1hc2sgaW5zdGVhZCBvZiBzZXR0aW5nIHRoaXMgdmFsdWUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZXR1cm5QaXhlbEludGVybGVhdmVkRGltc10gKG5EaW0gTEVSQzIgb25seSkgSWYgdHJ1ZSwgcmV0dXJuZWQgZGltZW5zaW9ucyBhcmUgcGl4ZWwtaW50ZXJsZWF2ZWQsIGEuay5hIFtwMV9kaW0wLCBwMV9kaW0xLCBwMV9kaW1uLCBwMl9kaW0wLi4uXSwgZGVmYXVsdCBpcyBbcDFfZGltMCwgcDJfZGltMCwgLi4uLCBwMV9kaW0xLCBwMl9kaW0xLi4uXVxuICAgICAqIEByZXR1cm5zIHt7d2lkdGgsIGhlaWdodCwgcGl4ZWxzLCBwaXhlbFR5cGUsIG1hc2ssIHN0YXRpc3RpY3N9fVxuICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHdpZHRoIFdpZHRoIG9mIGRlY29kZWQgaW1hZ2UuXG4gICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0IEhlaWdodCBvZiBkZWNvZGVkIGltYWdlLlxuICAgICAgICogQHByb3BlcnR5IHthcnJheX0gcGl4ZWxzIFtiYW5kMSwgYmFuZDIsIOKApl0gRWFjaCBiYW5kIGlzIGEgdHlwZWQgYXJyYXkgb2Ygd2lkdGgqaGVpZ2h0LlxuICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHBpeGVsVHlwZSBUaGUgdHlwZSBvZiBwaXhlbHMgcmVwcmVzZW50ZWQgaW4gdGhlIG91dHB1dC5cbiAgICAgICAqIEBwcm9wZXJ0eSB7bWFza30gbWFzayBUeXBlZCBhcnJheSB3aXRoIGEgc2l6ZSBvZiB3aWR0aCpoZWlnaHQsIG9yIG51bGwgaWYgYWxsIHBpeGVscyBhcmUgdmFsaWQuXG4gICAgICAgKiBAcHJvcGVydHkge2FycmF5fSBzdGF0aXN0aWNzIFtzdGF0aXN0aWNzX2JhbmQxLCBzdGF0aXN0aWNzX2JhbmQyLCDigKZdIEVhY2ggZWxlbWVudCBpcyBhIHN0YXRpc3RpY3Mgb2JqZWN0IHJlcHJlc2VudGluZyBtaW4gYW5kIG1heCB2YWx1ZXNcbiAgICAqKi9cbiAgICBkZWNvZGU6IGZ1bmN0aW9uKGVuY29kZWREYXRhLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIWlzUGxhdGZvcm1MaXR0bGVFbmRpYW4pIHtcbiAgICAgICAgdGhyb3cgXCJCaWcgZW5kaWFuIHN5c3RlbSBpcyBub3Qgc3VwcG9ydGVkLlwiO1xuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB2YXIgaW5wdXRPZmZzZXQgPSBvcHRpb25zLmlucHV0T2Zmc2V0IHx8IDA7XG4gICAgICB2YXIgZmlsZUlkVmlldyA9IG5ldyBVaW50OEFycmF5KGVuY29kZWREYXRhLCBpbnB1dE9mZnNldCwgMTApO1xuICAgICAgdmFyIGZpbGVJZGVudGlmaWVyU3RyaW5nID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBmaWxlSWRWaWV3KTtcbiAgICAgIHZhciBsZXJjLCBtYWpvclZlcnNpb247XG4gICAgICBpZiAoZmlsZUlkZW50aWZpZXJTdHJpbmcudHJpbSgpID09PSBcIkNudFpJbWFnZVwiKSB7XG4gICAgICAgIGxlcmMgPSBMZXJjRGVjb2RlO1xuICAgICAgICBtYWpvclZlcnNpb24gPSAxO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZmlsZUlkZW50aWZpZXJTdHJpbmcuc3Vic3RyaW5nKDAsIDUpID09PSBcIkxlcmMyXCIpIHtcbiAgICAgICAgbGVyYyA9IExlcmMyRGVjb2RlO1xuICAgICAgICBtYWpvclZlcnNpb24gPSAyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IFwiVW5leHBlY3RlZCBmaWxlIGlkZW50aWZpZXIgc3RyaW5nOiBcIiArIGZpbGVJZGVudGlmaWVyU3RyaW5nO1xuICAgICAgfVxuXG4gICAgICB2YXIgaVBsYW5lID0gMCwgZW9mID0gZW5jb2RlZERhdGEuYnl0ZUxlbmd0aCAtIDEwLCBlbmNvZGVkTWFza0RhdGEsIGJhbmRNYXNrcyA9IFtdLCBiYW5kTWFzaywgbWFza0RhdGE7XG4gICAgICB2YXIgZGVjb2RlZFBpeGVsQmxvY2sgPSB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIHBpeGVsczogW10sXG4gICAgICAgIHBpeGVsVHlwZTogb3B0aW9ucy5waXhlbFR5cGUsXG4gICAgICAgIG1hc2s6IG51bGwsXG4gICAgICAgIHN0YXRpc3RpY3M6IFtdXG4gICAgICB9O1xuICAgICAgdmFyIHVuaXF1ZUJhbmRNYXNrQ291bnQgPSAwO1xuXG4gICAgICB3aGlsZSAoaW5wdXRPZmZzZXQgPCBlb2YpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGxlcmMuZGVjb2RlKGVuY29kZWREYXRhLCB7XG4gICAgICAgICAgaW5wdXRPZmZzZXQ6IGlucHV0T2Zmc2V0LC8vZm9yIGJvdGggbGVyYzEgYW5kIGxlcmMyXG4gICAgICAgICAgZW5jb2RlZE1hc2tEYXRhOiBlbmNvZGVkTWFza0RhdGEsLy9sZXJjMSBvbmx5XG4gICAgICAgICAgbWFza0RhdGE6IG1hc2tEYXRhLC8vbGVyYzIgb25seVxuICAgICAgICAgIHJldHVybk1hc2s6IGlQbGFuZSA9PT0gMCA/IHRydWUgOiBmYWxzZSwvL2xlcmMxIG9ubHlcbiAgICAgICAgICByZXR1cm5FbmNvZGVkTWFzazogaVBsYW5lID09PSAwID8gdHJ1ZSA6IGZhbHNlLC8vbGVyYzEgb25seVxuICAgICAgICAgIHJldHVybkZpbGVJbmZvOiB0cnVlLC8vZm9yIGJvdGggbGVyYzEgYW5kIGxlcmMyXG4gICAgICAgICAgcmV0dXJuUGl4ZWxJbnRlcmxlYXZlZERpbXM6IG9wdGlvbnMucmV0dXJuUGl4ZWxJbnRlcmxlYXZlZERpbXMsLy9mb3IgbmRpbSBsZXJjMiBvbmx5XG4gICAgICAgICAgcGl4ZWxUeXBlOiBvcHRpb25zLnBpeGVsVHlwZSB8fCBudWxsLC8vbGVyYzEgb25seVxuICAgICAgICAgIG5vRGF0YVZhbHVlOiBvcHRpb25zLm5vRGF0YVZhbHVlIHx8IG51bGwvL2xlcmMxIG9ubHlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaW5wdXRPZmZzZXQgPSByZXN1bHQuZmlsZUluZm8uZW9mT2Zmc2V0O1xuICAgICAgICBtYXNrRGF0YSA9IHJlc3VsdC5tYXNrRGF0YTsvL2xlcmMyXG4gICAgICAgIGlmIChpUGxhbmUgPT09IDApIHtcbiAgICAgICAgICBlbmNvZGVkTWFza0RhdGEgPSByZXN1bHQuZW5jb2RlZE1hc2tEYXRhOy8vbGVyYzFcbiAgICAgICAgICBkZWNvZGVkUGl4ZWxCbG9jay53aWR0aCA9IHJlc3VsdC53aWR0aDtcbiAgICAgICAgICBkZWNvZGVkUGl4ZWxCbG9jay5oZWlnaHQgPSByZXN1bHQuaGVpZ2h0O1xuICAgICAgICAgIGRlY29kZWRQaXhlbEJsb2NrLmRpbUNvdW50ID0gcmVzdWx0LmRpbUNvdW50IHx8IDE7XG4gICAgICAgICAgLy9kZWNvZGVkUGl4ZWxCbG9jay5kaW1TdGF0cyA9IGRlY29kZWRQaXhlbEJsb2NrLmRpbVN0YXRzO1xuICAgICAgICAgIGRlY29kZWRQaXhlbEJsb2NrLnBpeGVsVHlwZSA9IHJlc3VsdC5waXhlbFR5cGUgfHwgcmVzdWx0LmZpbGVJbmZvLnBpeGVsVHlwZTtcbiAgICAgICAgICBkZWNvZGVkUGl4ZWxCbG9jay5tYXNrID0gbWFza0RhdGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ham9yVmVyc2lvbiA+IDEpIHtcbiAgICAgICAgICBpZiAobWFza0RhdGEpIHtcbiAgICAgICAgICAgIGJhbmRNYXNrcy5wdXNoKG1hc2tEYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdC5maWxlSW5mby5tYXNrICYmIHJlc3VsdC5maWxlSW5mby5tYXNrLm51bUJ5dGVzID4gMCkge1xuICAgICAgICAgICAgdW5pcXVlQmFuZE1hc2tDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlQbGFuZSsrO1xuICAgICAgICBkZWNvZGVkUGl4ZWxCbG9jay5waXhlbHMucHVzaChyZXN1bHQucGl4ZWxEYXRhKTtcbiAgICAgICAgZGVjb2RlZFBpeGVsQmxvY2suc3RhdGlzdGljcy5wdXNoKHtcbiAgICAgICAgICBtaW5WYWx1ZTogcmVzdWx0Lm1pblZhbHVlLFxuICAgICAgICAgIG1heFZhbHVlOiByZXN1bHQubWF4VmFsdWUsXG4gICAgICAgICAgbm9EYXRhVmFsdWU6IHJlc3VsdC5ub0RhdGFWYWx1ZSxcbiAgICAgICAgICBkaW1TdGF0czogcmVzdWx0LmRpbVN0YXRzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdmFyIGksIGosIG51bVBpeGVscztcbiAgICAgIGlmIChtYWpvclZlcnNpb24gPiAxICYmIHVuaXF1ZUJhbmRNYXNrQ291bnQgPiAxKSB7XG4gICAgICAgIG51bVBpeGVscyA9IGRlY29kZWRQaXhlbEJsb2NrLndpZHRoICogZGVjb2RlZFBpeGVsQmxvY2suaGVpZ2h0O1xuICAgICAgICBkZWNvZGVkUGl4ZWxCbG9jay5iYW5kTWFza3MgPSBiYW5kTWFza3M7XG4gICAgICAgIG1hc2tEYXRhID0gbmV3IFVpbnQ4QXJyYXkobnVtUGl4ZWxzKTtcbiAgICAgICAgbWFza0RhdGEuc2V0KGJhbmRNYXNrc1swXSk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBiYW5kTWFza3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBiYW5kTWFzayA9IGJhbmRNYXNrc1tpXTtcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbnVtUGl4ZWxzOyBqKyspIHtcbiAgICAgICAgICAgIG1hc2tEYXRhW2pdID0gbWFza0RhdGFbal0gJiBiYW5kTWFza1tqXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlZFBpeGVsQmxvY2subWFza0RhdGEgPSBtYXNrRGF0YTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlY29kZWRQaXhlbEJsb2NrO1xuICAgIH1cbiAgfTtcblxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHsvKiBqc2hpbnQgaWdub3JlOmxpbmUgKi9cbiAgICAvL2FtZCBsb2FkZXJzIHN1Y2ggYXMgZG9qbyBhbmQgcmVxdWlyZUpTXG4gICAgLy9odHRwOi8vd2lraS5jb21tb25qcy5vcmcvd2lraS9Nb2R1bGVzL0FzeW5jaHJvbm91c0RlZmluaXRpb25cbiAgICBkZWZpbmUoW10sIGZ1bmN0aW9uKCkgeyByZXR1cm4gTGVyYzsgfSk7LyoganNoaW50IGlnbm9yZTpsaW5lICovXG4gIH1cbiAgZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cykgey8qIGpzaGludCBpZ25vcmU6bGluZSAqL1xuICAgIC8vY29tbW9uSlMgbW9kdWxlIDEuMC8xLjEvMS4xLjEgc3lzdGVtcywgc3VjaCBhcyBub2RlSlNcbiAgICAvL2h0dHA6Ly93aWtpLmNvbW1vbmpzLm9yZy93aWtpL01vZHVsZXNcbiAgICBtb2R1bGUuZXhwb3J0cyA9IExlcmM7LyoganNoaW50IGlnbm9yZTpsaW5lICovXG4gIH1cbiAgZWxzZSB7XG4gICAgLy9hc3NpZ24gdG8gdGhpcywgbW9zdCBsaWtlbHkgd2luZG93XG4gICAgdGhpcy5MZXJjID0gTGVyYztcbiAgfVxuXG59KSgpO1xuIiwiaW1wb3J0IHsgaW5mbGF0ZSB9IGZyb20gJ3Bha28nO1xuaW1wb3J0IExlcmMgZnJvbSAnbGVyYyc7XG5pbXBvcnQgQmFzZURlY29kZXIgZnJvbSAnLi9iYXNlZGVjb2Rlci5qcyc7XG5pbXBvcnQgeyBMZXJjUGFyYW1ldGVycywgTGVyY0FkZENvbXByZXNzaW9uIH0gZnJvbSAnLi4vZ2xvYmFscy5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExlcmNEZWNvZGVyIGV4dGVuZHMgQmFzZURlY29kZXIge1xuICBjb25zdHJ1Y3RvcihmaWxlRGlyZWN0b3J5KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMucGxhbmFyQ29uZmlndXJhdGlvbiA9IHR5cGVvZiBmaWxlRGlyZWN0b3J5LlBsYW5hckNvbmZpZ3VyYXRpb24gIT09ICd1bmRlZmluZWQnID8gZmlsZURpcmVjdG9yeS5QbGFuYXJDb25maWd1cmF0aW9uIDogMTtcbiAgICB0aGlzLnNhbXBsZXNQZXJQaXhlbCA9IHR5cGVvZiBmaWxlRGlyZWN0b3J5LlNhbXBsZXNQZXJQaXhlbCAhPT0gJ3VuZGVmaW5lZCcgPyBmaWxlRGlyZWN0b3J5LlNhbXBsZXNQZXJQaXhlbCA6IDE7XG5cbiAgICB0aGlzLmFkZENvbXByZXNzaW9uID0gZmlsZURpcmVjdG9yeS5MZXJjUGFyYW1ldGVyc1tMZXJjUGFyYW1ldGVycy5BZGRDb21wcmVzc2lvbl07XG4gIH1cblxuICBkZWNvZGVCbG9jayhidWZmZXIpIHtcbiAgICBzd2l0Y2ggKHRoaXMuYWRkQ29tcHJlc3Npb24pIHtcbiAgICAgIGNhc2UgTGVyY0FkZENvbXByZXNzaW9uLk5vbmU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBMZXJjQWRkQ29tcHJlc3Npb24uRGVmbGF0ZTpcbiAgICAgICAgYnVmZmVyID0gaW5mbGF0ZShuZXcgVWludDhBcnJheShidWZmZXIpKS5idWZmZXI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ24sIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBMRVJDIGFkZGl0aW9uYWwgY29tcHJlc3Npb24gbWV0aG9kIGlkZW50aWZpZXI6ICR7dGhpcy5hZGRDb21wcmVzc2lvbn1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBsZXJjUmVzdWx0ID0gTGVyYy5kZWNvZGUoYnVmZmVyLCB7IHJldHVyblBpeGVsSW50ZXJsZWF2ZWREaW1zOiB0aGlzLnBsYW5hckNvbmZpZ3VyYXRpb24gPT09IDEgfSk7XG4gICAgY29uc3QgbGVyY0RhdGEgPSBsZXJjUmVzdWx0LnBpeGVsc1swXTtcbiAgICByZXR1cm4gbGVyY0RhdGEuYnVmZmVyO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=
"use strict";
(self["webpackChunkmapsbundle"] = self["webpackChunkmapsbundle"] || []).push([["node_modules_geotiff_dist-module_compression_raw_js"],{

/***/ "./node_modules/geotiff/dist-module/compression/basedecoder.js":
/*!*********************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/compression/basedecoder.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BaseDecoder)
/* harmony export */ });
/* harmony import */ var _predictor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../predictor.js */ "./node_modules/geotiff/dist-module/predictor.js");


class BaseDecoder {
  async decode(fileDirectory, buffer) {
    const decoded = await this.decodeBlock(buffer);
    const predictor = fileDirectory.Predictor || 1;
    if (predictor !== 1) {
      const isTiled = !fileDirectory.StripOffsets;
      const tileWidth = isTiled ? fileDirectory.TileWidth : fileDirectory.ImageWidth;
      const tileHeight = isTiled ? fileDirectory.TileLength : (
        fileDirectory.RowsPerStrip || fileDirectory.ImageLength
      );
      return (0,_predictor_js__WEBPACK_IMPORTED_MODULE_0__.applyPredictor)(
        decoded, predictor, tileWidth, tileHeight, fileDirectory.BitsPerSample,
        fileDirectory.PlanarConfiguration,
      );
    }
    return decoded;
  }
}


/***/ }),

/***/ "./node_modules/geotiff/dist-module/compression/raw.js":
/*!*************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/compression/raw.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RawDecoder)
/* harmony export */ });
/* harmony import */ var _basedecoder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basedecoder.js */ "./node_modules/geotiff/dist-module/compression/basedecoder.js");


class RawDecoder extends _basedecoder_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  decodeBlock(buffer) {
    return buffer;
  }
}


/***/ }),

/***/ "./node_modules/geotiff/dist-module/predictor.js":
/*!*******************************************************!*\
  !*** ./node_modules/geotiff/dist-module/predictor.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "applyPredictor": () => (/* binding */ applyPredictor)
/* harmony export */ });
function decodeRowAcc(row, stride) {
  let length = row.length - stride;
  let offset = 0;
  do {
    for (let i = stride; i > 0; i--) {
      row[offset + stride] += row[offset];
      offset++;
    }

    length -= stride;
  } while (length > 0);
}

function decodeRowFloatingPoint(row, stride, bytesPerSample) {
  let index = 0;
  let count = row.length;
  const wc = count / bytesPerSample;

  while (count > stride) {
    for (let i = stride; i > 0; --i) {
      row[index + stride] += row[index];
      ++index;
    }
    count -= stride;
  }

  const copy = row.slice();
  for (let i = 0; i < wc; ++i) {
    for (let b = 0; b < bytesPerSample; ++b) {
      row[(bytesPerSample * i) + b] = copy[((bytesPerSample - b - 1) * wc) + i];
    }
  }
}

function applyPredictor(block, predictor, width, height, bitsPerSample,
  planarConfiguration) {
  if (!predictor || predictor === 1) {
    return block;
  }

  for (let i = 0; i < bitsPerSample.length; ++i) {
    if (bitsPerSample[i] % 8 !== 0) {
      throw new Error('When decoding with predictor, only multiple of 8 bits are supported.');
    }
    if (bitsPerSample[i] !== bitsPerSample[0]) {
      throw new Error('When decoding with predictor, all samples must have the same size.');
    }
  }

  const bytesPerSample = bitsPerSample[0] / 8;
  const stride = planarConfiguration === 2 ? 1 : bitsPerSample.length;

  for (let i = 0; i < height; ++i) {
    // Last strip will be truncated if height % stripHeight != 0
    if (i * stride * width * bytesPerSample >= block.byteLength) {
      break;
    }
    let row;
    if (predictor === 2) { // horizontal prediction
      switch (bitsPerSample[0]) {
        case 8:
          row = new Uint8Array(
            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,
          );
          break;
        case 16:
          row = new Uint16Array(
            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 2,
          );
          break;
        case 32:
          row = new Uint32Array(
            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 4,
          );
          break;
        default:
          throw new Error(`Predictor 2 not allowed with ${bitsPerSample[0]} bits per sample.`);
      }
      decodeRowAcc(row, stride, bytesPerSample);
    } else if (predictor === 3) { // horizontal floating point
      row = new Uint8Array(
        block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,
      );
      decodeRowFloatingPoint(row, stride, bytesPerSample);
    }
  }
  return block;
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2dlb3RpZmZfZGlzdC1tb2R1bGVfY29tcHJlc3Npb25fcmF3X2pzLmJ1bmRsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFpRDs7QUFFbEM7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDZEQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDbkIyQzs7QUFFNUIseUJBQXlCLHVEQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixPQUFPO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixPQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQixvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLDBCQUEwQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxrQkFBa0I7QUFDNUU7QUFDQTtBQUNBLE1BQU0sNEJBQTRCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXBzYnVuZGxlLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvY29tcHJlc3Npb24vYmFzZWRlY29kZXIuanMiLCJ3ZWJwYWNrOi8vbWFwc2J1bmRsZS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL2NvbXByZXNzaW9uL3Jhdy5qcyIsIndlYnBhY2s6Ly9tYXBzYnVuZGxlLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvcHJlZGljdG9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFwcGx5UHJlZGljdG9yIH0gZnJvbSAnLi4vcHJlZGljdG9yLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzZURlY29kZXIge1xuICBhc3luYyBkZWNvZGUoZmlsZURpcmVjdG9yeSwgYnVmZmVyKSB7XG4gICAgY29uc3QgZGVjb2RlZCA9IGF3YWl0IHRoaXMuZGVjb2RlQmxvY2soYnVmZmVyKTtcbiAgICBjb25zdCBwcmVkaWN0b3IgPSBmaWxlRGlyZWN0b3J5LlByZWRpY3RvciB8fCAxO1xuICAgIGlmIChwcmVkaWN0b3IgIT09IDEpIHtcbiAgICAgIGNvbnN0IGlzVGlsZWQgPSAhZmlsZURpcmVjdG9yeS5TdHJpcE9mZnNldHM7XG4gICAgICBjb25zdCB0aWxlV2lkdGggPSBpc1RpbGVkID8gZmlsZURpcmVjdG9yeS5UaWxlV2lkdGggOiBmaWxlRGlyZWN0b3J5LkltYWdlV2lkdGg7XG4gICAgICBjb25zdCB0aWxlSGVpZ2h0ID0gaXNUaWxlZCA/IGZpbGVEaXJlY3RvcnkuVGlsZUxlbmd0aCA6IChcbiAgICAgICAgZmlsZURpcmVjdG9yeS5Sb3dzUGVyU3RyaXAgfHwgZmlsZURpcmVjdG9yeS5JbWFnZUxlbmd0aFxuICAgICAgKTtcbiAgICAgIHJldHVybiBhcHBseVByZWRpY3RvcihcbiAgICAgICAgZGVjb2RlZCwgcHJlZGljdG9yLCB0aWxlV2lkdGgsIHRpbGVIZWlnaHQsIGZpbGVEaXJlY3RvcnkuQml0c1BlclNhbXBsZSxcbiAgICAgICAgZmlsZURpcmVjdG9yeS5QbGFuYXJDb25maWd1cmF0aW9uLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZWQ7XG4gIH1cbn1cbiIsImltcG9ydCBCYXNlRGVjb2RlciBmcm9tICcuL2Jhc2VkZWNvZGVyLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmF3RGVjb2RlciBleHRlbmRzIEJhc2VEZWNvZGVyIHtcbiAgZGVjb2RlQmxvY2soYnVmZmVyKSB7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxufVxuIiwiZnVuY3Rpb24gZGVjb2RlUm93QWNjKHJvdywgc3RyaWRlKSB7XG4gIGxldCBsZW5ndGggPSByb3cubGVuZ3RoIC0gc3RyaWRlO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZG8ge1xuICAgIGZvciAobGV0IGkgPSBzdHJpZGU7IGkgPiAwOyBpLS0pIHtcbiAgICAgIHJvd1tvZmZzZXQgKyBzdHJpZGVdICs9IHJvd1tvZmZzZXRdO1xuICAgICAgb2Zmc2V0Kys7XG4gICAgfVxuXG4gICAgbGVuZ3RoIC09IHN0cmlkZTtcbiAgfSB3aGlsZSAobGVuZ3RoID4gMCk7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVJvd0Zsb2F0aW5nUG9pbnQocm93LCBzdHJpZGUsIGJ5dGVzUGVyU2FtcGxlKSB7XG4gIGxldCBpbmRleCA9IDA7XG4gIGxldCBjb3VudCA9IHJvdy5sZW5ndGg7XG4gIGNvbnN0IHdjID0gY291bnQgLyBieXRlc1BlclNhbXBsZTtcblxuICB3aGlsZSAoY291bnQgPiBzdHJpZGUpIHtcbiAgICBmb3IgKGxldCBpID0gc3RyaWRlOyBpID4gMDsgLS1pKSB7XG4gICAgICByb3dbaW5kZXggKyBzdHJpZGVdICs9IHJvd1tpbmRleF07XG4gICAgICArK2luZGV4O1xuICAgIH1cbiAgICBjb3VudCAtPSBzdHJpZGU7XG4gIH1cblxuICBjb25zdCBjb3B5ID0gcm93LnNsaWNlKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgd2M7ICsraSkge1xuICAgIGZvciAobGV0IGIgPSAwOyBiIDwgYnl0ZXNQZXJTYW1wbGU7ICsrYikge1xuICAgICAgcm93WyhieXRlc1BlclNhbXBsZSAqIGkpICsgYl0gPSBjb3B5WygoYnl0ZXNQZXJTYW1wbGUgLSBiIC0gMSkgKiB3YykgKyBpXTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5UHJlZGljdG9yKGJsb2NrLCBwcmVkaWN0b3IsIHdpZHRoLCBoZWlnaHQsIGJpdHNQZXJTYW1wbGUsXG4gIHBsYW5hckNvbmZpZ3VyYXRpb24pIHtcbiAgaWYgKCFwcmVkaWN0b3IgfHwgcHJlZGljdG9yID09PSAxKSB7XG4gICAgcmV0dXJuIGJsb2NrO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaXRzUGVyU2FtcGxlLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGJpdHNQZXJTYW1wbGVbaV0gJSA4ICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1doZW4gZGVjb2Rpbmcgd2l0aCBwcmVkaWN0b3IsIG9ubHkgbXVsdGlwbGUgb2YgOCBiaXRzIGFyZSBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuICAgIGlmIChiaXRzUGVyU2FtcGxlW2ldICE9PSBiaXRzUGVyU2FtcGxlWzBdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1doZW4gZGVjb2Rpbmcgd2l0aCBwcmVkaWN0b3IsIGFsbCBzYW1wbGVzIG11c3QgaGF2ZSB0aGUgc2FtZSBzaXplLicpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGJ5dGVzUGVyU2FtcGxlID0gYml0c1BlclNhbXBsZVswXSAvIDg7XG4gIGNvbnN0IHN0cmlkZSA9IHBsYW5hckNvbmZpZ3VyYXRpb24gPT09IDIgPyAxIDogYml0c1BlclNhbXBsZS5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWlnaHQ7ICsraSkge1xuICAgIC8vIExhc3Qgc3RyaXAgd2lsbCBiZSB0cnVuY2F0ZWQgaWYgaGVpZ2h0ICUgc3RyaXBIZWlnaHQgIT0gMFxuICAgIGlmIChpICogc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSA+PSBibG9jay5ieXRlTGVuZ3RoKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbGV0IHJvdztcbiAgICBpZiAocHJlZGljdG9yID09PSAyKSB7IC8vIGhvcml6b250YWwgcHJlZGljdGlvblxuICAgICAgc3dpdGNoIChiaXRzUGVyU2FtcGxlWzBdKSB7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICByb3cgPSBuZXcgVWludDhBcnJheShcbiAgICAgICAgICAgIGJsb2NrLCBpICogc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSwgc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgIHJvdyA9IG5ldyBVaW50MTZBcnJheShcbiAgICAgICAgICAgIGJsb2NrLCBpICogc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSwgc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSAvIDIsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICByb3cgPSBuZXcgVWludDMyQXJyYXkoXG4gICAgICAgICAgICBibG9jaywgaSAqIHN0cmlkZSAqIHdpZHRoICogYnl0ZXNQZXJTYW1wbGUsIHN0cmlkZSAqIHdpZHRoICogYnl0ZXNQZXJTYW1wbGUgLyA0LFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcmVkaWN0b3IgMiBub3QgYWxsb3dlZCB3aXRoICR7Yml0c1BlclNhbXBsZVswXX0gYml0cyBwZXIgc2FtcGxlLmApO1xuICAgICAgfVxuICAgICAgZGVjb2RlUm93QWNjKHJvdywgc3RyaWRlLCBieXRlc1BlclNhbXBsZSk7XG4gICAgfSBlbHNlIGlmIChwcmVkaWN0b3IgPT09IDMpIHsgLy8gaG9yaXpvbnRhbCBmbG9hdGluZyBwb2ludFxuICAgICAgcm93ID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgIGJsb2NrLCBpICogc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSwgc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSxcbiAgICAgICk7XG4gICAgICBkZWNvZGVSb3dGbG9hdGluZ1BvaW50KHJvdywgc3RyaWRlLCBieXRlc1BlclNhbXBsZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBibG9jaztcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==